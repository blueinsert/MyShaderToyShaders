{"userName":"bluebean","date":"2020-01-09T02:25:12.900Z","numShaders":36,"shaders":[{"Ver":null,"ImageRenderpass":{"Code":"const float cloudscale = 1.1;\r\nconst float speed = 0.03;\r\nconst float clouddark = 0.5;\r\nconst float cloudlight = 0.3;\r\nconst float cloudcover = 0.2;\r\nconst float cloudalpha = 8.0;\r\nconst float skytint = 0.5;\r\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\r\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\r\n\r\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\r\n\r\nvec2 hash( vec2 p ) {\r\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n    return dot(n, vec3(70.0));\t\r\n}\r\n\r\nfloat fbm(vec2 n) {\r\n\tfloat total = 0.0, amplitude = 0.1;\r\n\tfor (int i = 0; i < 7; i++) {\r\n\t\ttotal += noise(n) * amplitude;\r\n\t\tn = m * n;\r\n\t\tamplitude *= 0.4;\r\n\t}\r\n\treturn total;\r\n}\r\n\r\n// -----------------------------------------------\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 p = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \r\n    float time = iTime * speed;\r\n    float q = fbm(uv * cloudscale * 0.5);\r\n    \r\n    //ridged noise shape\r\n\tfloat r = 0.0;\r\n\tuv *= cloudscale;\r\n    uv -= q - time;\r\n    float weight = 0.8;\r\n    for (int i=0; i<8; i++){\r\n\t\tr += abs(weight*noise( uv ));\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.7;\r\n    }\r\n    \r\n    //noise shape\r\n\tfloat f = 0.0;\r\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\r\n\tuv *= cloudscale;\r\n    uv -= q - time;\r\n    weight = 0.7;\r\n    for (int i=0; i<8; i++){\r\n\t\tf += weight*noise( uv );\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.6;\r\n    }\r\n    \r\n    f *= r + f;\r\n    \r\n    //noise colour\r\n    float c = 0.0;\r\n    time = iTime * speed * 2.0;\r\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\r\n\tuv *= cloudscale*2.0;\r\n    uv -= q - time;\r\n    weight = 0.4;\r\n    for (int i=0; i<7; i++){\r\n\t\tc += weight*noise( uv );\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.6;\r\n    }\r\n    \r\n    //noise ridge colour\r\n    float c1 = 0.0;\r\n    time = iTime * speed * 3.0;\r\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\r\n\tuv *= cloudscale*3.0;\r\n    uv -= q - time;\r\n    weight = 0.4;\r\n    for (int i=0; i<7; i++){\r\n\t\tc1 += abs(weight*noise( uv ));\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.6;\r\n    }\r\n\t\r\n    c += c1;\r\n    \r\n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\r\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\r\n   \r\n    f = cloudcover + cloudalpha*f*r;\r\n    \r\n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\r\n    \r\n\tfragColor = vec4( result, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"const float cloudscale = 1.1;\r\nconst float speed = 0.03;\r\nconst float clouddark = 0.5;\r\nconst float cloudlight = 0.3;\r\nconst float cloudcover = 0.2;\r\nconst float cloudalpha = 8.0;\r\nconst float skytint = 0.5;\r\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\r\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\r\n\r\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\r\n\r\nvec2 hash( vec2 p ) {\r\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n    return dot(n, vec3(70.0));\t\r\n}\r\n\r\nfloat fbm(vec2 n) {\r\n\tfloat total = 0.0, amplitude = 0.1;\r\n\tfor (int i = 0; i < 7; i++) {\r\n\t\ttotal += noise(n) * amplitude;\r\n\t\tn = m * n;\r\n\t\tamplitude *= 0.4;\r\n\t}\r\n\treturn total;\r\n}\r\n\r\n// -----------------------------------------------\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 p = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \r\n    float time = iTime * speed;\r\n    float q = fbm(uv * cloudscale * 0.5);\r\n    \r\n    //ridged noise shape\r\n\tfloat r = 0.0;\r\n\tuv *= cloudscale;\r\n    uv -= q - time;\r\n    float weight = 0.8;\r\n    for (int i=0; i<8; i++){\r\n\t\tr += abs(weight*noise( uv ));\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.7;\r\n    }\r\n    \r\n    //noise shape\r\n\tfloat f = 0.0;\r\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\r\n\tuv *= cloudscale;\r\n    uv -= q - time;\r\n    weight = 0.7;\r\n    for (int i=0; i<8; i++){\r\n\t\tf += weight*noise( uv );\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.6;\r\n    }\r\n    \r\n    f *= r + f;\r\n    \r\n    //noise colour\r\n    float c = 0.0;\r\n    time = iTime * speed * 2.0;\r\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\r\n\tuv *= cloudscale*2.0;\r\n    uv -= q - time;\r\n    weight = 0.4;\r\n    for (int i=0; i<7; i++){\r\n\t\tc += weight*noise( uv );\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.6;\r\n    }\r\n    \r\n    //noise ridge colour\r\n    float c1 = 0.0;\r\n    time = iTime * speed * 3.0;\r\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\r\n\tuv *= cloudscale*3.0;\r\n    uv -= q - time;\r\n    weight = 0.4;\r\n    for (int i=0; i<7; i++){\r\n\t\tc1 += abs(weight*noise( uv ));\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.6;\r\n    }\r\n\t\r\n    c += c1;\r\n    \r\n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\r\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\r\n   \r\n    f = cloudcover + cloudalpha*f*r;\r\n    \r\n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\r\n    \r\n\tfragColor = vec4( result, 1.0 );\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"2D Clouds","id":null,"date":null,"viewed":0,"name":"2D Clouds","description":"Used in 2 different demos:\r\nhttp://www.pouet.net/prod.php?which=66590\r\nand\r\nhttp://www.pouet.net/prod.php?which=68483","likes":0,"published":null,"tags":["fractal"," noise"," clouds"," fbm"]},"ver":null,"info":{"Name":"2D Clouds","id":null,"date":null,"viewed":0,"name":"2D Clouds","description":"Used in 2 different demos:\r\nhttp://www.pouet.net/prod.php?which=66590\r\nand\r\nhttp://www.pouet.net/prod.php?which=68483","likes":0,"published":null,"tags":["fractal"," noise"," clouds"," fbm"]},"renderpass":[{"Code":"const float cloudscale = 1.1;\r\nconst float speed = 0.03;\r\nconst float clouddark = 0.5;\r\nconst float cloudlight = 0.3;\r\nconst float cloudcover = 0.2;\r\nconst float cloudalpha = 8.0;\r\nconst float skytint = 0.5;\r\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\r\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\r\n\r\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\r\n\r\nvec2 hash( vec2 p ) {\r\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n    return dot(n, vec3(70.0));\t\r\n}\r\n\r\nfloat fbm(vec2 n) {\r\n\tfloat total = 0.0, amplitude = 0.1;\r\n\tfor (int i = 0; i < 7; i++) {\r\n\t\ttotal += noise(n) * amplitude;\r\n\t\tn = m * n;\r\n\t\tamplitude *= 0.4;\r\n\t}\r\n\treturn total;\r\n}\r\n\r\n// -----------------------------------------------\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 p = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \r\n    float time = iTime * speed;\r\n    float q = fbm(uv * cloudscale * 0.5);\r\n    \r\n    //ridged noise shape\r\n\tfloat r = 0.0;\r\n\tuv *= cloudscale;\r\n    uv -= q - time;\r\n    float weight = 0.8;\r\n    for (int i=0; i<8; i++){\r\n\t\tr += abs(weight*noise( uv ));\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.7;\r\n    }\r\n    \r\n    //noise shape\r\n\tfloat f = 0.0;\r\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\r\n\tuv *= cloudscale;\r\n    uv -= q - time;\r\n    weight = 0.7;\r\n    for (int i=0; i<8; i++){\r\n\t\tf += weight*noise( uv );\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.6;\r\n    }\r\n    \r\n    f *= r + f;\r\n    \r\n    //noise colour\r\n    float c = 0.0;\r\n    time = iTime * speed * 2.0;\r\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\r\n\tuv *= cloudscale*2.0;\r\n    uv -= q - time;\r\n    weight = 0.4;\r\n    for (int i=0; i<7; i++){\r\n\t\tc += weight*noise( uv );\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.6;\r\n    }\r\n    \r\n    //noise ridge colour\r\n    float c1 = 0.0;\r\n    time = iTime * speed * 3.0;\r\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\r\n\tuv *= cloudscale*3.0;\r\n    uv -= q - time;\r\n    weight = 0.4;\r\n    for (int i=0; i<7; i++){\r\n\t\tc1 += abs(weight*noise( uv ));\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.6;\r\n    }\r\n\t\r\n    c += c1;\r\n    \r\n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\r\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\r\n   \r\n    f = cloudcover + cloudalpha*f*r;\r\n    \r\n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\r\n    \r\n\tfragColor = vec4( result, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"const float cloudscale = 1.1;\r\nconst float speed = 0.03;\r\nconst float clouddark = 0.5;\r\nconst float cloudlight = 0.3;\r\nconst float cloudcover = 0.2;\r\nconst float cloudalpha = 8.0;\r\nconst float skytint = 0.5;\r\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\r\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\r\n\r\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\r\n\r\nvec2 hash( vec2 p ) {\r\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n    return dot(n, vec3(70.0));\t\r\n}\r\n\r\nfloat fbm(vec2 n) {\r\n\tfloat total = 0.0, amplitude = 0.1;\r\n\tfor (int i = 0; i < 7; i++) {\r\n\t\ttotal += noise(n) * amplitude;\r\n\t\tn = m * n;\r\n\t\tamplitude *= 0.4;\r\n\t}\r\n\treturn total;\r\n}\r\n\r\n// -----------------------------------------------\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 p = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \r\n    float time = iTime * speed;\r\n    float q = fbm(uv * cloudscale * 0.5);\r\n    \r\n    //ridged noise shape\r\n\tfloat r = 0.0;\r\n\tuv *= cloudscale;\r\n    uv -= q - time;\r\n    float weight = 0.8;\r\n    for (int i=0; i<8; i++){\r\n\t\tr += abs(weight*noise( uv ));\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.7;\r\n    }\r\n    \r\n    //noise shape\r\n\tfloat f = 0.0;\r\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\r\n\tuv *= cloudscale;\r\n    uv -= q - time;\r\n    weight = 0.7;\r\n    for (int i=0; i<8; i++){\r\n\t\tf += weight*noise( uv );\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.6;\r\n    }\r\n    \r\n    f *= r + f;\r\n    \r\n    //noise colour\r\n    float c = 0.0;\r\n    time = iTime * speed * 2.0;\r\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\r\n\tuv *= cloudscale*2.0;\r\n    uv -= q - time;\r\n    weight = 0.4;\r\n    for (int i=0; i<7; i++){\r\n\t\tc += weight*noise( uv );\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.6;\r\n    }\r\n    \r\n    //noise ridge colour\r\n    float c1 = 0.0;\r\n    time = iTime * speed * 3.0;\r\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\r\n\tuv *= cloudscale*3.0;\r\n    uv -= q - time;\r\n    weight = 0.4;\r\n    for (int i=0; i<7; i++){\r\n\t\tc1 += abs(weight*noise( uv ));\r\n        uv = m*uv + time;\r\n\t\tweight *= 0.6;\r\n    }\r\n\t\r\n    c += c1;\r\n    \r\n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\r\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\r\n   \r\n    f = cloudcover + cloudalpha*f*r;\r\n    \r\n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\r\n    \r\n\tfragColor = vec4( result, 1.0 );\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"\r\n#define MAX_REFLECTIONS 24\r\n#define MULTISAMPLES 2 // Max 4\r\n\r\n// Refraction index\r\nconst float N = 2.55; // Diamond\r\n//const float N = 1.5; // Glass\r\n//const float N = 1.33; // Water\r\n\r\n// Shape of diamond, tiny changes affects total internal reflection patterns alot\r\nfloat toph = -1.075;\r\nfloat bottomh = 0.8;\r\nfloat ring1r = 0.7;\r\nfloat ring2h = -0.33;\r\nfloat ring2r = 1.4;\r\n\r\nconst float pi = 3.1415926536;\r\n\r\nvec3 ring1[9];\r\n\r\nstruct Triangle\r\n{\r\n    vec3 p;\r\n    vec3 e1;\r\n    vec3 e2;\r\n    vec3 n;\r\n};\r\nconst int num_tris = 24;\r\nTriangle tris[num_tris];\r\nmat3 rotation;\r\n\r\nfloat sq(float x) { return x * x; }\r\nfloat sq(vec3 x) { return dot(x, x); }\r\n\r\nvoid setup_diamond()\r\n{\r\n\tvec3 ring2[9];\r\n    for (int i = 0; i < 8; ++i)\r\n    {\r\n        float a2 = float(i) * pi / 4.0;\r\n        float a1 = a2 + pi / 8.0;\r\n        vec4 cs = cos(vec4(a1, a2, a1 - 0.5 * pi, a2 - 0.5 * pi));\r\n        ring1[i] = vec3(cs.x * ring1r, toph, cs.z * ring1r);\r\n        ring2[i] = vec3(cs.y * ring2r, ring2h, cs.w * ring2r);\r\n\t}\r\n    ring1[8] = ring1[0];\r\n    ring2[8] = ring2[0];\r\n    for (int i = 0; i < 8; ++i)\r\n    {\r\n        tris[i].p = vec3(0.0, bottomh, 0.0);\r\n        tris[i].e1 = ring2[i + 1] - tris[i].p;\r\n        tris[i].e2 = ring2[i] - tris[i].p;\r\n        tris[i + 8].p = ring1[i];\r\n        tris[i + 8].e1 = ring2[i] - ring1[i];\r\n        tris[i + 8].e2 = ring2[i + 1] - ring1[i];\r\n        tris[i + 16].p = ring2[i + 1];\r\n        tris[i + 16].e1 = ring1[i + 1] - ring2[i + 1];\r\n        tris[i + 16].e2 = ring1[i] - ring2[i + 1];\r\n    }    \r\n    for (int i = 0; i < num_tris; ++i)\r\n        tris[i].n = normalize(cross(tris[i].e1, tris[i].e2));           \r\n}\r\n\r\nfloat intersect_octagon(vec3 p, vec3 d, float nf, out vec3 rn)\r\n{\r\n    vec3 n = vec3(0.0, -nf, 0.0);\r\n    float dd = dot(-d, n);\r\n    if (dd <= 0.0)\r\n        return -1.0;\r\n    float t = dot(p - ring1[0], n) / dd;\r\n    vec3 pp = p + d * t;\r\n    for (int i = 0; i < 8; ++i)\r\n    \tif (dot(cross(pp - ring1[i], ring1[i + 1] - ring1[i]), n) * nf > 0.0)\r\n        \treturn -1.0;\r\n    rn = n;\r\n\treturn t;\r\n}\r\n\r\nfloat intersect_diamond(vec3 p, vec3 d, float nf, out vec3 n)\r\n{\r\n    float t = intersect_octagon(p, d, nf, n);\r\n    if (t > 0.0)\r\n        return t;\r\n    for (int i = 0; i < num_tris; ++i)\r\n    {\r\n        vec3 P = cross(d, tris[i].e2);\r\n        float det = dot(tris[i].e1, P) * nf;\r\n        if (det <= 0.0) continue;\r\n        vec3 T = p - tris[i].p;\r\n        float u = dot(T, P) * nf;\r\n        if (u < 0.0 || u > det) continue;\r\n        vec3 Q = cross(T, tris[i].e1);\r\n        float v = dot(d, Q) * nf;\r\n        if (v < 0.0 || u + v > det) continue;\r\n        float t = dot(tris[i].e2, Q) * nf;\r\n        if (t > 0.0)\r\n        {\r\n\t\t\tn = tris[i].n * nf;\r\n            return t / det;\r\n        }\r\n    }\r\n    return -1.0;\r\n}\r\n\r\nfloat fresnel(float n1, float n2, float cos_theta)\r\n{\r\n    float r = sq((n1 - n2) / (n1 + n2));\r\n    return r + (1.0 - r) * pow(1.0 - cos_theta, 5.0);\r\n}\r\n\r\nvec4 background(vec3 d)\r\n{\r\n    return textureLod(iChannel0, (rotation * d).xy, 0.0);\r\n}\r\n\r\nvec4 ray(vec3 p, vec3 d)\r\n{    \r\n    vec3 n;\r\n    float t = intersect_diamond(p, d, 1.0, n);\r\n    if (t <= 0.0)\r\n\t\treturn background(d);\r\n\r\n    float f = fresnel(1.0, N, dot(-d, n));\r\n    vec4 c = background(reflect(d, n)) * f;\r\n    float cr = 1.0 - f;\r\n\r\n    p += d * t;\r\n    d = refract(d, n, 1.0 / N);\r\n\r\n    for (int i = 0; i < MAX_REFLECTIONS; ++i)\r\n    {\r\n        if (cr < 0.05)\r\n            break;\r\n        t = intersect_diamond(p, d, -1.0, n);\r\n        if (t > 0.0)\r\n        {\r\n            vec3 r = refract(d, n, N);\r\n            if (r != vec3(0.0))\r\n            {\r\n                f = fresnel(N, 1.0, dot(-d, n));\r\n                c += background(r) * (1.0 - f) * cr;\r\n                cr *= f;\r\n            }\r\n            p += d * t;\r\n            d = reflect(d, n);\r\n        }\r\n    }\r\n    return c + background(d) * cr;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float r = iTime;\r\n    float ry = iMouse.x * 6.28 / iResolution.x + r;\r\n    float rx = (iMouse.y / iResolution.y - 0.5) * 3.0;\r\n\r\n    vec4 cs = cos(vec4(ry, rx, ry - pi * 0.5, rx - pi * 0.5));\r\n    vec3 forward = -vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\r\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\r\n\tvec3 left = cross(up, forward);\r\n    vec3 eye = -forward * 5.0;\r\n\r\n    float zoom = 2.0;\r\n    vec2 uv = zoom * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\r\n    vec3 dir = normalize(vec3(forward + uv.y * up + uv.x * left));\r\n\r\n    vec2 rcs = cos(vec2(r, r - 0.5 * pi));\r\n \trotation = mat3(\r\n        rcs.x, 0.0, -rcs.y,\r\n        0.0, 1.0, 0.0,\r\n        rcs.y, 0.0, rcs.x);\r\n\r\n    // early reject, bit hacky\r\n    if (sq(dot(dir, -eye) * dir) < sq(4.75))\r\n    {\r\n\t\tfragColor = background(dir);\r\n        return;\r\n    }\r\n\r\n    setup_diamond();\r\n\r\n    vec4 color = ray(eye, dir);\r\n#if MULTISAMPLES > 1\r\n    vec2 uvh = zoom * vec2(0.5) / iResolution.x;\r\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up + (uv.x + uvh.x) * left));\r\n#if MULTISAMPLES > 2\r\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up  + uv.x * left));\r\n#if MULTISAMPLES > 3\r\n    color += ray(eye, normalize(forward + uv.y * up + (uv.x + uvh.x) * left));\r\n#endif\r\n#endif\r\n    color /= float(MULTISAMPLES);\r\n#endif\r\n    fragColor = color;\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"\r\n#define MAX_REFLECTIONS 24\r\n#define MULTISAMPLES 2 // Max 4\r\n\r\n// Refraction index\r\nconst float N = 2.55; // Diamond\r\n//const float N = 1.5; // Glass\r\n//const float N = 1.33; // Water\r\n\r\n// Shape of diamond, tiny changes affects total internal reflection patterns alot\r\nfloat toph = -1.075;\r\nfloat bottomh = 0.8;\r\nfloat ring1r = 0.7;\r\nfloat ring2h = -0.33;\r\nfloat ring2r = 1.4;\r\n\r\nconst float pi = 3.1415926536;\r\n\r\nvec3 ring1[9];\r\n\r\nstruct Triangle\r\n{\r\n    vec3 p;\r\n    vec3 e1;\r\n    vec3 e2;\r\n    vec3 n;\r\n};\r\nconst int num_tris = 24;\r\nTriangle tris[num_tris];\r\nmat3 rotation;\r\n\r\nfloat sq(float x) { return x * x; }\r\nfloat sq(vec3 x) { return dot(x, x); }\r\n\r\nvoid setup_diamond()\r\n{\r\n\tvec3 ring2[9];\r\n    for (int i = 0; i < 8; ++i)\r\n    {\r\n        float a2 = float(i) * pi / 4.0;\r\n        float a1 = a2 + pi / 8.0;\r\n        vec4 cs = cos(vec4(a1, a2, a1 - 0.5 * pi, a2 - 0.5 * pi));\r\n        ring1[i] = vec3(cs.x * ring1r, toph, cs.z * ring1r);\r\n        ring2[i] = vec3(cs.y * ring2r, ring2h, cs.w * ring2r);\r\n\t}\r\n    ring1[8] = ring1[0];\r\n    ring2[8] = ring2[0];\r\n    for (int i = 0; i < 8; ++i)\r\n    {\r\n        tris[i].p = vec3(0.0, bottomh, 0.0);\r\n        tris[i].e1 = ring2[i + 1] - tris[i].p;\r\n        tris[i].e2 = ring2[i] - tris[i].p;\r\n        tris[i + 8].p = ring1[i];\r\n        tris[i + 8].e1 = ring2[i] - ring1[i];\r\n        tris[i + 8].e2 = ring2[i + 1] - ring1[i];\r\n        tris[i + 16].p = ring2[i + 1];\r\n        tris[i + 16].e1 = ring1[i + 1] - ring2[i + 1];\r\n        tris[i + 16].e2 = ring1[i] - ring2[i + 1];\r\n    }    \r\n    for (int i = 0; i < num_tris; ++i)\r\n        tris[i].n = normalize(cross(tris[i].e1, tris[i].e2));           \r\n}\r\n\r\nfloat intersect_octagon(vec3 p, vec3 d, float nf, out vec3 rn)\r\n{\r\n    vec3 n = vec3(0.0, -nf, 0.0);\r\n    float dd = dot(-d, n);\r\n    if (dd <= 0.0)\r\n        return -1.0;\r\n    float t = dot(p - ring1[0], n) / dd;\r\n    vec3 pp = p + d * t;\r\n    for (int i = 0; i < 8; ++i)\r\n    \tif (dot(cross(pp - ring1[i], ring1[i + 1] - ring1[i]), n) * nf > 0.0)\r\n        \treturn -1.0;\r\n    rn = n;\r\n\treturn t;\r\n}\r\n\r\nfloat intersect_diamond(vec3 p, vec3 d, float nf, out vec3 n)\r\n{\r\n    float t = intersect_octagon(p, d, nf, n);\r\n    if (t > 0.0)\r\n        return t;\r\n    for (int i = 0; i < num_tris; ++i)\r\n    {\r\n        vec3 P = cross(d, tris[i].e2);\r\n        float det = dot(tris[i].e1, P) * nf;\r\n        if (det <= 0.0) continue;\r\n        vec3 T = p - tris[i].p;\r\n        float u = dot(T, P) * nf;\r\n        if (u < 0.0 || u > det) continue;\r\n        vec3 Q = cross(T, tris[i].e1);\r\n        float v = dot(d, Q) * nf;\r\n        if (v < 0.0 || u + v > det) continue;\r\n        float t = dot(tris[i].e2, Q) * nf;\r\n        if (t > 0.0)\r\n        {\r\n\t\t\tn = tris[i].n * nf;\r\n            return t / det;\r\n        }\r\n    }\r\n    return -1.0;\r\n}\r\n\r\nfloat fresnel(float n1, float n2, float cos_theta)\r\n{\r\n    float r = sq((n1 - n2) / (n1 + n2));\r\n    return r + (1.0 - r) * pow(1.0 - cos_theta, 5.0);\r\n}\r\n\r\nvec4 background(vec3 d)\r\n{\r\n    return textureLod(iChannel0, (rotation * d).xy, 0.0);\r\n}\r\n\r\nvec4 ray(vec3 p, vec3 d)\r\n{    \r\n    vec3 n;\r\n    float t = intersect_diamond(p, d, 1.0, n);\r\n    if (t <= 0.0)\r\n\t\treturn background(d);\r\n\r\n    float f = fresnel(1.0, N, dot(-d, n));\r\n    vec4 c = background(reflect(d, n)) * f;\r\n    float cr = 1.0 - f;\r\n\r\n    p += d * t;\r\n    d = refract(d, n, 1.0 / N);\r\n\r\n    for (int i = 0; i < MAX_REFLECTIONS; ++i)\r\n    {\r\n        if (cr < 0.05)\r\n            break;\r\n        t = intersect_diamond(p, d, -1.0, n);\r\n        if (t > 0.0)\r\n        {\r\n            vec3 r = refract(d, n, N);\r\n            if (r != vec3(0.0))\r\n            {\r\n                f = fresnel(N, 1.0, dot(-d, n));\r\n                c += background(r) * (1.0 - f) * cr;\r\n                cr *= f;\r\n            }\r\n            p += d * t;\r\n            d = reflect(d, n);\r\n        }\r\n    }\r\n    return c + background(d) * cr;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float r = iTime;\r\n    float ry = iMouse.x * 6.28 / iResolution.x + r;\r\n    float rx = (iMouse.y / iResolution.y - 0.5) * 3.0;\r\n\r\n    vec4 cs = cos(vec4(ry, rx, ry - pi * 0.5, rx - pi * 0.5));\r\n    vec3 forward = -vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\r\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\r\n\tvec3 left = cross(up, forward);\r\n    vec3 eye = -forward * 5.0;\r\n\r\n    float zoom = 2.0;\r\n    vec2 uv = zoom * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\r\n    vec3 dir = normalize(vec3(forward + uv.y * up + uv.x * left));\r\n\r\n    vec2 rcs = cos(vec2(r, r - 0.5 * pi));\r\n \trotation = mat3(\r\n        rcs.x, 0.0, -rcs.y,\r\n        0.0, 1.0, 0.0,\r\n        rcs.y, 0.0, rcs.x);\r\n\r\n    // early reject, bit hacky\r\n    if (sq(dot(dir, -eye) * dir) < sq(4.75))\r\n    {\r\n\t\tfragColor = background(dir);\r\n        return;\r\n    }\r\n\r\n    setup_diamond();\r\n\r\n    vec4 color = ray(eye, dir);\r\n#if MULTISAMPLES > 1\r\n    vec2 uvh = zoom * vec2(0.5) / iResolution.x;\r\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up + (uv.x + uvh.x) * left));\r\n#if MULTISAMPLES > 2\r\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up  + uv.x * left));\r\n#if MULTISAMPLES > 3\r\n    color += ray(eye, normalize(forward + uv.y * up + (uv.x + uvh.x) * left));\r\n#endif\r\n#endif\r\n    color /= float(MULTISAMPLES);\r\n#endif\r\n    fragColor = color;\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":null,"published":0}],"Info":{"Name":"Diamond (internal reflection)","id":null,"date":null,"viewed":0,"name":"Diamond (internal reflection)","description":"Diamond with internal reflection.\r\n\r\nUse camera to look around. You can change N to compare to glass/fake diamonds.","likes":0,"published":null,"tags":["reflection"," refraction"," cubemap"," diamond"," material"]},"ver":null,"info":{"Name":"Diamond (internal reflection)","id":null,"date":null,"viewed":0,"name":"Diamond (internal reflection)","description":"Diamond with internal reflection.\r\n\r\nUse camera to look around. You can change N to compare to glass/fake diamonds.","likes":0,"published":null,"tags":["reflection"," refraction"," cubemap"," diamond"," material"]},"renderpass":[{"Code":"\r\n#define MAX_REFLECTIONS 24\r\n#define MULTISAMPLES 2 // Max 4\r\n\r\n// Refraction index\r\nconst float N = 2.55; // Diamond\r\n//const float N = 1.5; // Glass\r\n//const float N = 1.33; // Water\r\n\r\n// Shape of diamond, tiny changes affects total internal reflection patterns alot\r\nfloat toph = -1.075;\r\nfloat bottomh = 0.8;\r\nfloat ring1r = 0.7;\r\nfloat ring2h = -0.33;\r\nfloat ring2r = 1.4;\r\n\r\nconst float pi = 3.1415926536;\r\n\r\nvec3 ring1[9];\r\n\r\nstruct Triangle\r\n{\r\n    vec3 p;\r\n    vec3 e1;\r\n    vec3 e2;\r\n    vec3 n;\r\n};\r\nconst int num_tris = 24;\r\nTriangle tris[num_tris];\r\nmat3 rotation;\r\n\r\nfloat sq(float x) { return x * x; }\r\nfloat sq(vec3 x) { return dot(x, x); }\r\n\r\nvoid setup_diamond()\r\n{\r\n\tvec3 ring2[9];\r\n    for (int i = 0; i < 8; ++i)\r\n    {\r\n        float a2 = float(i) * pi / 4.0;\r\n        float a1 = a2 + pi / 8.0;\r\n        vec4 cs = cos(vec4(a1, a2, a1 - 0.5 * pi, a2 - 0.5 * pi));\r\n        ring1[i] = vec3(cs.x * ring1r, toph, cs.z * ring1r);\r\n        ring2[i] = vec3(cs.y * ring2r, ring2h, cs.w * ring2r);\r\n\t}\r\n    ring1[8] = ring1[0];\r\n    ring2[8] = ring2[0];\r\n    for (int i = 0; i < 8; ++i)\r\n    {\r\n        tris[i].p = vec3(0.0, bottomh, 0.0);\r\n        tris[i].e1 = ring2[i + 1] - tris[i].p;\r\n        tris[i].e2 = ring2[i] - tris[i].p;\r\n        tris[i + 8].p = ring1[i];\r\n        tris[i + 8].e1 = ring2[i] - ring1[i];\r\n        tris[i + 8].e2 = ring2[i + 1] - ring1[i];\r\n        tris[i + 16].p = ring2[i + 1];\r\n        tris[i + 16].e1 = ring1[i + 1] - ring2[i + 1];\r\n        tris[i + 16].e2 = ring1[i] - ring2[i + 1];\r\n    }    \r\n    for (int i = 0; i < num_tris; ++i)\r\n        tris[i].n = normalize(cross(tris[i].e1, tris[i].e2));           \r\n}\r\n\r\nfloat intersect_octagon(vec3 p, vec3 d, float nf, out vec3 rn)\r\n{\r\n    vec3 n = vec3(0.0, -nf, 0.0);\r\n    float dd = dot(-d, n);\r\n    if (dd <= 0.0)\r\n        return -1.0;\r\n    float t = dot(p - ring1[0], n) / dd;\r\n    vec3 pp = p + d * t;\r\n    for (int i = 0; i < 8; ++i)\r\n    \tif (dot(cross(pp - ring1[i], ring1[i + 1] - ring1[i]), n) * nf > 0.0)\r\n        \treturn -1.0;\r\n    rn = n;\r\n\treturn t;\r\n}\r\n\r\nfloat intersect_diamond(vec3 p, vec3 d, float nf, out vec3 n)\r\n{\r\n    float t = intersect_octagon(p, d, nf, n);\r\n    if (t > 0.0)\r\n        return t;\r\n    for (int i = 0; i < num_tris; ++i)\r\n    {\r\n        vec3 P = cross(d, tris[i].e2);\r\n        float det = dot(tris[i].e1, P) * nf;\r\n        if (det <= 0.0) continue;\r\n        vec3 T = p - tris[i].p;\r\n        float u = dot(T, P) * nf;\r\n        if (u < 0.0 || u > det) continue;\r\n        vec3 Q = cross(T, tris[i].e1);\r\n        float v = dot(d, Q) * nf;\r\n        if (v < 0.0 || u + v > det) continue;\r\n        float t = dot(tris[i].e2, Q) * nf;\r\n        if (t > 0.0)\r\n        {\r\n\t\t\tn = tris[i].n * nf;\r\n            return t / det;\r\n        }\r\n    }\r\n    return -1.0;\r\n}\r\n\r\nfloat fresnel(float n1, float n2, float cos_theta)\r\n{\r\n    float r = sq((n1 - n2) / (n1 + n2));\r\n    return r + (1.0 - r) * pow(1.0 - cos_theta, 5.0);\r\n}\r\n\r\nvec4 background(vec3 d)\r\n{\r\n    return textureLod(iChannel0, (rotation * d).xy, 0.0);\r\n}\r\n\r\nvec4 ray(vec3 p, vec3 d)\r\n{    \r\n    vec3 n;\r\n    float t = intersect_diamond(p, d, 1.0, n);\r\n    if (t <= 0.0)\r\n\t\treturn background(d);\r\n\r\n    float f = fresnel(1.0, N, dot(-d, n));\r\n    vec4 c = background(reflect(d, n)) * f;\r\n    float cr = 1.0 - f;\r\n\r\n    p += d * t;\r\n    d = refract(d, n, 1.0 / N);\r\n\r\n    for (int i = 0; i < MAX_REFLECTIONS; ++i)\r\n    {\r\n        if (cr < 0.05)\r\n            break;\r\n        t = intersect_diamond(p, d, -1.0, n);\r\n        if (t > 0.0)\r\n        {\r\n            vec3 r = refract(d, n, N);\r\n            if (r != vec3(0.0))\r\n            {\r\n                f = fresnel(N, 1.0, dot(-d, n));\r\n                c += background(r) * (1.0 - f) * cr;\r\n                cr *= f;\r\n            }\r\n            p += d * t;\r\n            d = reflect(d, n);\r\n        }\r\n    }\r\n    return c + background(d) * cr;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float r = iTime;\r\n    float ry = iMouse.x * 6.28 / iResolution.x + r;\r\n    float rx = (iMouse.y / iResolution.y - 0.5) * 3.0;\r\n\r\n    vec4 cs = cos(vec4(ry, rx, ry - pi * 0.5, rx - pi * 0.5));\r\n    vec3 forward = -vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\r\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\r\n\tvec3 left = cross(up, forward);\r\n    vec3 eye = -forward * 5.0;\r\n\r\n    float zoom = 2.0;\r\n    vec2 uv = zoom * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\r\n    vec3 dir = normalize(vec3(forward + uv.y * up + uv.x * left));\r\n\r\n    vec2 rcs = cos(vec2(r, r - 0.5 * pi));\r\n \trotation = mat3(\r\n        rcs.x, 0.0, -rcs.y,\r\n        0.0, 1.0, 0.0,\r\n        rcs.y, 0.0, rcs.x);\r\n\r\n    // early reject, bit hacky\r\n    if (sq(dot(dir, -eye) * dir) < sq(4.75))\r\n    {\r\n\t\tfragColor = background(dir);\r\n        return;\r\n    }\r\n\r\n    setup_diamond();\r\n\r\n    vec4 color = ray(eye, dir);\r\n#if MULTISAMPLES > 1\r\n    vec2 uvh = zoom * vec2(0.5) / iResolution.x;\r\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up + (uv.x + uvh.x) * left));\r\n#if MULTISAMPLES > 2\r\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up  + uv.x * left));\r\n#if MULTISAMPLES > 3\r\n    color += ray(eye, normalize(forward + uv.y * up + (uv.x + uvh.x) * left));\r\n#endif\r\n#endif\r\n    color /= float(MULTISAMPLES);\r\n#endif\r\n    fragColor = color;\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"\r\n#define MAX_REFLECTIONS 24\r\n#define MULTISAMPLES 2 // Max 4\r\n\r\n// Refraction index\r\nconst float N = 2.55; // Diamond\r\n//const float N = 1.5; // Glass\r\n//const float N = 1.33; // Water\r\n\r\n// Shape of diamond, tiny changes affects total internal reflection patterns alot\r\nfloat toph = -1.075;\r\nfloat bottomh = 0.8;\r\nfloat ring1r = 0.7;\r\nfloat ring2h = -0.33;\r\nfloat ring2r = 1.4;\r\n\r\nconst float pi = 3.1415926536;\r\n\r\nvec3 ring1[9];\r\n\r\nstruct Triangle\r\n{\r\n    vec3 p;\r\n    vec3 e1;\r\n    vec3 e2;\r\n    vec3 n;\r\n};\r\nconst int num_tris = 24;\r\nTriangle tris[num_tris];\r\nmat3 rotation;\r\n\r\nfloat sq(float x) { return x * x; }\r\nfloat sq(vec3 x) { return dot(x, x); }\r\n\r\nvoid setup_diamond()\r\n{\r\n\tvec3 ring2[9];\r\n    for (int i = 0; i < 8; ++i)\r\n    {\r\n        float a2 = float(i) * pi / 4.0;\r\n        float a1 = a2 + pi / 8.0;\r\n        vec4 cs = cos(vec4(a1, a2, a1 - 0.5 * pi, a2 - 0.5 * pi));\r\n        ring1[i] = vec3(cs.x * ring1r, toph, cs.z * ring1r);\r\n        ring2[i] = vec3(cs.y * ring2r, ring2h, cs.w * ring2r);\r\n\t}\r\n    ring1[8] = ring1[0];\r\n    ring2[8] = ring2[0];\r\n    for (int i = 0; i < 8; ++i)\r\n    {\r\n        tris[i].p = vec3(0.0, bottomh, 0.0);\r\n        tris[i].e1 = ring2[i + 1] - tris[i].p;\r\n        tris[i].e2 = ring2[i] - tris[i].p;\r\n        tris[i + 8].p = ring1[i];\r\n        tris[i + 8].e1 = ring2[i] - ring1[i];\r\n        tris[i + 8].e2 = ring2[i + 1] - ring1[i];\r\n        tris[i + 16].p = ring2[i + 1];\r\n        tris[i + 16].e1 = ring1[i + 1] - ring2[i + 1];\r\n        tris[i + 16].e2 = ring1[i] - ring2[i + 1];\r\n    }    \r\n    for (int i = 0; i < num_tris; ++i)\r\n        tris[i].n = normalize(cross(tris[i].e1, tris[i].e2));           \r\n}\r\n\r\nfloat intersect_octagon(vec3 p, vec3 d, float nf, out vec3 rn)\r\n{\r\n    vec3 n = vec3(0.0, -nf, 0.0);\r\n    float dd = dot(-d, n);\r\n    if (dd <= 0.0)\r\n        return -1.0;\r\n    float t = dot(p - ring1[0], n) / dd;\r\n    vec3 pp = p + d * t;\r\n    for (int i = 0; i < 8; ++i)\r\n    \tif (dot(cross(pp - ring1[i], ring1[i + 1] - ring1[i]), n) * nf > 0.0)\r\n        \treturn -1.0;\r\n    rn = n;\r\n\treturn t;\r\n}\r\n\r\nfloat intersect_diamond(vec3 p, vec3 d, float nf, out vec3 n)\r\n{\r\n    float t = intersect_octagon(p, d, nf, n);\r\n    if (t > 0.0)\r\n        return t;\r\n    for (int i = 0; i < num_tris; ++i)\r\n    {\r\n        vec3 P = cross(d, tris[i].e2);\r\n        float det = dot(tris[i].e1, P) * nf;\r\n        if (det <= 0.0) continue;\r\n        vec3 T = p - tris[i].p;\r\n        float u = dot(T, P) * nf;\r\n        if (u < 0.0 || u > det) continue;\r\n        vec3 Q = cross(T, tris[i].e1);\r\n        float v = dot(d, Q) * nf;\r\n        if (v < 0.0 || u + v > det) continue;\r\n        float t = dot(tris[i].e2, Q) * nf;\r\n        if (t > 0.0)\r\n        {\r\n\t\t\tn = tris[i].n * nf;\r\n            return t / det;\r\n        }\r\n    }\r\n    return -1.0;\r\n}\r\n\r\nfloat fresnel(float n1, float n2, float cos_theta)\r\n{\r\n    float r = sq((n1 - n2) / (n1 + n2));\r\n    return r + (1.0 - r) * pow(1.0 - cos_theta, 5.0);\r\n}\r\n\r\nvec4 background(vec3 d)\r\n{\r\n    return textureLod(iChannel0, (rotation * d).xy, 0.0);\r\n}\r\n\r\nvec4 ray(vec3 p, vec3 d)\r\n{    \r\n    vec3 n;\r\n    float t = intersect_diamond(p, d, 1.0, n);\r\n    if (t <= 0.0)\r\n\t\treturn background(d);\r\n\r\n    float f = fresnel(1.0, N, dot(-d, n));\r\n    vec4 c = background(reflect(d, n)) * f;\r\n    float cr = 1.0 - f;\r\n\r\n    p += d * t;\r\n    d = refract(d, n, 1.0 / N);\r\n\r\n    for (int i = 0; i < MAX_REFLECTIONS; ++i)\r\n    {\r\n        if (cr < 0.05)\r\n            break;\r\n        t = intersect_diamond(p, d, -1.0, n);\r\n        if (t > 0.0)\r\n        {\r\n            vec3 r = refract(d, n, N);\r\n            if (r != vec3(0.0))\r\n            {\r\n                f = fresnel(N, 1.0, dot(-d, n));\r\n                c += background(r) * (1.0 - f) * cr;\r\n                cr *= f;\r\n            }\r\n            p += d * t;\r\n            d = reflect(d, n);\r\n        }\r\n    }\r\n    return c + background(d) * cr;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float r = iTime;\r\n    float ry = iMouse.x * 6.28 / iResolution.x + r;\r\n    float rx = (iMouse.y / iResolution.y - 0.5) * 3.0;\r\n\r\n    vec4 cs = cos(vec4(ry, rx, ry - pi * 0.5, rx - pi * 0.5));\r\n    vec3 forward = -vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\r\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\r\n\tvec3 left = cross(up, forward);\r\n    vec3 eye = -forward * 5.0;\r\n\r\n    float zoom = 2.0;\r\n    vec2 uv = zoom * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\r\n    vec3 dir = normalize(vec3(forward + uv.y * up + uv.x * left));\r\n\r\n    vec2 rcs = cos(vec2(r, r - 0.5 * pi));\r\n \trotation = mat3(\r\n        rcs.x, 0.0, -rcs.y,\r\n        0.0, 1.0, 0.0,\r\n        rcs.y, 0.0, rcs.x);\r\n\r\n    // early reject, bit hacky\r\n    if (sq(dot(dir, -eye) * dir) < sq(4.75))\r\n    {\r\n\t\tfragColor = background(dir);\r\n        return;\r\n    }\r\n\r\n    setup_diamond();\r\n\r\n    vec4 color = ray(eye, dir);\r\n#if MULTISAMPLES > 1\r\n    vec2 uvh = zoom * vec2(0.5) / iResolution.x;\r\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up + (uv.x + uvh.x) * left));\r\n#if MULTISAMPLES > 2\r\n    color += ray(eye, normalize(forward + (uv.y + uvh.y) * up  + uv.x * left));\r\n#if MULTISAMPLES > 3\r\n    color += ray(eye, normalize(forward + uv.y * up + (uv.x + uvh.x) * left));\r\n#endif\r\n#endif\r\n    color /= float(MULTISAMPLES);\r\n#endif\r\n    fragColor = color;\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Global rendering switch\r\n//#define FAST\r\n\r\n// Rendering parameters\r\n#define RAY_LENGTH_MAX\t\t100.0\r\n#define RAY_BOUNCE_MAX\t\t10\r\n#define RAY_STEP_MAX\t\t100\r\n#define LIGHT\t\t\t\tvec3 (-1.0, 0.5, 0.0)\r\n#define AMBIENT\t\t\t\t0.2\r\n#define SPECULAR_POWER\t\t3.0\r\n#define SPECULAR_INTENSITY\t0.8\r\n#define DIAMOND_FACES\t\t8.0\r\n#define RING_ROTATE\t\t\tPI * 0.465\r\n#define RING_TRANSLATE\t\t3.0\r\n#define TRAY_HEIGHT\t\t\t1.3\r\n\r\n// Rendering options (for those who have a slow GPU)\r\n#define PROPAGATION\r\n#ifndef FAST\r\n\t#define DISPERSION\r\n\t#define COVER\r\n#endif\r\n\r\n// Macros used to handle color channels\r\n#ifdef DISPERSION\r\n\t#define COLOR float\r\n\t#define CHANNEL(x) dot (x, channel)\r\n#else\r\n\t#define COLOR vec3\r\n\t#define CHANNEL(x) x\r\n#endif\r\n\r\n// Math constants\r\n#define DELTA\t0.01\r\n#define PI\t\t3.14159265359\r\n\r\n// Rotation on the X axis\r\nvec3 rotateX (in vec3 p, in float angle) {\r\n\tfloat c = cos (angle);\r\n\tfloat s = sin (angle);\r\n\treturn vec3 (p.x, c * p.y + s * p.z, c * p.z - s * p.y);\r\n}\r\n\r\n// Rotation on the Y axis\r\nvec3 rotateY (in vec3 p, in float angle) {\r\n\tfloat c = cos (angle);\r\n\tfloat s = sin (angle);\r\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\r\n}\r\n\r\n// Materials\r\nstruct Material {\r\n\tvec3 color;\r\n\tfloat behavior; // from -1.0 (fully reflective) to 1.0 (fully transparent)\r\n\tvec3 refractIndex; // not used if behavior < 0.0\r\n};\r\nMaterial getMaterial (in int materialIndex) {\r\n\tMaterial material;\r\n\tif (materialIndex == 0) { // Ring\r\n\t\tmaterial = Material (vec3 (1.0, 1.0, 0.8), -0.5, vec3 (1.50, 1.55, 1.60));\r\n\t} else if (materialIndex == 1) { // Diamond\r\n\t\tmaterial = Material (vec3 (0.9, 0.9, 1.0), 0.7, vec3 (2.407, 2.426, 2.451));\r\n\t} else if (materialIndex == 2) { // Tray\r\n\t\tmaterial = Material (vec3 (0.5, 0.5, 0.7), -0.4, vec3 (1.50, 1.55, 1.60));\r\n\t} else { // materialIndex == 3 // Cover\r\n\t\tmaterial = Material (vec3 (1.0, 1.0, 1.0), 0.8, vec3 (1.50, 1.55, 1.60));\r\n\t}\r\n\treturn material;\r\n}\r\n\r\n// Distance to the ring\r\nfloat getDistanceRing (in vec3 p) {\r\n\tvec2 q = vec2 (length (p.xy) - 7.8, p.z);\r\n\tfloat d1 = max (length (q) - 0.6, -0.2 - q.x);\r\n\tfloat d2 = length (max (abs (vec3 (abs (p.x), p.y, abs (p.z)) - vec3 (0.7, 8.2, 0.7)) - vec3 (0.1, 0.5, 0.1), 0.0)) - 0.1;\r\n\treturn min (d1, d2);\r\n}\r\n\r\n// Distance to the diamond\r\nvec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\r\nvec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\r\nvec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.5));\r\nvec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.0));\r\nvec3 normalBottomB = normalize (vec3 (0.0, -1.0, 1.6));\r\nfloat getDistanceDiamond (in vec3 p) {\r\n\tp.y -= 10.0;\r\n\tfloat topCut = p.y - 1.0;\r\n\tfloat angleStep = PI / DIAMOND_FACES;\r\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\r\n\tvec3 q = rotateY (p, angle);\r\n\tfloat topA = dot (q, normalTopA) - 2.0;\r\n\tfloat topC = dot (q, normalTopC) - 1.5;\r\n\tfloat bottomA = dot (q, normalBottomA) - 1.7;\r\n\tq = rotateY (p, -angleStep * 0.5);\r\n\tangle = angleStep * floor (atan (q.x, q.z) / angleStep);\r\n\tq = rotateY (p, angle);\r\n\tfloat topB = dot (q, normalTopB) - 1.85;\r\n\tfloat bottomB = dot (q, normalBottomB) - 1.9;\r\n\r\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\r\n}\r\n\r\n// Distance to the tray\r\nfloat getDistanceTray (in vec3 p) {\r\n\tp.y += TRAY_HEIGHT;\r\n\tfloat d = length (p.xz);\r\n\treturn max (min (d - 4.0, max (d - 17.0, -p.y - 1.0)), p.y);\r\n}\r\n\r\n// Distance to the cover\r\nfloat getDistanceCover (in vec3 p) {\r\n\tp.y += TRAY_HEIGHT + 4.0;\r\n\tfloat d = length (p) - 17.0;\r\n\treturn max (max (d, -d - 1.0), -p.y + 3.5);\r\n}\r\n\r\n// Distance to a given material\r\nfloat getDistanceMaterial (in vec3 p, in int materialIndex) {\r\n\tvec3 q = rotateX (p + vec3 (0.0, 0.0, RING_TRANSLATE), RING_ROTATE);\r\n\tfloat materialDist;\r\n\tif (materialIndex == 0) {\r\n\t\tmaterialDist = getDistanceRing (q);\r\n\t} else if (materialIndex == 1) {\r\n\t\tmaterialDist = getDistanceDiamond (q);\r\n\t} else if (materialIndex == 2) {\r\n\t\tmaterialDist = getDistanceTray (p);\r\n\t#ifdef COVER\r\n\t} else { // materialIndex == 3\r\n\t\tmaterialDist = getDistanceCover (p);\r\n\t#endif\r\n\t}\r\n\treturn materialDist;\r\n}\r\n\r\n// Distance to the scene\r\n#define MATERIAL_PROCESS(MATERIAL) if (materialDist < 0.0) materialTo = MATERIAL; sceneDist = min (sceneDist, materialFrom != MATERIAL ? materialDist : -materialDist);\r\nfloat getDistanceScene (in vec3 p, in int materialFrom, out int materialTo) {\r\n\tvec3 q = rotateX (p + vec3 (0.0, 0.0, RING_TRANSLATE), RING_ROTATE);\r\n\r\n\t// Air\r\n\tmaterialTo = -1;\r\n\tfloat sceneDist = RAY_LENGTH_MAX;\r\n\r\n\t// Ring\r\n\tfloat materialDist = getDistanceRing (q);\r\n\tMATERIAL_PROCESS (0)\r\n\r\n\t// Diamond\r\n\tmaterialDist = getDistanceDiamond (q);\r\n\tMATERIAL_PROCESS (1)\r\n\r\n\t// Tray\r\n\tmaterialDist = getDistanceTray (p);\r\n\tMATERIAL_PROCESS (2)\r\n\r\n\t// Cover\r\n\t#ifdef COVER\r\n\tmaterialDist = getDistanceCover (p);\r\n\tMATERIAL_PROCESS (3)\r\n\t#endif\r\n\r\n\t// Return the distance\r\n\treturn sceneDist;\r\n}\r\n\r\n// Normal at a given point\r\nvec3 getNormal (in vec3 p, in int materialIndex) {\r\n\tconst vec2 h = vec2 (DELTA, -DELTA);\r\n\treturn normalize (\r\n\t\th.xxx * getDistanceMaterial (p + h.xxx, materialIndex) +\r\n\t\th.xyy * getDistanceMaterial (p + h.xyy, materialIndex) +\r\n\t\th.yxy * getDistanceMaterial (p + h.yxy, materialIndex) +\r\n\t\th.yyx * getDistanceMaterial (p + h.yyx, materialIndex)\r\n\t);\r\n}\r\n\r\n// Cast a ray for a given color channel (and its corresponding refraction index)\r\nvec3 lightDirection = normalize (LIGHT);\r\nCOLOR raycast (in vec3 origin, in vec3 direction, in vec4 normal, in int materialTo, in COLOR color, in vec3 channel) {\r\n\r\n\t// Check the behavior of the material\r\n\tMaterial material = getMaterial (materialTo);\r\n\tfloat alpha = abs (material.behavior);\r\n\tcolor *= 1.0 - alpha;\r\n\r\n\t// The ray continues...\r\n\tint materialFrom = -1;\r\n\tfloat refractIndexFrom = 1.0;\r\n\tfor (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {\r\n\r\n\t\t// Interface with the material\r\n\t\tfloat refractIndexTo;\r\n\t\tvec3 refraction;\r\n\t\tif (materialTo == -1) {\r\n\t\t\trefractIndexTo = 1.0;\r\n\t\t\trefraction = refract (direction, normal.xyz, refractIndexFrom);\r\n\t\t} else {\r\n\t\t\trefractIndexTo = dot (material.refractIndex, channel);\r\n\t\t\trefraction = material.behavior < 0.0 ? vec3 (0.0) : refract (direction, normal.xyz, refractIndexFrom / refractIndexTo);\r\n\t\t}\r\n\t\tif (dot (refraction, refraction) < DELTA) {\r\n\t\t\tdirection = reflect (direction, normal.xyz);\r\n\t\t\torigin += direction * DELTA * 2.0;\r\n\t\t} else {\r\n\t\t\tdirection = refraction;\r\n\t\t\tmaterialFrom = materialTo;\r\n\t\t\trefractIndexFrom = refractIndexTo;\r\n\t\t}\r\n\r\n\t\t// Ray marching\r\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\r\n\t\t\tfloat dist = max (getDistanceScene (origin, materialFrom, materialTo), DELTA);\r\n\t\t\tnormal.w += dist;\r\n\t\t\tif (materialFrom != materialTo || normal.w > RAY_LENGTH_MAX) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\torigin += direction * dist;\r\n\t\t}\r\n\r\n\t\t// Check whether we hit something\r\n\t\tif (materialFrom == materialTo) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Get the normal\r\n\t\tif (materialTo == -1) {\r\n\t\t\tnormal.xyz = -getNormal (origin, materialFrom);\r\n\t\t} else {\r\n\t\t\tnormal.xyz = getNormal (origin, materialTo);\r\n\r\n\t\t\t// Basic lighting\r\n\t\t\tmaterial = getMaterial (materialTo);\r\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\r\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\r\n\t\t\tCOLOR localColor = (AMBIENT + relfectionDiffuse) * CHANNEL (material.color) + relfectionSpecular;\r\n\t\t\tfloat localAlpha = abs (material.behavior);\r\n\t\t\tcolor += localColor * (1.0 - localAlpha) * alpha;\r\n\t\t\talpha *= localAlpha;\r\n\t\t}\r\n\t}\r\n\r\n\t// Get the background color\r\n\tCOLOR backColor = CHANNEL (texture (iChannel0, -direction.xy).rgb);\r\n\r\n\t// Return the intensity of this color channel\r\n\treturn color + backColor * alpha;\r\n}\r\n\r\n// Main function\r\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n\t// Define the ray corresponding to this fragment\r\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\r\n\tvec3 direction = normalize (vec3 (frag, 4.0));\r\n\r\n\t// Set the camera\r\n\tvec3 origin = (35.0 + 10.0 * cos (iTime * 0.5)) * vec3 (cos (iTime * 0.1), 0.6 + 0.5 * sin (iTime * 0.2), sin (iTime * 0.1));\r\n\tvec3 forward = -origin;\r\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\r\n\tmat3 rotation;\r\n\trotation [2] = normalize (forward);\r\n\trotation [0] = normalize (cross (up, forward));\r\n\trotation [1] = cross (rotation [2], rotation [0]);\r\n\tdirection = rotation * direction;\r\n\torigin.z += 6.0;\r\n\r\n\t// Cast the initial ray\r\n\tvec4 normal = vec4 (0.0);\r\n\tint materialTo = -1;\r\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\r\n\t\tfloat dist = max (getDistanceScene (origin, -1, materialTo), DELTA);\r\n\t\tnormal.w += dist;\r\n\t\tif (materialTo != -1 || normal.w > RAY_LENGTH_MAX) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\torigin += direction * dist;\r\n\t}\r\n\r\n\t// Check whether we hit something\r\n\tif (materialTo == -1) {\r\n\t\tfragColor.rgb = texture (iChannel0, -direction.xy).rgb;\r\n\t} else {\r\n\r\n\t\t// Get the normal\r\n\t\tnormal.xyz = getNormal (origin, materialTo);\r\n\r\n\t\t// Basic lighting\r\n\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\r\n\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\r\n\t\tfragColor.rgb = (AMBIENT + relfectionDiffuse) * getMaterial (materialTo).color + relfectionSpecular;\r\n\r\n\t\t// The ray continues...\r\n\t\t#ifdef PROPAGATION\r\n\t\t\t#ifdef DISPERSION\r\n\t\t\t\tfragColor.r = raycast (origin, direction, normal, materialTo, fragColor.r, vec3 (1.0, 0.0, 0.0));\r\n\t\t\t\tfragColor.g = raycast (origin, direction, normal, materialTo, fragColor.g, vec3 (0.0, 1.0, 0.0));\r\n\t\t\t\tfragColor.b = raycast (origin, direction, normal, materialTo, fragColor.b, vec3 (0.0, 0.0, 1.0));\r\n\t\t\t#else\r\n\t\t\t\tfragColor.rgb = raycast (origin, direction, normal, materialTo, fragColor.rgb, vec3 (1.0 / 3.0));\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t}\r\n\r\n\t// Set the alpha channel\r\n\tfragColor.a = 1.0;\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"// Global rendering switch\r\n//#define FAST\r\n\r\n// Rendering parameters\r\n#define RAY_LENGTH_MAX\t\t100.0\r\n#define RAY_BOUNCE_MAX\t\t10\r\n#define RAY_STEP_MAX\t\t100\r\n#define LIGHT\t\t\t\tvec3 (-1.0, 0.5, 0.0)\r\n#define AMBIENT\t\t\t\t0.2\r\n#define SPECULAR_POWER\t\t3.0\r\n#define SPECULAR_INTENSITY\t0.8\r\n#define DIAMOND_FACES\t\t8.0\r\n#define RING_ROTATE\t\t\tPI * 0.465\r\n#define RING_TRANSLATE\t\t3.0\r\n#define TRAY_HEIGHT\t\t\t1.3\r\n\r\n// Rendering options (for those who have a slow GPU)\r\n#define PROPAGATION\r\n#ifndef FAST\r\n\t#define DISPERSION\r\n\t#define COVER\r\n#endif\r\n\r\n// Macros used to handle color channels\r\n#ifdef DISPERSION\r\n\t#define COLOR float\r\n\t#define CHANNEL(x) dot (x, channel)\r\n#else\r\n\t#define COLOR vec3\r\n\t#define CHANNEL(x) x\r\n#endif\r\n\r\n// Math constants\r\n#define DELTA\t0.01\r\n#define PI\t\t3.14159265359\r\n\r\n// Rotation on the X axis\r\nvec3 rotateX (in vec3 p, in float angle) {\r\n\tfloat c = cos (angle);\r\n\tfloat s = sin (angle);\r\n\treturn vec3 (p.x, c * p.y + s * p.z, c * p.z - s * p.y);\r\n}\r\n\r\n// Rotation on the Y axis\r\nvec3 rotateY (in vec3 p, in float angle) {\r\n\tfloat c = cos (angle);\r\n\tfloat s = sin (angle);\r\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\r\n}\r\n\r\n// Materials\r\nstruct Material {\r\n\tvec3 color;\r\n\tfloat behavior; // from -1.0 (fully reflective) to 1.0 (fully transparent)\r\n\tvec3 refractIndex; // not used if behavior < 0.0\r\n};\r\nMaterial getMaterial (in int materialIndex) {\r\n\tMaterial material;\r\n\tif (materialIndex == 0) { // Ring\r\n\t\tmaterial = Material (vec3 (1.0, 1.0, 0.8), -0.5, vec3 (1.50, 1.55, 1.60));\r\n\t} else if (materialIndex == 1) { // Diamond\r\n\t\tmaterial = Material (vec3 (0.9, 0.9, 1.0), 0.7, vec3 (2.407, 2.426, 2.451));\r\n\t} else if (materialIndex == 2) { // Tray\r\n\t\tmaterial = Material (vec3 (0.5, 0.5, 0.7), -0.4, vec3 (1.50, 1.55, 1.60));\r\n\t} else { // materialIndex == 3 // Cover\r\n\t\tmaterial = Material (vec3 (1.0, 1.0, 1.0), 0.8, vec3 (1.50, 1.55, 1.60));\r\n\t}\r\n\treturn material;\r\n}\r\n\r\n// Distance to the ring\r\nfloat getDistanceRing (in vec3 p) {\r\n\tvec2 q = vec2 (length (p.xy) - 7.8, p.z);\r\n\tfloat d1 = max (length (q) - 0.6, -0.2 - q.x);\r\n\tfloat d2 = length (max (abs (vec3 (abs (p.x), p.y, abs (p.z)) - vec3 (0.7, 8.2, 0.7)) - vec3 (0.1, 0.5, 0.1), 0.0)) - 0.1;\r\n\treturn min (d1, d2);\r\n}\r\n\r\n// Distance to the diamond\r\nvec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\r\nvec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\r\nvec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.5));\r\nvec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.0));\r\nvec3 normalBottomB = normalize (vec3 (0.0, -1.0, 1.6));\r\nfloat getDistanceDiamond (in vec3 p) {\r\n\tp.y -= 10.0;\r\n\tfloat topCut = p.y - 1.0;\r\n\tfloat angleStep = PI / DIAMOND_FACES;\r\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\r\n\tvec3 q = rotateY (p, angle);\r\n\tfloat topA = dot (q, normalTopA) - 2.0;\r\n\tfloat topC = dot (q, normalTopC) - 1.5;\r\n\tfloat bottomA = dot (q, normalBottomA) - 1.7;\r\n\tq = rotateY (p, -angleStep * 0.5);\r\n\tangle = angleStep * floor (atan (q.x, q.z) / angleStep);\r\n\tq = rotateY (p, angle);\r\n\tfloat topB = dot (q, normalTopB) - 1.85;\r\n\tfloat bottomB = dot (q, normalBottomB) - 1.9;\r\n\r\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\r\n}\r\n\r\n// Distance to the tray\r\nfloat getDistanceTray (in vec3 p) {\r\n\tp.y += TRAY_HEIGHT;\r\n\tfloat d = length (p.xz);\r\n\treturn max (min (d - 4.0, max (d - 17.0, -p.y - 1.0)), p.y);\r\n}\r\n\r\n// Distance to the cover\r\nfloat getDistanceCover (in vec3 p) {\r\n\tp.y += TRAY_HEIGHT + 4.0;\r\n\tfloat d = length (p) - 17.0;\r\n\treturn max (max (d, -d - 1.0), -p.y + 3.5);\r\n}\r\n\r\n// Distance to a given material\r\nfloat getDistanceMaterial (in vec3 p, in int materialIndex) {\r\n\tvec3 q = rotateX (p + vec3 (0.0, 0.0, RING_TRANSLATE), RING_ROTATE);\r\n\tfloat materialDist;\r\n\tif (materialIndex == 0) {\r\n\t\tmaterialDist = getDistanceRing (q);\r\n\t} else if (materialIndex == 1) {\r\n\t\tmaterialDist = getDistanceDiamond (q);\r\n\t} else if (materialIndex == 2) {\r\n\t\tmaterialDist = getDistanceTray (p);\r\n\t#ifdef COVER\r\n\t} else { // materialIndex == 3\r\n\t\tmaterialDist = getDistanceCover (p);\r\n\t#endif\r\n\t}\r\n\treturn materialDist;\r\n}\r\n\r\n// Distance to the scene\r\n#define MATERIAL_PROCESS(MATERIAL) if (materialDist < 0.0) materialTo = MATERIAL; sceneDist = min (sceneDist, materialFrom != MATERIAL ? materialDist : -materialDist);\r\nfloat getDistanceScene (in vec3 p, in int materialFrom, out int materialTo) {\r\n\tvec3 q = rotateX (p + vec3 (0.0, 0.0, RING_TRANSLATE), RING_ROTATE);\r\n\r\n\t// Air\r\n\tmaterialTo = -1;\r\n\tfloat sceneDist = RAY_LENGTH_MAX;\r\n\r\n\t// Ring\r\n\tfloat materialDist = getDistanceRing (q);\r\n\tMATERIAL_PROCESS (0)\r\n\r\n\t// Diamond\r\n\tmaterialDist = getDistanceDiamond (q);\r\n\tMATERIAL_PROCESS (1)\r\n\r\n\t// Tray\r\n\tmaterialDist = getDistanceTray (p);\r\n\tMATERIAL_PROCESS (2)\r\n\r\n\t// Cover\r\n\t#ifdef COVER\r\n\tmaterialDist = getDistanceCover (p);\r\n\tMATERIAL_PROCESS (3)\r\n\t#endif\r\n\r\n\t// Return the distance\r\n\treturn sceneDist;\r\n}\r\n\r\n// Normal at a given point\r\nvec3 getNormal (in vec3 p, in int materialIndex) {\r\n\tconst vec2 h = vec2 (DELTA, -DELTA);\r\n\treturn normalize (\r\n\t\th.xxx * getDistanceMaterial (p + h.xxx, materialIndex) +\r\n\t\th.xyy * getDistanceMaterial (p + h.xyy, materialIndex) +\r\n\t\th.yxy * getDistanceMaterial (p + h.yxy, materialIndex) +\r\n\t\th.yyx * getDistanceMaterial (p + h.yyx, materialIndex)\r\n\t);\r\n}\r\n\r\n// Cast a ray for a given color channel (and its corresponding refraction index)\r\nvec3 lightDirection = normalize (LIGHT);\r\nCOLOR raycast (in vec3 origin, in vec3 direction, in vec4 normal, in int materialTo, in COLOR color, in vec3 channel) {\r\n\r\n\t// Check the behavior of the material\r\n\tMaterial material = getMaterial (materialTo);\r\n\tfloat alpha = abs (material.behavior);\r\n\tcolor *= 1.0 - alpha;\r\n\r\n\t// The ray continues...\r\n\tint materialFrom = -1;\r\n\tfloat refractIndexFrom = 1.0;\r\n\tfor (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {\r\n\r\n\t\t// Interface with the material\r\n\t\tfloat refractIndexTo;\r\n\t\tvec3 refraction;\r\n\t\tif (materialTo == -1) {\r\n\t\t\trefractIndexTo = 1.0;\r\n\t\t\trefraction = refract (direction, normal.xyz, refractIndexFrom);\r\n\t\t} else {\r\n\t\t\trefractIndexTo = dot (material.refractIndex, channel);\r\n\t\t\trefraction = material.behavior < 0.0 ? vec3 (0.0) : refract (direction, normal.xyz, refractIndexFrom / refractIndexTo);\r\n\t\t}\r\n\t\tif (dot (refraction, refraction) < DELTA) {\r\n\t\t\tdirection = reflect (direction, normal.xyz);\r\n\t\t\torigin += direction * DELTA * 2.0;\r\n\t\t} else {\r\n\t\t\tdirection = refraction;\r\n\t\t\tmaterialFrom = materialTo;\r\n\t\t\trefractIndexFrom = refractIndexTo;\r\n\t\t}\r\n\r\n\t\t// Ray marching\r\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\r\n\t\t\tfloat dist = max (getDistanceScene (origin, materialFrom, materialTo), DELTA);\r\n\t\t\tnormal.w += dist;\r\n\t\t\tif (materialFrom != materialTo || normal.w > RAY_LENGTH_MAX) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\torigin += direction * dist;\r\n\t\t}\r\n\r\n\t\t// Check whether we hit something\r\n\t\tif (materialFrom == materialTo) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Get the normal\r\n\t\tif (materialTo == -1) {\r\n\t\t\tnormal.xyz = -getNormal (origin, materialFrom);\r\n\t\t} else {\r\n\t\t\tnormal.xyz = getNormal (origin, materialTo);\r\n\r\n\t\t\t// Basic lighting\r\n\t\t\tmaterial = getMaterial (materialTo);\r\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\r\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\r\n\t\t\tCOLOR localColor = (AMBIENT + relfectionDiffuse) * CHANNEL (material.color) + relfectionSpecular;\r\n\t\t\tfloat localAlpha = abs (material.behavior);\r\n\t\t\tcolor += localColor * (1.0 - localAlpha) * alpha;\r\n\t\t\talpha *= localAlpha;\r\n\t\t}\r\n\t}\r\n\r\n\t// Get the background color\r\n\tCOLOR backColor = CHANNEL (texture (iChannel0, -direction.xy).rgb);\r\n\r\n\t// Return the intensity of this color channel\r\n\treturn color + backColor * alpha;\r\n}\r\n\r\n// Main function\r\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n\t// Define the ray corresponding to this fragment\r\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\r\n\tvec3 direction = normalize (vec3 (frag, 4.0));\r\n\r\n\t// Set the camera\r\n\tvec3 origin = (35.0 + 10.0 * cos (iTime * 0.5)) * vec3 (cos (iTime * 0.1), 0.6 + 0.5 * sin (iTime * 0.2), sin (iTime * 0.1));\r\n\tvec3 forward = -origin;\r\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\r\n\tmat3 rotation;\r\n\trotation [2] = normalize (forward);\r\n\trotation [0] = normalize (cross (up, forward));\r\n\trotation [1] = cross (rotation [2], rotation [0]);\r\n\tdirection = rotation * direction;\r\n\torigin.z += 6.0;\r\n\r\n\t// Cast the initial ray\r\n\tvec4 normal = vec4 (0.0);\r\n\tint materialTo = -1;\r\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\r\n\t\tfloat dist = max (getDistanceScene (origin, -1, materialTo), DELTA);\r\n\t\tnormal.w += dist;\r\n\t\tif (materialTo != -1 || normal.w > RAY_LENGTH_MAX) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\torigin += direction * dist;\r\n\t}\r\n\r\n\t// Check whether we hit something\r\n\tif (materialTo == -1) {\r\n\t\tfragColor.rgb = texture (iChannel0, -direction.xy).rgb;\r\n\t} else {\r\n\r\n\t\t// Get the normal\r\n\t\tnormal.xyz = getNormal (origin, materialTo);\r\n\r\n\t\t// Basic lighting\r\n\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\r\n\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\r\n\t\tfragColor.rgb = (AMBIENT + relfectionDiffuse) * getMaterial (materialTo).color + relfectionSpecular;\r\n\r\n\t\t// The ray continues...\r\n\t\t#ifdef PROPAGATION\r\n\t\t\t#ifdef DISPERSION\r\n\t\t\t\tfragColor.r = raycast (origin, direction, normal, materialTo, fragColor.r, vec3 (1.0, 0.0, 0.0));\r\n\t\t\t\tfragColor.g = raycast (origin, direction, normal, materialTo, fragColor.g, vec3 (0.0, 1.0, 0.0));\r\n\t\t\t\tfragColor.b = raycast (origin, direction, normal, materialTo, fragColor.b, vec3 (0.0, 0.0, 1.0));\r\n\t\t\t#else\r\n\t\t\t\tfragColor.rgb = raycast (origin, direction, normal, materialTo, fragColor.rgb, vec3 (1.0 / 3.0));\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t}\r\n\r\n\t// Set the alpha channel\r\n\tfragColor.a = 1.0;\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":null,"published":0}],"Info":{"Name":"Diamond ring ","id":null,"date":null,"viewed":0,"name":"Diamond ring ","description":"Rework of A lonely diamond","likes":0,"published":null,"tags":["transparency"," diamond"]},"ver":null,"info":{"Name":"Diamond ring ","id":null,"date":null,"viewed":0,"name":"Diamond ring ","description":"Rework of A lonely diamond","likes":0,"published":null,"tags":["transparency"," diamond"]},"renderpass":[{"Code":"// Global rendering switch\r\n//#define FAST\r\n\r\n// Rendering parameters\r\n#define RAY_LENGTH_MAX\t\t100.0\r\n#define RAY_BOUNCE_MAX\t\t10\r\n#define RAY_STEP_MAX\t\t100\r\n#define LIGHT\t\t\t\tvec3 (-1.0, 0.5, 0.0)\r\n#define AMBIENT\t\t\t\t0.2\r\n#define SPECULAR_POWER\t\t3.0\r\n#define SPECULAR_INTENSITY\t0.8\r\n#define DIAMOND_FACES\t\t8.0\r\n#define RING_ROTATE\t\t\tPI * 0.465\r\n#define RING_TRANSLATE\t\t3.0\r\n#define TRAY_HEIGHT\t\t\t1.3\r\n\r\n// Rendering options (for those who have a slow GPU)\r\n#define PROPAGATION\r\n#ifndef FAST\r\n\t#define DISPERSION\r\n\t#define COVER\r\n#endif\r\n\r\n// Macros used to handle color channels\r\n#ifdef DISPERSION\r\n\t#define COLOR float\r\n\t#define CHANNEL(x) dot (x, channel)\r\n#else\r\n\t#define COLOR vec3\r\n\t#define CHANNEL(x) x\r\n#endif\r\n\r\n// Math constants\r\n#define DELTA\t0.01\r\n#define PI\t\t3.14159265359\r\n\r\n// Rotation on the X axis\r\nvec3 rotateX (in vec3 p, in float angle) {\r\n\tfloat c = cos (angle);\r\n\tfloat s = sin (angle);\r\n\treturn vec3 (p.x, c * p.y + s * p.z, c * p.z - s * p.y);\r\n}\r\n\r\n// Rotation on the Y axis\r\nvec3 rotateY (in vec3 p, in float angle) {\r\n\tfloat c = cos (angle);\r\n\tfloat s = sin (angle);\r\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\r\n}\r\n\r\n// Materials\r\nstruct Material {\r\n\tvec3 color;\r\n\tfloat behavior; // from -1.0 (fully reflective) to 1.0 (fully transparent)\r\n\tvec3 refractIndex; // not used if behavior < 0.0\r\n};\r\nMaterial getMaterial (in int materialIndex) {\r\n\tMaterial material;\r\n\tif (materialIndex == 0) { // Ring\r\n\t\tmaterial = Material (vec3 (1.0, 1.0, 0.8), -0.5, vec3 (1.50, 1.55, 1.60));\r\n\t} else if (materialIndex == 1) { // Diamond\r\n\t\tmaterial = Material (vec3 (0.9, 0.9, 1.0), 0.7, vec3 (2.407, 2.426, 2.451));\r\n\t} else if (materialIndex == 2) { // Tray\r\n\t\tmaterial = Material (vec3 (0.5, 0.5, 0.7), -0.4, vec3 (1.50, 1.55, 1.60));\r\n\t} else { // materialIndex == 3 // Cover\r\n\t\tmaterial = Material (vec3 (1.0, 1.0, 1.0), 0.8, vec3 (1.50, 1.55, 1.60));\r\n\t}\r\n\treturn material;\r\n}\r\n\r\n// Distance to the ring\r\nfloat getDistanceRing (in vec3 p) {\r\n\tvec2 q = vec2 (length (p.xy) - 7.8, p.z);\r\n\tfloat d1 = max (length (q) - 0.6, -0.2 - q.x);\r\n\tfloat d2 = length (max (abs (vec3 (abs (p.x), p.y, abs (p.z)) - vec3 (0.7, 8.2, 0.7)) - vec3 (0.1, 0.5, 0.1), 0.0)) - 0.1;\r\n\treturn min (d1, d2);\r\n}\r\n\r\n// Distance to the diamond\r\nvec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\r\nvec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\r\nvec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.5));\r\nvec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.0));\r\nvec3 normalBottomB = normalize (vec3 (0.0, -1.0, 1.6));\r\nfloat getDistanceDiamond (in vec3 p) {\r\n\tp.y -= 10.0;\r\n\tfloat topCut = p.y - 1.0;\r\n\tfloat angleStep = PI / DIAMOND_FACES;\r\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\r\n\tvec3 q = rotateY (p, angle);\r\n\tfloat topA = dot (q, normalTopA) - 2.0;\r\n\tfloat topC = dot (q, normalTopC) - 1.5;\r\n\tfloat bottomA = dot (q, normalBottomA) - 1.7;\r\n\tq = rotateY (p, -angleStep * 0.5);\r\n\tangle = angleStep * floor (atan (q.x, q.z) / angleStep);\r\n\tq = rotateY (p, angle);\r\n\tfloat topB = dot (q, normalTopB) - 1.85;\r\n\tfloat bottomB = dot (q, normalBottomB) - 1.9;\r\n\r\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\r\n}\r\n\r\n// Distance to the tray\r\nfloat getDistanceTray (in vec3 p) {\r\n\tp.y += TRAY_HEIGHT;\r\n\tfloat d = length (p.xz);\r\n\treturn max (min (d - 4.0, max (d - 17.0, -p.y - 1.0)), p.y);\r\n}\r\n\r\n// Distance to the cover\r\nfloat getDistanceCover (in vec3 p) {\r\n\tp.y += TRAY_HEIGHT + 4.0;\r\n\tfloat d = length (p) - 17.0;\r\n\treturn max (max (d, -d - 1.0), -p.y + 3.5);\r\n}\r\n\r\n// Distance to a given material\r\nfloat getDistanceMaterial (in vec3 p, in int materialIndex) {\r\n\tvec3 q = rotateX (p + vec3 (0.0, 0.0, RING_TRANSLATE), RING_ROTATE);\r\n\tfloat materialDist;\r\n\tif (materialIndex == 0) {\r\n\t\tmaterialDist = getDistanceRing (q);\r\n\t} else if (materialIndex == 1) {\r\n\t\tmaterialDist = getDistanceDiamond (q);\r\n\t} else if (materialIndex == 2) {\r\n\t\tmaterialDist = getDistanceTray (p);\r\n\t#ifdef COVER\r\n\t} else { // materialIndex == 3\r\n\t\tmaterialDist = getDistanceCover (p);\r\n\t#endif\r\n\t}\r\n\treturn materialDist;\r\n}\r\n\r\n// Distance to the scene\r\n#define MATERIAL_PROCESS(MATERIAL) if (materialDist < 0.0) materialTo = MATERIAL; sceneDist = min (sceneDist, materialFrom != MATERIAL ? materialDist : -materialDist);\r\nfloat getDistanceScene (in vec3 p, in int materialFrom, out int materialTo) {\r\n\tvec3 q = rotateX (p + vec3 (0.0, 0.0, RING_TRANSLATE), RING_ROTATE);\r\n\r\n\t// Air\r\n\tmaterialTo = -1;\r\n\tfloat sceneDist = RAY_LENGTH_MAX;\r\n\r\n\t// Ring\r\n\tfloat materialDist = getDistanceRing (q);\r\n\tMATERIAL_PROCESS (0)\r\n\r\n\t// Diamond\r\n\tmaterialDist = getDistanceDiamond (q);\r\n\tMATERIAL_PROCESS (1)\r\n\r\n\t// Tray\r\n\tmaterialDist = getDistanceTray (p);\r\n\tMATERIAL_PROCESS (2)\r\n\r\n\t// Cover\r\n\t#ifdef COVER\r\n\tmaterialDist = getDistanceCover (p);\r\n\tMATERIAL_PROCESS (3)\r\n\t#endif\r\n\r\n\t// Return the distance\r\n\treturn sceneDist;\r\n}\r\n\r\n// Normal at a given point\r\nvec3 getNormal (in vec3 p, in int materialIndex) {\r\n\tconst vec2 h = vec2 (DELTA, -DELTA);\r\n\treturn normalize (\r\n\t\th.xxx * getDistanceMaterial (p + h.xxx, materialIndex) +\r\n\t\th.xyy * getDistanceMaterial (p + h.xyy, materialIndex) +\r\n\t\th.yxy * getDistanceMaterial (p + h.yxy, materialIndex) +\r\n\t\th.yyx * getDistanceMaterial (p + h.yyx, materialIndex)\r\n\t);\r\n}\r\n\r\n// Cast a ray for a given color channel (and its corresponding refraction index)\r\nvec3 lightDirection = normalize (LIGHT);\r\nCOLOR raycast (in vec3 origin, in vec3 direction, in vec4 normal, in int materialTo, in COLOR color, in vec3 channel) {\r\n\r\n\t// Check the behavior of the material\r\n\tMaterial material = getMaterial (materialTo);\r\n\tfloat alpha = abs (material.behavior);\r\n\tcolor *= 1.0 - alpha;\r\n\r\n\t// The ray continues...\r\n\tint materialFrom = -1;\r\n\tfloat refractIndexFrom = 1.0;\r\n\tfor (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {\r\n\r\n\t\t// Interface with the material\r\n\t\tfloat refractIndexTo;\r\n\t\tvec3 refraction;\r\n\t\tif (materialTo == -1) {\r\n\t\t\trefractIndexTo = 1.0;\r\n\t\t\trefraction = refract (direction, normal.xyz, refractIndexFrom);\r\n\t\t} else {\r\n\t\t\trefractIndexTo = dot (material.refractIndex, channel);\r\n\t\t\trefraction = material.behavior < 0.0 ? vec3 (0.0) : refract (direction, normal.xyz, refractIndexFrom / refractIndexTo);\r\n\t\t}\r\n\t\tif (dot (refraction, refraction) < DELTA) {\r\n\t\t\tdirection = reflect (direction, normal.xyz);\r\n\t\t\torigin += direction * DELTA * 2.0;\r\n\t\t} else {\r\n\t\t\tdirection = refraction;\r\n\t\t\tmaterialFrom = materialTo;\r\n\t\t\trefractIndexFrom = refractIndexTo;\r\n\t\t}\r\n\r\n\t\t// Ray marching\r\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\r\n\t\t\tfloat dist = max (getDistanceScene (origin, materialFrom, materialTo), DELTA);\r\n\t\t\tnormal.w += dist;\r\n\t\t\tif (materialFrom != materialTo || normal.w > RAY_LENGTH_MAX) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\torigin += direction * dist;\r\n\t\t}\r\n\r\n\t\t// Check whether we hit something\r\n\t\tif (materialFrom == materialTo) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Get the normal\r\n\t\tif (materialTo == -1) {\r\n\t\t\tnormal.xyz = -getNormal (origin, materialFrom);\r\n\t\t} else {\r\n\t\t\tnormal.xyz = getNormal (origin, materialTo);\r\n\r\n\t\t\t// Basic lighting\r\n\t\t\tmaterial = getMaterial (materialTo);\r\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\r\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\r\n\t\t\tCOLOR localColor = (AMBIENT + relfectionDiffuse) * CHANNEL (material.color) + relfectionSpecular;\r\n\t\t\tfloat localAlpha = abs (material.behavior);\r\n\t\t\tcolor += localColor * (1.0 - localAlpha) * alpha;\r\n\t\t\talpha *= localAlpha;\r\n\t\t}\r\n\t}\r\n\r\n\t// Get the background color\r\n\tCOLOR backColor = CHANNEL (texture (iChannel0, -direction.xy).rgb);\r\n\r\n\t// Return the intensity of this color channel\r\n\treturn color + backColor * alpha;\r\n}\r\n\r\n// Main function\r\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n\t// Define the ray corresponding to this fragment\r\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\r\n\tvec3 direction = normalize (vec3 (frag, 4.0));\r\n\r\n\t// Set the camera\r\n\tvec3 origin = (35.0 + 10.0 * cos (iTime * 0.5)) * vec3 (cos (iTime * 0.1), 0.6 + 0.5 * sin (iTime * 0.2), sin (iTime * 0.1));\r\n\tvec3 forward = -origin;\r\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\r\n\tmat3 rotation;\r\n\trotation [2] = normalize (forward);\r\n\trotation [0] = normalize (cross (up, forward));\r\n\trotation [1] = cross (rotation [2], rotation [0]);\r\n\tdirection = rotation * direction;\r\n\torigin.z += 6.0;\r\n\r\n\t// Cast the initial ray\r\n\tvec4 normal = vec4 (0.0);\r\n\tint materialTo = -1;\r\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\r\n\t\tfloat dist = max (getDistanceScene (origin, -1, materialTo), DELTA);\r\n\t\tnormal.w += dist;\r\n\t\tif (materialTo != -1 || normal.w > RAY_LENGTH_MAX) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\torigin += direction * dist;\r\n\t}\r\n\r\n\t// Check whether we hit something\r\n\tif (materialTo == -1) {\r\n\t\tfragColor.rgb = texture (iChannel0, -direction.xy).rgb;\r\n\t} else {\r\n\r\n\t\t// Get the normal\r\n\t\tnormal.xyz = getNormal (origin, materialTo);\r\n\r\n\t\t// Basic lighting\r\n\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\r\n\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\r\n\t\tfragColor.rgb = (AMBIENT + relfectionDiffuse) * getMaterial (materialTo).color + relfectionSpecular;\r\n\r\n\t\t// The ray continues...\r\n\t\t#ifdef PROPAGATION\r\n\t\t\t#ifdef DISPERSION\r\n\t\t\t\tfragColor.r = raycast (origin, direction, normal, materialTo, fragColor.r, vec3 (1.0, 0.0, 0.0));\r\n\t\t\t\tfragColor.g = raycast (origin, direction, normal, materialTo, fragColor.g, vec3 (0.0, 1.0, 0.0));\r\n\t\t\t\tfragColor.b = raycast (origin, direction, normal, materialTo, fragColor.b, vec3 (0.0, 0.0, 1.0));\r\n\t\t\t#else\r\n\t\t\t\tfragColor.rgb = raycast (origin, direction, normal, materialTo, fragColor.rgb, vec3 (1.0 / 3.0));\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t}\r\n\r\n\t// Set the alpha channel\r\n\tfragColor.a = 1.0;\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"// Global rendering switch\r\n//#define FAST\r\n\r\n// Rendering parameters\r\n#define RAY_LENGTH_MAX\t\t100.0\r\n#define RAY_BOUNCE_MAX\t\t10\r\n#define RAY_STEP_MAX\t\t100\r\n#define LIGHT\t\t\t\tvec3 (-1.0, 0.5, 0.0)\r\n#define AMBIENT\t\t\t\t0.2\r\n#define SPECULAR_POWER\t\t3.0\r\n#define SPECULAR_INTENSITY\t0.8\r\n#define DIAMOND_FACES\t\t8.0\r\n#define RING_ROTATE\t\t\tPI * 0.465\r\n#define RING_TRANSLATE\t\t3.0\r\n#define TRAY_HEIGHT\t\t\t1.3\r\n\r\n// Rendering options (for those who have a slow GPU)\r\n#define PROPAGATION\r\n#ifndef FAST\r\n\t#define DISPERSION\r\n\t#define COVER\r\n#endif\r\n\r\n// Macros used to handle color channels\r\n#ifdef DISPERSION\r\n\t#define COLOR float\r\n\t#define CHANNEL(x) dot (x, channel)\r\n#else\r\n\t#define COLOR vec3\r\n\t#define CHANNEL(x) x\r\n#endif\r\n\r\n// Math constants\r\n#define DELTA\t0.01\r\n#define PI\t\t3.14159265359\r\n\r\n// Rotation on the X axis\r\nvec3 rotateX (in vec3 p, in float angle) {\r\n\tfloat c = cos (angle);\r\n\tfloat s = sin (angle);\r\n\treturn vec3 (p.x, c * p.y + s * p.z, c * p.z - s * p.y);\r\n}\r\n\r\n// Rotation on the Y axis\r\nvec3 rotateY (in vec3 p, in float angle) {\r\n\tfloat c = cos (angle);\r\n\tfloat s = sin (angle);\r\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\r\n}\r\n\r\n// Materials\r\nstruct Material {\r\n\tvec3 color;\r\n\tfloat behavior; // from -1.0 (fully reflective) to 1.0 (fully transparent)\r\n\tvec3 refractIndex; // not used if behavior < 0.0\r\n};\r\nMaterial getMaterial (in int materialIndex) {\r\n\tMaterial material;\r\n\tif (materialIndex == 0) { // Ring\r\n\t\tmaterial = Material (vec3 (1.0, 1.0, 0.8), -0.5, vec3 (1.50, 1.55, 1.60));\r\n\t} else if (materialIndex == 1) { // Diamond\r\n\t\tmaterial = Material (vec3 (0.9, 0.9, 1.0), 0.7, vec3 (2.407, 2.426, 2.451));\r\n\t} else if (materialIndex == 2) { // Tray\r\n\t\tmaterial = Material (vec3 (0.5, 0.5, 0.7), -0.4, vec3 (1.50, 1.55, 1.60));\r\n\t} else { // materialIndex == 3 // Cover\r\n\t\tmaterial = Material (vec3 (1.0, 1.0, 1.0), 0.8, vec3 (1.50, 1.55, 1.60));\r\n\t}\r\n\treturn material;\r\n}\r\n\r\n// Distance to the ring\r\nfloat getDistanceRing (in vec3 p) {\r\n\tvec2 q = vec2 (length (p.xy) - 7.8, p.z);\r\n\tfloat d1 = max (length (q) - 0.6, -0.2 - q.x);\r\n\tfloat d2 = length (max (abs (vec3 (abs (p.x), p.y, abs (p.z)) - vec3 (0.7, 8.2, 0.7)) - vec3 (0.1, 0.5, 0.1), 0.0)) - 0.1;\r\n\treturn min (d1, d2);\r\n}\r\n\r\n// Distance to the diamond\r\nvec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\r\nvec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\r\nvec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.5));\r\nvec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.0));\r\nvec3 normalBottomB = normalize (vec3 (0.0, -1.0, 1.6));\r\nfloat getDistanceDiamond (in vec3 p) {\r\n\tp.y -= 10.0;\r\n\tfloat topCut = p.y - 1.0;\r\n\tfloat angleStep = PI / DIAMOND_FACES;\r\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\r\n\tvec3 q = rotateY (p, angle);\r\n\tfloat topA = dot (q, normalTopA) - 2.0;\r\n\tfloat topC = dot (q, normalTopC) - 1.5;\r\n\tfloat bottomA = dot (q, normalBottomA) - 1.7;\r\n\tq = rotateY (p, -angleStep * 0.5);\r\n\tangle = angleStep * floor (atan (q.x, q.z) / angleStep);\r\n\tq = rotateY (p, angle);\r\n\tfloat topB = dot (q, normalTopB) - 1.85;\r\n\tfloat bottomB = dot (q, normalBottomB) - 1.9;\r\n\r\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\r\n}\r\n\r\n// Distance to the tray\r\nfloat getDistanceTray (in vec3 p) {\r\n\tp.y += TRAY_HEIGHT;\r\n\tfloat d = length (p.xz);\r\n\treturn max (min (d - 4.0, max (d - 17.0, -p.y - 1.0)), p.y);\r\n}\r\n\r\n// Distance to the cover\r\nfloat getDistanceCover (in vec3 p) {\r\n\tp.y += TRAY_HEIGHT + 4.0;\r\n\tfloat d = length (p) - 17.0;\r\n\treturn max (max (d, -d - 1.0), -p.y + 3.5);\r\n}\r\n\r\n// Distance to a given material\r\nfloat getDistanceMaterial (in vec3 p, in int materialIndex) {\r\n\tvec3 q = rotateX (p + vec3 (0.0, 0.0, RING_TRANSLATE), RING_ROTATE);\r\n\tfloat materialDist;\r\n\tif (materialIndex == 0) {\r\n\t\tmaterialDist = getDistanceRing (q);\r\n\t} else if (materialIndex == 1) {\r\n\t\tmaterialDist = getDistanceDiamond (q);\r\n\t} else if (materialIndex == 2) {\r\n\t\tmaterialDist = getDistanceTray (p);\r\n\t#ifdef COVER\r\n\t} else { // materialIndex == 3\r\n\t\tmaterialDist = getDistanceCover (p);\r\n\t#endif\r\n\t}\r\n\treturn materialDist;\r\n}\r\n\r\n// Distance to the scene\r\n#define MATERIAL_PROCESS(MATERIAL) if (materialDist < 0.0) materialTo = MATERIAL; sceneDist = min (sceneDist, materialFrom != MATERIAL ? materialDist : -materialDist);\r\nfloat getDistanceScene (in vec3 p, in int materialFrom, out int materialTo) {\r\n\tvec3 q = rotateX (p + vec3 (0.0, 0.0, RING_TRANSLATE), RING_ROTATE);\r\n\r\n\t// Air\r\n\tmaterialTo = -1;\r\n\tfloat sceneDist = RAY_LENGTH_MAX;\r\n\r\n\t// Ring\r\n\tfloat materialDist = getDistanceRing (q);\r\n\tMATERIAL_PROCESS (0)\r\n\r\n\t// Diamond\r\n\tmaterialDist = getDistanceDiamond (q);\r\n\tMATERIAL_PROCESS (1)\r\n\r\n\t// Tray\r\n\tmaterialDist = getDistanceTray (p);\r\n\tMATERIAL_PROCESS (2)\r\n\r\n\t// Cover\r\n\t#ifdef COVER\r\n\tmaterialDist = getDistanceCover (p);\r\n\tMATERIAL_PROCESS (3)\r\n\t#endif\r\n\r\n\t// Return the distance\r\n\treturn sceneDist;\r\n}\r\n\r\n// Normal at a given point\r\nvec3 getNormal (in vec3 p, in int materialIndex) {\r\n\tconst vec2 h = vec2 (DELTA, -DELTA);\r\n\treturn normalize (\r\n\t\th.xxx * getDistanceMaterial (p + h.xxx, materialIndex) +\r\n\t\th.xyy * getDistanceMaterial (p + h.xyy, materialIndex) +\r\n\t\th.yxy * getDistanceMaterial (p + h.yxy, materialIndex) +\r\n\t\th.yyx * getDistanceMaterial (p + h.yyx, materialIndex)\r\n\t);\r\n}\r\n\r\n// Cast a ray for a given color channel (and its corresponding refraction index)\r\nvec3 lightDirection = normalize (LIGHT);\r\nCOLOR raycast (in vec3 origin, in vec3 direction, in vec4 normal, in int materialTo, in COLOR color, in vec3 channel) {\r\n\r\n\t// Check the behavior of the material\r\n\tMaterial material = getMaterial (materialTo);\r\n\tfloat alpha = abs (material.behavior);\r\n\tcolor *= 1.0 - alpha;\r\n\r\n\t// The ray continues...\r\n\tint materialFrom = -1;\r\n\tfloat refractIndexFrom = 1.0;\r\n\tfor (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {\r\n\r\n\t\t// Interface with the material\r\n\t\tfloat refractIndexTo;\r\n\t\tvec3 refraction;\r\n\t\tif (materialTo == -1) {\r\n\t\t\trefractIndexTo = 1.0;\r\n\t\t\trefraction = refract (direction, normal.xyz, refractIndexFrom);\r\n\t\t} else {\r\n\t\t\trefractIndexTo = dot (material.refractIndex, channel);\r\n\t\t\trefraction = material.behavior < 0.0 ? vec3 (0.0) : refract (direction, normal.xyz, refractIndexFrom / refractIndexTo);\r\n\t\t}\r\n\t\tif (dot (refraction, refraction) < DELTA) {\r\n\t\t\tdirection = reflect (direction, normal.xyz);\r\n\t\t\torigin += direction * DELTA * 2.0;\r\n\t\t} else {\r\n\t\t\tdirection = refraction;\r\n\t\t\tmaterialFrom = materialTo;\r\n\t\t\trefractIndexFrom = refractIndexTo;\r\n\t\t}\r\n\r\n\t\t// Ray marching\r\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\r\n\t\t\tfloat dist = max (getDistanceScene (origin, materialFrom, materialTo), DELTA);\r\n\t\t\tnormal.w += dist;\r\n\t\t\tif (materialFrom != materialTo || normal.w > RAY_LENGTH_MAX) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\torigin += direction * dist;\r\n\t\t}\r\n\r\n\t\t// Check whether we hit something\r\n\t\tif (materialFrom == materialTo) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Get the normal\r\n\t\tif (materialTo == -1) {\r\n\t\t\tnormal.xyz = -getNormal (origin, materialFrom);\r\n\t\t} else {\r\n\t\t\tnormal.xyz = getNormal (origin, materialTo);\r\n\r\n\t\t\t// Basic lighting\r\n\t\t\tmaterial = getMaterial (materialTo);\r\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\r\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\r\n\t\t\tCOLOR localColor = (AMBIENT + relfectionDiffuse) * CHANNEL (material.color) + relfectionSpecular;\r\n\t\t\tfloat localAlpha = abs (material.behavior);\r\n\t\t\tcolor += localColor * (1.0 - localAlpha) * alpha;\r\n\t\t\talpha *= localAlpha;\r\n\t\t}\r\n\t}\r\n\r\n\t// Get the background color\r\n\tCOLOR backColor = CHANNEL (texture (iChannel0, -direction.xy).rgb);\r\n\r\n\t// Return the intensity of this color channel\r\n\treturn color + backColor * alpha;\r\n}\r\n\r\n// Main function\r\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n\t// Define the ray corresponding to this fragment\r\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\r\n\tvec3 direction = normalize (vec3 (frag, 4.0));\r\n\r\n\t// Set the camera\r\n\tvec3 origin = (35.0 + 10.0 * cos (iTime * 0.5)) * vec3 (cos (iTime * 0.1), 0.6 + 0.5 * sin (iTime * 0.2), sin (iTime * 0.1));\r\n\tvec3 forward = -origin;\r\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\r\n\tmat3 rotation;\r\n\trotation [2] = normalize (forward);\r\n\trotation [0] = normalize (cross (up, forward));\r\n\trotation [1] = cross (rotation [2], rotation [0]);\r\n\tdirection = rotation * direction;\r\n\torigin.z += 6.0;\r\n\r\n\t// Cast the initial ray\r\n\tvec4 normal = vec4 (0.0);\r\n\tint materialTo = -1;\r\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\r\n\t\tfloat dist = max (getDistanceScene (origin, -1, materialTo), DELTA);\r\n\t\tnormal.w += dist;\r\n\t\tif (materialTo != -1 || normal.w > RAY_LENGTH_MAX) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\torigin += direction * dist;\r\n\t}\r\n\r\n\t// Check whether we hit something\r\n\tif (materialTo == -1) {\r\n\t\tfragColor.rgb = texture (iChannel0, -direction.xy).rgb;\r\n\t} else {\r\n\r\n\t\t// Get the normal\r\n\t\tnormal.xyz = getNormal (origin, materialTo);\r\n\r\n\t\t// Basic lighting\r\n\t\tfloat relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));\r\n\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\r\n\t\tfragColor.rgb = (AMBIENT + relfectionDiffuse) * getMaterial (materialTo).color + relfectionSpecular;\r\n\r\n\t\t// The ray continues...\r\n\t\t#ifdef PROPAGATION\r\n\t\t\t#ifdef DISPERSION\r\n\t\t\t\tfragColor.r = raycast (origin, direction, normal, materialTo, fragColor.r, vec3 (1.0, 0.0, 0.0));\r\n\t\t\t\tfragColor.g = raycast (origin, direction, normal, materialTo, fragColor.g, vec3 (0.0, 1.0, 0.0));\r\n\t\t\t\tfragColor.b = raycast (origin, direction, normal, materialTo, fragColor.b, vec3 (0.0, 0.0, 1.0));\r\n\t\t\t#else\r\n\t\t\t\tfragColor.rgb = raycast (origin, direction, normal, materialTo, fragColor.rgb, vec3 (1.0 / 3.0));\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t}\r\n\r\n\t// Set the alpha channel\r\n\tfragColor.a = 1.0;\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Forked from: https://www.shadertoy.com/view/ldfXzn\r\n\r\n#define DELTA\t\t\t\t0.001\r\n#define RAY_COUNT\t\t\t7\r\n#define RAY_LENGTH_MAX\t\t100.0\r\n#define RAY_STEP_MAX\t\t100\r\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\r\n#define REFRACT_FACTOR\t\t0.6\r\n#define REFRACT_INDEX\t\t1.6\r\n#define AMBIENT\t\t\t\t0.2\r\n#define SPECULAR_POWER\t\t3.0\r\n#define SPECULAR_INTENSITY\t0.5\r\n#define FADE_POWER\t\t\t1.0\r\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\r\n#define GLOW_FACTOR\t\t\t1.5\r\n#define LUMINOSITY_FACTOR\t2.0\r\n\r\nmat3 mRotate (in vec3 angle) {\r\n\tfloat c = cos (angle.x);\r\n\tfloat s = sin (angle.x);\r\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\r\n\r\n\tc = cos (angle.y);\r\n\ts = sin (angle.y);\r\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\r\n\r\n\tc = cos (angle.z);\r\n\ts = sin (angle.z);\r\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\r\n\r\n\treturn rz * ry * rx;\r\n}\r\n\r\nvec3 k;\r\nfloat getDistance (in vec3 p) {\r\n\tfloat repeat = 20.0;\r\n\tvec3 q = p + repeat * 0.5;\r\n\tk = floor (q / repeat);\r\n\tq -= repeat * (k + 0.5);\r\n\tp = mRotate (k) * q;\r\n\r\n\tfloat top = p.y - 3.0;\r\n\tfloat angleStep = M_PI / max (2.0, abs (k.x + 2.0 * k.y + 4.0 * k.z));\r\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\r\n\tfloat side = cos (angle) * p.z + sin (angle) * p.x - 2.0;\r\n\tfloat bottom = -p.y - 3.0;\r\n\r\n\treturn max (top, max (side, bottom));\r\n}\r\n\r\nvec3 getFragmentColor (in vec3 origin, in vec3 direction) {\r\n\tvec3 lightDirection = normalize (LIGHT);\r\n\tvec2 delta = vec2 (DELTA, 0.0);\r\n\r\n\tvec3 fragColor = vec3 (0.0, 0.0, 0.0);\r\n\tfloat intensity = 1.0;\r\n\r\n\tfloat distanceFactor = 1.0;\r\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\r\n\tfloat rayStepCount = 0.0;\r\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\r\n\r\n\t\t// Ray marching\r\n\t\tfloat dist = RAY_LENGTH_MAX;\r\n\t\tfloat rayLength = 0.0;\r\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\r\n\t\t\tdist = distanceFactor * getDistance (origin);\r\n\t\t\tfloat distMin = max (dist, DELTA);\r\n\t\t\trayLength += distMin;\r\n\t\t\tif (dist < 0.0 || rayLength > RAY_LENGTH_MAX) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\torigin += direction * distMin;\r\n\t\t\t++rayStepCount;\r\n\t\t}\r\n\r\n\t\t// Check whether we hit something\r\n\t\tvec3 backColor = vec3 (0.0, 0.0, 0.1 + 0.2 * max (0.0, dot (-direction, lightDirection)));\r\n\t\tif (dist >= 0.0) {\r\n\t\t\tfragColor = fragColor * (1.0 - intensity) + backColor * intensity;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Get the normal\r\n\t\tvec3 normal = normalize (distanceFactor * vec3 (\r\n\t\t\tgetDistance (origin + delta.xyy) - getDistance (origin - delta.xyy),\r\n\t\t\tgetDistance (origin + delta.yxy) - getDistance (origin - delta.yxy),\r\n\t\t\tgetDistance (origin + delta.yyx) - getDistance (origin - delta.yyx)));\r\n\r\n\t\t// Basic lighting\r\n\t\tvec3 reflection = reflect (direction, normal);\r\n\t\tif (distanceFactor > 0.0) {\r\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal, lightDirection));\r\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\r\n\t\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\r\n\r\n\t\t\tvec3 localColor = max (sin (k * k), 0.2);\r\n\t\t\tlocalColor = (AMBIENT + relfectionDiffuse) * localColor + relfectionSpecular;\r\n\t\t\tlocalColor = mix (backColor, localColor, fade);\r\n\r\n\t\t\tfragColor = fragColor * (1.0 - intensity) + localColor * intensity;\r\n\t\t\tintensity *= REFRACT_FACTOR;\r\n\t\t}\r\n\r\n\t\t// Next ray...\r\n\t\tvec3 refraction = refract (direction, normal, refractionRatio);\r\n\t\tif (dot (refraction, refraction) < DELTA) {\r\n\t\t\tdirection = reflection;\r\n\t\t\torigin += direction * DELTA * 2.0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdirection = refraction;\r\n\t\t\tdistanceFactor = -distanceFactor;\r\n\t\t\trefractionRatio = 1.0 / refractionRatio;\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the fragment color\r\n\treturn fragColor * LUMINOSITY_FACTOR + GLOW_FACTOR * rayStepCount / float (RAY_STEP_MAX * RAY_COUNT);\r\n}\r\n\r\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n\t// Define the ray corresponding to this fragment\r\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\r\n\tvec3 direction = normalize (vec3 (frag, 2.0));\r\n\r\n\t// Set the camera\r\n\tvec3 origin = vec3 ((15.0 * cos (iTime * 0.1)), 10.0 * sin (iTime * 0.2), 15.0 * sin (iTime * 0.1));\r\n\tvec3 forward = -origin;\r\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\r\n\tmat3 rotation;\r\n\trotation [2] = normalize (forward);\r\n\trotation [0] = normalize (cross (up, forward));\r\n\trotation [1] = cross (rotation [2], rotation [0]);\r\n\tdirection = rotation * direction;\r\n\r\n\t// Set the fragment color\r\n\tfragColor = vec4 (getFragmentColor (origin, direction), 1.0);\r\n}","inputs":[],"outputs":[],"code":"// Forked from: https://www.shadertoy.com/view/ldfXzn\r\n\r\n#define DELTA\t\t\t\t0.001\r\n#define RAY_COUNT\t\t\t7\r\n#define RAY_LENGTH_MAX\t\t100.0\r\n#define RAY_STEP_MAX\t\t100\r\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\r\n#define REFRACT_FACTOR\t\t0.6\r\n#define REFRACT_INDEX\t\t1.6\r\n#define AMBIENT\t\t\t\t0.2\r\n#define SPECULAR_POWER\t\t3.0\r\n#define SPECULAR_INTENSITY\t0.5\r\n#define FADE_POWER\t\t\t1.0\r\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\r\n#define GLOW_FACTOR\t\t\t1.5\r\n#define LUMINOSITY_FACTOR\t2.0\r\n\r\nmat3 mRotate (in vec3 angle) {\r\n\tfloat c = cos (angle.x);\r\n\tfloat s = sin (angle.x);\r\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\r\n\r\n\tc = cos (angle.y);\r\n\ts = sin (angle.y);\r\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\r\n\r\n\tc = cos (angle.z);\r\n\ts = sin (angle.z);\r\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\r\n\r\n\treturn rz * ry * rx;\r\n}\r\n\r\nvec3 k;\r\nfloat getDistance (in vec3 p) {\r\n\tfloat repeat = 20.0;\r\n\tvec3 q = p + repeat * 0.5;\r\n\tk = floor (q / repeat);\r\n\tq -= repeat * (k + 0.5);\r\n\tp = mRotate (k) * q;\r\n\r\n\tfloat top = p.y - 3.0;\r\n\tfloat angleStep = M_PI / max (2.0, abs (k.x + 2.0 * k.y + 4.0 * k.z));\r\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\r\n\tfloat side = cos (angle) * p.z + sin (angle) * p.x - 2.0;\r\n\tfloat bottom = -p.y - 3.0;\r\n\r\n\treturn max (top, max (side, bottom));\r\n}\r\n\r\nvec3 getFragmentColor (in vec3 origin, in vec3 direction) {\r\n\tvec3 lightDirection = normalize (LIGHT);\r\n\tvec2 delta = vec2 (DELTA, 0.0);\r\n\r\n\tvec3 fragColor = vec3 (0.0, 0.0, 0.0);\r\n\tfloat intensity = 1.0;\r\n\r\n\tfloat distanceFactor = 1.0;\r\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\r\n\tfloat rayStepCount = 0.0;\r\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\r\n\r\n\t\t// Ray marching\r\n\t\tfloat dist = RAY_LENGTH_MAX;\r\n\t\tfloat rayLength = 0.0;\r\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\r\n\t\t\tdist = distanceFactor * getDistance (origin);\r\n\t\t\tfloat distMin = max (dist, DELTA);\r\n\t\t\trayLength += distMin;\r\n\t\t\tif (dist < 0.0 || rayLength > RAY_LENGTH_MAX) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\torigin += direction * distMin;\r\n\t\t\t++rayStepCount;\r\n\t\t}\r\n\r\n\t\t// Check whether we hit something\r\n\t\tvec3 backColor = vec3 (0.0, 0.0, 0.1 + 0.2 * max (0.0, dot (-direction, lightDirection)));\r\n\t\tif (dist >= 0.0) {\r\n\t\t\tfragColor = fragColor * (1.0 - intensity) + backColor * intensity;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Get the normal\r\n\t\tvec3 normal = normalize (distanceFactor * vec3 (\r\n\t\t\tgetDistance (origin + delta.xyy) - getDistance (origin - delta.xyy),\r\n\t\t\tgetDistance (origin + delta.yxy) - getDistance (origin - delta.yxy),\r\n\t\t\tgetDistance (origin + delta.yyx) - getDistance (origin - delta.yyx)));\r\n\r\n\t\t// Basic lighting\r\n\t\tvec3 reflection = reflect (direction, normal);\r\n\t\tif (distanceFactor > 0.0) {\r\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal, lightDirection));\r\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\r\n\t\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\r\n\r\n\t\t\tvec3 localColor = max (sin (k * k), 0.2);\r\n\t\t\tlocalColor = (AMBIENT + relfectionDiffuse) * localColor + relfectionSpecular;\r\n\t\t\tlocalColor = mix (backColor, localColor, fade);\r\n\r\n\t\t\tfragColor = fragColor * (1.0 - intensity) + localColor * intensity;\r\n\t\t\tintensity *= REFRACT_FACTOR;\r\n\t\t}\r\n\r\n\t\t// Next ray...\r\n\t\tvec3 refraction = refract (direction, normal, refractionRatio);\r\n\t\tif (dot (refraction, refraction) < DELTA) {\r\n\t\t\tdirection = reflection;\r\n\t\t\torigin += direction * DELTA * 2.0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdirection = refraction;\r\n\t\t\tdistanceFactor = -distanceFactor;\r\n\t\t\trefractionRatio = 1.0 / refractionRatio;\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the fragment color\r\n\treturn fragColor * LUMINOSITY_FACTOR + GLOW_FACTOR * rayStepCount / float (RAY_STEP_MAX * RAY_COUNT);\r\n}\r\n\r\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n\t// Define the ray corresponding to this fragment\r\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\r\n\tvec3 direction = normalize (vec3 (frag, 2.0));\r\n\r\n\t// Set the camera\r\n\tvec3 origin = vec3 ((15.0 * cos (iTime * 0.1)), 10.0 * sin (iTime * 0.2), 15.0 * sin (iTime * 0.1));\r\n\tvec3 forward = -origin;\r\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\r\n\tmat3 rotation;\r\n\trotation [2] = normalize (forward);\r\n\trotation [0] = normalize (cross (up, forward));\r\n\trotation [1] = cross (rotation [2], rotation [0]);\r\n\tdirection = rotation * direction;\r\n\r\n\t// Set the fragment color\r\n\tfragColor = vec4 (getFragmentColor (origin, direction), 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Glass Polyhedron","id":null,"date":null,"viewed":0,"name":"Glass Polyhedron","description":"Forked from: https://www.shadertoy.com/view/ldfXzn\r\n\r\nThis is a simplification of my \"diamond\", to check about refraction and reflection...","likes":0,"published":null,"tags":["raymarching"," glass"]},"ver":null,"info":{"Name":"Glass Polyhedron","id":null,"date":null,"viewed":0,"name":"Glass Polyhedron","description":"Forked from: https://www.shadertoy.com/view/ldfXzn\r\n\r\nThis is a simplification of my \"diamond\", to check about refraction and reflection...","likes":0,"published":null,"tags":["raymarching"," glass"]},"renderpass":[{"Code":"// Forked from: https://www.shadertoy.com/view/ldfXzn\r\n\r\n#define DELTA\t\t\t\t0.001\r\n#define RAY_COUNT\t\t\t7\r\n#define RAY_LENGTH_MAX\t\t100.0\r\n#define RAY_STEP_MAX\t\t100\r\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\r\n#define REFRACT_FACTOR\t\t0.6\r\n#define REFRACT_INDEX\t\t1.6\r\n#define AMBIENT\t\t\t\t0.2\r\n#define SPECULAR_POWER\t\t3.0\r\n#define SPECULAR_INTENSITY\t0.5\r\n#define FADE_POWER\t\t\t1.0\r\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\r\n#define GLOW_FACTOR\t\t\t1.5\r\n#define LUMINOSITY_FACTOR\t2.0\r\n\r\nmat3 mRotate (in vec3 angle) {\r\n\tfloat c = cos (angle.x);\r\n\tfloat s = sin (angle.x);\r\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\r\n\r\n\tc = cos (angle.y);\r\n\ts = sin (angle.y);\r\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\r\n\r\n\tc = cos (angle.z);\r\n\ts = sin (angle.z);\r\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\r\n\r\n\treturn rz * ry * rx;\r\n}\r\n\r\nvec3 k;\r\nfloat getDistance (in vec3 p) {\r\n\tfloat repeat = 20.0;\r\n\tvec3 q = p + repeat * 0.5;\r\n\tk = floor (q / repeat);\r\n\tq -= repeat * (k + 0.5);\r\n\tp = mRotate (k) * q;\r\n\r\n\tfloat top = p.y - 3.0;\r\n\tfloat angleStep = M_PI / max (2.0, abs (k.x + 2.0 * k.y + 4.0 * k.z));\r\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\r\n\tfloat side = cos (angle) * p.z + sin (angle) * p.x - 2.0;\r\n\tfloat bottom = -p.y - 3.0;\r\n\r\n\treturn max (top, max (side, bottom));\r\n}\r\n\r\nvec3 getFragmentColor (in vec3 origin, in vec3 direction) {\r\n\tvec3 lightDirection = normalize (LIGHT);\r\n\tvec2 delta = vec2 (DELTA, 0.0);\r\n\r\n\tvec3 fragColor = vec3 (0.0, 0.0, 0.0);\r\n\tfloat intensity = 1.0;\r\n\r\n\tfloat distanceFactor = 1.0;\r\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\r\n\tfloat rayStepCount = 0.0;\r\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\r\n\r\n\t\t// Ray marching\r\n\t\tfloat dist = RAY_LENGTH_MAX;\r\n\t\tfloat rayLength = 0.0;\r\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\r\n\t\t\tdist = distanceFactor * getDistance (origin);\r\n\t\t\tfloat distMin = max (dist, DELTA);\r\n\t\t\trayLength += distMin;\r\n\t\t\tif (dist < 0.0 || rayLength > RAY_LENGTH_MAX) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\torigin += direction * distMin;\r\n\t\t\t++rayStepCount;\r\n\t\t}\r\n\r\n\t\t// Check whether we hit something\r\n\t\tvec3 backColor = vec3 (0.0, 0.0, 0.1 + 0.2 * max (0.0, dot (-direction, lightDirection)));\r\n\t\tif (dist >= 0.0) {\r\n\t\t\tfragColor = fragColor * (1.0 - intensity) + backColor * intensity;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Get the normal\r\n\t\tvec3 normal = normalize (distanceFactor * vec3 (\r\n\t\t\tgetDistance (origin + delta.xyy) - getDistance (origin - delta.xyy),\r\n\t\t\tgetDistance (origin + delta.yxy) - getDistance (origin - delta.yxy),\r\n\t\t\tgetDistance (origin + delta.yyx) - getDistance (origin - delta.yyx)));\r\n\r\n\t\t// Basic lighting\r\n\t\tvec3 reflection = reflect (direction, normal);\r\n\t\tif (distanceFactor > 0.0) {\r\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal, lightDirection));\r\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\r\n\t\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\r\n\r\n\t\t\tvec3 localColor = max (sin (k * k), 0.2);\r\n\t\t\tlocalColor = (AMBIENT + relfectionDiffuse) * localColor + relfectionSpecular;\r\n\t\t\tlocalColor = mix (backColor, localColor, fade);\r\n\r\n\t\t\tfragColor = fragColor * (1.0 - intensity) + localColor * intensity;\r\n\t\t\tintensity *= REFRACT_FACTOR;\r\n\t\t}\r\n\r\n\t\t// Next ray...\r\n\t\tvec3 refraction = refract (direction, normal, refractionRatio);\r\n\t\tif (dot (refraction, refraction) < DELTA) {\r\n\t\t\tdirection = reflection;\r\n\t\t\torigin += direction * DELTA * 2.0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdirection = refraction;\r\n\t\t\tdistanceFactor = -distanceFactor;\r\n\t\t\trefractionRatio = 1.0 / refractionRatio;\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the fragment color\r\n\treturn fragColor * LUMINOSITY_FACTOR + GLOW_FACTOR * rayStepCount / float (RAY_STEP_MAX * RAY_COUNT);\r\n}\r\n\r\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n\t// Define the ray corresponding to this fragment\r\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\r\n\tvec3 direction = normalize (vec3 (frag, 2.0));\r\n\r\n\t// Set the camera\r\n\tvec3 origin = vec3 ((15.0 * cos (iTime * 0.1)), 10.0 * sin (iTime * 0.2), 15.0 * sin (iTime * 0.1));\r\n\tvec3 forward = -origin;\r\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\r\n\tmat3 rotation;\r\n\trotation [2] = normalize (forward);\r\n\trotation [0] = normalize (cross (up, forward));\r\n\trotation [1] = cross (rotation [2], rotation [0]);\r\n\tdirection = rotation * direction;\r\n\r\n\t// Set the fragment color\r\n\tfragColor = vec4 (getFragmentColor (origin, direction), 1.0);\r\n}","inputs":[],"outputs":[],"code":"// Forked from: https://www.shadertoy.com/view/ldfXzn\r\n\r\n#define DELTA\t\t\t\t0.001\r\n#define RAY_COUNT\t\t\t7\r\n#define RAY_LENGTH_MAX\t\t100.0\r\n#define RAY_STEP_MAX\t\t100\r\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\r\n#define REFRACT_FACTOR\t\t0.6\r\n#define REFRACT_INDEX\t\t1.6\r\n#define AMBIENT\t\t\t\t0.2\r\n#define SPECULAR_POWER\t\t3.0\r\n#define SPECULAR_INTENSITY\t0.5\r\n#define FADE_POWER\t\t\t1.0\r\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\r\n#define GLOW_FACTOR\t\t\t1.5\r\n#define LUMINOSITY_FACTOR\t2.0\r\n\r\nmat3 mRotate (in vec3 angle) {\r\n\tfloat c = cos (angle.x);\r\n\tfloat s = sin (angle.x);\r\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\r\n\r\n\tc = cos (angle.y);\r\n\ts = sin (angle.y);\r\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\r\n\r\n\tc = cos (angle.z);\r\n\ts = sin (angle.z);\r\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\r\n\r\n\treturn rz * ry * rx;\r\n}\r\n\r\nvec3 k;\r\nfloat getDistance (in vec3 p) {\r\n\tfloat repeat = 20.0;\r\n\tvec3 q = p + repeat * 0.5;\r\n\tk = floor (q / repeat);\r\n\tq -= repeat * (k + 0.5);\r\n\tp = mRotate (k) * q;\r\n\r\n\tfloat top = p.y - 3.0;\r\n\tfloat angleStep = M_PI / max (2.0, abs (k.x + 2.0 * k.y + 4.0 * k.z));\r\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\r\n\tfloat side = cos (angle) * p.z + sin (angle) * p.x - 2.0;\r\n\tfloat bottom = -p.y - 3.0;\r\n\r\n\treturn max (top, max (side, bottom));\r\n}\r\n\r\nvec3 getFragmentColor (in vec3 origin, in vec3 direction) {\r\n\tvec3 lightDirection = normalize (LIGHT);\r\n\tvec2 delta = vec2 (DELTA, 0.0);\r\n\r\n\tvec3 fragColor = vec3 (0.0, 0.0, 0.0);\r\n\tfloat intensity = 1.0;\r\n\r\n\tfloat distanceFactor = 1.0;\r\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\r\n\tfloat rayStepCount = 0.0;\r\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\r\n\r\n\t\t// Ray marching\r\n\t\tfloat dist = RAY_LENGTH_MAX;\r\n\t\tfloat rayLength = 0.0;\r\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\r\n\t\t\tdist = distanceFactor * getDistance (origin);\r\n\t\t\tfloat distMin = max (dist, DELTA);\r\n\t\t\trayLength += distMin;\r\n\t\t\tif (dist < 0.0 || rayLength > RAY_LENGTH_MAX) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\torigin += direction * distMin;\r\n\t\t\t++rayStepCount;\r\n\t\t}\r\n\r\n\t\t// Check whether we hit something\r\n\t\tvec3 backColor = vec3 (0.0, 0.0, 0.1 + 0.2 * max (0.0, dot (-direction, lightDirection)));\r\n\t\tif (dist >= 0.0) {\r\n\t\t\tfragColor = fragColor * (1.0 - intensity) + backColor * intensity;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Get the normal\r\n\t\tvec3 normal = normalize (distanceFactor * vec3 (\r\n\t\t\tgetDistance (origin + delta.xyy) - getDistance (origin - delta.xyy),\r\n\t\t\tgetDistance (origin + delta.yxy) - getDistance (origin - delta.yxy),\r\n\t\t\tgetDistance (origin + delta.yyx) - getDistance (origin - delta.yyx)));\r\n\r\n\t\t// Basic lighting\r\n\t\tvec3 reflection = reflect (direction, normal);\r\n\t\tif (distanceFactor > 0.0) {\r\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal, lightDirection));\r\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\r\n\t\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\r\n\r\n\t\t\tvec3 localColor = max (sin (k * k), 0.2);\r\n\t\t\tlocalColor = (AMBIENT + relfectionDiffuse) * localColor + relfectionSpecular;\r\n\t\t\tlocalColor = mix (backColor, localColor, fade);\r\n\r\n\t\t\tfragColor = fragColor * (1.0 - intensity) + localColor * intensity;\r\n\t\t\tintensity *= REFRACT_FACTOR;\r\n\t\t}\r\n\r\n\t\t// Next ray...\r\n\t\tvec3 refraction = refract (direction, normal, refractionRatio);\r\n\t\tif (dot (refraction, refraction) < DELTA) {\r\n\t\t\tdirection = reflection;\r\n\t\t\torigin += direction * DELTA * 2.0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdirection = refraction;\r\n\t\t\tdistanceFactor = -distanceFactor;\r\n\t\t\trefractionRatio = 1.0 / refractionRatio;\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the fragment color\r\n\treturn fragColor * LUMINOSITY_FACTOR + GLOW_FACTOR * rayStepCount / float (RAY_STEP_MAX * RAY_COUNT);\r\n}\r\n\r\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n\t// Define the ray corresponding to this fragment\r\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\r\n\tvec3 direction = normalize (vec3 (frag, 2.0));\r\n\r\n\t// Set the camera\r\n\tvec3 origin = vec3 ((15.0 * cos (iTime * 0.1)), 10.0 * sin (iTime * 0.2), 15.0 * sin (iTime * 0.1));\r\n\tvec3 forward = -origin;\r\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\r\n\tmat3 rotation;\r\n\trotation [2] = normalize (forward);\r\n\trotation [0] = normalize (cross (up, forward));\r\n\trotation [1] = cross (rotation [2], rotation [0]);\r\n\tdirection = rotation * direction;\r\n\r\n\t// Set the fragment color\r\n\tfragColor = vec4 (getFragmentColor (origin, direction), 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*\r\n\"Diamond test\" by Emmanuel Keller aka Tambako - January 2016\r\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\nContact: tamby@tambako.ch\r\n*/\r\n\r\n#define pi 3.141593\r\n\r\nstruct Lamp\r\n{\r\n  vec3 position;\r\n  vec3 color;\r\n  float intensity;\r\n  float attenuation;\r\n};\r\n\r\nLamp lamps[3];\r\n    \r\nstruct RenderData\r\n{\r\n  vec3 col;\r\n  vec3 pos;\r\n  vec3 norm;\r\n  int objnr;\r\n};\r\n\r\nvec3 campos = vec3(0., 0.5, 5.);\r\nvec3 camdir = vec3(0., -0.1, -1.);\r\nfloat fov = 5.;\r\n\r\nconst vec3 ambientColor = vec3(0.7);\r\nconst float ambientint = 0.08;\r\n\r\n#define specular\r\n//#define color_disp\r\n//#define only_shape\r\n//#define show_not_finished\r\nconst int nb_refr = 7; \r\n\r\nconst float specint = 0.2;\r\nconst float specshin = 20.;\r\n\r\nconst float normdelta = 0.0004;\r\nconst float maxdist = 55.;\r\n\r\nconst float ior = 2.418;\r\nconst float ior_r = 2.408;\r\nconst float ior_g = 2.424;\r\nconst float ior_b = 2.432;\r\nconst vec3 diamondColor = vec3(.98, 0.95, 0.9);\r\n\r\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\r\nconst float aawidth = 0.9;\r\nconst int aasamples = 1;\r\n\r\nvec2 rotateVec(vec2 vect, float angle)\r\n{\r\n    vec2 rv;\r\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\r\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\r\n    return rv;\r\n}\r\n\r\nfloat map_simple(vec3 pos)\r\n{   \r\n    float angle = 2.*pi*iMouse.x/iResolution.x;\r\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\r\n    \r\n    vec3 posr = pos;\r\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\r\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \r\n    \r\n    float d = 1.05;\r\n    float s = atan(posr.y, posr.x);\r\n    \r\n    vec3 flatvec = vec3(cos(s), sin(s), 1.444);\r\n    vec3 flatvec2 = vec3(cos(s), sin(s), -1.072);\r\n     \r\n    float d1 = dot(flatvec, posr) - d;                        // Crown\r\n    d1 = max(dot(flatvec2, posr) - d, d1);                    // Pavillon\r\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.35, d1);         // Table\r\n    return d1;\r\n}\r\n\r\nfloat map(vec3 pos)\r\n{     \r\n    float angle = 2.*pi*iMouse.x/iResolution.x;\r\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\r\n    \r\n    vec3 posr = pos;\r\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\r\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle));\r\n    \r\n    float d = 0.94;\r\n    float b = 0.5;\r\n\r\n    float af2 = 4./pi;\r\n    float s = atan(posr.y, posr.x);\r\n    float sf = floor(s*af2 + b)/af2;\r\n    float sf2 = floor(s*af2)/af2;\r\n    \r\n    vec3 flatvec = vec3(cos(sf), sin(sf), 1.444);\r\n    vec3 flatvec2 = vec3(cos(sf), sin(sf), -1.072);\r\n    vec3 flatvec3 = vec3(cos(s), sin(s), 0);\r\n    float csf1 = cos(sf + 0.21);\r\n    float csf2 = cos(sf - 0.21);\r\n    float ssf1 = sin(sf + 0.21);\r\n    float ssf2 = sin(sf - 0.21);\r\n    vec3 flatvec4 = vec3(csf1, ssf1, -1.02);\r\n    vec3 flatvec5 = vec3(csf2, ssf2, -1.02);\r\n    vec3 flatvec6 = vec3(csf2, ssf2, 1.03);\r\n    vec3 flatvec7 = vec3(csf1, ssf1, 1.03);\r\n    vec3 flatvec8 = vec3(cos(sf2 + 0.393), sin(sf2 + 0.393), 2.21);\r\n     \r\n    float d1 = dot(flatvec, posr) - d;                           // Crown, bezel facets\r\n    d1 = max(dot(flatvec2, posr) - d, d1);                       // Pavillon, pavillon facets\r\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.3, d1);             // Table\r\n    d1 = max(dot(vec3(0., 0., -1.), posr) - 0.865, d1);          // Cutlet\r\n    d1 = max(dot(flatvec3, posr) - 0.911, d1);                   // Girdle\r\n    d1 = max(dot(flatvec4, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\r\n    d1 = max(dot(flatvec5, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\r\n    d1 = max(dot(flatvec6, posr) - 0.912, d1);                   // Crown, upper-girdle facets\r\n    d1 = max(dot(flatvec7, posr) - 0.912, d1);                   // Crown, upper-girdle facets\r\n    d1 = max(dot(flatvec8, posr) - 1.131, d1);                   // Crown, star facets\r\n    return d1;\r\n}\r\n\r\nfloat trace(vec3 cam, vec3 ray, float maxdist, bool inside) \r\n{\r\n    float t = 4.2;\r\n    float dist;\r\n    \r\n    // \"Bounding\" tracing\r\n    if (!inside)\r\n    {\r\n  \t\tfor (int i = 0; i < 12; ++i)\r\n    \t{\r\n    \t\tvec3 pos = ray*t + cam;\r\n    \t\tdist = map_simple(pos);\r\n        \tif (dist>maxdist || abs(dist)<0.001)\r\n            \tbreak;\r\n        \tt+= dist*0.95;\r\n  \t\t}\r\n    }\r\n\r\n    // \"Actual\" tracing\r\n  \tfor (int i = 0; i < 30; ++i)\r\n    {\r\n    \tvec3 pos = ray*t + cam;\r\n    \tdist = inside?-map(pos):map(pos);\r\n        if (dist>maxdist)\r\n            break;\r\n        t+= dist*(inside?0.4:0.8);\r\n  \t}\r\n  \treturn t;\r\n}\r\n\r\n// Old slower version (but a bit more precise)\r\nfloat trace_sl(vec3 cam, vec3 ray, float maxdist, bool inside) \r\n{\r\n    float t = 4.;\r\n  \tfor (int i = 0; i < 80; ++i)\r\n    {\r\n    \tvec3 pos = ray*t + cam;\r\n    \tfloat dist = inside?-map(pos):map(pos);\r\n        if (dist>(inside?3.:maxdist) || abs(dist)<0.001 || (inside && i>30))\r\n            break;\r\n        t+= dist*0.4;\r\n  \t}\r\n  \treturn t;\r\n}\r\n\r\n// From https://www.shadertoy.com/view/MstGDM\r\nvec3 getNormal(vec3 pos, float e, bool inside)\r\n{\r\n    vec2 q = vec2(0, e);\r\n    return (inside?-1.:1.)*normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\r\n                          map(pos + q.xyx) - map(pos - q.xyx),\r\n                          map(pos + q.xxy) - map(pos - q.xxy)));\r\n}\r\n\r\nvec3 obj_color(vec3 norm, vec3 pos)\r\n{\r\n  \t#ifdef only_shape\r\n  \treturn vec3(0.35, 0.7, 1.0);\r\n  \t#else\r\n    return vec3(0.);\r\n    #endif\r\n}\r\n\r\nvec3 sky_color(vec3 ray)\r\n{\r\n\tvec3 rc = texture(iChannel2, ray.xy).rrr;\r\n    for (int l=0; l<3; l++)\r\n        rc+= 1.5*normalize(lamps[l].color)*lamps[l].intensity*specint*pow(max(0.0, dot(ray, normalize(lamps[l].position - campos))), 200.);\r\n    return rc;\r\n}\r\n\r\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\r\nfloat fresnel(vec3 ray, vec3 norm, float n2)\r\n{\r\n   float n1 = 1.; // air\r\n   float angle = clamp(acos(-dot(ray, norm)), -pi/2.15, pi/2.15);\r\n   float r0 = pow((n1-n2)/(n1+n2), 2.);\r\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\r\n   return clamp(0., 0.9, r);\r\n}\r\n\r\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, bool inside)\r\n{\r\n\tvec3 pl = normalize(lamp.position - pos);\r\n    float dlp = distance(lamp.position, pos);\r\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\r\n      \r\n    vec3 col;\r\n    \r\n    // Diffuse shading\r\n    if (!inside)\r\n    {\r\n    \tfloat diff = clamp(dot(norm, pli), 0., 1.);\r\n    \tcol = ocol*normalize(lamp.color)*lamp.intensity*smoothstep(0., 1.04, pow(diff, 0.78));\r\n    }\r\n    \r\n    // Specular shading\r\n    #ifdef specular\r\n    if (dot(norm, lamp.position - pos) > 0.0)\r\n        col+= normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\r\n    #endif\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, bool inside)\r\n{\r\n    vec3 col = vec3(0.);\r\n    for (int l=0; l<3; l++) // lamps.length()\r\n        col+= lampShading(lamps[l], norm, pos, ocol, inside);\r\n    \r\n    return col;\r\n}\r\n\r\n// From https://www.shadertoy.com/view/lsSXzD, modified\r\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\r\n{\r\n\tvec3 vForward = normalize(vCameraDir);\r\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\r\n\tvec3 vUp = normalize(cross(vForward, vRight));\r\n    \r\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\r\n\r\n\treturn vDir;\r\n}\r\n\r\nRenderData trace0(vec3 tpos, vec3 ray, bool inside)\r\n{\r\n    float tx = trace(tpos, ray, maxdist, inside);\r\n    vec3 col;\r\n    int objnr;\r\n    \r\n    vec3 pos = tpos + tx*ray;\r\n    vec3 norm;\r\n    if (tx<10.)\r\n    {\r\n        norm = getNormal(pos, normdelta, inside);\r\n        if (!inside)\r\n        {\r\n            // Coloring\r\n        \tcol = obj_color(norm, pos) + ambientColor*ambientint;\r\n        \tobjnr = 1;\r\n        }\r\n        \r\n        // Shading\r\n        col = lampsShading(norm, pos, col, inside);\r\n  }\r\n  else\r\n  {\r\n      // Sky\r\n      col = sky_color(ray);\r\n      objnr = 3;\r\n  }\r\n  return RenderData(col, pos, norm, objnr);\r\n}\r\n\r\nvec4 render(vec2 fragCoord, vec3 campos, float ior)\r\n{   \r\n  lamps[0] = Lamp(vec3(0., 4.5, 10.), vec3(1., 1., 1.), 5., 0.1);\r\n  lamps[1] = Lamp(vec3(12., -0.5, 6.), vec3(.7, .8, 1.), 5., 0.1);\r\n  lamps[2] = Lamp(vec3(-1.3, 0.8, -1.5), vec3(1., .95, .8), 3.5, 0.1);\r\n    \r\n  vec2 uv = fragCoord.xy / iResolution.xy; \r\n  uv = uv*2.0 - 1.0;\r\n  uv.x*= iResolution.x / iResolution.y;\r\n\r\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\r\n    \r\n  RenderData traceinf = trace0(campos, ray, false);\r\n  vec3 col = traceinf.col;\r\n    \r\n  #ifdef only_shape\r\n  \treturn vec4(col, 1.0);\r\n  #else\r\n    \r\n  if (traceinf.objnr==1)\r\n  {\r\n  \t\tvec3 norm = traceinf.norm;\r\n        vec3 ray_r = refract(ray, traceinf.norm, 1./ior);\r\n        vec3 ray_r2;\r\n      \r\n        int n2;\r\n        for (int n=0; n<nb_refr; n++)\r\n        {\r\n        \ttraceinf = trace0(traceinf.pos, ray_r, true);\r\n        \tcol+= traceinf.col;\r\n        \tcol*= diamondColor;\r\n      \t\tray_r2 = refract(ray_r, traceinf.norm, ior);\r\n        \tif (length(ray_r2)!=0.)\r\n            {\r\n           \t\tcol+= sky_color(ray_r2)*diamondColor;\r\n                break;\r\n            }\r\n            ray_r2 = reflect(ray_r, traceinf.norm);\r\n            ray_r = ray_r2;\r\n            n2 = n;\r\n        }\r\n        if (n2==nb_refr-1)\r\n            #ifdef show_not_finished\r\n            col = vec3(1., 0., 1.);\r\n      \t\t#else\r\n            col+= sky_color(ray_r2)*diamondColor;\r\n      \t\t#endif\r\n                      \r\n        // Outer reflection\r\n        float r = fresnel(ray, norm, ior);\r\n        col = mix(col, sky_color(reflect(ray, norm)), r);\r\n  }\r\n  return vec4(col, 1.0);\r\n  #endif\r\n}\r\n\r\nvec4 render_rgb(vec2 fragCoord, vec3 campos)\r\n{\r\n    #ifdef color_disp\r\n    \tvec4 col;\r\n    \tcol.r = render(fragCoord, campos, ior_r).r;\r\n    \tcol.g = render(fragCoord, campos, ior_g).g;\r\n    \tcol.b = render(fragCoord, campos, ior_b).b;\r\n    \tcol.a = 1.;\r\n\treturn col;\r\n    #else\r\n    \treturn render(fragCoord, campos, ior);\r\n    #endif\r\n}\r\n\r\nvec4 render_aa(vec2 fragCoord, vec3 campos)\r\n{\r\n    // Antialiasing\r\n    vec4 vs = vec4(0.);\r\n    for (int j=0;j<aasamples ;j++)\r\n    {\r\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\r\n       for (int i=0;i<aasamples ;i++)\r\n       {\r\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\r\n          vs+= render_rgb(fragCoord + vec2(ox, oy), campos);\r\n       }\r\n    }\r\n    return vs/vec4(aasamples*aasamples);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n       fragColor = render_aa(fragCoord, campos);    \r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":null,"published":0}],"outputs":[],"code":"/*\r\n\"Diamond test\" by Emmanuel Keller aka Tambako - January 2016\r\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\nContact: tamby@tambako.ch\r\n*/\r\n\r\n#define pi 3.141593\r\n\r\nstruct Lamp\r\n{\r\n  vec3 position;\r\n  vec3 color;\r\n  float intensity;\r\n  float attenuation;\r\n};\r\n\r\nLamp lamps[3];\r\n    \r\nstruct RenderData\r\n{\r\n  vec3 col;\r\n  vec3 pos;\r\n  vec3 norm;\r\n  int objnr;\r\n};\r\n\r\nvec3 campos = vec3(0., 0.5, 5.);\r\nvec3 camdir = vec3(0., -0.1, -1.);\r\nfloat fov = 5.;\r\n\r\nconst vec3 ambientColor = vec3(0.7);\r\nconst float ambientint = 0.08;\r\n\r\n#define specular\r\n//#define color_disp\r\n//#define only_shape\r\n//#define show_not_finished\r\nconst int nb_refr = 7; \r\n\r\nconst float specint = 0.2;\r\nconst float specshin = 20.;\r\n\r\nconst float normdelta = 0.0004;\r\nconst float maxdist = 55.;\r\n\r\nconst float ior = 2.418;\r\nconst float ior_r = 2.408;\r\nconst float ior_g = 2.424;\r\nconst float ior_b = 2.432;\r\nconst vec3 diamondColor = vec3(.98, 0.95, 0.9);\r\n\r\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\r\nconst float aawidth = 0.9;\r\nconst int aasamples = 1;\r\n\r\nvec2 rotateVec(vec2 vect, float angle)\r\n{\r\n    vec2 rv;\r\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\r\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\r\n    return rv;\r\n}\r\n\r\nfloat map_simple(vec3 pos)\r\n{   \r\n    float angle = 2.*pi*iMouse.x/iResolution.x;\r\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\r\n    \r\n    vec3 posr = pos;\r\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\r\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \r\n    \r\n    float d = 1.05;\r\n    float s = atan(posr.y, posr.x);\r\n    \r\n    vec3 flatvec = vec3(cos(s), sin(s), 1.444);\r\n    vec3 flatvec2 = vec3(cos(s), sin(s), -1.072);\r\n     \r\n    float d1 = dot(flatvec, posr) - d;                        // Crown\r\n    d1 = max(dot(flatvec2, posr) - d, d1);                    // Pavillon\r\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.35, d1);         // Table\r\n    return d1;\r\n}\r\n\r\nfloat map(vec3 pos)\r\n{     \r\n    float angle = 2.*pi*iMouse.x/iResolution.x;\r\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\r\n    \r\n    vec3 posr = pos;\r\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\r\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle));\r\n    \r\n    float d = 0.94;\r\n    float b = 0.5;\r\n\r\n    float af2 = 4./pi;\r\n    float s = atan(posr.y, posr.x);\r\n    float sf = floor(s*af2 + b)/af2;\r\n    float sf2 = floor(s*af2)/af2;\r\n    \r\n    vec3 flatvec = vec3(cos(sf), sin(sf), 1.444);\r\n    vec3 flatvec2 = vec3(cos(sf), sin(sf), -1.072);\r\n    vec3 flatvec3 = vec3(cos(s), sin(s), 0);\r\n    float csf1 = cos(sf + 0.21);\r\n    float csf2 = cos(sf - 0.21);\r\n    float ssf1 = sin(sf + 0.21);\r\n    float ssf2 = sin(sf - 0.21);\r\n    vec3 flatvec4 = vec3(csf1, ssf1, -1.02);\r\n    vec3 flatvec5 = vec3(csf2, ssf2, -1.02);\r\n    vec3 flatvec6 = vec3(csf2, ssf2, 1.03);\r\n    vec3 flatvec7 = vec3(csf1, ssf1, 1.03);\r\n    vec3 flatvec8 = vec3(cos(sf2 + 0.393), sin(sf2 + 0.393), 2.21);\r\n     \r\n    float d1 = dot(flatvec, posr) - d;                           // Crown, bezel facets\r\n    d1 = max(dot(flatvec2, posr) - d, d1);                       // Pavillon, pavillon facets\r\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.3, d1);             // Table\r\n    d1 = max(dot(vec3(0., 0., -1.), posr) - 0.865, d1);          // Cutlet\r\n    d1 = max(dot(flatvec3, posr) - 0.911, d1);                   // Girdle\r\n    d1 = max(dot(flatvec4, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\r\n    d1 = max(dot(flatvec5, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\r\n    d1 = max(dot(flatvec6, posr) - 0.912, d1);                   // Crown, upper-girdle facets\r\n    d1 = max(dot(flatvec7, posr) - 0.912, d1);                   // Crown, upper-girdle facets\r\n    d1 = max(dot(flatvec8, posr) - 1.131, d1);                   // Crown, star facets\r\n    return d1;\r\n}\r\n\r\nfloat trace(vec3 cam, vec3 ray, float maxdist, bool inside) \r\n{\r\n    float t = 4.2;\r\n    float dist;\r\n    \r\n    // \"Bounding\" tracing\r\n    if (!inside)\r\n    {\r\n  \t\tfor (int i = 0; i < 12; ++i)\r\n    \t{\r\n    \t\tvec3 pos = ray*t + cam;\r\n    \t\tdist = map_simple(pos);\r\n        \tif (dist>maxdist || abs(dist)<0.001)\r\n            \tbreak;\r\n        \tt+= dist*0.95;\r\n  \t\t}\r\n    }\r\n\r\n    // \"Actual\" tracing\r\n  \tfor (int i = 0; i < 30; ++i)\r\n    {\r\n    \tvec3 pos = ray*t + cam;\r\n    \tdist = inside?-map(pos):map(pos);\r\n        if (dist>maxdist)\r\n            break;\r\n        t+= dist*(inside?0.4:0.8);\r\n  \t}\r\n  \treturn t;\r\n}\r\n\r\n// Old slower version (but a bit more precise)\r\nfloat trace_sl(vec3 cam, vec3 ray, float maxdist, bool inside) \r\n{\r\n    float t = 4.;\r\n  \tfor (int i = 0; i < 80; ++i)\r\n    {\r\n    \tvec3 pos = ray*t + cam;\r\n    \tfloat dist = inside?-map(pos):map(pos);\r\n        if (dist>(inside?3.:maxdist) || abs(dist)<0.001 || (inside && i>30))\r\n            break;\r\n        t+= dist*0.4;\r\n  \t}\r\n  \treturn t;\r\n}\r\n\r\n// From https://www.shadertoy.com/view/MstGDM\r\nvec3 getNormal(vec3 pos, float e, bool inside)\r\n{\r\n    vec2 q = vec2(0, e);\r\n    return (inside?-1.:1.)*normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\r\n                          map(pos + q.xyx) - map(pos - q.xyx),\r\n                          map(pos + q.xxy) - map(pos - q.xxy)));\r\n}\r\n\r\nvec3 obj_color(vec3 norm, vec3 pos)\r\n{\r\n  \t#ifdef only_shape\r\n  \treturn vec3(0.35, 0.7, 1.0);\r\n  \t#else\r\n    return vec3(0.);\r\n    #endif\r\n}\r\n\r\nvec3 sky_color(vec3 ray)\r\n{\r\n\tvec3 rc = texture(iChannel2, ray.xy).rrr;\r\n    for (int l=0; l<3; l++)\r\n        rc+= 1.5*normalize(lamps[l].color)*lamps[l].intensity*specint*pow(max(0.0, dot(ray, normalize(lamps[l].position - campos))), 200.);\r\n    return rc;\r\n}\r\n\r\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\r\nfloat fresnel(vec3 ray, vec3 norm, float n2)\r\n{\r\n   float n1 = 1.; // air\r\n   float angle = clamp(acos(-dot(ray, norm)), -pi/2.15, pi/2.15);\r\n   float r0 = pow((n1-n2)/(n1+n2), 2.);\r\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\r\n   return clamp(0., 0.9, r);\r\n}\r\n\r\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, bool inside)\r\n{\r\n\tvec3 pl = normalize(lamp.position - pos);\r\n    float dlp = distance(lamp.position, pos);\r\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\r\n      \r\n    vec3 col;\r\n    \r\n    // Diffuse shading\r\n    if (!inside)\r\n    {\r\n    \tfloat diff = clamp(dot(norm, pli), 0., 1.);\r\n    \tcol = ocol*normalize(lamp.color)*lamp.intensity*smoothstep(0., 1.04, pow(diff, 0.78));\r\n    }\r\n    \r\n    // Specular shading\r\n    #ifdef specular\r\n    if (dot(norm, lamp.position - pos) > 0.0)\r\n        col+= normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\r\n    #endif\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, bool inside)\r\n{\r\n    vec3 col = vec3(0.);\r\n    for (int l=0; l<3; l++) // lamps.length()\r\n        col+= lampShading(lamps[l], norm, pos, ocol, inside);\r\n    \r\n    return col;\r\n}\r\n\r\n// From https://www.shadertoy.com/view/lsSXzD, modified\r\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\r\n{\r\n\tvec3 vForward = normalize(vCameraDir);\r\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\r\n\tvec3 vUp = normalize(cross(vForward, vRight));\r\n    \r\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\r\n\r\n\treturn vDir;\r\n}\r\n\r\nRenderData trace0(vec3 tpos, vec3 ray, bool inside)\r\n{\r\n    float tx = trace(tpos, ray, maxdist, inside);\r\n    vec3 col;\r\n    int objnr;\r\n    \r\n    vec3 pos = tpos + tx*ray;\r\n    vec3 norm;\r\n    if (tx<10.)\r\n    {\r\n        norm = getNormal(pos, normdelta, inside);\r\n        if (!inside)\r\n        {\r\n            // Coloring\r\n        \tcol = obj_color(norm, pos) + ambientColor*ambientint;\r\n        \tobjnr = 1;\r\n        }\r\n        \r\n        // Shading\r\n        col = lampsShading(norm, pos, col, inside);\r\n  }\r\n  else\r\n  {\r\n      // Sky\r\n      col = sky_color(ray);\r\n      objnr = 3;\r\n  }\r\n  return RenderData(col, pos, norm, objnr);\r\n}\r\n\r\nvec4 render(vec2 fragCoord, vec3 campos, float ior)\r\n{   \r\n  lamps[0] = Lamp(vec3(0., 4.5, 10.), vec3(1., 1., 1.), 5., 0.1);\r\n  lamps[1] = Lamp(vec3(12., -0.5, 6.), vec3(.7, .8, 1.), 5., 0.1);\r\n  lamps[2] = Lamp(vec3(-1.3, 0.8, -1.5), vec3(1., .95, .8), 3.5, 0.1);\r\n    \r\n  vec2 uv = fragCoord.xy / iResolution.xy; \r\n  uv = uv*2.0 - 1.0;\r\n  uv.x*= iResolution.x / iResolution.y;\r\n\r\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\r\n    \r\n  RenderData traceinf = trace0(campos, ray, false);\r\n  vec3 col = traceinf.col;\r\n    \r\n  #ifdef only_shape\r\n  \treturn vec4(col, 1.0);\r\n  #else\r\n    \r\n  if (traceinf.objnr==1)\r\n  {\r\n  \t\tvec3 norm = traceinf.norm;\r\n        vec3 ray_r = refract(ray, traceinf.norm, 1./ior);\r\n        vec3 ray_r2;\r\n      \r\n        int n2;\r\n        for (int n=0; n<nb_refr; n++)\r\n        {\r\n        \ttraceinf = trace0(traceinf.pos, ray_r, true);\r\n        \tcol+= traceinf.col;\r\n        \tcol*= diamondColor;\r\n      \t\tray_r2 = refract(ray_r, traceinf.norm, ior);\r\n        \tif (length(ray_r2)!=0.)\r\n            {\r\n           \t\tcol+= sky_color(ray_r2)*diamondColor;\r\n                break;\r\n            }\r\n            ray_r2 = reflect(ray_r, traceinf.norm);\r\n            ray_r = ray_r2;\r\n            n2 = n;\r\n        }\r\n        if (n2==nb_refr-1)\r\n            #ifdef show_not_finished\r\n            col = vec3(1., 0., 1.);\r\n      \t\t#else\r\n            col+= sky_color(ray_r2)*diamondColor;\r\n      \t\t#endif\r\n                      \r\n        // Outer reflection\r\n        float r = fresnel(ray, norm, ior);\r\n        col = mix(col, sky_color(reflect(ray, norm)), r);\r\n  }\r\n  return vec4(col, 1.0);\r\n  #endif\r\n}\r\n\r\nvec4 render_rgb(vec2 fragCoord, vec3 campos)\r\n{\r\n    #ifdef color_disp\r\n    \tvec4 col;\r\n    \tcol.r = render(fragCoord, campos, ior_r).r;\r\n    \tcol.g = render(fragCoord, campos, ior_g).g;\r\n    \tcol.b = render(fragCoord, campos, ior_b).b;\r\n    \tcol.a = 1.;\r\n\treturn col;\r\n    #else\r\n    \treturn render(fragCoord, campos, ior);\r\n    #endif\r\n}\r\n\r\nvec4 render_aa(vec2 fragCoord, vec3 campos)\r\n{\r\n    // Antialiasing\r\n    vec4 vs = vec4(0.);\r\n    for (int j=0;j<aasamples ;j++)\r\n    {\r\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\r\n       for (int i=0;i<aasamples ;i++)\r\n       {\r\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\r\n          vs+= render_rgb(fragCoord + vec2(ox, oy), campos);\r\n       }\r\n    }\r\n    return vs/vec4(aasamples*aasamples);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n       fragColor = render_aa(fragCoord, campos);    \r\n}","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":null,"published":0}],"Info":{"Name":"Diamond test ","id":null,"date":null,"viewed":0,"name":"Diamond test ","description":"I tried to simulate a diamond with brilliant cut. Use the mouse to rotate it\r\nYou can increase the max number of total reflections (line 38), enable color dispersion (line 35) or enable antialiasing (line 54), but be careful!\r\nComments&help welcome as usual","likes":0,"published":null,"tags":["raymarching"," sphere"," facets"]},"ver":null,"info":{"Name":"Diamond test ","id":null,"date":null,"viewed":0,"name":"Diamond test ","description":"I tried to simulate a diamond with brilliant cut. Use the mouse to rotate it\r\nYou can increase the max number of total reflections (line 38), enable color dispersion (line 35) or enable antialiasing (line 54), but be careful!\r\nComments&help welcome as usual","likes":0,"published":null,"tags":["raymarching"," sphere"," facets"]},"renderpass":[{"Code":"/*\r\n\"Diamond test\" by Emmanuel Keller aka Tambako - January 2016\r\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\nContact: tamby@tambako.ch\r\n*/\r\n\r\n#define pi 3.141593\r\n\r\nstruct Lamp\r\n{\r\n  vec3 position;\r\n  vec3 color;\r\n  float intensity;\r\n  float attenuation;\r\n};\r\n\r\nLamp lamps[3];\r\n    \r\nstruct RenderData\r\n{\r\n  vec3 col;\r\n  vec3 pos;\r\n  vec3 norm;\r\n  int objnr;\r\n};\r\n\r\nvec3 campos = vec3(0., 0.5, 5.);\r\nvec3 camdir = vec3(0., -0.1, -1.);\r\nfloat fov = 5.;\r\n\r\nconst vec3 ambientColor = vec3(0.7);\r\nconst float ambientint = 0.08;\r\n\r\n#define specular\r\n//#define color_disp\r\n//#define only_shape\r\n//#define show_not_finished\r\nconst int nb_refr = 7; \r\n\r\nconst float specint = 0.2;\r\nconst float specshin = 20.;\r\n\r\nconst float normdelta = 0.0004;\r\nconst float maxdist = 55.;\r\n\r\nconst float ior = 2.418;\r\nconst float ior_r = 2.408;\r\nconst float ior_g = 2.424;\r\nconst float ior_b = 2.432;\r\nconst vec3 diamondColor = vec3(.98, 0.95, 0.9);\r\n\r\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\r\nconst float aawidth = 0.9;\r\nconst int aasamples = 1;\r\n\r\nvec2 rotateVec(vec2 vect, float angle)\r\n{\r\n    vec2 rv;\r\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\r\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\r\n    return rv;\r\n}\r\n\r\nfloat map_simple(vec3 pos)\r\n{   \r\n    float angle = 2.*pi*iMouse.x/iResolution.x;\r\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\r\n    \r\n    vec3 posr = pos;\r\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\r\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \r\n    \r\n    float d = 1.05;\r\n    float s = atan(posr.y, posr.x);\r\n    \r\n    vec3 flatvec = vec3(cos(s), sin(s), 1.444);\r\n    vec3 flatvec2 = vec3(cos(s), sin(s), -1.072);\r\n     \r\n    float d1 = dot(flatvec, posr) - d;                        // Crown\r\n    d1 = max(dot(flatvec2, posr) - d, d1);                    // Pavillon\r\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.35, d1);         // Table\r\n    return d1;\r\n}\r\n\r\nfloat map(vec3 pos)\r\n{     \r\n    float angle = 2.*pi*iMouse.x/iResolution.x;\r\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\r\n    \r\n    vec3 posr = pos;\r\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\r\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle));\r\n    \r\n    float d = 0.94;\r\n    float b = 0.5;\r\n\r\n    float af2 = 4./pi;\r\n    float s = atan(posr.y, posr.x);\r\n    float sf = floor(s*af2 + b)/af2;\r\n    float sf2 = floor(s*af2)/af2;\r\n    \r\n    vec3 flatvec = vec3(cos(sf), sin(sf), 1.444);\r\n    vec3 flatvec2 = vec3(cos(sf), sin(sf), -1.072);\r\n    vec3 flatvec3 = vec3(cos(s), sin(s), 0);\r\n    float csf1 = cos(sf + 0.21);\r\n    float csf2 = cos(sf - 0.21);\r\n    float ssf1 = sin(sf + 0.21);\r\n    float ssf2 = sin(sf - 0.21);\r\n    vec3 flatvec4 = vec3(csf1, ssf1, -1.02);\r\n    vec3 flatvec5 = vec3(csf2, ssf2, -1.02);\r\n    vec3 flatvec6 = vec3(csf2, ssf2, 1.03);\r\n    vec3 flatvec7 = vec3(csf1, ssf1, 1.03);\r\n    vec3 flatvec8 = vec3(cos(sf2 + 0.393), sin(sf2 + 0.393), 2.21);\r\n     \r\n    float d1 = dot(flatvec, posr) - d;                           // Crown, bezel facets\r\n    d1 = max(dot(flatvec2, posr) - d, d1);                       // Pavillon, pavillon facets\r\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.3, d1);             // Table\r\n    d1 = max(dot(vec3(0., 0., -1.), posr) - 0.865, d1);          // Cutlet\r\n    d1 = max(dot(flatvec3, posr) - 0.911, d1);                   // Girdle\r\n    d1 = max(dot(flatvec4, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\r\n    d1 = max(dot(flatvec5, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\r\n    d1 = max(dot(flatvec6, posr) - 0.912, d1);                   // Crown, upper-girdle facets\r\n    d1 = max(dot(flatvec7, posr) - 0.912, d1);                   // Crown, upper-girdle facets\r\n    d1 = max(dot(flatvec8, posr) - 1.131, d1);                   // Crown, star facets\r\n    return d1;\r\n}\r\n\r\nfloat trace(vec3 cam, vec3 ray, float maxdist, bool inside) \r\n{\r\n    float t = 4.2;\r\n    float dist;\r\n    \r\n    // \"Bounding\" tracing\r\n    if (!inside)\r\n    {\r\n  \t\tfor (int i = 0; i < 12; ++i)\r\n    \t{\r\n    \t\tvec3 pos = ray*t + cam;\r\n    \t\tdist = map_simple(pos);\r\n        \tif (dist>maxdist || abs(dist)<0.001)\r\n            \tbreak;\r\n        \tt+= dist*0.95;\r\n  \t\t}\r\n    }\r\n\r\n    // \"Actual\" tracing\r\n  \tfor (int i = 0; i < 30; ++i)\r\n    {\r\n    \tvec3 pos = ray*t + cam;\r\n    \tdist = inside?-map(pos):map(pos);\r\n        if (dist>maxdist)\r\n            break;\r\n        t+= dist*(inside?0.4:0.8);\r\n  \t}\r\n  \treturn t;\r\n}\r\n\r\n// Old slower version (but a bit more precise)\r\nfloat trace_sl(vec3 cam, vec3 ray, float maxdist, bool inside) \r\n{\r\n    float t = 4.;\r\n  \tfor (int i = 0; i < 80; ++i)\r\n    {\r\n    \tvec3 pos = ray*t + cam;\r\n    \tfloat dist = inside?-map(pos):map(pos);\r\n        if (dist>(inside?3.:maxdist) || abs(dist)<0.001 || (inside && i>30))\r\n            break;\r\n        t+= dist*0.4;\r\n  \t}\r\n  \treturn t;\r\n}\r\n\r\n// From https://www.shadertoy.com/view/MstGDM\r\nvec3 getNormal(vec3 pos, float e, bool inside)\r\n{\r\n    vec2 q = vec2(0, e);\r\n    return (inside?-1.:1.)*normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\r\n                          map(pos + q.xyx) - map(pos - q.xyx),\r\n                          map(pos + q.xxy) - map(pos - q.xxy)));\r\n}\r\n\r\nvec3 obj_color(vec3 norm, vec3 pos)\r\n{\r\n  \t#ifdef only_shape\r\n  \treturn vec3(0.35, 0.7, 1.0);\r\n  \t#else\r\n    return vec3(0.);\r\n    #endif\r\n}\r\n\r\nvec3 sky_color(vec3 ray)\r\n{\r\n\tvec3 rc = texture(iChannel2, ray.xy).rrr;\r\n    for (int l=0; l<3; l++)\r\n        rc+= 1.5*normalize(lamps[l].color)*lamps[l].intensity*specint*pow(max(0.0, dot(ray, normalize(lamps[l].position - campos))), 200.);\r\n    return rc;\r\n}\r\n\r\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\r\nfloat fresnel(vec3 ray, vec3 norm, float n2)\r\n{\r\n   float n1 = 1.; // air\r\n   float angle = clamp(acos(-dot(ray, norm)), -pi/2.15, pi/2.15);\r\n   float r0 = pow((n1-n2)/(n1+n2), 2.);\r\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\r\n   return clamp(0., 0.9, r);\r\n}\r\n\r\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, bool inside)\r\n{\r\n\tvec3 pl = normalize(lamp.position - pos);\r\n    float dlp = distance(lamp.position, pos);\r\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\r\n      \r\n    vec3 col;\r\n    \r\n    // Diffuse shading\r\n    if (!inside)\r\n    {\r\n    \tfloat diff = clamp(dot(norm, pli), 0., 1.);\r\n    \tcol = ocol*normalize(lamp.color)*lamp.intensity*smoothstep(0., 1.04, pow(diff, 0.78));\r\n    }\r\n    \r\n    // Specular shading\r\n    #ifdef specular\r\n    if (dot(norm, lamp.position - pos) > 0.0)\r\n        col+= normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\r\n    #endif\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, bool inside)\r\n{\r\n    vec3 col = vec3(0.);\r\n    for (int l=0; l<3; l++) // lamps.length()\r\n        col+= lampShading(lamps[l], norm, pos, ocol, inside);\r\n    \r\n    return col;\r\n}\r\n\r\n// From https://www.shadertoy.com/view/lsSXzD, modified\r\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\r\n{\r\n\tvec3 vForward = normalize(vCameraDir);\r\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\r\n\tvec3 vUp = normalize(cross(vForward, vRight));\r\n    \r\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\r\n\r\n\treturn vDir;\r\n}\r\n\r\nRenderData trace0(vec3 tpos, vec3 ray, bool inside)\r\n{\r\n    float tx = trace(tpos, ray, maxdist, inside);\r\n    vec3 col;\r\n    int objnr;\r\n    \r\n    vec3 pos = tpos + tx*ray;\r\n    vec3 norm;\r\n    if (tx<10.)\r\n    {\r\n        norm = getNormal(pos, normdelta, inside);\r\n        if (!inside)\r\n        {\r\n            // Coloring\r\n        \tcol = obj_color(norm, pos) + ambientColor*ambientint;\r\n        \tobjnr = 1;\r\n        }\r\n        \r\n        // Shading\r\n        col = lampsShading(norm, pos, col, inside);\r\n  }\r\n  else\r\n  {\r\n      // Sky\r\n      col = sky_color(ray);\r\n      objnr = 3;\r\n  }\r\n  return RenderData(col, pos, norm, objnr);\r\n}\r\n\r\nvec4 render(vec2 fragCoord, vec3 campos, float ior)\r\n{   \r\n  lamps[0] = Lamp(vec3(0., 4.5, 10.), vec3(1., 1., 1.), 5., 0.1);\r\n  lamps[1] = Lamp(vec3(12., -0.5, 6.), vec3(.7, .8, 1.), 5., 0.1);\r\n  lamps[2] = Lamp(vec3(-1.3, 0.8, -1.5), vec3(1., .95, .8), 3.5, 0.1);\r\n    \r\n  vec2 uv = fragCoord.xy / iResolution.xy; \r\n  uv = uv*2.0 - 1.0;\r\n  uv.x*= iResolution.x / iResolution.y;\r\n\r\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\r\n    \r\n  RenderData traceinf = trace0(campos, ray, false);\r\n  vec3 col = traceinf.col;\r\n    \r\n  #ifdef only_shape\r\n  \treturn vec4(col, 1.0);\r\n  #else\r\n    \r\n  if (traceinf.objnr==1)\r\n  {\r\n  \t\tvec3 norm = traceinf.norm;\r\n        vec3 ray_r = refract(ray, traceinf.norm, 1./ior);\r\n        vec3 ray_r2;\r\n      \r\n        int n2;\r\n        for (int n=0; n<nb_refr; n++)\r\n        {\r\n        \ttraceinf = trace0(traceinf.pos, ray_r, true);\r\n        \tcol+= traceinf.col;\r\n        \tcol*= diamondColor;\r\n      \t\tray_r2 = refract(ray_r, traceinf.norm, ior);\r\n        \tif (length(ray_r2)!=0.)\r\n            {\r\n           \t\tcol+= sky_color(ray_r2)*diamondColor;\r\n                break;\r\n            }\r\n            ray_r2 = reflect(ray_r, traceinf.norm);\r\n            ray_r = ray_r2;\r\n            n2 = n;\r\n        }\r\n        if (n2==nb_refr-1)\r\n            #ifdef show_not_finished\r\n            col = vec3(1., 0., 1.);\r\n      \t\t#else\r\n            col+= sky_color(ray_r2)*diamondColor;\r\n      \t\t#endif\r\n                      \r\n        // Outer reflection\r\n        float r = fresnel(ray, norm, ior);\r\n        col = mix(col, sky_color(reflect(ray, norm)), r);\r\n  }\r\n  return vec4(col, 1.0);\r\n  #endif\r\n}\r\n\r\nvec4 render_rgb(vec2 fragCoord, vec3 campos)\r\n{\r\n    #ifdef color_disp\r\n    \tvec4 col;\r\n    \tcol.r = render(fragCoord, campos, ior_r).r;\r\n    \tcol.g = render(fragCoord, campos, ior_g).g;\r\n    \tcol.b = render(fragCoord, campos, ior_b).b;\r\n    \tcol.a = 1.;\r\n\treturn col;\r\n    #else\r\n    \treturn render(fragCoord, campos, ior);\r\n    #endif\r\n}\r\n\r\nvec4 render_aa(vec2 fragCoord, vec3 campos)\r\n{\r\n    // Antialiasing\r\n    vec4 vs = vec4(0.);\r\n    for (int j=0;j<aasamples ;j++)\r\n    {\r\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\r\n       for (int i=0;i<aasamples ;i++)\r\n       {\r\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\r\n          vs+= render_rgb(fragCoord + vec2(ox, oy), campos);\r\n       }\r\n    }\r\n    return vs/vec4(aasamples*aasamples);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n       fragColor = render_aa(fragCoord, campos);    \r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":null,"published":0}],"outputs":[],"code":"/*\r\n\"Diamond test\" by Emmanuel Keller aka Tambako - January 2016\r\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\nContact: tamby@tambako.ch\r\n*/\r\n\r\n#define pi 3.141593\r\n\r\nstruct Lamp\r\n{\r\n  vec3 position;\r\n  vec3 color;\r\n  float intensity;\r\n  float attenuation;\r\n};\r\n\r\nLamp lamps[3];\r\n    \r\nstruct RenderData\r\n{\r\n  vec3 col;\r\n  vec3 pos;\r\n  vec3 norm;\r\n  int objnr;\r\n};\r\n\r\nvec3 campos = vec3(0., 0.5, 5.);\r\nvec3 camdir = vec3(0., -0.1, -1.);\r\nfloat fov = 5.;\r\n\r\nconst vec3 ambientColor = vec3(0.7);\r\nconst float ambientint = 0.08;\r\n\r\n#define specular\r\n//#define color_disp\r\n//#define only_shape\r\n//#define show_not_finished\r\nconst int nb_refr = 7; \r\n\r\nconst float specint = 0.2;\r\nconst float specshin = 20.;\r\n\r\nconst float normdelta = 0.0004;\r\nconst float maxdist = 55.;\r\n\r\nconst float ior = 2.418;\r\nconst float ior_r = 2.408;\r\nconst float ior_g = 2.424;\r\nconst float ior_b = 2.432;\r\nconst vec3 diamondColor = vec3(.98, 0.95, 0.9);\r\n\r\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\r\nconst float aawidth = 0.9;\r\nconst int aasamples = 1;\r\n\r\nvec2 rotateVec(vec2 vect, float angle)\r\n{\r\n    vec2 rv;\r\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\r\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\r\n    return rv;\r\n}\r\n\r\nfloat map_simple(vec3 pos)\r\n{   \r\n    float angle = 2.*pi*iMouse.x/iResolution.x;\r\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\r\n    \r\n    vec3 posr = pos;\r\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\r\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \r\n    \r\n    float d = 1.05;\r\n    float s = atan(posr.y, posr.x);\r\n    \r\n    vec3 flatvec = vec3(cos(s), sin(s), 1.444);\r\n    vec3 flatvec2 = vec3(cos(s), sin(s), -1.072);\r\n     \r\n    float d1 = dot(flatvec, posr) - d;                        // Crown\r\n    d1 = max(dot(flatvec2, posr) - d, d1);                    // Pavillon\r\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.35, d1);         // Table\r\n    return d1;\r\n}\r\n\r\nfloat map(vec3 pos)\r\n{     \r\n    float angle = 2.*pi*iMouse.x/iResolution.x;\r\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\r\n    \r\n    vec3 posr = pos;\r\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\r\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle));\r\n    \r\n    float d = 0.94;\r\n    float b = 0.5;\r\n\r\n    float af2 = 4./pi;\r\n    float s = atan(posr.y, posr.x);\r\n    float sf = floor(s*af2 + b)/af2;\r\n    float sf2 = floor(s*af2)/af2;\r\n    \r\n    vec3 flatvec = vec3(cos(sf), sin(sf), 1.444);\r\n    vec3 flatvec2 = vec3(cos(sf), sin(sf), -1.072);\r\n    vec3 flatvec3 = vec3(cos(s), sin(s), 0);\r\n    float csf1 = cos(sf + 0.21);\r\n    float csf2 = cos(sf - 0.21);\r\n    float ssf1 = sin(sf + 0.21);\r\n    float ssf2 = sin(sf - 0.21);\r\n    vec3 flatvec4 = vec3(csf1, ssf1, -1.02);\r\n    vec3 flatvec5 = vec3(csf2, ssf2, -1.02);\r\n    vec3 flatvec6 = vec3(csf2, ssf2, 1.03);\r\n    vec3 flatvec7 = vec3(csf1, ssf1, 1.03);\r\n    vec3 flatvec8 = vec3(cos(sf2 + 0.393), sin(sf2 + 0.393), 2.21);\r\n     \r\n    float d1 = dot(flatvec, posr) - d;                           // Crown, bezel facets\r\n    d1 = max(dot(flatvec2, posr) - d, d1);                       // Pavillon, pavillon facets\r\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.3, d1);             // Table\r\n    d1 = max(dot(vec3(0., 0., -1.), posr) - 0.865, d1);          // Cutlet\r\n    d1 = max(dot(flatvec3, posr) - 0.911, d1);                   // Girdle\r\n    d1 = max(dot(flatvec4, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\r\n    d1 = max(dot(flatvec5, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\r\n    d1 = max(dot(flatvec6, posr) - 0.912, d1);                   // Crown, upper-girdle facets\r\n    d1 = max(dot(flatvec7, posr) - 0.912, d1);                   // Crown, upper-girdle facets\r\n    d1 = max(dot(flatvec8, posr) - 1.131, d1);                   // Crown, star facets\r\n    return d1;\r\n}\r\n\r\nfloat trace(vec3 cam, vec3 ray, float maxdist, bool inside) \r\n{\r\n    float t = 4.2;\r\n    float dist;\r\n    \r\n    // \"Bounding\" tracing\r\n    if (!inside)\r\n    {\r\n  \t\tfor (int i = 0; i < 12; ++i)\r\n    \t{\r\n    \t\tvec3 pos = ray*t + cam;\r\n    \t\tdist = map_simple(pos);\r\n        \tif (dist>maxdist || abs(dist)<0.001)\r\n            \tbreak;\r\n        \tt+= dist*0.95;\r\n  \t\t}\r\n    }\r\n\r\n    // \"Actual\" tracing\r\n  \tfor (int i = 0; i < 30; ++i)\r\n    {\r\n    \tvec3 pos = ray*t + cam;\r\n    \tdist = inside?-map(pos):map(pos);\r\n        if (dist>maxdist)\r\n            break;\r\n        t+= dist*(inside?0.4:0.8);\r\n  \t}\r\n  \treturn t;\r\n}\r\n\r\n// Old slower version (but a bit more precise)\r\nfloat trace_sl(vec3 cam, vec3 ray, float maxdist, bool inside) \r\n{\r\n    float t = 4.;\r\n  \tfor (int i = 0; i < 80; ++i)\r\n    {\r\n    \tvec3 pos = ray*t + cam;\r\n    \tfloat dist = inside?-map(pos):map(pos);\r\n        if (dist>(inside?3.:maxdist) || abs(dist)<0.001 || (inside && i>30))\r\n            break;\r\n        t+= dist*0.4;\r\n  \t}\r\n  \treturn t;\r\n}\r\n\r\n// From https://www.shadertoy.com/view/MstGDM\r\nvec3 getNormal(vec3 pos, float e, bool inside)\r\n{\r\n    vec2 q = vec2(0, e);\r\n    return (inside?-1.:1.)*normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\r\n                          map(pos + q.xyx) - map(pos - q.xyx),\r\n                          map(pos + q.xxy) - map(pos - q.xxy)));\r\n}\r\n\r\nvec3 obj_color(vec3 norm, vec3 pos)\r\n{\r\n  \t#ifdef only_shape\r\n  \treturn vec3(0.35, 0.7, 1.0);\r\n  \t#else\r\n    return vec3(0.);\r\n    #endif\r\n}\r\n\r\nvec3 sky_color(vec3 ray)\r\n{\r\n\tvec3 rc = texture(iChannel2, ray.xy).rrr;\r\n    for (int l=0; l<3; l++)\r\n        rc+= 1.5*normalize(lamps[l].color)*lamps[l].intensity*specint*pow(max(0.0, dot(ray, normalize(lamps[l].position - campos))), 200.);\r\n    return rc;\r\n}\r\n\r\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\r\nfloat fresnel(vec3 ray, vec3 norm, float n2)\r\n{\r\n   float n1 = 1.; // air\r\n   float angle = clamp(acos(-dot(ray, norm)), -pi/2.15, pi/2.15);\r\n   float r0 = pow((n1-n2)/(n1+n2), 2.);\r\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\r\n   return clamp(0., 0.9, r);\r\n}\r\n\r\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, bool inside)\r\n{\r\n\tvec3 pl = normalize(lamp.position - pos);\r\n    float dlp = distance(lamp.position, pos);\r\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\r\n      \r\n    vec3 col;\r\n    \r\n    // Diffuse shading\r\n    if (!inside)\r\n    {\r\n    \tfloat diff = clamp(dot(norm, pli), 0., 1.);\r\n    \tcol = ocol*normalize(lamp.color)*lamp.intensity*smoothstep(0., 1.04, pow(diff, 0.78));\r\n    }\r\n    \r\n    // Specular shading\r\n    #ifdef specular\r\n    if (dot(norm, lamp.position - pos) > 0.0)\r\n        col+= normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\r\n    #endif\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, bool inside)\r\n{\r\n    vec3 col = vec3(0.);\r\n    for (int l=0; l<3; l++) // lamps.length()\r\n        col+= lampShading(lamps[l], norm, pos, ocol, inside);\r\n    \r\n    return col;\r\n}\r\n\r\n// From https://www.shadertoy.com/view/lsSXzD, modified\r\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\r\n{\r\n\tvec3 vForward = normalize(vCameraDir);\r\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\r\n\tvec3 vUp = normalize(cross(vForward, vRight));\r\n    \r\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\r\n\r\n\treturn vDir;\r\n}\r\n\r\nRenderData trace0(vec3 tpos, vec3 ray, bool inside)\r\n{\r\n    float tx = trace(tpos, ray, maxdist, inside);\r\n    vec3 col;\r\n    int objnr;\r\n    \r\n    vec3 pos = tpos + tx*ray;\r\n    vec3 norm;\r\n    if (tx<10.)\r\n    {\r\n        norm = getNormal(pos, normdelta, inside);\r\n        if (!inside)\r\n        {\r\n            // Coloring\r\n        \tcol = obj_color(norm, pos) + ambientColor*ambientint;\r\n        \tobjnr = 1;\r\n        }\r\n        \r\n        // Shading\r\n        col = lampsShading(norm, pos, col, inside);\r\n  }\r\n  else\r\n  {\r\n      // Sky\r\n      col = sky_color(ray);\r\n      objnr = 3;\r\n  }\r\n  return RenderData(col, pos, norm, objnr);\r\n}\r\n\r\nvec4 render(vec2 fragCoord, vec3 campos, float ior)\r\n{   \r\n  lamps[0] = Lamp(vec3(0., 4.5, 10.), vec3(1., 1., 1.), 5., 0.1);\r\n  lamps[1] = Lamp(vec3(12., -0.5, 6.), vec3(.7, .8, 1.), 5., 0.1);\r\n  lamps[2] = Lamp(vec3(-1.3, 0.8, -1.5), vec3(1., .95, .8), 3.5, 0.1);\r\n    \r\n  vec2 uv = fragCoord.xy / iResolution.xy; \r\n  uv = uv*2.0 - 1.0;\r\n  uv.x*= iResolution.x / iResolution.y;\r\n\r\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\r\n    \r\n  RenderData traceinf = trace0(campos, ray, false);\r\n  vec3 col = traceinf.col;\r\n    \r\n  #ifdef only_shape\r\n  \treturn vec4(col, 1.0);\r\n  #else\r\n    \r\n  if (traceinf.objnr==1)\r\n  {\r\n  \t\tvec3 norm = traceinf.norm;\r\n        vec3 ray_r = refract(ray, traceinf.norm, 1./ior);\r\n        vec3 ray_r2;\r\n      \r\n        int n2;\r\n        for (int n=0; n<nb_refr; n++)\r\n        {\r\n        \ttraceinf = trace0(traceinf.pos, ray_r, true);\r\n        \tcol+= traceinf.col;\r\n        \tcol*= diamondColor;\r\n      \t\tray_r2 = refract(ray_r, traceinf.norm, ior);\r\n        \tif (length(ray_r2)!=0.)\r\n            {\r\n           \t\tcol+= sky_color(ray_r2)*diamondColor;\r\n                break;\r\n            }\r\n            ray_r2 = reflect(ray_r, traceinf.norm);\r\n            ray_r = ray_r2;\r\n            n2 = n;\r\n        }\r\n        if (n2==nb_refr-1)\r\n            #ifdef show_not_finished\r\n            col = vec3(1., 0., 1.);\r\n      \t\t#else\r\n            col+= sky_color(ray_r2)*diamondColor;\r\n      \t\t#endif\r\n                      \r\n        // Outer reflection\r\n        float r = fresnel(ray, norm, ior);\r\n        col = mix(col, sky_color(reflect(ray, norm)), r);\r\n  }\r\n  return vec4(col, 1.0);\r\n  #endif\r\n}\r\n\r\nvec4 render_rgb(vec2 fragCoord, vec3 campos)\r\n{\r\n    #ifdef color_disp\r\n    \tvec4 col;\r\n    \tcol.r = render(fragCoord, campos, ior_r).r;\r\n    \tcol.g = render(fragCoord, campos, ior_g).g;\r\n    \tcol.b = render(fragCoord, campos, ior_b).b;\r\n    \tcol.a = 1.;\r\n\treturn col;\r\n    #else\r\n    \treturn render(fragCoord, campos, ior);\r\n    #endif\r\n}\r\n\r\nvec4 render_aa(vec2 fragCoord, vec3 campos)\r\n{\r\n    // Antialiasing\r\n    vec4 vs = vec4(0.);\r\n    for (int j=0;j<aasamples ;j++)\r\n    {\r\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\r\n       for (int i=0;i<aasamples ;i++)\r\n       {\r\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\r\n          vs+= render_rgb(fragCoord + vec2(ox, oy), campos);\r\n       }\r\n    }\r\n    return vs/vec4(aasamples*aasamples);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n       fragColor = render_aa(fragCoord, campos);    \r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Misty Lake. Created by Reinder Nijhoff 2013\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/MsB3WR\r\n//\r\n\r\n#define BUMPFACTOR 0.1\r\n#define EPSILON 0.1\r\n#define BUMPDISTANCE 60.\r\n\r\n#define time (iTime+285.)\r\n\r\n// Noise functions by inigo quilez \r\n\r\nfloat noise( const in vec2 x ) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy) + f.xy;\r\n\treturn textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).x;\r\n}\r\n\r\nfloat noise( const in vec3 x ) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nmat2 rot(const in float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\r\n\r\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\r\n                     -0.80,  0.36, -0.48,\r\n                     -0.60, -0.48,  0.64 );\r\n\r\nfloat fbm( in vec3 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m3*p*2.02;\r\n    f += 0.2500*noise( p ); p = m3*p*2.03;\r\n    f += 0.1250*noise( p ); p = m3*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n}\r\n\r\nfloat hash( in float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n// intersection functions\r\n\r\nbool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, inout float dist) {\t\r\n\tif (rd.y==0.0) {\r\n\t\treturn false;\r\n\t}\r\n\t\t\r\n\tfloat d = -(ro.y - height)/rd.y;\r\n\td = min(100000.0, d);\r\n\tif( d > 0. && d < dist ) {\r\n\t\tdist = d;\r\n\t\treturn true;\r\n    } else {\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n// light direction\r\n\r\nvec3 lig = normalize(vec3( 0.3,0.5, 0.6));\r\n\r\nvec3 bgColor( const in vec3 rd ) {\r\n\tfloat sun = clamp( dot(lig,rd), 0.0, 1.0 );\r\n\tvec3 col = vec3(0.5, 0.52, 0.55) - rd.y*0.2*vec3(1.0,0.8,1.0) + 0.15*0.75;\r\n\tcol += vec3(1.0,.6,0.1)*pow( sun, 8.0 );\r\n\tcol *= 0.95;\r\n\treturn col;\r\n}\r\n\r\n// coulds functions by inigo quilez\r\n\r\n#define CLOUDSCALE (500./(64.*0.03))\r\n\r\nfloat cloudMap( const in vec3 p, const in float ani ) {\r\n\tvec3 r = p/CLOUDSCALE;\r\n\r\n\tfloat den = -1.8+cos(r.y*5.-4.3);\r\n\t\t\r\n\tfloat f;\r\n\tvec3 q = 2.5*r*vec3(0.75,1.0,0.75)  + vec3(1.0,1.0,15.0)*ani*0.15;\r\n    f  = 0.50000*noise( q ); q = q*2.02 - vec3(-1.0,1.0,-1.0)*ani*0.15;\r\n    f += 0.25000*noise( q ); q = q*2.03 + vec3(1.0,-1.0,1.0)*ani*0.15;\r\n    f += 0.12500*noise( q ); q = q*2.01 - vec3(1.0,1.0,-1.0)*ani*0.15;\r\n    f += 0.06250*noise( q ); q = q*2.02 + vec3(1.0,1.0,1.0)*ani*0.15;\r\n    f += 0.03125*noise( q );\r\n\t\r\n\treturn 0.065*clamp( den + 4.4*f, 0.0, 1.0 );\r\n}\r\n\r\nvec3 raymarchClouds( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in vec3 fgc, const in float startdist, const in float maxdist, const in float ani ) {\r\n    // dithering\t\r\n\tfloat t = startdist+CLOUDSCALE*0.02*hash(rd.x+35.6987221*rd.y+time);//0.1*texture( iChannel0, fragCoord.xy/iChannelResolution[0].x ).x;\r\n\t\r\n    // raymarch\t\r\n\tvec4 sum = vec4( 0.0 );\r\n\tfor( int i=0; i<64; i++ ) {\r\n\t\tif( sum.a > 0.99 || t > maxdist ) continue;\r\n\t\t\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\tfloat a = cloudMap( pos, ani );\r\n\r\n        // lighting\t\r\n\t\tfloat dif = clamp(0.1 + 0.8*(a - cloudMap( pos + lig*0.15*CLOUDSCALE, ani )), 0., 0.5);\r\n\t\tvec4 col = vec4( (1.+dif)*fgc, a );\r\n\t\t// fog\t\t\r\n\t//\tcol.xyz = mix( col.xyz, fgc, 1.0-exp(-0.0000005*t*t) );\r\n\t\t\r\n\t\tcol.rgb *= col.a;\r\n\t\tsum = sum + col*(1.0 - sum.a);\t\r\n\r\n        // advance ray with LOD\r\n\t\tt += (0.03*CLOUDSCALE)+t*0.012;\r\n\t}\r\n\r\n    // blend with background\t\r\n\tsum.xyz = mix( bgc, sum.xyz/(sum.w+0.0001), sum.w );\r\n\t\r\n\treturn clamp( sum.xyz, 0.0, 1.0 );\r\n}\r\n\r\n// terrain functions\r\nfloat terrainMap( const in vec3 p ) {\r\n\treturn (textureLod( iChannel1, (-p.zx*m2)*0.000046, 0. ).x*600.) * smoothstep( 820., 1000., length(p.xz) ) - 2. + noise(p.xz*0.5)*15.;\r\n}\r\n\r\nvec3 raymarchTerrain( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in float startdist, inout float dist ) {\r\n\tfloat t = startdist;\r\n\r\n    // raymarch\t\r\n\tvec4 sum = vec4( 0.0 );\r\n\tbool hit = false;\r\n\tvec3 col = bgc;\r\n\t\r\n\tfor( int i=0; i<80; i++ ) {\r\n\t\tif( hit ) break;\r\n\t\t\r\n\t\tt += 8. + t/300.;\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\t\r\n\t\tif( pos.y < terrainMap(pos) ) {\r\n\t\t\thit = true;\r\n\t\t}\t\t\r\n\t}\r\n\tif( hit ) {\r\n\t\t// binary search for hit\t\t\r\n\t\tfloat dt = 4.+t/400.;\r\n\t\tt -= dt;\r\n\t\t\r\n\t\tvec3 pos = ro + t*rd;\t\r\n\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\t\t\r\n\t\tfor( int j=0; j<2; j++ ) {\r\n\t\t\tpos = ro + t*rd;\r\n\t\t\tdt *= 0.5;\r\n\t\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\r\n\t\t}\r\n\t\tpos = ro + t*rd;\r\n\t\t\r\n\t\tvec3 dx = vec3( 100.*EPSILON, 0., 0. );\r\n\t\tvec3 dz = vec3( 0., 0., 100.*EPSILON );\r\n\t\t\r\n\t\tvec3 normal = vec3( 0., 0., 0. );\r\n\t\tnormal.x = (terrainMap(pos + dx) - terrainMap(pos-dx) ) / (200. * EPSILON);\r\n\t\tnormal.z = (terrainMap(pos + dz) - terrainMap(pos-dz) ) / (200. * EPSILON);\r\n\t\tnormal.y = 1.;\r\n\t\tnormal = normalize( normal );\t\t\r\n\r\n\t\tcol = vec3(0.2) + 0.7*texture( iChannel2, pos.xz * 0.01 ).xyz * \r\n\t\t\t\t   vec3(1.,.9,0.6);\r\n\t\t\r\n\t\tfloat veg = 0.3*fbm(pos*0.2)+normal.y;\r\n\t\t\t\t\t\r\n\t\tif( veg > 0.75 ) {\r\n\t\t\tcol = vec3( 0.45, 0.6, 0.3 )*(0.5+0.5*fbm(pos*0.5))*0.6;\r\n\t\t} else \r\n\t\tif( veg > 0.66 ) {\r\n\t\t\tcol = col*0.6+vec3( 0.4, 0.5, 0.3 )*(0.5+0.5*fbm(pos*0.25))*0.3;\r\n\t\t}\r\n\t\tcol *= vec3(0.5, 0.52, 0.65)*vec3(1.,.9,0.8);\r\n\t\t\r\n\t\tvec3 brdf = col;\r\n\t\t\r\n\t\tfloat diff = clamp( dot( normal, -lig ), 0., 1.);\r\n\t\t\r\n\t\tcol = brdf*diff*vec3(1.0,.6,0.1);\r\n\t\tcol += brdf*clamp( dot( normal, lig ), 0., 1.)*vec3(0.8,.6,0.5)*0.8;\r\n\t\tcol += brdf*clamp( dot( normal, vec3(0.,1.,0.) ), 0., 1.)*vec3(0.8,.8,1.)*0.2;\r\n\t\t\r\n\t\tdist = t;\r\n\t\tt -= pos.y*3.5;\r\n\t\tcol = mix( col, bgc, 1.0-exp(-0.0000005*t*t) );\r\n\t\t\r\n\t}\r\n\treturn col;\r\n}\r\n\r\nfloat waterMap( vec2 pos ) {\r\n\tvec2 posm = pos * m2;\r\n\t\r\n\treturn abs( fbm( vec3( 8.*posm, time ))-0.5 )* 0.1;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n\t\r\n\t// camera parameters\r\n\tvec3 ro = vec3(0.0, 0.5, 0.0);\r\n\tvec3 ta = vec3(0.0, 0.45,1.0);\r\n\tif (iMouse.z>=1.) {\r\n\t\tta.xz *= rot( (iMouse.x/iResolution.x-.5)*7. );\r\n\t}\r\n\t\t\r\n\tta.xz *= rot( mod(iTime * 0.05, 6.2831852) );\r\n    \r\n\t// build ray\r\n    vec3 ww = normalize( ta - ro);\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\r\n\r\n\tfloat fresnel, refldist = 5000., maxdist = 5000.;\r\n\tbool reflected = false;\r\n\tvec3 normal, col = bgColor( rd );\r\n\tvec3 roo = ro, rdo = rd, bgc = col;\r\n\t\r\n\tif( intersectPlane( ro, rd, 0., refldist ) && refldist < 200. ) {\r\n\t\tro += refldist*rd;\t\r\n\t\tvec2 coord = ro.xz;\r\n\t\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, refldist) );\r\n\t\t\t\t\r\n\t\tvec2 dx = vec2( EPSILON, 0. );\r\n\t\tvec2 dz = vec2( 0., EPSILON );\r\n\t\t\r\n\t\tnormal = vec3( 0., 1., 0. );\r\n\t\tnormal.x = -bumpfactor * (waterMap(coord + dx) - waterMap(coord-dx) ) / (2. * EPSILON);\r\n\t\tnormal.z = -bumpfactor * (waterMap(coord + dz) - waterMap(coord-dz) ) / (2. * EPSILON);\r\n\t\tnormal = normalize( normal );\t\t\r\n\t\t\r\n\t\tfloat ndotr = dot(normal,rd);\r\n\t\tfresnel = pow(1.0-abs(ndotr),5.);\r\n\r\n\t\trd = reflect( rd, normal);\r\n\r\n\t\treflected = true;\r\n\t\tbgc = col = bgColor( rd );\r\n\t}\r\n\r\n\tcol = raymarchTerrain( ro, rd, col, reflected?(800.-refldist):800., maxdist );\r\n    col = raymarchClouds( ro, rd, col, bgc, reflected?max(0.,min(150.,(150.-refldist))):150., maxdist, time*0.05 );\r\n\t\r\n\tif( reflected ) {\r\n\t\tcol = mix( col.xyz, bgc, 1.0-exp(-0.0000005*refldist*refldist) );\r\n\t\tcol *= fresnel*0.9;\t\t\r\n\t\tvec3 refr = refract( rdo, normal, 1./1.3330 );\r\n\t\tintersectPlane( ro, refr, -2., refldist );\r\n\t\tcol += mix( texture( iChannel2, (roo+refldist*refr).xz*1.3 ).xyz * \r\n\t\t\t\t   vec3(1.,.9,0.6), vec3(1.,.9,0.8)*0.5, clamp( refldist / 3., 0., 1.) ) \r\n\t\t\t   * (1.-fresnel)*0.125;\r\n\t}\r\n\t\r\n\tcol = pow( col, vec3(0.7) );\r\n\t\r\n\t// contrast, saturation and vignetting\t\r\n\tcol = col*col*(3.0-2.0*col);\r\n    col = mix( col, vec3(dot(col,vec3(0.33))), -0.5 );\r\n \tcol *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\t\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":null,"published":0}],"outputs":[],"code":"// Misty Lake. Created by Reinder Nijhoff 2013\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/MsB3WR\r\n//\r\n\r\n#define BUMPFACTOR 0.1\r\n#define EPSILON 0.1\r\n#define BUMPDISTANCE 60.\r\n\r\n#define time (iTime+285.)\r\n\r\n// Noise functions by inigo quilez \r\n\r\nfloat noise( const in vec2 x ) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy) + f.xy;\r\n\treturn textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).x;\r\n}\r\n\r\nfloat noise( const in vec3 x ) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nmat2 rot(const in float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\r\n\r\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\r\n                     -0.80,  0.36, -0.48,\r\n                     -0.60, -0.48,  0.64 );\r\n\r\nfloat fbm( in vec3 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m3*p*2.02;\r\n    f += 0.2500*noise( p ); p = m3*p*2.03;\r\n    f += 0.1250*noise( p ); p = m3*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n}\r\n\r\nfloat hash( in float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n// intersection functions\r\n\r\nbool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, inout float dist) {\t\r\n\tif (rd.y==0.0) {\r\n\t\treturn false;\r\n\t}\r\n\t\t\r\n\tfloat d = -(ro.y - height)/rd.y;\r\n\td = min(100000.0, d);\r\n\tif( d > 0. && d < dist ) {\r\n\t\tdist = d;\r\n\t\treturn true;\r\n    } else {\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n// light direction\r\n\r\nvec3 lig = normalize(vec3( 0.3,0.5, 0.6));\r\n\r\nvec3 bgColor( const in vec3 rd ) {\r\n\tfloat sun = clamp( dot(lig,rd), 0.0, 1.0 );\r\n\tvec3 col = vec3(0.5, 0.52, 0.55) - rd.y*0.2*vec3(1.0,0.8,1.0) + 0.15*0.75;\r\n\tcol += vec3(1.0,.6,0.1)*pow( sun, 8.0 );\r\n\tcol *= 0.95;\r\n\treturn col;\r\n}\r\n\r\n// coulds functions by inigo quilez\r\n\r\n#define CLOUDSCALE (500./(64.*0.03))\r\n\r\nfloat cloudMap( const in vec3 p, const in float ani ) {\r\n\tvec3 r = p/CLOUDSCALE;\r\n\r\n\tfloat den = -1.8+cos(r.y*5.-4.3);\r\n\t\t\r\n\tfloat f;\r\n\tvec3 q = 2.5*r*vec3(0.75,1.0,0.75)  + vec3(1.0,1.0,15.0)*ani*0.15;\r\n    f  = 0.50000*noise( q ); q = q*2.02 - vec3(-1.0,1.0,-1.0)*ani*0.15;\r\n    f += 0.25000*noise( q ); q = q*2.03 + vec3(1.0,-1.0,1.0)*ani*0.15;\r\n    f += 0.12500*noise( q ); q = q*2.01 - vec3(1.0,1.0,-1.0)*ani*0.15;\r\n    f += 0.06250*noise( q ); q = q*2.02 + vec3(1.0,1.0,1.0)*ani*0.15;\r\n    f += 0.03125*noise( q );\r\n\t\r\n\treturn 0.065*clamp( den + 4.4*f, 0.0, 1.0 );\r\n}\r\n\r\nvec3 raymarchClouds( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in vec3 fgc, const in float startdist, const in float maxdist, const in float ani ) {\r\n    // dithering\t\r\n\tfloat t = startdist+CLOUDSCALE*0.02*hash(rd.x+35.6987221*rd.y+time);//0.1*texture( iChannel0, fragCoord.xy/iChannelResolution[0].x ).x;\r\n\t\r\n    // raymarch\t\r\n\tvec4 sum = vec4( 0.0 );\r\n\tfor( int i=0; i<64; i++ ) {\r\n\t\tif( sum.a > 0.99 || t > maxdist ) continue;\r\n\t\t\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\tfloat a = cloudMap( pos, ani );\r\n\r\n        // lighting\t\r\n\t\tfloat dif = clamp(0.1 + 0.8*(a - cloudMap( pos + lig*0.15*CLOUDSCALE, ani )), 0., 0.5);\r\n\t\tvec4 col = vec4( (1.+dif)*fgc, a );\r\n\t\t// fog\t\t\r\n\t//\tcol.xyz = mix( col.xyz, fgc, 1.0-exp(-0.0000005*t*t) );\r\n\t\t\r\n\t\tcol.rgb *= col.a;\r\n\t\tsum = sum + col*(1.0 - sum.a);\t\r\n\r\n        // advance ray with LOD\r\n\t\tt += (0.03*CLOUDSCALE)+t*0.012;\r\n\t}\r\n\r\n    // blend with background\t\r\n\tsum.xyz = mix( bgc, sum.xyz/(sum.w+0.0001), sum.w );\r\n\t\r\n\treturn clamp( sum.xyz, 0.0, 1.0 );\r\n}\r\n\r\n// terrain functions\r\nfloat terrainMap( const in vec3 p ) {\r\n\treturn (textureLod( iChannel1, (-p.zx*m2)*0.000046, 0. ).x*600.) * smoothstep( 820., 1000., length(p.xz) ) - 2. + noise(p.xz*0.5)*15.;\r\n}\r\n\r\nvec3 raymarchTerrain( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in float startdist, inout float dist ) {\r\n\tfloat t = startdist;\r\n\r\n    // raymarch\t\r\n\tvec4 sum = vec4( 0.0 );\r\n\tbool hit = false;\r\n\tvec3 col = bgc;\r\n\t\r\n\tfor( int i=0; i<80; i++ ) {\r\n\t\tif( hit ) break;\r\n\t\t\r\n\t\tt += 8. + t/300.;\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\t\r\n\t\tif( pos.y < terrainMap(pos) ) {\r\n\t\t\thit = true;\r\n\t\t}\t\t\r\n\t}\r\n\tif( hit ) {\r\n\t\t// binary search for hit\t\t\r\n\t\tfloat dt = 4.+t/400.;\r\n\t\tt -= dt;\r\n\t\t\r\n\t\tvec3 pos = ro + t*rd;\t\r\n\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\t\t\r\n\t\tfor( int j=0; j<2; j++ ) {\r\n\t\t\tpos = ro + t*rd;\r\n\t\t\tdt *= 0.5;\r\n\t\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\r\n\t\t}\r\n\t\tpos = ro + t*rd;\r\n\t\t\r\n\t\tvec3 dx = vec3( 100.*EPSILON, 0., 0. );\r\n\t\tvec3 dz = vec3( 0., 0., 100.*EPSILON );\r\n\t\t\r\n\t\tvec3 normal = vec3( 0., 0., 0. );\r\n\t\tnormal.x = (terrainMap(pos + dx) - terrainMap(pos-dx) ) / (200. * EPSILON);\r\n\t\tnormal.z = (terrainMap(pos + dz) - terrainMap(pos-dz) ) / (200. * EPSILON);\r\n\t\tnormal.y = 1.;\r\n\t\tnormal = normalize( normal );\t\t\r\n\r\n\t\tcol = vec3(0.2) + 0.7*texture( iChannel2, pos.xz * 0.01 ).xyz * \r\n\t\t\t\t   vec3(1.,.9,0.6);\r\n\t\t\r\n\t\tfloat veg = 0.3*fbm(pos*0.2)+normal.y;\r\n\t\t\t\t\t\r\n\t\tif( veg > 0.75 ) {\r\n\t\t\tcol = vec3( 0.45, 0.6, 0.3 )*(0.5+0.5*fbm(pos*0.5))*0.6;\r\n\t\t} else \r\n\t\tif( veg > 0.66 ) {\r\n\t\t\tcol = col*0.6+vec3( 0.4, 0.5, 0.3 )*(0.5+0.5*fbm(pos*0.25))*0.3;\r\n\t\t}\r\n\t\tcol *= vec3(0.5, 0.52, 0.65)*vec3(1.,.9,0.8);\r\n\t\t\r\n\t\tvec3 brdf = col;\r\n\t\t\r\n\t\tfloat diff = clamp( dot( normal, -lig ), 0., 1.);\r\n\t\t\r\n\t\tcol = brdf*diff*vec3(1.0,.6,0.1);\r\n\t\tcol += brdf*clamp( dot( normal, lig ), 0., 1.)*vec3(0.8,.6,0.5)*0.8;\r\n\t\tcol += brdf*clamp( dot( normal, vec3(0.,1.,0.) ), 0., 1.)*vec3(0.8,.8,1.)*0.2;\r\n\t\t\r\n\t\tdist = t;\r\n\t\tt -= pos.y*3.5;\r\n\t\tcol = mix( col, bgc, 1.0-exp(-0.0000005*t*t) );\r\n\t\t\r\n\t}\r\n\treturn col;\r\n}\r\n\r\nfloat waterMap( vec2 pos ) {\r\n\tvec2 posm = pos * m2;\r\n\t\r\n\treturn abs( fbm( vec3( 8.*posm, time ))-0.5 )* 0.1;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n\t\r\n\t// camera parameters\r\n\tvec3 ro = vec3(0.0, 0.5, 0.0);\r\n\tvec3 ta = vec3(0.0, 0.45,1.0);\r\n\tif (iMouse.z>=1.) {\r\n\t\tta.xz *= rot( (iMouse.x/iResolution.x-.5)*7. );\r\n\t}\r\n\t\t\r\n\tta.xz *= rot( mod(iTime * 0.05, 6.2831852) );\r\n    \r\n\t// build ray\r\n    vec3 ww = normalize( ta - ro);\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\r\n\r\n\tfloat fresnel, refldist = 5000., maxdist = 5000.;\r\n\tbool reflected = false;\r\n\tvec3 normal, col = bgColor( rd );\r\n\tvec3 roo = ro, rdo = rd, bgc = col;\r\n\t\r\n\tif( intersectPlane( ro, rd, 0., refldist ) && refldist < 200. ) {\r\n\t\tro += refldist*rd;\t\r\n\t\tvec2 coord = ro.xz;\r\n\t\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, refldist) );\r\n\t\t\t\t\r\n\t\tvec2 dx = vec2( EPSILON, 0. );\r\n\t\tvec2 dz = vec2( 0., EPSILON );\r\n\t\t\r\n\t\tnormal = vec3( 0., 1., 0. );\r\n\t\tnormal.x = -bumpfactor * (waterMap(coord + dx) - waterMap(coord-dx) ) / (2. * EPSILON);\r\n\t\tnormal.z = -bumpfactor * (waterMap(coord + dz) - waterMap(coord-dz) ) / (2. * EPSILON);\r\n\t\tnormal = normalize( normal );\t\t\r\n\t\t\r\n\t\tfloat ndotr = dot(normal,rd);\r\n\t\tfresnel = pow(1.0-abs(ndotr),5.);\r\n\r\n\t\trd = reflect( rd, normal);\r\n\r\n\t\treflected = true;\r\n\t\tbgc = col = bgColor( rd );\r\n\t}\r\n\r\n\tcol = raymarchTerrain( ro, rd, col, reflected?(800.-refldist):800., maxdist );\r\n    col = raymarchClouds( ro, rd, col, bgc, reflected?max(0.,min(150.,(150.-refldist))):150., maxdist, time*0.05 );\r\n\t\r\n\tif( reflected ) {\r\n\t\tcol = mix( col.xyz, bgc, 1.0-exp(-0.0000005*refldist*refldist) );\r\n\t\tcol *= fresnel*0.9;\t\t\r\n\t\tvec3 refr = refract( rdo, normal, 1./1.3330 );\r\n\t\tintersectPlane( ro, refr, -2., refldist );\r\n\t\tcol += mix( texture( iChannel2, (roo+refldist*refr).xz*1.3 ).xyz * \r\n\t\t\t\t   vec3(1.,.9,0.6), vec3(1.,.9,0.8)*0.5, clamp( refldist / 3., 0., 1.) ) \r\n\t\t\t   * (1.-fresnel)*0.125;\r\n\t}\r\n\t\r\n\tcol = pow( col, vec3(0.7) );\r\n\t\r\n\t// contrast, saturation and vignetting\t\r\n\tcol = col*col*(3.0-2.0*col);\r\n    col = mix( col, vec3(dot(col,vec3(0.33))), -0.5 );\r\n \tcol *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\t\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":null,"published":0}],"Info":{"Name":"Misty Lake","id":null,"date":null,"viewed":0,"name":"Misty Lake","description":"A misty lake in the morning. Cloud and noise functions by Inigo Quilez.\r\n\r\nYou can use your mouse to look around.","likes":0,"published":null,"tags":["raymarching"," reflection"," clouds"," refraction"," water"," fog"," mountains"," lake"]},"ver":null,"info":{"Name":"Misty Lake","id":null,"date":null,"viewed":0,"name":"Misty Lake","description":"A misty lake in the morning. Cloud and noise functions by Inigo Quilez.\r\n\r\nYou can use your mouse to look around.","likes":0,"published":null,"tags":["raymarching"," reflection"," clouds"," refraction"," water"," fog"," mountains"," lake"]},"renderpass":[{"Code":"// Misty Lake. Created by Reinder Nijhoff 2013\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/MsB3WR\r\n//\r\n\r\n#define BUMPFACTOR 0.1\r\n#define EPSILON 0.1\r\n#define BUMPDISTANCE 60.\r\n\r\n#define time (iTime+285.)\r\n\r\n// Noise functions by inigo quilez \r\n\r\nfloat noise( const in vec2 x ) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy) + f.xy;\r\n\treturn textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).x;\r\n}\r\n\r\nfloat noise( const in vec3 x ) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nmat2 rot(const in float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\r\n\r\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\r\n                     -0.80,  0.36, -0.48,\r\n                     -0.60, -0.48,  0.64 );\r\n\r\nfloat fbm( in vec3 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m3*p*2.02;\r\n    f += 0.2500*noise( p ); p = m3*p*2.03;\r\n    f += 0.1250*noise( p ); p = m3*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n}\r\n\r\nfloat hash( in float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n// intersection functions\r\n\r\nbool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, inout float dist) {\t\r\n\tif (rd.y==0.0) {\r\n\t\treturn false;\r\n\t}\r\n\t\t\r\n\tfloat d = -(ro.y - height)/rd.y;\r\n\td = min(100000.0, d);\r\n\tif( d > 0. && d < dist ) {\r\n\t\tdist = d;\r\n\t\treturn true;\r\n    } else {\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n// light direction\r\n\r\nvec3 lig = normalize(vec3( 0.3,0.5, 0.6));\r\n\r\nvec3 bgColor( const in vec3 rd ) {\r\n\tfloat sun = clamp( dot(lig,rd), 0.0, 1.0 );\r\n\tvec3 col = vec3(0.5, 0.52, 0.55) - rd.y*0.2*vec3(1.0,0.8,1.0) + 0.15*0.75;\r\n\tcol += vec3(1.0,.6,0.1)*pow( sun, 8.0 );\r\n\tcol *= 0.95;\r\n\treturn col;\r\n}\r\n\r\n// coulds functions by inigo quilez\r\n\r\n#define CLOUDSCALE (500./(64.*0.03))\r\n\r\nfloat cloudMap( const in vec3 p, const in float ani ) {\r\n\tvec3 r = p/CLOUDSCALE;\r\n\r\n\tfloat den = -1.8+cos(r.y*5.-4.3);\r\n\t\t\r\n\tfloat f;\r\n\tvec3 q = 2.5*r*vec3(0.75,1.0,0.75)  + vec3(1.0,1.0,15.0)*ani*0.15;\r\n    f  = 0.50000*noise( q ); q = q*2.02 - vec3(-1.0,1.0,-1.0)*ani*0.15;\r\n    f += 0.25000*noise( q ); q = q*2.03 + vec3(1.0,-1.0,1.0)*ani*0.15;\r\n    f += 0.12500*noise( q ); q = q*2.01 - vec3(1.0,1.0,-1.0)*ani*0.15;\r\n    f += 0.06250*noise( q ); q = q*2.02 + vec3(1.0,1.0,1.0)*ani*0.15;\r\n    f += 0.03125*noise( q );\r\n\t\r\n\treturn 0.065*clamp( den + 4.4*f, 0.0, 1.0 );\r\n}\r\n\r\nvec3 raymarchClouds( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in vec3 fgc, const in float startdist, const in float maxdist, const in float ani ) {\r\n    // dithering\t\r\n\tfloat t = startdist+CLOUDSCALE*0.02*hash(rd.x+35.6987221*rd.y+time);//0.1*texture( iChannel0, fragCoord.xy/iChannelResolution[0].x ).x;\r\n\t\r\n    // raymarch\t\r\n\tvec4 sum = vec4( 0.0 );\r\n\tfor( int i=0; i<64; i++ ) {\r\n\t\tif( sum.a > 0.99 || t > maxdist ) continue;\r\n\t\t\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\tfloat a = cloudMap( pos, ani );\r\n\r\n        // lighting\t\r\n\t\tfloat dif = clamp(0.1 + 0.8*(a - cloudMap( pos + lig*0.15*CLOUDSCALE, ani )), 0., 0.5);\r\n\t\tvec4 col = vec4( (1.+dif)*fgc, a );\r\n\t\t// fog\t\t\r\n\t//\tcol.xyz = mix( col.xyz, fgc, 1.0-exp(-0.0000005*t*t) );\r\n\t\t\r\n\t\tcol.rgb *= col.a;\r\n\t\tsum = sum + col*(1.0 - sum.a);\t\r\n\r\n        // advance ray with LOD\r\n\t\tt += (0.03*CLOUDSCALE)+t*0.012;\r\n\t}\r\n\r\n    // blend with background\t\r\n\tsum.xyz = mix( bgc, sum.xyz/(sum.w+0.0001), sum.w );\r\n\t\r\n\treturn clamp( sum.xyz, 0.0, 1.0 );\r\n}\r\n\r\n// terrain functions\r\nfloat terrainMap( const in vec3 p ) {\r\n\treturn (textureLod( iChannel1, (-p.zx*m2)*0.000046, 0. ).x*600.) * smoothstep( 820., 1000., length(p.xz) ) - 2. + noise(p.xz*0.5)*15.;\r\n}\r\n\r\nvec3 raymarchTerrain( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in float startdist, inout float dist ) {\r\n\tfloat t = startdist;\r\n\r\n    // raymarch\t\r\n\tvec4 sum = vec4( 0.0 );\r\n\tbool hit = false;\r\n\tvec3 col = bgc;\r\n\t\r\n\tfor( int i=0; i<80; i++ ) {\r\n\t\tif( hit ) break;\r\n\t\t\r\n\t\tt += 8. + t/300.;\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\t\r\n\t\tif( pos.y < terrainMap(pos) ) {\r\n\t\t\thit = true;\r\n\t\t}\t\t\r\n\t}\r\n\tif( hit ) {\r\n\t\t// binary search for hit\t\t\r\n\t\tfloat dt = 4.+t/400.;\r\n\t\tt -= dt;\r\n\t\t\r\n\t\tvec3 pos = ro + t*rd;\t\r\n\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\t\t\r\n\t\tfor( int j=0; j<2; j++ ) {\r\n\t\t\tpos = ro + t*rd;\r\n\t\t\tdt *= 0.5;\r\n\t\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\r\n\t\t}\r\n\t\tpos = ro + t*rd;\r\n\t\t\r\n\t\tvec3 dx = vec3( 100.*EPSILON, 0., 0. );\r\n\t\tvec3 dz = vec3( 0., 0., 100.*EPSILON );\r\n\t\t\r\n\t\tvec3 normal = vec3( 0., 0., 0. );\r\n\t\tnormal.x = (terrainMap(pos + dx) - terrainMap(pos-dx) ) / (200. * EPSILON);\r\n\t\tnormal.z = (terrainMap(pos + dz) - terrainMap(pos-dz) ) / (200. * EPSILON);\r\n\t\tnormal.y = 1.;\r\n\t\tnormal = normalize( normal );\t\t\r\n\r\n\t\tcol = vec3(0.2) + 0.7*texture( iChannel2, pos.xz * 0.01 ).xyz * \r\n\t\t\t\t   vec3(1.,.9,0.6);\r\n\t\t\r\n\t\tfloat veg = 0.3*fbm(pos*0.2)+normal.y;\r\n\t\t\t\t\t\r\n\t\tif( veg > 0.75 ) {\r\n\t\t\tcol = vec3( 0.45, 0.6, 0.3 )*(0.5+0.5*fbm(pos*0.5))*0.6;\r\n\t\t} else \r\n\t\tif( veg > 0.66 ) {\r\n\t\t\tcol = col*0.6+vec3( 0.4, 0.5, 0.3 )*(0.5+0.5*fbm(pos*0.25))*0.3;\r\n\t\t}\r\n\t\tcol *= vec3(0.5, 0.52, 0.65)*vec3(1.,.9,0.8);\r\n\t\t\r\n\t\tvec3 brdf = col;\r\n\t\t\r\n\t\tfloat diff = clamp( dot( normal, -lig ), 0., 1.);\r\n\t\t\r\n\t\tcol = brdf*diff*vec3(1.0,.6,0.1);\r\n\t\tcol += brdf*clamp( dot( normal, lig ), 0., 1.)*vec3(0.8,.6,0.5)*0.8;\r\n\t\tcol += brdf*clamp( dot( normal, vec3(0.,1.,0.) ), 0., 1.)*vec3(0.8,.8,1.)*0.2;\r\n\t\t\r\n\t\tdist = t;\r\n\t\tt -= pos.y*3.5;\r\n\t\tcol = mix( col, bgc, 1.0-exp(-0.0000005*t*t) );\r\n\t\t\r\n\t}\r\n\treturn col;\r\n}\r\n\r\nfloat waterMap( vec2 pos ) {\r\n\tvec2 posm = pos * m2;\r\n\t\r\n\treturn abs( fbm( vec3( 8.*posm, time ))-0.5 )* 0.1;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n\t\r\n\t// camera parameters\r\n\tvec3 ro = vec3(0.0, 0.5, 0.0);\r\n\tvec3 ta = vec3(0.0, 0.45,1.0);\r\n\tif (iMouse.z>=1.) {\r\n\t\tta.xz *= rot( (iMouse.x/iResolution.x-.5)*7. );\r\n\t}\r\n\t\t\r\n\tta.xz *= rot( mod(iTime * 0.05, 6.2831852) );\r\n    \r\n\t// build ray\r\n    vec3 ww = normalize( ta - ro);\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\r\n\r\n\tfloat fresnel, refldist = 5000., maxdist = 5000.;\r\n\tbool reflected = false;\r\n\tvec3 normal, col = bgColor( rd );\r\n\tvec3 roo = ro, rdo = rd, bgc = col;\r\n\t\r\n\tif( intersectPlane( ro, rd, 0., refldist ) && refldist < 200. ) {\r\n\t\tro += refldist*rd;\t\r\n\t\tvec2 coord = ro.xz;\r\n\t\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, refldist) );\r\n\t\t\t\t\r\n\t\tvec2 dx = vec2( EPSILON, 0. );\r\n\t\tvec2 dz = vec2( 0., EPSILON );\r\n\t\t\r\n\t\tnormal = vec3( 0., 1., 0. );\r\n\t\tnormal.x = -bumpfactor * (waterMap(coord + dx) - waterMap(coord-dx) ) / (2. * EPSILON);\r\n\t\tnormal.z = -bumpfactor * (waterMap(coord + dz) - waterMap(coord-dz) ) / (2. * EPSILON);\r\n\t\tnormal = normalize( normal );\t\t\r\n\t\t\r\n\t\tfloat ndotr = dot(normal,rd);\r\n\t\tfresnel = pow(1.0-abs(ndotr),5.);\r\n\r\n\t\trd = reflect( rd, normal);\r\n\r\n\t\treflected = true;\r\n\t\tbgc = col = bgColor( rd );\r\n\t}\r\n\r\n\tcol = raymarchTerrain( ro, rd, col, reflected?(800.-refldist):800., maxdist );\r\n    col = raymarchClouds( ro, rd, col, bgc, reflected?max(0.,min(150.,(150.-refldist))):150., maxdist, time*0.05 );\r\n\t\r\n\tif( reflected ) {\r\n\t\tcol = mix( col.xyz, bgc, 1.0-exp(-0.0000005*refldist*refldist) );\r\n\t\tcol *= fresnel*0.9;\t\t\r\n\t\tvec3 refr = refract( rdo, normal, 1./1.3330 );\r\n\t\tintersectPlane( ro, refr, -2., refldist );\r\n\t\tcol += mix( texture( iChannel2, (roo+refldist*refr).xz*1.3 ).xyz * \r\n\t\t\t\t   vec3(1.,.9,0.6), vec3(1.,.9,0.8)*0.5, clamp( refldist / 3., 0., 1.) ) \r\n\t\t\t   * (1.-fresnel)*0.125;\r\n\t}\r\n\t\r\n\tcol = pow( col, vec3(0.7) );\r\n\t\r\n\t// contrast, saturation and vignetting\t\r\n\tcol = col*col*(3.0-2.0*col);\r\n    col = mix( col, vec3(dot(col,vec3(0.33))), -0.5 );\r\n \tcol *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\t\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":null,"published":0}],"outputs":[],"code":"// Misty Lake. Created by Reinder Nijhoff 2013\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/MsB3WR\r\n//\r\n\r\n#define BUMPFACTOR 0.1\r\n#define EPSILON 0.1\r\n#define BUMPDISTANCE 60.\r\n\r\n#define time (iTime+285.)\r\n\r\n// Noise functions by inigo quilez \r\n\r\nfloat noise( const in vec2 x ) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy) + f.xy;\r\n\treturn textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).x;\r\n}\r\n\r\nfloat noise( const in vec3 x ) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nmat2 rot(const in float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\r\n\r\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\r\n                     -0.80,  0.36, -0.48,\r\n                     -0.60, -0.48,  0.64 );\r\n\r\nfloat fbm( in vec3 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m3*p*2.02;\r\n    f += 0.2500*noise( p ); p = m3*p*2.03;\r\n    f += 0.1250*noise( p ); p = m3*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n}\r\n\r\nfloat hash( in float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n// intersection functions\r\n\r\nbool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, inout float dist) {\t\r\n\tif (rd.y==0.0) {\r\n\t\treturn false;\r\n\t}\r\n\t\t\r\n\tfloat d = -(ro.y - height)/rd.y;\r\n\td = min(100000.0, d);\r\n\tif( d > 0. && d < dist ) {\r\n\t\tdist = d;\r\n\t\treturn true;\r\n    } else {\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n// light direction\r\n\r\nvec3 lig = normalize(vec3( 0.3,0.5, 0.6));\r\n\r\nvec3 bgColor( const in vec3 rd ) {\r\n\tfloat sun = clamp( dot(lig,rd), 0.0, 1.0 );\r\n\tvec3 col = vec3(0.5, 0.52, 0.55) - rd.y*0.2*vec3(1.0,0.8,1.0) + 0.15*0.75;\r\n\tcol += vec3(1.0,.6,0.1)*pow( sun, 8.0 );\r\n\tcol *= 0.95;\r\n\treturn col;\r\n}\r\n\r\n// coulds functions by inigo quilez\r\n\r\n#define CLOUDSCALE (500./(64.*0.03))\r\n\r\nfloat cloudMap( const in vec3 p, const in float ani ) {\r\n\tvec3 r = p/CLOUDSCALE;\r\n\r\n\tfloat den = -1.8+cos(r.y*5.-4.3);\r\n\t\t\r\n\tfloat f;\r\n\tvec3 q = 2.5*r*vec3(0.75,1.0,0.75)  + vec3(1.0,1.0,15.0)*ani*0.15;\r\n    f  = 0.50000*noise( q ); q = q*2.02 - vec3(-1.0,1.0,-1.0)*ani*0.15;\r\n    f += 0.25000*noise( q ); q = q*2.03 + vec3(1.0,-1.0,1.0)*ani*0.15;\r\n    f += 0.12500*noise( q ); q = q*2.01 - vec3(1.0,1.0,-1.0)*ani*0.15;\r\n    f += 0.06250*noise( q ); q = q*2.02 + vec3(1.0,1.0,1.0)*ani*0.15;\r\n    f += 0.03125*noise( q );\r\n\t\r\n\treturn 0.065*clamp( den + 4.4*f, 0.0, 1.0 );\r\n}\r\n\r\nvec3 raymarchClouds( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in vec3 fgc, const in float startdist, const in float maxdist, const in float ani ) {\r\n    // dithering\t\r\n\tfloat t = startdist+CLOUDSCALE*0.02*hash(rd.x+35.6987221*rd.y+time);//0.1*texture( iChannel0, fragCoord.xy/iChannelResolution[0].x ).x;\r\n\t\r\n    // raymarch\t\r\n\tvec4 sum = vec4( 0.0 );\r\n\tfor( int i=0; i<64; i++ ) {\r\n\t\tif( sum.a > 0.99 || t > maxdist ) continue;\r\n\t\t\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\tfloat a = cloudMap( pos, ani );\r\n\r\n        // lighting\t\r\n\t\tfloat dif = clamp(0.1 + 0.8*(a - cloudMap( pos + lig*0.15*CLOUDSCALE, ani )), 0., 0.5);\r\n\t\tvec4 col = vec4( (1.+dif)*fgc, a );\r\n\t\t// fog\t\t\r\n\t//\tcol.xyz = mix( col.xyz, fgc, 1.0-exp(-0.0000005*t*t) );\r\n\t\t\r\n\t\tcol.rgb *= col.a;\r\n\t\tsum = sum + col*(1.0 - sum.a);\t\r\n\r\n        // advance ray with LOD\r\n\t\tt += (0.03*CLOUDSCALE)+t*0.012;\r\n\t}\r\n\r\n    // blend with background\t\r\n\tsum.xyz = mix( bgc, sum.xyz/(sum.w+0.0001), sum.w );\r\n\t\r\n\treturn clamp( sum.xyz, 0.0, 1.0 );\r\n}\r\n\r\n// terrain functions\r\nfloat terrainMap( const in vec3 p ) {\r\n\treturn (textureLod( iChannel1, (-p.zx*m2)*0.000046, 0. ).x*600.) * smoothstep( 820., 1000., length(p.xz) ) - 2. + noise(p.xz*0.5)*15.;\r\n}\r\n\r\nvec3 raymarchTerrain( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in float startdist, inout float dist ) {\r\n\tfloat t = startdist;\r\n\r\n    // raymarch\t\r\n\tvec4 sum = vec4( 0.0 );\r\n\tbool hit = false;\r\n\tvec3 col = bgc;\r\n\t\r\n\tfor( int i=0; i<80; i++ ) {\r\n\t\tif( hit ) break;\r\n\t\t\r\n\t\tt += 8. + t/300.;\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\t\r\n\t\tif( pos.y < terrainMap(pos) ) {\r\n\t\t\thit = true;\r\n\t\t}\t\t\r\n\t}\r\n\tif( hit ) {\r\n\t\t// binary search for hit\t\t\r\n\t\tfloat dt = 4.+t/400.;\r\n\t\tt -= dt;\r\n\t\t\r\n\t\tvec3 pos = ro + t*rd;\t\r\n\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\t\t\r\n\t\tfor( int j=0; j<2; j++ ) {\r\n\t\t\tpos = ro + t*rd;\r\n\t\t\tdt *= 0.5;\r\n\t\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\r\n\t\t}\r\n\t\tpos = ro + t*rd;\r\n\t\t\r\n\t\tvec3 dx = vec3( 100.*EPSILON, 0., 0. );\r\n\t\tvec3 dz = vec3( 0., 0., 100.*EPSILON );\r\n\t\t\r\n\t\tvec3 normal = vec3( 0., 0., 0. );\r\n\t\tnormal.x = (terrainMap(pos + dx) - terrainMap(pos-dx) ) / (200. * EPSILON);\r\n\t\tnormal.z = (terrainMap(pos + dz) - terrainMap(pos-dz) ) / (200. * EPSILON);\r\n\t\tnormal.y = 1.;\r\n\t\tnormal = normalize( normal );\t\t\r\n\r\n\t\tcol = vec3(0.2) + 0.7*texture( iChannel2, pos.xz * 0.01 ).xyz * \r\n\t\t\t\t   vec3(1.,.9,0.6);\r\n\t\t\r\n\t\tfloat veg = 0.3*fbm(pos*0.2)+normal.y;\r\n\t\t\t\t\t\r\n\t\tif( veg > 0.75 ) {\r\n\t\t\tcol = vec3( 0.45, 0.6, 0.3 )*(0.5+0.5*fbm(pos*0.5))*0.6;\r\n\t\t} else \r\n\t\tif( veg > 0.66 ) {\r\n\t\t\tcol = col*0.6+vec3( 0.4, 0.5, 0.3 )*(0.5+0.5*fbm(pos*0.25))*0.3;\r\n\t\t}\r\n\t\tcol *= vec3(0.5, 0.52, 0.65)*vec3(1.,.9,0.8);\r\n\t\t\r\n\t\tvec3 brdf = col;\r\n\t\t\r\n\t\tfloat diff = clamp( dot( normal, -lig ), 0., 1.);\r\n\t\t\r\n\t\tcol = brdf*diff*vec3(1.0,.6,0.1);\r\n\t\tcol += brdf*clamp( dot( normal, lig ), 0., 1.)*vec3(0.8,.6,0.5)*0.8;\r\n\t\tcol += brdf*clamp( dot( normal, vec3(0.,1.,0.) ), 0., 1.)*vec3(0.8,.8,1.)*0.2;\r\n\t\t\r\n\t\tdist = t;\r\n\t\tt -= pos.y*3.5;\r\n\t\tcol = mix( col, bgc, 1.0-exp(-0.0000005*t*t) );\r\n\t\t\r\n\t}\r\n\treturn col;\r\n}\r\n\r\nfloat waterMap( vec2 pos ) {\r\n\tvec2 posm = pos * m2;\r\n\t\r\n\treturn abs( fbm( vec3( 8.*posm, time ))-0.5 )* 0.1;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n\t\r\n\t// camera parameters\r\n\tvec3 ro = vec3(0.0, 0.5, 0.0);\r\n\tvec3 ta = vec3(0.0, 0.45,1.0);\r\n\tif (iMouse.z>=1.) {\r\n\t\tta.xz *= rot( (iMouse.x/iResolution.x-.5)*7. );\r\n\t}\r\n\t\t\r\n\tta.xz *= rot( mod(iTime * 0.05, 6.2831852) );\r\n    \r\n\t// build ray\r\n    vec3 ww = normalize( ta - ro);\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\r\n\r\n\tfloat fresnel, refldist = 5000., maxdist = 5000.;\r\n\tbool reflected = false;\r\n\tvec3 normal, col = bgColor( rd );\r\n\tvec3 roo = ro, rdo = rd, bgc = col;\r\n\t\r\n\tif( intersectPlane( ro, rd, 0., refldist ) && refldist < 200. ) {\r\n\t\tro += refldist*rd;\t\r\n\t\tvec2 coord = ro.xz;\r\n\t\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, refldist) );\r\n\t\t\t\t\r\n\t\tvec2 dx = vec2( EPSILON, 0. );\r\n\t\tvec2 dz = vec2( 0., EPSILON );\r\n\t\t\r\n\t\tnormal = vec3( 0., 1., 0. );\r\n\t\tnormal.x = -bumpfactor * (waterMap(coord + dx) - waterMap(coord-dx) ) / (2. * EPSILON);\r\n\t\tnormal.z = -bumpfactor * (waterMap(coord + dz) - waterMap(coord-dz) ) / (2. * EPSILON);\r\n\t\tnormal = normalize( normal );\t\t\r\n\t\t\r\n\t\tfloat ndotr = dot(normal,rd);\r\n\t\tfresnel = pow(1.0-abs(ndotr),5.);\r\n\r\n\t\trd = reflect( rd, normal);\r\n\r\n\t\treflected = true;\r\n\t\tbgc = col = bgColor( rd );\r\n\t}\r\n\r\n\tcol = raymarchTerrain( ro, rd, col, reflected?(800.-refldist):800., maxdist );\r\n    col = raymarchClouds( ro, rd, col, bgc, reflected?max(0.,min(150.,(150.-refldist))):150., maxdist, time*0.05 );\r\n\t\r\n\tif( reflected ) {\r\n\t\tcol = mix( col.xyz, bgc, 1.0-exp(-0.0000005*refldist*refldist) );\r\n\t\tcol *= fresnel*0.9;\t\t\r\n\t\tvec3 refr = refract( rdo, normal, 1./1.3330 );\r\n\t\tintersectPlane( ro, refr, -2., refldist );\r\n\t\tcol += mix( texture( iChannel2, (roo+refldist*refr).xz*1.3 ).xyz * \r\n\t\t\t\t   vec3(1.,.9,0.6), vec3(1.,.9,0.8)*0.5, clamp( refldist / 3., 0., 1.) ) \r\n\t\t\t   * (1.-fresnel)*0.125;\r\n\t}\r\n\t\r\n\tcol = pow( col, vec3(0.7) );\r\n\t\r\n\t// contrast, saturation and vignetting\t\r\n\tcol = col*col*(3.0-2.0*col);\r\n    col = mix( col, vec3(dot(col,vec3(0.33))), -0.5 );\r\n \tcol *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\t\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"vec3 saturate(vec3 x)\r\n{\r\n    return clamp(x, vec3(0.0), vec3(1.0));\r\n}\r\n\r\nvec4 cubic(float x)\r\n{\r\n    float x2 = x * x;\r\n    float x3 = x2 * x;\r\n    vec4 w;\r\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\r\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\r\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\r\n    w.w =  x3;\r\n    return w / 6.0;\r\n}\r\n\r\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\r\n{\r\n\tvec2 resolution = iResolution.xy;\r\n\r\n\tcoord *= resolution;\r\n\r\n\tfloat fx = fract(coord.x);\r\n    float fy = fract(coord.y);\r\n    coord.x -= fx;\r\n    coord.y -= fy;\r\n\r\n    fx -= 0.5;\r\n    fy -= 0.5;\r\n\r\n    vec4 xcubic = cubic(fx);\r\n    vec4 ycubic = cubic(fy);\r\n\r\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\r\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\r\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\r\n\r\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\r\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\r\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\r\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\r\n\r\n    float sx = s.x / (s.x + s.y);\r\n    float sy = s.z / (s.z + s.w);\r\n\r\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\r\n}\r\n\r\nvec3 ColorFetch(vec2 coord)\r\n{\r\n \treturn texture(iChannel0, coord).rgb;   \r\n}\r\n\r\nvec3 BloomFetch(vec2 coord)\r\n{\r\n \treturn BicubicTexture(iChannel3, coord).rgb;   \r\n}\r\n\r\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\r\n{\r\n \tfloat scale = exp2(octave);\r\n    \r\n    coord /= scale;\r\n    coord -= offset;\r\n\r\n    return BloomFetch(coord);\r\n}\r\n\r\nvec2 CalcOffset(float octave)\r\n{\r\n    vec2 offset = vec2(0.0);\r\n    \r\n    vec2 padding = vec2(10.0) / iResolution.xy;\r\n    \r\n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\r\n    \r\n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\r\n\r\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\r\n    \r\n \treturn offset;   \r\n}\r\n\r\nvec3 GetBloom(vec2 coord)\r\n{\r\n \tvec3 bloom = vec3(0.0);\r\n    \r\n    //Reconstruct bloom from multiple blurred images\r\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\r\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\r\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\r\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\r\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\r\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\r\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\r\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\r\n\r\n\treturn bloom;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec3 color = ColorFetch(uv);\r\n    \r\n    \r\n    color += GetBloom(uv) * 0.08;\r\n    \r\n    color *= 200.0;\r\n    \r\n\r\n    //Tonemapping and color grading\r\n    color = pow(color, vec3(1.5));\r\n    color = color / (1.0 + color);\r\n    color = pow(color, vec3(1.0 / 1.5));\r\n\r\n    \r\n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\r\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \r\n\r\n\tcolor = saturate(color * 1.01);\r\n    \r\n    color = pow(color, vec3(0.7 / 2.2));\r\n\r\n    fragColor = vec4(color, 1.0);\r\n\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\buffer01.png","type":"buffer","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\buffer02.png","type":"buffer","channel":2,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\buffer03.png","type":"buffer","channel":3,"sampler":null,"published":0}],"outputs":[],"code":"vec3 saturate(vec3 x)\r\n{\r\n    return clamp(x, vec3(0.0), vec3(1.0));\r\n}\r\n\r\nvec4 cubic(float x)\r\n{\r\n    float x2 = x * x;\r\n    float x3 = x2 * x;\r\n    vec4 w;\r\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\r\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\r\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\r\n    w.w =  x3;\r\n    return w / 6.0;\r\n}\r\n\r\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\r\n{\r\n\tvec2 resolution = iResolution.xy;\r\n\r\n\tcoord *= resolution;\r\n\r\n\tfloat fx = fract(coord.x);\r\n    float fy = fract(coord.y);\r\n    coord.x -= fx;\r\n    coord.y -= fy;\r\n\r\n    fx -= 0.5;\r\n    fy -= 0.5;\r\n\r\n    vec4 xcubic = cubic(fx);\r\n    vec4 ycubic = cubic(fy);\r\n\r\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\r\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\r\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\r\n\r\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\r\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\r\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\r\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\r\n\r\n    float sx = s.x / (s.x + s.y);\r\n    float sy = s.z / (s.z + s.w);\r\n\r\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\r\n}\r\n\r\nvec3 ColorFetch(vec2 coord)\r\n{\r\n \treturn texture(iChannel0, coord).rgb;   \r\n}\r\n\r\nvec3 BloomFetch(vec2 coord)\r\n{\r\n \treturn BicubicTexture(iChannel3, coord).rgb;   \r\n}\r\n\r\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\r\n{\r\n \tfloat scale = exp2(octave);\r\n    \r\n    coord /= scale;\r\n    coord -= offset;\r\n\r\n    return BloomFetch(coord);\r\n}\r\n\r\nvec2 CalcOffset(float octave)\r\n{\r\n    vec2 offset = vec2(0.0);\r\n    \r\n    vec2 padding = vec2(10.0) / iResolution.xy;\r\n    \r\n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\r\n    \r\n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\r\n\r\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\r\n    \r\n \treturn offset;   \r\n}\r\n\r\nvec3 GetBloom(vec2 coord)\r\n{\r\n \tvec3 bloom = vec3(0.0);\r\n    \r\n    //Reconstruct bloom from multiple blurred images\r\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\r\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\r\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\r\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\r\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\r\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\r\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\r\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\r\n\r\n\treturn bloom;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec3 color = ColorFetch(uv);\r\n    \r\n    \r\n    color += GetBloom(uv) * 0.08;\r\n    \r\n    color *= 200.0;\r\n    \r\n\r\n    //Tonemapping and color grading\r\n    color = pow(color, vec3(1.5));\r\n    color = color / (1.0 + color);\r\n    color = pow(color, vec3(1.0 / 1.5));\r\n\r\n    \r\n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\r\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \r\n\r\n\tcolor = saturate(color * 1.01);\r\n    \r\n    color = pow(color, vec3(0.7 / 2.2));\r\n\r\n    fragColor = vec4(color, 1.0);\r\n\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\buffer01.png","type":"buffer","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\buffer02.png","type":"buffer","channel":2,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\buffer03.png","type":"buffer","channel":3,"sampler":null,"published":0}],"Info":{"Name":"Gargantua With HDR Bloom","id":null,"date":null,"viewed":0,"name":"Gargantua With HDR Bloom","description":"","likes":0,"published":null,"tags":[""]},"ver":null,"info":{"Name":"Gargantua With HDR Bloom","id":null,"date":null,"viewed":0,"name":"Gargantua With HDR Bloom","description":"","likes":0,"published":null,"tags":[""]},"renderpass":[{"Code":"vec3 saturate(vec3 x)\r\n{\r\n    return clamp(x, vec3(0.0), vec3(1.0));\r\n}\r\n\r\nvec4 cubic(float x)\r\n{\r\n    float x2 = x * x;\r\n    float x3 = x2 * x;\r\n    vec4 w;\r\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\r\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\r\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\r\n    w.w =  x3;\r\n    return w / 6.0;\r\n}\r\n\r\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\r\n{\r\n\tvec2 resolution = iResolution.xy;\r\n\r\n\tcoord *= resolution;\r\n\r\n\tfloat fx = fract(coord.x);\r\n    float fy = fract(coord.y);\r\n    coord.x -= fx;\r\n    coord.y -= fy;\r\n\r\n    fx -= 0.5;\r\n    fy -= 0.5;\r\n\r\n    vec4 xcubic = cubic(fx);\r\n    vec4 ycubic = cubic(fy);\r\n\r\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\r\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\r\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\r\n\r\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\r\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\r\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\r\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\r\n\r\n    float sx = s.x / (s.x + s.y);\r\n    float sy = s.z / (s.z + s.w);\r\n\r\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\r\n}\r\n\r\nvec3 ColorFetch(vec2 coord)\r\n{\r\n \treturn texture(iChannel0, coord).rgb;   \r\n}\r\n\r\nvec3 BloomFetch(vec2 coord)\r\n{\r\n \treturn BicubicTexture(iChannel3, coord).rgb;   \r\n}\r\n\r\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\r\n{\r\n \tfloat scale = exp2(octave);\r\n    \r\n    coord /= scale;\r\n    coord -= offset;\r\n\r\n    return BloomFetch(coord);\r\n}\r\n\r\nvec2 CalcOffset(float octave)\r\n{\r\n    vec2 offset = vec2(0.0);\r\n    \r\n    vec2 padding = vec2(10.0) / iResolution.xy;\r\n    \r\n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\r\n    \r\n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\r\n\r\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\r\n    \r\n \treturn offset;   \r\n}\r\n\r\nvec3 GetBloom(vec2 coord)\r\n{\r\n \tvec3 bloom = vec3(0.0);\r\n    \r\n    //Reconstruct bloom from multiple blurred images\r\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\r\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\r\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\r\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\r\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\r\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\r\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\r\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\r\n\r\n\treturn bloom;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec3 color = ColorFetch(uv);\r\n    \r\n    \r\n    color += GetBloom(uv) * 0.08;\r\n    \r\n    color *= 200.0;\r\n    \r\n\r\n    //Tonemapping and color grading\r\n    color = pow(color, vec3(1.5));\r\n    color = color / (1.0 + color);\r\n    color = pow(color, vec3(1.0 / 1.5));\r\n\r\n    \r\n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\r\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \r\n\r\n\tcolor = saturate(color * 1.01);\r\n    \r\n    color = pow(color, vec3(0.7 / 2.2));\r\n\r\n    fragColor = vec4(color, 1.0);\r\n\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\buffer01.png","type":"buffer","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\buffer02.png","type":"buffer","channel":2,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\buffer03.png","type":"buffer","channel":3,"sampler":null,"published":0}],"outputs":[],"code":"vec3 saturate(vec3 x)\r\n{\r\n    return clamp(x, vec3(0.0), vec3(1.0));\r\n}\r\n\r\nvec4 cubic(float x)\r\n{\r\n    float x2 = x * x;\r\n    float x3 = x2 * x;\r\n    vec4 w;\r\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\r\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\r\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\r\n    w.w =  x3;\r\n    return w / 6.0;\r\n}\r\n\r\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\r\n{\r\n\tvec2 resolution = iResolution.xy;\r\n\r\n\tcoord *= resolution;\r\n\r\n\tfloat fx = fract(coord.x);\r\n    float fy = fract(coord.y);\r\n    coord.x -= fx;\r\n    coord.y -= fy;\r\n\r\n    fx -= 0.5;\r\n    fy -= 0.5;\r\n\r\n    vec4 xcubic = cubic(fx);\r\n    vec4 ycubic = cubic(fy);\r\n\r\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\r\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\r\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\r\n\r\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\r\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\r\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\r\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\r\n\r\n    float sx = s.x / (s.x + s.y);\r\n    float sy = s.z / (s.z + s.w);\r\n\r\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\r\n}\r\n\r\nvec3 ColorFetch(vec2 coord)\r\n{\r\n \treturn texture(iChannel0, coord).rgb;   \r\n}\r\n\r\nvec3 BloomFetch(vec2 coord)\r\n{\r\n \treturn BicubicTexture(iChannel3, coord).rgb;   \r\n}\r\n\r\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\r\n{\r\n \tfloat scale = exp2(octave);\r\n    \r\n    coord /= scale;\r\n    coord -= offset;\r\n\r\n    return BloomFetch(coord);\r\n}\r\n\r\nvec2 CalcOffset(float octave)\r\n{\r\n    vec2 offset = vec2(0.0);\r\n    \r\n    vec2 padding = vec2(10.0) / iResolution.xy;\r\n    \r\n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\r\n    \r\n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\r\n\r\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\r\n    \r\n \treturn offset;   \r\n}\r\n\r\nvec3 GetBloom(vec2 coord)\r\n{\r\n \tvec3 bloom = vec3(0.0);\r\n    \r\n    //Reconstruct bloom from multiple blurred images\r\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\r\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\r\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\r\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\r\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\r\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\r\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\r\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\r\n\r\n\treturn bloom;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec3 color = ColorFetch(uv);\r\n    \r\n    \r\n    color += GetBloom(uv) * 0.08;\r\n    \r\n    color *= 200.0;\r\n    \r\n\r\n    //Tonemapping and color grading\r\n    color = pow(color, vec3(1.5));\r\n    color = color / (1.0 + color);\r\n    color = pow(color, vec3(1.0 / 1.5));\r\n\r\n    \r\n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\r\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \r\n\r\n\tcolor = saturate(color * 1.01);\r\n    \r\n    color = pow(color, vec3(0.7 / 2.2));\r\n\r\n    fragColor = vec4(color, 1.0);\r\n\r\n}\r\n","name":"Image","description":null,"type":"image"},{"Code":"/*  \r\nMain render. \r\n\r\nTemporal AA for a smooth image. Temporal accumulation is disabled while moving the view to prevent ghosting.\r\n*/\r\n\r\n#define ITERATIONS 200          //Increase for less grainy result\r\n#define TEMPORAL_AA\r\n\r\n\r\nconst vec3 MainColor = vec3(1.0);\r\n\r\n//noise code by iq\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n    return -1.0+2.0*mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat saturate(float x)\r\n{\r\n    return clamp(x, 0.0, 1.0);\r\n}\r\n\r\nvec3 saturate(vec3 x)\r\n{\r\n    return clamp(x, vec3(0.0), vec3(1.0));\r\n}\r\n\r\nfloat rand(vec2 coord)\r\n{\r\n    return saturate(fract(sin(dot(coord, vec2(12.9898, 78.223))) * 43758.5453));\r\n}\r\n\r\nfloat pcurve( float x, float a, float b )\r\n{\r\n    float k = pow(a+b,a+b) / (pow(a,a)*pow(b,b));\r\n    return k * pow( x, a ) * pow( 1.0-x, b );\r\n}\r\n\r\nconst float pi = 3.14159265;\r\n\r\nfloat atan2(float y, float x)\r\n{\r\n    if (x > 0.0)\r\n    {\r\n        return atan(y / x);\r\n    }\r\n    else if (x == 0.0)\r\n    {\r\n        if (y > 0.0)\r\n        {\r\n            return pi / 2.0;\r\n        }\r\n        else if (y < 0.0)\r\n        {\r\n            return -(pi / 2.0);\r\n        }\r\n        else\r\n        {\r\n            return 0.0;\r\n        }\r\n    }\r\n    else //(x < 0.0)\r\n    {\r\n        if (y >= 0.0)\r\n        {\r\n            return atan(y / x) + pi;\r\n        }\r\n        else\r\n        {\r\n            return atan(y / x) - pi;\r\n        }\r\n    }\r\n}\r\n\r\nfloat sdTorus(vec3 p, vec2 t)\r\n{\r\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\r\n    return length(q)-t.y;\r\n}\r\n\r\nfloat sdSphere(vec3 p, float r)\r\n{\r\n  return length(p)-r;\r\n}\r\n\r\nvoid Haze(inout vec3 color, vec3 pos, float alpha)\r\n{\r\n    vec2 t = vec2(1.0, 0.01);\r\n\r\n    float torusDist = length(sdTorus(pos + vec3(0.0, -0.05, 0.0), t));\r\n\r\n    float bloomDisc = 1.0 / (pow(torusDist, 2.0) + 0.001);\r\n    vec3 col = MainColor;\r\n    bloomDisc *= length(pos) < 0.5 ? 0.0 : 1.0;\r\n\r\n    color += col * bloomDisc * (2.9 / float(ITERATIONS)) * (1.0 - alpha * 1.0);\r\n}\r\n\r\nvoid GasDisc(inout vec3 color, inout float alpha, vec3 pos)\r\n{\r\n    float discRadius = 3.2;\r\n    float discWidth = 5.3;\r\n    float discInner = discRadius - discWidth * 0.5;\r\n    float discOuter = discRadius + discWidth * 0.5;\r\n    \r\n    vec3 origin = vec3(0.0, 0.0, 0.0);\r\n    float mouseZ = iMouse.y / iResolution.y;\r\n    vec3 discNormal = normalize(vec3(0.0, 1.0, 0.0));\r\n    float discThickness = 0.1;\r\n\r\n    float distFromCenter = distance(pos, origin);\r\n    float distFromDisc = dot(discNormal, pos - origin);\r\n    \r\n    float radialGradient = 1.0 - saturate((distFromCenter - discInner) / discWidth * 0.5);\r\n\r\n    float coverage = pcurve(radialGradient, 4.0, 0.9);\r\n\r\n    discThickness *= radialGradient;\r\n    coverage *= saturate(1.0 - abs(distFromDisc) / discThickness);\r\n\r\n    vec3 dustColorLit = MainColor;\r\n    vec3 dustColorDark = vec3(0.0, 0.0, 0.0);\r\n\r\n    float dustGlow = 1.0 / (pow(1.0 - radialGradient, 2.0) * 290.0 + 0.002);\r\n    vec3 dustColor = dustColorLit * dustGlow * 8.2;\r\n\r\n    coverage = saturate(coverage * 0.7);\r\n\r\n\r\n    float fade = pow((abs(distFromCenter - discInner) + 0.4), 4.0) * 0.04;\r\n    float bloomFactor = 1.0 / (pow(distFromDisc, 2.0) * 40.0 + fade + 0.00002);\r\n    vec3 b = dustColorLit * pow(bloomFactor, 1.5);\r\n    \r\n    b *= mix(vec3(1.7, 1.1, 1.0), vec3(0.5, 0.6, 1.0), vec3(pow(radialGradient, 2.0)));\r\n    b *= mix(vec3(1.7, 0.5, 0.1), vec3(1.0), vec3(pow(radialGradient, 0.5)));\r\n\r\n    dustColor = mix(dustColor, b * 150.0, saturate(1.0 - coverage * 1.0));\r\n    coverage = saturate(coverage + bloomFactor * bloomFactor * 0.1);\r\n    \r\n    if (coverage < 0.01)\r\n    {\r\n        return;   \r\n    }\r\n    \r\n    \r\n    vec3 radialCoords;\r\n    radialCoords.x = distFromCenter * 1.5 + 0.55;\r\n    radialCoords.y = atan2(-pos.x, -pos.z) * 1.5;\r\n    radialCoords.z = distFromDisc * 1.5;\r\n\r\n    radialCoords *= 0.95;\r\n    \r\n    float speed = 0.06;\r\n    \r\n    float noise1 = 1.0;\r\n    vec3 rc = radialCoords + 0.0;               rc.y += iTime * speed;\r\n    noise1 *= noise(rc * 3.0) * 0.5 + 0.5;      rc.y -= iTime * speed;\r\n    noise1 *= noise(rc * 6.0) * 0.5 + 0.5;      rc.y += iTime * speed;\r\n    noise1 *= noise(rc * 12.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\r\n    noise1 *= noise(rc * 24.0) * 0.5 + 0.5;     rc.y += iTime * speed;\r\n\r\n    float noise2 = 2.0;\r\n    rc = radialCoords + 30.0;\r\n    noise2 *= noise(rc * 3.0) * 0.5 + 0.5;      rc.y += iTime * speed;\r\n    noise2 *= noise(rc * 6.0) * 0.5 + 0.5;      rc.y -= iTime * speed;\r\n    noise2 *= noise(rc * 12.0) * 0.5 + 0.5;     rc.y += iTime * speed;\r\n    noise2 *= noise(rc * 24.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\r\n    noise2 *= noise(rc * 48.0) * 0.5 + 0.5;     rc.y += iTime * speed;\r\n    noise2 *= noise(rc * 92.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\r\n\r\n    dustColor *= noise1 * 0.998 + 0.002;\r\n    coverage *= noise2;\r\n    \r\n    radialCoords.y += iTime * speed * 0.5;\r\n    \r\n    dustColor *= pow(texture(iChannel1, radialCoords.yx * vec2(0.15, 0.27)).rgb, vec3(2.0)) * 4.0;\r\n\r\n    coverage = saturate(coverage * 1200.0 / float(ITERATIONS));\r\n    dustColor = max(vec3(0.0), dustColor);\r\n\r\n    coverage *= pcurve(radialGradient, 4.0, 0.9);\r\n\r\n    color = (1.0 - alpha) * dustColor * coverage + color;\r\n\r\n    alpha = (1.0 - alpha) * coverage + alpha;\r\n}\r\n\r\n\r\n\r\nvec3 rotate(vec3 p, float x, float y, float z)\r\n{\r\n    mat3 matx = mat3(1.0, 0.0, 0.0,\r\n                     0.0, cos(x), sin(x),\r\n                     0.0, -sin(x), cos(x));\r\n\r\n    mat3 maty = mat3(cos(y), 0.0, -sin(y),\r\n                     0.0, 1.0, 0.0,\r\n                     sin(y), 0.0, cos(y));\r\n\r\n    mat3 matz = mat3(cos(z), sin(z), 0.0,\r\n                     -sin(z), cos(z), 0.0,\r\n                     0.0, 0.0, 1.0);\r\n\r\n    p = matx * p;\r\n    p = matz * p;\r\n    p = maty * p;\r\n\r\n    return p;\r\n}\r\n\r\nvoid RotateCamera(inout vec3 eyevec, inout vec3 eyepos)\r\n{\r\n    float mousePosY = iMouse.y / iResolution.y;\r\n    float mousePosX = iMouse.x / iResolution.x;\r\n\r\n    vec3 angle = vec3(mousePosY * 0.05 + 0.05, 1.0 + mousePosX * 1.0, -0.45);\r\n\r\n    eyevec = rotate(eyevec, angle.x, angle.y, angle.z);\r\n    eyepos = rotate(eyepos, angle.x, angle.y, angle.z);\r\n}\r\n\r\nvoid WarpSpace(inout vec3 eyevec, inout vec3 raypos)\r\n{\r\n    vec3 origin = vec3(0.0, 0.0, 0.0);\r\n\r\n    float singularityDist = distance(raypos, origin);\r\n    float warpFactor = 1.0 / (pow(singularityDist, 2.0) + 0.000001);\r\n\r\n    vec3 singularityVector = normalize(origin - raypos);\r\n    \r\n    float warpAmount = 5.0;\r\n\r\n    eyevec = normalize(eyevec + singularityVector * warpFactor * warpAmount / float(ITERATIONS));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    float aspect = iResolution.x / iResolution.y;\r\n\r\n    vec2 uveye = uv;\r\n    \r\n    #ifdef TEMPORAL_AA\r\n    uveye.x += (rand(uv + sin(iTime * 1.0)) / iResolution.x) * (iMouse.z > 1.0 ? 0.0 : 1.0);\r\n    uveye.y += (rand(uv + 1.0 + sin(iTime * 1.0)) / iResolution.y) * (iMouse.z > 1.0 ? 0.0 : 1.0);\r\n    #endif\r\n    \r\n    vec3 eyevec = normalize(vec3((uveye * 2.0 - 1.0) * vec2(aspect, 1.0), 6.0));\r\n    vec3 eyepos = vec3(0.0, -0.0, -10.0);\r\n    \r\n    vec2 mousepos = iMouse.xy / iResolution.xy;\r\n    if (mousepos.x == 0.0)\r\n    {\r\n        mousepos.x = 0.35;\r\n    }\r\n    eyepos.x += mousepos.x * 3.0 - 1.5;\r\n    \r\n    const float far = 15.0;\r\n\r\n    RotateCamera(eyevec, eyepos);\r\n\r\n    vec3 color = vec3(0.0, 0.0, 0.0);\r\n    \r\n    float dither = rand(uv \r\n                        #ifdef TEMPORAL_AA\r\n                        + sin(iTime * 1.0) * (iMouse.z > 1.0 ? 0.0 : 1.0)\r\n                        #endif\r\n                       ) * 2.0;\r\n\r\n\r\n    float alpha = 0.0;\r\n    vec3 raypos = eyepos + eyevec * dither * far / float(ITERATIONS);\r\n    for (int i = 0; i < ITERATIONS; i++)\r\n    {        \r\n        WarpSpace(eyevec, raypos);\r\n        raypos += eyevec * far / float(ITERATIONS);\r\n        GasDisc(color, alpha, raypos);\r\n        Haze(color, raypos, alpha);\r\n    }\r\n    \r\n    color *= 0.0001;\r\n\r\n    \r\n    #ifdef TEMPORAL_AA\r\n    const float p = 1.0;\r\n    vec3 previous = pow(texture(iChannel2, uv).rgb, vec3(1.0 / p));\r\n    \r\n    color = pow(color, vec3(1.0 / p));\r\n    \r\n    float blendWeight = 0.9 * (iMouse.z > 1.0 ? 0.0 : 1.0);\r\n    \r\n    color = mix(color, previous, blendWeight);\r\n    \r\n    color = pow(color, vec3(p));\r\n    #endif\r\n    \r\n    fragColor = vec4(saturate(color), 1.0);\r\n\r\n}","inputs":[],"outputs":[],"code":"/*  \r\nMain render. \r\n\r\nTemporal AA for a smooth image. Temporal accumulation is disabled while moving the view to prevent ghosting.\r\n*/\r\n\r\n#define ITERATIONS 200          //Increase for less grainy result\r\n#define TEMPORAL_AA\r\n\r\n\r\nconst vec3 MainColor = vec3(1.0);\r\n\r\n//noise code by iq\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n    return -1.0+2.0*mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat saturate(float x)\r\n{\r\n    return clamp(x, 0.0, 1.0);\r\n}\r\n\r\nvec3 saturate(vec3 x)\r\n{\r\n    return clamp(x, vec3(0.0), vec3(1.0));\r\n}\r\n\r\nfloat rand(vec2 coord)\r\n{\r\n    return saturate(fract(sin(dot(coord, vec2(12.9898, 78.223))) * 43758.5453));\r\n}\r\n\r\nfloat pcurve( float x, float a, float b )\r\n{\r\n    float k = pow(a+b,a+b) / (pow(a,a)*pow(b,b));\r\n    return k * pow( x, a ) * pow( 1.0-x, b );\r\n}\r\n\r\nconst float pi = 3.14159265;\r\n\r\nfloat atan2(float y, float x)\r\n{\r\n    if (x > 0.0)\r\n    {\r\n        return atan(y / x);\r\n    }\r\n    else if (x == 0.0)\r\n    {\r\n        if (y > 0.0)\r\n        {\r\n            return pi / 2.0;\r\n        }\r\n        else if (y < 0.0)\r\n        {\r\n            return -(pi / 2.0);\r\n        }\r\n        else\r\n        {\r\n            return 0.0;\r\n        }\r\n    }\r\n    else //(x < 0.0)\r\n    {\r\n        if (y >= 0.0)\r\n        {\r\n            return atan(y / x) + pi;\r\n        }\r\n        else\r\n        {\r\n            return atan(y / x) - pi;\r\n        }\r\n    }\r\n}\r\n\r\nfloat sdTorus(vec3 p, vec2 t)\r\n{\r\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\r\n    return length(q)-t.y;\r\n}\r\n\r\nfloat sdSphere(vec3 p, float r)\r\n{\r\n  return length(p)-r;\r\n}\r\n\r\nvoid Haze(inout vec3 color, vec3 pos, float alpha)\r\n{\r\n    vec2 t = vec2(1.0, 0.01);\r\n\r\n    float torusDist = length(sdTorus(pos + vec3(0.0, -0.05, 0.0), t));\r\n\r\n    float bloomDisc = 1.0 / (pow(torusDist, 2.0) + 0.001);\r\n    vec3 col = MainColor;\r\n    bloomDisc *= length(pos) < 0.5 ? 0.0 : 1.0;\r\n\r\n    color += col * bloomDisc * (2.9 / float(ITERATIONS)) * (1.0 - alpha * 1.0);\r\n}\r\n\r\nvoid GasDisc(inout vec3 color, inout float alpha, vec3 pos)\r\n{\r\n    float discRadius = 3.2;\r\n    float discWidth = 5.3;\r\n    float discInner = discRadius - discWidth * 0.5;\r\n    float discOuter = discRadius + discWidth * 0.5;\r\n    \r\n    vec3 origin = vec3(0.0, 0.0, 0.0);\r\n    float mouseZ = iMouse.y / iResolution.y;\r\n    vec3 discNormal = normalize(vec3(0.0, 1.0, 0.0));\r\n    float discThickness = 0.1;\r\n\r\n    float distFromCenter = distance(pos, origin);\r\n    float distFromDisc = dot(discNormal, pos - origin);\r\n    \r\n    float radialGradient = 1.0 - saturate((distFromCenter - discInner) / discWidth * 0.5);\r\n\r\n    float coverage = pcurve(radialGradient, 4.0, 0.9);\r\n\r\n    discThickness *= radialGradient;\r\n    coverage *= saturate(1.0 - abs(distFromDisc) / discThickness);\r\n\r\n    vec3 dustColorLit = MainColor;\r\n    vec3 dustColorDark = vec3(0.0, 0.0, 0.0);\r\n\r\n    float dustGlow = 1.0 / (pow(1.0 - radialGradient, 2.0) * 290.0 + 0.002);\r\n    vec3 dustColor = dustColorLit * dustGlow * 8.2;\r\n\r\n    coverage = saturate(coverage * 0.7);\r\n\r\n\r\n    float fade = pow((abs(distFromCenter - discInner) + 0.4), 4.0) * 0.04;\r\n    float bloomFactor = 1.0 / (pow(distFromDisc, 2.0) * 40.0 + fade + 0.00002);\r\n    vec3 b = dustColorLit * pow(bloomFactor, 1.5);\r\n    \r\n    b *= mix(vec3(1.7, 1.1, 1.0), vec3(0.5, 0.6, 1.0), vec3(pow(radialGradient, 2.0)));\r\n    b *= mix(vec3(1.7, 0.5, 0.1), vec3(1.0), vec3(pow(radialGradient, 0.5)));\r\n\r\n    dustColor = mix(dustColor, b * 150.0, saturate(1.0 - coverage * 1.0));\r\n    coverage = saturate(coverage + bloomFactor * bloomFactor * 0.1);\r\n    \r\n    if (coverage < 0.01)\r\n    {\r\n        return;   \r\n    }\r\n    \r\n    \r\n    vec3 radialCoords;\r\n    radialCoords.x = distFromCenter * 1.5 + 0.55;\r\n    radialCoords.y = atan2(-pos.x, -pos.z) * 1.5;\r\n    radialCoords.z = distFromDisc * 1.5;\r\n\r\n    radialCoords *= 0.95;\r\n    \r\n    float speed = 0.06;\r\n    \r\n    float noise1 = 1.0;\r\n    vec3 rc = radialCoords + 0.0;               rc.y += iTime * speed;\r\n    noise1 *= noise(rc * 3.0) * 0.5 + 0.5;      rc.y -= iTime * speed;\r\n    noise1 *= noise(rc * 6.0) * 0.5 + 0.5;      rc.y += iTime * speed;\r\n    noise1 *= noise(rc * 12.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\r\n    noise1 *= noise(rc * 24.0) * 0.5 + 0.5;     rc.y += iTime * speed;\r\n\r\n    float noise2 = 2.0;\r\n    rc = radialCoords + 30.0;\r\n    noise2 *= noise(rc * 3.0) * 0.5 + 0.5;      rc.y += iTime * speed;\r\n    noise2 *= noise(rc * 6.0) * 0.5 + 0.5;      rc.y -= iTime * speed;\r\n    noise2 *= noise(rc * 12.0) * 0.5 + 0.5;     rc.y += iTime * speed;\r\n    noise2 *= noise(rc * 24.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\r\n    noise2 *= noise(rc * 48.0) * 0.5 + 0.5;     rc.y += iTime * speed;\r\n    noise2 *= noise(rc * 92.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\r\n\r\n    dustColor *= noise1 * 0.998 + 0.002;\r\n    coverage *= noise2;\r\n    \r\n    radialCoords.y += iTime * speed * 0.5;\r\n    \r\n    dustColor *= pow(texture(iChannel1, radialCoords.yx * vec2(0.15, 0.27)).rgb, vec3(2.0)) * 4.0;\r\n\r\n    coverage = saturate(coverage * 1200.0 / float(ITERATIONS));\r\n    dustColor = max(vec3(0.0), dustColor);\r\n\r\n    coverage *= pcurve(radialGradient, 4.0, 0.9);\r\n\r\n    color = (1.0 - alpha) * dustColor * coverage + color;\r\n\r\n    alpha = (1.0 - alpha) * coverage + alpha;\r\n}\r\n\r\n\r\n\r\nvec3 rotate(vec3 p, float x, float y, float z)\r\n{\r\n    mat3 matx = mat3(1.0, 0.0, 0.0,\r\n                     0.0, cos(x), sin(x),\r\n                     0.0, -sin(x), cos(x));\r\n\r\n    mat3 maty = mat3(cos(y), 0.0, -sin(y),\r\n                     0.0, 1.0, 0.0,\r\n                     sin(y), 0.0, cos(y));\r\n\r\n    mat3 matz = mat3(cos(z), sin(z), 0.0,\r\n                     -sin(z), cos(z), 0.0,\r\n                     0.0, 0.0, 1.0);\r\n\r\n    p = matx * p;\r\n    p = matz * p;\r\n    p = maty * p;\r\n\r\n    return p;\r\n}\r\n\r\nvoid RotateCamera(inout vec3 eyevec, inout vec3 eyepos)\r\n{\r\n    float mousePosY = iMouse.y / iResolution.y;\r\n    float mousePosX = iMouse.x / iResolution.x;\r\n\r\n    vec3 angle = vec3(mousePosY * 0.05 + 0.05, 1.0 + mousePosX * 1.0, -0.45);\r\n\r\n    eyevec = rotate(eyevec, angle.x, angle.y, angle.z);\r\n    eyepos = rotate(eyepos, angle.x, angle.y, angle.z);\r\n}\r\n\r\nvoid WarpSpace(inout vec3 eyevec, inout vec3 raypos)\r\n{\r\n    vec3 origin = vec3(0.0, 0.0, 0.0);\r\n\r\n    float singularityDist = distance(raypos, origin);\r\n    float warpFactor = 1.0 / (pow(singularityDist, 2.0) + 0.000001);\r\n\r\n    vec3 singularityVector = normalize(origin - raypos);\r\n    \r\n    float warpAmount = 5.0;\r\n\r\n    eyevec = normalize(eyevec + singularityVector * warpFactor * warpAmount / float(ITERATIONS));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    float aspect = iResolution.x / iResolution.y;\r\n\r\n    vec2 uveye = uv;\r\n    \r\n    #ifdef TEMPORAL_AA\r\n    uveye.x += (rand(uv + sin(iTime * 1.0)) / iResolution.x) * (iMouse.z > 1.0 ? 0.0 : 1.0);\r\n    uveye.y += (rand(uv + 1.0 + sin(iTime * 1.0)) / iResolution.y) * (iMouse.z > 1.0 ? 0.0 : 1.0);\r\n    #endif\r\n    \r\n    vec3 eyevec = normalize(vec3((uveye * 2.0 - 1.0) * vec2(aspect, 1.0), 6.0));\r\n    vec3 eyepos = vec3(0.0, -0.0, -10.0);\r\n    \r\n    vec2 mousepos = iMouse.xy / iResolution.xy;\r\n    if (mousepos.x == 0.0)\r\n    {\r\n        mousepos.x = 0.35;\r\n    }\r\n    eyepos.x += mousepos.x * 3.0 - 1.5;\r\n    \r\n    const float far = 15.0;\r\n\r\n    RotateCamera(eyevec, eyepos);\r\n\r\n    vec3 color = vec3(0.0, 0.0, 0.0);\r\n    \r\n    float dither = rand(uv \r\n                        #ifdef TEMPORAL_AA\r\n                        + sin(iTime * 1.0) * (iMouse.z > 1.0 ? 0.0 : 1.0)\r\n                        #endif\r\n                       ) * 2.0;\r\n\r\n\r\n    float alpha = 0.0;\r\n    vec3 raypos = eyepos + eyevec * dither * far / float(ITERATIONS);\r\n    for (int i = 0; i < ITERATIONS; i++)\r\n    {        \r\n        WarpSpace(eyevec, raypos);\r\n        raypos += eyevec * far / float(ITERATIONS);\r\n        GasDisc(color, alpha, raypos);\r\n        Haze(color, raypos, alpha);\r\n    }\r\n    \r\n    color *= 0.0001;\r\n\r\n    \r\n    #ifdef TEMPORAL_AA\r\n    const float p = 1.0;\r\n    vec3 previous = pow(texture(iChannel2, uv).rgb, vec3(1.0 / p));\r\n    \r\n    color = pow(color, vec3(1.0 / p));\r\n    \r\n    float blendWeight = 0.9 * (iMouse.z > 1.0 ? 0.0 : 1.0);\r\n    \r\n    color = mix(color, previous, blendWeight);\r\n    \r\n    color = pow(color, vec3(p));\r\n    #endif\r\n    \r\n    fragColor = vec4(saturate(color), 1.0);\r\n\r\n}","name":"Buf A","description":null,"type":null},{"Code":"//First bloom pass, mipmap tree thing\r\n\r\nvec3 ColorFetch(vec2 coord)\r\n{\r\n \treturn texture(iChannel0, coord).rgb;   \r\n}\r\n\r\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\r\n{\r\n \tfloat scale = exp2(octave);\r\n    \r\n    coord += offset;\r\n    coord *= scale;\r\n\r\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\r\n    {\r\n     \treturn vec3(0.0);   \r\n    }\r\n    \r\n    vec3 color = ColorFetch(coord);\r\n\r\n    return color;\r\n}\r\n\r\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\r\n{\r\n \tfloat scale = exp2(octave);\r\n    \r\n    coord += offset;\r\n    coord *= scale;\r\n\r\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\r\n    {\r\n     \treturn vec3(0.0);   \r\n    }\r\n    \r\n    vec3 color = vec3(0.0);\r\n    float weights = 0.0;\r\n    \r\n    const int oversampling = 4;\r\n    \r\n    for (int i = 0; i < oversampling; i++)\r\n    {    \t    \r\n        for (int j = 0; j < oversampling; j++)\r\n        {\r\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\r\n            color += ColorFetch(coord + off);\r\n            \r\n\r\n            weights += 1.0;\r\n        }\r\n    }\r\n    \r\n    color /= weights;\r\n    \r\n    return color;\r\n}\r\n\r\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\r\n{\r\n \tfloat scale = exp2(octave);\r\n    \r\n    coord += offset;\r\n    coord *= scale;\r\n\r\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\r\n    {\r\n     \treturn vec3(0.0);   \r\n    }\r\n    \r\n    vec3 color = vec3(0.0);\r\n    float weights = 0.0;\r\n    \r\n    const int oversampling = 8;\r\n    \r\n    for (int i = 0; i < oversampling; i++)\r\n    {    \t    \r\n        for (int j = 0; j < oversampling; j++)\r\n        {\r\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\r\n            color += ColorFetch(coord + off);\r\n            \r\n\r\n            weights += 1.0;\r\n        }\r\n    }\r\n    \r\n    color /= weights;\r\n    \r\n    return color;\r\n}\r\n\r\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\r\n{\r\n \tfloat scale = exp2(octave);\r\n    \r\n    coord += offset;\r\n    coord *= scale;\r\n\r\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\r\n    {\r\n     \treturn vec3(0.0);   \r\n    }\r\n    \r\n    vec3 color = vec3(0.0);\r\n    float weights = 0.0;\r\n    \r\n    const int oversampling = 16;\r\n    \r\n    for (int i = 0; i < oversampling; i++)\r\n    {    \t    \r\n        for (int j = 0; j < oversampling; j++)\r\n        {\r\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\r\n            color += ColorFetch(coord + off);\r\n            \r\n\r\n            weights += 1.0;\r\n        }\r\n    }\r\n    \r\n    color /= weights;\r\n    \r\n    return color;\r\n}\r\n\r\nvec2 CalcOffset(float octave)\r\n{\r\n    vec2 offset = vec2(0.0);\r\n    \r\n    vec2 padding = vec2(10.0) / iResolution.xy;\r\n    \r\n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\r\n    \r\n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\r\n\r\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\r\n    \r\n \treturn offset;   \r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    \r\n    vec3 color = vec3(0.0);\r\n    \r\n    /*\r\n    Create a mipmap tree thingy with padding to prevent leaking bloom\r\n   \t\r\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\r\n    oversampling is required for a proper result\r\n\t*/\r\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\r\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\r\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\r\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\r\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\r\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\r\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\r\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\r\n\r\n\r\n    fragColor = vec4(color, 1.0);\r\n}","inputs":[],"outputs":[],"code":"//First bloom pass, mipmap tree thing\r\n\r\nvec3 ColorFetch(vec2 coord)\r\n{\r\n \treturn texture(iChannel0, coord).rgb;   \r\n}\r\n\r\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\r\n{\r\n \tfloat scale = exp2(octave);\r\n    \r\n    coord += offset;\r\n    coord *= scale;\r\n\r\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\r\n    {\r\n     \treturn vec3(0.0);   \r\n    }\r\n    \r\n    vec3 color = ColorFetch(coord);\r\n\r\n    return color;\r\n}\r\n\r\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\r\n{\r\n \tfloat scale = exp2(octave);\r\n    \r\n    coord += offset;\r\n    coord *= scale;\r\n\r\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\r\n    {\r\n     \treturn vec3(0.0);   \r\n    }\r\n    \r\n    vec3 color = vec3(0.0);\r\n    float weights = 0.0;\r\n    \r\n    const int oversampling = 4;\r\n    \r\n    for (int i = 0; i < oversampling; i++)\r\n    {    \t    \r\n        for (int j = 0; j < oversampling; j++)\r\n        {\r\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\r\n            color += ColorFetch(coord + off);\r\n            \r\n\r\n            weights += 1.0;\r\n        }\r\n    }\r\n    \r\n    color /= weights;\r\n    \r\n    return color;\r\n}\r\n\r\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\r\n{\r\n \tfloat scale = exp2(octave);\r\n    \r\n    coord += offset;\r\n    coord *= scale;\r\n\r\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\r\n    {\r\n     \treturn vec3(0.0);   \r\n    }\r\n    \r\n    vec3 color = vec3(0.0);\r\n    float weights = 0.0;\r\n    \r\n    const int oversampling = 8;\r\n    \r\n    for (int i = 0; i < oversampling; i++)\r\n    {    \t    \r\n        for (int j = 0; j < oversampling; j++)\r\n        {\r\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\r\n            color += ColorFetch(coord + off);\r\n            \r\n\r\n            weights += 1.0;\r\n        }\r\n    }\r\n    \r\n    color /= weights;\r\n    \r\n    return color;\r\n}\r\n\r\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\r\n{\r\n \tfloat scale = exp2(octave);\r\n    \r\n    coord += offset;\r\n    coord *= scale;\r\n\r\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\r\n    {\r\n     \treturn vec3(0.0);   \r\n    }\r\n    \r\n    vec3 color = vec3(0.0);\r\n    float weights = 0.0;\r\n    \r\n    const int oversampling = 16;\r\n    \r\n    for (int i = 0; i < oversampling; i++)\r\n    {    \t    \r\n        for (int j = 0; j < oversampling; j++)\r\n        {\r\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\r\n            color += ColorFetch(coord + off);\r\n            \r\n\r\n            weights += 1.0;\r\n        }\r\n    }\r\n    \r\n    color /= weights;\r\n    \r\n    return color;\r\n}\r\n\r\nvec2 CalcOffset(float octave)\r\n{\r\n    vec2 offset = vec2(0.0);\r\n    \r\n    vec2 padding = vec2(10.0) / iResolution.xy;\r\n    \r\n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\r\n    \r\n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\r\n\r\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\r\n    \r\n \treturn offset;   \r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    \r\n    vec3 color = vec3(0.0);\r\n    \r\n    /*\r\n    Create a mipmap tree thingy with padding to prevent leaking bloom\r\n   \t\r\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\r\n    oversampling is required for a proper result\r\n\t*/\r\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\r\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\r\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\r\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\r\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\r\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\r\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\r\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\r\n\r\n\r\n    fragColor = vec4(color, 1.0);\r\n}","name":"Buf B","description":null,"type":null},{"Code":"//Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\r\n\r\nvec3 ColorFetch(vec2 coord)\r\n{\r\n \treturn texture(iChannel0, coord).rgb;   \r\n}\r\n\r\nfloat weights[5];\r\nfloat offsets[5];\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{    \r\n    \r\n    weights[0] = 0.19638062;\r\n    weights[1] = 0.29675293;\r\n    weights[2] = 0.09442139;\r\n    weights[3] = 0.01037598;\r\n    weights[4] = 0.00025940;\r\n    \r\n    offsets[0] = 0.00000000;\r\n    offsets[1] = 1.41176471;\r\n    offsets[2] = 3.29411765;\r\n    offsets[3] = 5.17647059;\r\n    offsets[4] = 7.05882353;\r\n    \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec3 color = vec3(0.0);\r\n    float weightSum = 0.0;\r\n    \r\n    if (uv.x < 0.52)\r\n    {\r\n        color += ColorFetch(uv) * weights[0];\r\n        weightSum += weights[0];\r\n\r\n        for(int i = 1; i < 5; i++)\r\n        {\r\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\r\n            color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\r\n            color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\r\n            weightSum += weights[i] * 2.0;\r\n        }\r\n\r\n        color /= weightSum;\r\n    }\r\n\r\n    fragColor = vec4(color,1.0);\r\n}","inputs":[],"outputs":[],"code":"//Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\r\n\r\nvec3 ColorFetch(vec2 coord)\r\n{\r\n \treturn texture(iChannel0, coord).rgb;   \r\n}\r\n\r\nfloat weights[5];\r\nfloat offsets[5];\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{    \r\n    \r\n    weights[0] = 0.19638062;\r\n    weights[1] = 0.29675293;\r\n    weights[2] = 0.09442139;\r\n    weights[3] = 0.01037598;\r\n    weights[4] = 0.00025940;\r\n    \r\n    offsets[0] = 0.00000000;\r\n    offsets[1] = 1.41176471;\r\n    offsets[2] = 3.29411765;\r\n    offsets[3] = 5.17647059;\r\n    offsets[4] = 7.05882353;\r\n    \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec3 color = vec3(0.0);\r\n    float weightSum = 0.0;\r\n    \r\n    if (uv.x < 0.52)\r\n    {\r\n        color += ColorFetch(uv) * weights[0];\r\n        weightSum += weights[0];\r\n\r\n        for(int i = 1; i < 5; i++)\r\n        {\r\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\r\n            color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\r\n            color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\r\n            weightSum += weights[i] * 2.0;\r\n        }\r\n\r\n        color /= weightSum;\r\n    }\r\n\r\n    fragColor = vec4(color,1.0);\r\n}","name":"Buf C","description":null,"type":null},{"Code":"//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\r\n\r\nvec3 ColorFetch(vec2 coord)\r\n{\r\n \treturn texture(iChannel0, coord).rgb;   \r\n}\r\n\r\nfloat weights[5];\r\nfloat offsets[5];\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{    \r\n    \r\n    weights[0] = 0.19638062;\r\n    weights[1] = 0.29675293;\r\n    weights[2] = 0.09442139;\r\n    weights[3] = 0.01037598;\r\n    weights[4] = 0.00025940;\r\n    \r\n    offsets[0] = 0.00000000;\r\n    offsets[1] = 1.41176471;\r\n    offsets[2] = 3.29411765;\r\n    offsets[3] = 5.17647059;\r\n    offsets[4] = 7.05882353;\r\n    \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec3 color = vec3(0.0);\r\n    float weightSum = 0.0;\r\n    \r\n    if (uv.x < 0.52)\r\n    {\r\n        color += ColorFetch(uv) * weights[0];\r\n        weightSum += weights[0];\r\n\r\n        for(int i = 1; i < 5; i++)\r\n        {\r\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\r\n            color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\r\n            color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\r\n            weightSum += weights[i] * 2.0;\r\n        }\r\n\r\n        color /= weightSum;\r\n    }\r\n\r\n    fragColor = vec4(color,1.0);\r\n}","inputs":[],"outputs":[],"code":"//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\r\n\r\nvec3 ColorFetch(vec2 coord)\r\n{\r\n \treturn texture(iChannel0, coord).rgb;   \r\n}\r\n\r\nfloat weights[5];\r\nfloat offsets[5];\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{    \r\n    \r\n    weights[0] = 0.19638062;\r\n    weights[1] = 0.29675293;\r\n    weights[2] = 0.09442139;\r\n    weights[3] = 0.01037598;\r\n    weights[4] = 0.00025940;\r\n    \r\n    offsets[0] = 0.00000000;\r\n    offsets[1] = 1.41176471;\r\n    offsets[2] = 3.29411765;\r\n    offsets[3] = 5.17647059;\r\n    offsets[4] = 7.05882353;\r\n    \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec3 color = vec3(0.0);\r\n    float weightSum = 0.0;\r\n    \r\n    if (uv.x < 0.52)\r\n    {\r\n        color += ColorFetch(uv) * weights[0];\r\n        weightSum += weights[0];\r\n\r\n        for(int i = 1; i < 5; i++)\r\n        {\r\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\r\n            color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\r\n            color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\r\n            weightSum += weights[i] * 2.0;\r\n        }\r\n\r\n        color /= weightSum;\r\n    }\r\n\r\n    fragColor = vec4(color,1.0);\r\n}","name":"Buf D","description":null,"type":null}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by Reinder Nijhoff 2014\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/Xtf3zn\r\n//\r\n// car model is made by Eiffie\r\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\r\n\r\n#define BUMPMAP\r\n#define MARCHSTEPS 128\r\n#define MARCHSTEPSREFLECTION 48\r\n#define LIGHTINTENSITY 5.\r\n\r\n//----------------------------------------------------------------------\r\n\r\nconst vec3 backgroundColor = vec3(0.2,0.4,0.6) * 0.09;\r\n#define time (iTime + 90.)\r\n\r\n//----------------------------------------------------------------------\r\n// noises\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*687.3123);\r\n}\r\n\r\nfloat noise( in vec2 x ) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0;\r\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\r\n}\r\n\r\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\r\n\r\nfloat fbm( vec2 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n    f += 0.1250*noise( p ); p = m2*p*2.01;\r\n//    f += 0.0625*noise( p );\r\n    \r\n    return f/0.9375;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// distance primitives\r\n\r\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\r\n  return length(max(abs(p)-b,0.0))-r;\r\n}\r\n\r\nfloat sdBox( in vec3 p, in vec3 b ) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat sdSphere( in vec3 p, in float s ) {\r\n    return length(p)-s;\r\n}\r\n\r\nfloat sdCylinder( in vec3 p, in vec2 h ) {\r\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// distance operators\r\n\r\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\r\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\r\nfloat smin( float a, float b, float k ) { return -log(exp(-k*a)+exp(-k*b))/k; } //from iq\r\n\r\n//----------------------------------------------------------------------\r\n// Map functions\r\n\r\n// car model is made by Eiffie\r\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\r\n\r\nfloat mapCar(in vec3 p0){ \r\n\tvec3 p=p0+vec3(0.0,1.24,0.0);\r\n\tfloat r=length(p.yz);\r\n\tfloat d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\r\n\td=max(d,p.z-1.0);\r\n\tp=p0+vec3(0.0,-0.22,0.39);\r\n\tp.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\r\n\tr=length(p.yz);\r\n\td=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\r\n\td=max(d,-max(p.x-0.165,r-0.24));\r\n\tfloat d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\r\n\td=min(d,d2);\r\n\r\n\treturn d;\r\n}\r\n\r\nfloat dL; // minimal distance to light\r\n\r\nfloat map( const in vec3 p ) {\r\n\tvec3 pd = p;\r\n    float d;\r\n    \r\n    pd.x = abs( pd.x );\r\n    pd.z *= -sign( p.x );\r\n    \r\n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\r\n    float lh = hash( floor( pd.z/13. ) );\r\n    \r\n    vec3 pdm = vec3( pd.x, pd.y, mod( pd.z, 10.) - 5. );\r\n    dL = sdSphere( vec3(pdm.x-8.1,pdm.y-4.5,pdm.z), 0.1 );\r\n    \r\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-9.5-lh,  mod( pd.z, 91.) - 45.5 ), vec3(0.2,4.5, 0.2) ) );\r\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-11.5+lh, mod( pd.z, 31.) - 15.5 ), vec3(0.22,5.5, 0.2) ) );\r\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-8.5-lh,  mod( pd.z, 41.) - 20.5 ), vec3(0.24,3.5, 0.2) ) );\r\n   \r\n    if( lh > 0.5 ) {\r\n\t    dL = opU( dL, sdBox( vec3(pdm.x-12.5,pdm.y-2.75-lh,  mod( pd.z, 13.) - 6.5 ), vec3(0.1,0.25, 3.2) ) );\r\n    }\r\n    \r\n    vec3 pm = vec3( mod( pd.x + floor( pd.z * 4. )*0.25, 0.5 ) - 0.25, pd.y, mod( pd.z, 0.25 ) - 0.125 );\r\n\td = udRoundBox( pm, vec3( 0.245,0.1, 0.12 ), 0.005 ); \r\n    \r\n    d = opS( d, -(p.x+8.) );\r\n    d = opU( d, pd.y );\r\n\r\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\r\n    \r\n    // car\r\n    if( ch > 0.75 ) {\r\n        pdc.x += (ch-0.75)*4.;\r\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ),    0.025 ) );\r\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.2,  pdc.y-0.65,  pdc.z+6.05 ), 0.025 ) );\r\n\r\n        d = opU( d,  mapCar( (pdc-vec3(5.,-0.025,-2.3))*0.45 ) );\r\n \t}\r\n    \r\n    d = opU( d, 13.-pd.x );\r\n    d = opU( d, sdCylinder( vec3(pdm.x-8.5, pdm.y, pdm.z), vec2(0.075,4.5)) );\r\n    d = opU( d, dL );\r\n    \r\n\treturn d;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n\r\nvec3 calcNormalSimple( in vec3 pos ) {   \r\n    const vec2 e = vec2(1.0,-1.0)*0.005;\r\n\r\n    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + \r\n\t\t\t\t\t    e.yyx*map( pos + e.yyx )   + \r\n\t\t\t\t\t    e.yxy*map( pos + e.yxy )   + \r\n\t\t\t\t\t    e.xxx*map( pos + e.xxx )   );  \r\n    return n;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos ) {\r\n    vec3 n = calcNormalSimple( pos );\r\n    if( pos.y > 0.12 ) return n;\r\n\r\n#ifdef BUMPMAP\r\n    vec2 oc = floor( vec2(pos.x+floor( pos.z * 4. )*0.25, pos.z) * vec2( 2., 4. ) );\r\n\r\n    if( abs(pos.x)<8. ) {\r\n\t\toc = pos.xz;\r\n    }\r\n    \r\n     vec3 p = pos * 250.;\r\n   \t vec3 xn = 0.05*vec3(noise(p.xz)-0.5,0.,noise(p.zx)-0.5);\r\n     xn += 0.1*vec3(fbm(oc.xy)-0.5,0.,fbm(oc.yx)-0.5);\r\n    \r\n    n = normalize( xn + n );\r\n#endif\r\n    \r\n    return n;\r\n}\r\n\r\nvec3 int1, int2, nor1;\r\nvec4 lint1, lint2;\r\n\r\nfloat intersect( in vec3 ro, in vec3 rd ) {\r\n\tconst float precis = 0.001;\r\n    float h = precis*2.0;\r\n    float t = 0.;\r\n    int1 = int2 = vec3( -500. );\r\n    lint1 = lint2 = vec4( -500. );\r\n    float mld = 100.;\r\n    \r\n\tfor( int i=0; i < MARCHSTEPS; i++ ) {\r\n        h = map( ro+rd*t );\r\n\t\tif(dL < mld){\r\n\t\t\tmld=dL;\r\n            lint1.xyz = ro+rd*t;\r\n\t\t\tlint1.w = abs(dL);\r\n\t\t}\r\n        if( h < precis ) {\r\n            int1.xyz = ro+rd*t;\r\n            break;\r\n        } \r\n        t += max(h, precis*2.);\r\n    }\r\n    \r\n    if( int1.z < -400. || t > 300.) {\r\n        // check intersection with plane y = -0.1;\r\n        float d = -(ro.y + 0.1)/rd.y;\r\n\t\tif( d > 0. ) {\r\n\t\t\tint1.xyz = ro+rd*d;\r\n\t    } else {\r\n        \treturn -1.;\r\n    \t}\r\n    }\r\n    \r\n    ro = ro + rd*t;\r\n    nor1 = calcNormal(ro);\r\n    ro += 0.01*nor1;\r\n    rd = reflect( rd, nor1 );\r\n    t = 0.0;\r\n    h = precis*2.0;\r\n    mld = 100.;\r\n    \r\n    for( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\r\n        h = map( ro+rd*t );\r\n\t\tif(dL < mld){\r\n\t\t\tmld=dL;            \r\n            lint2.xyz = ro+rd*t;\r\n\t\t\tlint2.w = abs(dL);\r\n\t\t}\r\n        if( h < precis ) {\r\n   \t\t\tint2.xyz = ro+rd*t;\r\n            return 1.;\r\n        }   \r\n        t += max(h, precis*2.);\r\n    }\r\n\r\n    return 0.;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// shade\r\n\r\nvec3 shade( in vec3 ro, in vec3 pos, in vec3 nor ) {\r\n    vec3  col = vec3(0.5);\r\n    \r\n    if( abs(pos.x) > 15. || abs(pos.x) < 8. ) col = vec3( 0.02 );\r\n    if( pos.y < 0.01 ) {\r\n        if( abs( int1.x ) < 0.1 ) col = vec3( 0.9 );\r\n        if( abs( abs( int1.x )-7.4 ) < 0.1 ) col = vec3( 0.9 );\r\n    }    \r\n    \r\n    float sh = clamp( dot( nor, normalize( vec3( -0.3, 0.3, -0.5 ) ) ), 0., 1.);\r\n  \tcol *= (sh * backgroundColor);  \r\n \r\n    if( abs( pos.x ) > 12.9 && pos.y > 9.) { // windows\r\n        float ha = hash(  133.1234*floor( pos.y / 3. ) + floor( (pos.z) / 3. ) );\r\n        if( ha > 0.95) {\r\n            col = ( (ha-0.95)*10.) * vec3( 1., 0.7, 0.4 );\r\n        }\r\n    }\r\n    \r\n\tcol = mix(  backgroundColor, col, exp( min(max(0.1*pos.y,0.25)-0.065*distance(pos, ro),0.) ) );\r\n  \r\n    return col;\r\n}\r\n\r\nvec3 getLightColor( in vec3 pos ) {\r\n    vec3 lcol = vec3( 1., .7, .5 );\r\n    \r\n\tvec3 pd = pos;\r\n    pd.x = abs( pd.x );\r\n    pd.z *= -sign( pos.x );\r\n    \r\n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\r\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\r\n\r\n    if( ch > 0.75 ) { // car\r\n        pdc.x += (ch-0.75)*4.;\r\n        if(  sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ), 0.25) < 2. ) {\r\n            lcol = vec3( 1., 0.05, 0.01 );\r\n        }\r\n    }\r\n    if( pd.y > 2. && abs(pd.x) > 10. && pd.y < 5. ) {\r\n        float fl = floor( pd.z/13. );\r\n        lcol = 0.4*lcol+0.5*vec3( hash( .1562+fl ), hash( .423134+fl ), 0. );\r\n    }\r\n    if(  abs(pd.x) > 10. && pd.y > 5. ) {\r\n        float fl = floor( pd.z/2. );\r\n        lcol = 0.5*lcol+0.5*vec3( hash( .1562+fl ),  hash( .923134+fl ), hash( .423134+fl ) );\r\n    }\r\n   \r\n    return lcol;\r\n}\r\n\r\nfloat randomStart(vec2 co){return 0.8+0.2*hash(dot(co,vec2(123.42,117.853))*412.453);}\r\n\r\n//----------------------------------------------------------------------\r\n// main\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n\tvec2 p = -1.0 + 2.0*q;\r\n\tp.x *= iResolution.x / iResolution.y;\r\n        \r\n    if (q.y < .12 || q.y >= .88) {\r\n\t\tfragColor=vec4(0.,0.,0.,1.);\r\n\t\treturn;\r\n    } else {\r\n    \r\n        // camera\r\n        float z = time;\r\n        float x = -10.9+1.*sin(time*0.2);\r\n        vec3 ro = vec3(x,  1.3+.3*cos(time*0.26), z-1.);\r\n        vec3 ta = vec3(-8.,1.3+.4*cos(time*0.26), z+4.+cos(time*0.04));\r\n\r\n        vec3 ww = normalize( ta - ro );\r\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n        vec3 vv = normalize( cross(uu,ww));\r\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\r\n\r\n        vec3 col = backgroundColor;\r\n\r\n        // raymarch\r\n        float ints = intersect(ro+randomStart(p)*rd ,rd );\r\n        if(  ints > -0.5 ) {\r\n\r\n            // calculate reflectance\r\n            float r = 0.09;     \t        \r\n            if( int1.y > 0.129 ) r = 0.025 * hash(  133.1234*floor( int1.y / 3. ) + floor( int1.z / 3. ) );\r\n            if( abs(int1.x) < 8. ) {\r\n                if( int1.y < 0.01 ) { // road\r\n                    r = 0.007*fbm(int1.xz);\r\n                } else { // car\r\n                    r = 0.02;\r\n                }\r\n            }\r\n            if( abs( int1.x ) < 0.1 ) r *= 4.;\r\n            if( abs( abs( int1.x )-7.4 ) < 0.1 ) r *= 4.;\r\n\r\n            r *= 2.;\r\n\r\n            col = shade( ro, int1.xyz, nor1 );\r\n\r\n            if( ints > 0.5 ) {\r\n                col += r * shade( int1.xyz, int2.xyz, calcNormalSimple(int2.xyz) );\r\n            }  \r\n            if( lint2.w > 0. ) {            \r\n                col += (r*LIGHTINTENSITY*exp(-lint2.w*7.0)) * getLightColor(lint2.xyz);\r\n            } \r\n        } \r\n\r\n        // Rain (by Dave Hoskins)\r\n        vec2 st = 256. * ( p* vec2(.5, .01)+vec2(time*.13-q.y*.6, time*.13) );\r\n        float f = noise( st ) * noise( st*0.773) * 1.55;\r\n        f = 0.25+ clamp(pow(abs(f), 13.0) * 13.0, 0.0, q.y*.14);\r\n\r\n        if( lint1.w > 0. ) {\r\n            col += (f*LIGHTINTENSITY*exp(-lint1.w*7.0)) * getLightColor(lint1.xyz);\r\n        }  \r\n\r\n        col += 0.25*f*(0.2+backgroundColor);\r\n\r\n        // post processing\r\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n        col *= 1.2*vec3(1.,0.99,0.95);   \r\n        col = clamp(1.06*col-0.03, 0., 1.);  \r\n        q.y = (q.y-.12)*(1./0.76);\r\n        col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 ); \r\n\r\n        fragColor = vec4( col, 1.0 );\r\n    }\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by Reinder Nijhoff 2014\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/Xtf3zn\r\n//\r\n// car model is made by Eiffie\r\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\r\n\r\n#define BUMPMAP\r\n#define MARCHSTEPS 128\r\n#define MARCHSTEPSREFLECTION 48\r\n#define LIGHTINTENSITY 5.\r\n\r\n//----------------------------------------------------------------------\r\n\r\nconst vec3 backgroundColor = vec3(0.2,0.4,0.6) * 0.09;\r\n#define time (iTime + 90.)\r\n\r\n//----------------------------------------------------------------------\r\n// noises\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*687.3123);\r\n}\r\n\r\nfloat noise( in vec2 x ) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0;\r\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\r\n}\r\n\r\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\r\n\r\nfloat fbm( vec2 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n    f += 0.1250*noise( p ); p = m2*p*2.01;\r\n//    f += 0.0625*noise( p );\r\n    \r\n    return f/0.9375;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// distance primitives\r\n\r\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\r\n  return length(max(abs(p)-b,0.0))-r;\r\n}\r\n\r\nfloat sdBox( in vec3 p, in vec3 b ) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat sdSphere( in vec3 p, in float s ) {\r\n    return length(p)-s;\r\n}\r\n\r\nfloat sdCylinder( in vec3 p, in vec2 h ) {\r\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// distance operators\r\n\r\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\r\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\r\nfloat smin( float a, float b, float k ) { return -log(exp(-k*a)+exp(-k*b))/k; } //from iq\r\n\r\n//----------------------------------------------------------------------\r\n// Map functions\r\n\r\n// car model is made by Eiffie\r\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\r\n\r\nfloat mapCar(in vec3 p0){ \r\n\tvec3 p=p0+vec3(0.0,1.24,0.0);\r\n\tfloat r=length(p.yz);\r\n\tfloat d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\r\n\td=max(d,p.z-1.0);\r\n\tp=p0+vec3(0.0,-0.22,0.39);\r\n\tp.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\r\n\tr=length(p.yz);\r\n\td=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\r\n\td=max(d,-max(p.x-0.165,r-0.24));\r\n\tfloat d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\r\n\td=min(d,d2);\r\n\r\n\treturn d;\r\n}\r\n\r\nfloat dL; // minimal distance to light\r\n\r\nfloat map( const in vec3 p ) {\r\n\tvec3 pd = p;\r\n    float d;\r\n    \r\n    pd.x = abs( pd.x );\r\n    pd.z *= -sign( p.x );\r\n    \r\n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\r\n    float lh = hash( floor( pd.z/13. ) );\r\n    \r\n    vec3 pdm = vec3( pd.x, pd.y, mod( pd.z, 10.) - 5. );\r\n    dL = sdSphere( vec3(pdm.x-8.1,pdm.y-4.5,pdm.z), 0.1 );\r\n    \r\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-9.5-lh,  mod( pd.z, 91.) - 45.5 ), vec3(0.2,4.5, 0.2) ) );\r\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-11.5+lh, mod( pd.z, 31.) - 15.5 ), vec3(0.22,5.5, 0.2) ) );\r\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-8.5-lh,  mod( pd.z, 41.) - 20.5 ), vec3(0.24,3.5, 0.2) ) );\r\n   \r\n    if( lh > 0.5 ) {\r\n\t    dL = opU( dL, sdBox( vec3(pdm.x-12.5,pdm.y-2.75-lh,  mod( pd.z, 13.) - 6.5 ), vec3(0.1,0.25, 3.2) ) );\r\n    }\r\n    \r\n    vec3 pm = vec3( mod( pd.x + floor( pd.z * 4. )*0.25, 0.5 ) - 0.25, pd.y, mod( pd.z, 0.25 ) - 0.125 );\r\n\td = udRoundBox( pm, vec3( 0.245,0.1, 0.12 ), 0.005 ); \r\n    \r\n    d = opS( d, -(p.x+8.) );\r\n    d = opU( d, pd.y );\r\n\r\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\r\n    \r\n    // car\r\n    if( ch > 0.75 ) {\r\n        pdc.x += (ch-0.75)*4.;\r\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ),    0.025 ) );\r\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.2,  pdc.y-0.65,  pdc.z+6.05 ), 0.025 ) );\r\n\r\n        d = opU( d,  mapCar( (pdc-vec3(5.,-0.025,-2.3))*0.45 ) );\r\n \t}\r\n    \r\n    d = opU( d, 13.-pd.x );\r\n    d = opU( d, sdCylinder( vec3(pdm.x-8.5, pdm.y, pdm.z), vec2(0.075,4.5)) );\r\n    d = opU( d, dL );\r\n    \r\n\treturn d;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n\r\nvec3 calcNormalSimple( in vec3 pos ) {   \r\n    const vec2 e = vec2(1.0,-1.0)*0.005;\r\n\r\n    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + \r\n\t\t\t\t\t    e.yyx*map( pos + e.yyx )   + \r\n\t\t\t\t\t    e.yxy*map( pos + e.yxy )   + \r\n\t\t\t\t\t    e.xxx*map( pos + e.xxx )   );  \r\n    return n;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos ) {\r\n    vec3 n = calcNormalSimple( pos );\r\n    if( pos.y > 0.12 ) return n;\r\n\r\n#ifdef BUMPMAP\r\n    vec2 oc = floor( vec2(pos.x+floor( pos.z * 4. )*0.25, pos.z) * vec2( 2., 4. ) );\r\n\r\n    if( abs(pos.x)<8. ) {\r\n\t\toc = pos.xz;\r\n    }\r\n    \r\n     vec3 p = pos * 250.;\r\n   \t vec3 xn = 0.05*vec3(noise(p.xz)-0.5,0.,noise(p.zx)-0.5);\r\n     xn += 0.1*vec3(fbm(oc.xy)-0.5,0.,fbm(oc.yx)-0.5);\r\n    \r\n    n = normalize( xn + n );\r\n#endif\r\n    \r\n    return n;\r\n}\r\n\r\nvec3 int1, int2, nor1;\r\nvec4 lint1, lint2;\r\n\r\nfloat intersect( in vec3 ro, in vec3 rd ) {\r\n\tconst float precis = 0.001;\r\n    float h = precis*2.0;\r\n    float t = 0.;\r\n    int1 = int2 = vec3( -500. );\r\n    lint1 = lint2 = vec4( -500. );\r\n    float mld = 100.;\r\n    \r\n\tfor( int i=0; i < MARCHSTEPS; i++ ) {\r\n        h = map( ro+rd*t );\r\n\t\tif(dL < mld){\r\n\t\t\tmld=dL;\r\n            lint1.xyz = ro+rd*t;\r\n\t\t\tlint1.w = abs(dL);\r\n\t\t}\r\n        if( h < precis ) {\r\n            int1.xyz = ro+rd*t;\r\n            break;\r\n        } \r\n        t += max(h, precis*2.);\r\n    }\r\n    \r\n    if( int1.z < -400. || t > 300.) {\r\n        // check intersection with plane y = -0.1;\r\n        float d = -(ro.y + 0.1)/rd.y;\r\n\t\tif( d > 0. ) {\r\n\t\t\tint1.xyz = ro+rd*d;\r\n\t    } else {\r\n        \treturn -1.;\r\n    \t}\r\n    }\r\n    \r\n    ro = ro + rd*t;\r\n    nor1 = calcNormal(ro);\r\n    ro += 0.01*nor1;\r\n    rd = reflect( rd, nor1 );\r\n    t = 0.0;\r\n    h = precis*2.0;\r\n    mld = 100.;\r\n    \r\n    for( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\r\n        h = map( ro+rd*t );\r\n\t\tif(dL < mld){\r\n\t\t\tmld=dL;            \r\n            lint2.xyz = ro+rd*t;\r\n\t\t\tlint2.w = abs(dL);\r\n\t\t}\r\n        if( h < precis ) {\r\n   \t\t\tint2.xyz = ro+rd*t;\r\n            return 1.;\r\n        }   \r\n        t += max(h, precis*2.);\r\n    }\r\n\r\n    return 0.;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// shade\r\n\r\nvec3 shade( in vec3 ro, in vec3 pos, in vec3 nor ) {\r\n    vec3  col = vec3(0.5);\r\n    \r\n    if( abs(pos.x) > 15. || abs(pos.x) < 8. ) col = vec3( 0.02 );\r\n    if( pos.y < 0.01 ) {\r\n        if( abs( int1.x ) < 0.1 ) col = vec3( 0.9 );\r\n        if( abs( abs( int1.x )-7.4 ) < 0.1 ) col = vec3( 0.9 );\r\n    }    \r\n    \r\n    float sh = clamp( dot( nor, normalize( vec3( -0.3, 0.3, -0.5 ) ) ), 0., 1.);\r\n  \tcol *= (sh * backgroundColor);  \r\n \r\n    if( abs( pos.x ) > 12.9 && pos.y > 9.) { // windows\r\n        float ha = hash(  133.1234*floor( pos.y / 3. ) + floor( (pos.z) / 3. ) );\r\n        if( ha > 0.95) {\r\n            col = ( (ha-0.95)*10.) * vec3( 1., 0.7, 0.4 );\r\n        }\r\n    }\r\n    \r\n\tcol = mix(  backgroundColor, col, exp( min(max(0.1*pos.y,0.25)-0.065*distance(pos, ro),0.) ) );\r\n  \r\n    return col;\r\n}\r\n\r\nvec3 getLightColor( in vec3 pos ) {\r\n    vec3 lcol = vec3( 1., .7, .5 );\r\n    \r\n\tvec3 pd = pos;\r\n    pd.x = abs( pd.x );\r\n    pd.z *= -sign( pos.x );\r\n    \r\n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\r\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\r\n\r\n    if( ch > 0.75 ) { // car\r\n        pdc.x += (ch-0.75)*4.;\r\n        if(  sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ), 0.25) < 2. ) {\r\n            lcol = vec3( 1., 0.05, 0.01 );\r\n        }\r\n    }\r\n    if( pd.y > 2. && abs(pd.x) > 10. && pd.y < 5. ) {\r\n        float fl = floor( pd.z/13. );\r\n        lcol = 0.4*lcol+0.5*vec3( hash( .1562+fl ), hash( .423134+fl ), 0. );\r\n    }\r\n    if(  abs(pd.x) > 10. && pd.y > 5. ) {\r\n        float fl = floor( pd.z/2. );\r\n        lcol = 0.5*lcol+0.5*vec3( hash( .1562+fl ),  hash( .923134+fl ), hash( .423134+fl ) );\r\n    }\r\n   \r\n    return lcol;\r\n}\r\n\r\nfloat randomStart(vec2 co){return 0.8+0.2*hash(dot(co,vec2(123.42,117.853))*412.453);}\r\n\r\n//----------------------------------------------------------------------\r\n// main\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n\tvec2 p = -1.0 + 2.0*q;\r\n\tp.x *= iResolution.x / iResolution.y;\r\n        \r\n    if (q.y < .12 || q.y >= .88) {\r\n\t\tfragColor=vec4(0.,0.,0.,1.);\r\n\t\treturn;\r\n    } else {\r\n    \r\n        // camera\r\n        float z = time;\r\n        float x = -10.9+1.*sin(time*0.2);\r\n        vec3 ro = vec3(x,  1.3+.3*cos(time*0.26), z-1.);\r\n        vec3 ta = vec3(-8.,1.3+.4*cos(time*0.26), z+4.+cos(time*0.04));\r\n\r\n        vec3 ww = normalize( ta - ro );\r\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n        vec3 vv = normalize( cross(uu,ww));\r\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\r\n\r\n        vec3 col = backgroundColor;\r\n\r\n        // raymarch\r\n        float ints = intersect(ro+randomStart(p)*rd ,rd );\r\n        if(  ints > -0.5 ) {\r\n\r\n            // calculate reflectance\r\n            float r = 0.09;     \t        \r\n            if( int1.y > 0.129 ) r = 0.025 * hash(  133.1234*floor( int1.y / 3. ) + floor( int1.z / 3. ) );\r\n            if( abs(int1.x) < 8. ) {\r\n                if( int1.y < 0.01 ) { // road\r\n                    r = 0.007*fbm(int1.xz);\r\n                } else { // car\r\n                    r = 0.02;\r\n                }\r\n            }\r\n            if( abs( int1.x ) < 0.1 ) r *= 4.;\r\n            if( abs( abs( int1.x )-7.4 ) < 0.1 ) r *= 4.;\r\n\r\n            r *= 2.;\r\n\r\n            col = shade( ro, int1.xyz, nor1 );\r\n\r\n            if( ints > 0.5 ) {\r\n                col += r * shade( int1.xyz, int2.xyz, calcNormalSimple(int2.xyz) );\r\n            }  \r\n            if( lint2.w > 0. ) {            \r\n                col += (r*LIGHTINTENSITY*exp(-lint2.w*7.0)) * getLightColor(lint2.xyz);\r\n            } \r\n        } \r\n\r\n        // Rain (by Dave Hoskins)\r\n        vec2 st = 256. * ( p* vec2(.5, .01)+vec2(time*.13-q.y*.6, time*.13) );\r\n        float f = noise( st ) * noise( st*0.773) * 1.55;\r\n        f = 0.25+ clamp(pow(abs(f), 13.0) * 13.0, 0.0, q.y*.14);\r\n\r\n        if( lint1.w > 0. ) {\r\n            col += (f*LIGHTINTENSITY*exp(-lint1.w*7.0)) * getLightColor(lint1.xyz);\r\n        }  \r\n\r\n        col += 0.25*f*(0.2+backgroundColor);\r\n\r\n        // post processing\r\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n        col *= 1.2*vec3(1.,0.99,0.95);   \r\n        col = clamp(1.06*col-0.03, 0., 1.);  \r\n        q.y = (q.y-.12)*(1./0.76);\r\n        col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 ); \r\n\r\n        fragColor = vec4( col, 1.0 );\r\n    }\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Tokyo","id":null,"date":null,"viewed":0,"name":"Tokyo","description":"Tokyo by night in the rain. The car model is made by Eiffie (Shiny Toy': https://www.shadertoy.com/view/ldsGWB). I have never been in Tokyo btw.","likes":0,"published":null,"tags":["raymarching"," reflection"," rain"," city"," car"]},"ver":null,"info":{"Name":"Tokyo","id":null,"date":null,"viewed":0,"name":"Tokyo","description":"Tokyo by night in the rain. The car model is made by Eiffie (Shiny Toy': https://www.shadertoy.com/view/ldsGWB). I have never been in Tokyo btw.","likes":0,"published":null,"tags":["raymarching"," reflection"," rain"," city"," car"]},"renderpass":[{"Code":"// Created by Reinder Nijhoff 2014\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/Xtf3zn\r\n//\r\n// car model is made by Eiffie\r\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\r\n\r\n#define BUMPMAP\r\n#define MARCHSTEPS 128\r\n#define MARCHSTEPSREFLECTION 48\r\n#define LIGHTINTENSITY 5.\r\n\r\n//----------------------------------------------------------------------\r\n\r\nconst vec3 backgroundColor = vec3(0.2,0.4,0.6) * 0.09;\r\n#define time (iTime + 90.)\r\n\r\n//----------------------------------------------------------------------\r\n// noises\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*687.3123);\r\n}\r\n\r\nfloat noise( in vec2 x ) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0;\r\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\r\n}\r\n\r\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\r\n\r\nfloat fbm( vec2 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n    f += 0.1250*noise( p ); p = m2*p*2.01;\r\n//    f += 0.0625*noise( p );\r\n    \r\n    return f/0.9375;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// distance primitives\r\n\r\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\r\n  return length(max(abs(p)-b,0.0))-r;\r\n}\r\n\r\nfloat sdBox( in vec3 p, in vec3 b ) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat sdSphere( in vec3 p, in float s ) {\r\n    return length(p)-s;\r\n}\r\n\r\nfloat sdCylinder( in vec3 p, in vec2 h ) {\r\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// distance operators\r\n\r\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\r\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\r\nfloat smin( float a, float b, float k ) { return -log(exp(-k*a)+exp(-k*b))/k; } //from iq\r\n\r\n//----------------------------------------------------------------------\r\n// Map functions\r\n\r\n// car model is made by Eiffie\r\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\r\n\r\nfloat mapCar(in vec3 p0){ \r\n\tvec3 p=p0+vec3(0.0,1.24,0.0);\r\n\tfloat r=length(p.yz);\r\n\tfloat d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\r\n\td=max(d,p.z-1.0);\r\n\tp=p0+vec3(0.0,-0.22,0.39);\r\n\tp.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\r\n\tr=length(p.yz);\r\n\td=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\r\n\td=max(d,-max(p.x-0.165,r-0.24));\r\n\tfloat d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\r\n\td=min(d,d2);\r\n\r\n\treturn d;\r\n}\r\n\r\nfloat dL; // minimal distance to light\r\n\r\nfloat map( const in vec3 p ) {\r\n\tvec3 pd = p;\r\n    float d;\r\n    \r\n    pd.x = abs( pd.x );\r\n    pd.z *= -sign( p.x );\r\n    \r\n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\r\n    float lh = hash( floor( pd.z/13. ) );\r\n    \r\n    vec3 pdm = vec3( pd.x, pd.y, mod( pd.z, 10.) - 5. );\r\n    dL = sdSphere( vec3(pdm.x-8.1,pdm.y-4.5,pdm.z), 0.1 );\r\n    \r\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-9.5-lh,  mod( pd.z, 91.) - 45.5 ), vec3(0.2,4.5, 0.2) ) );\r\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-11.5+lh, mod( pd.z, 31.) - 15.5 ), vec3(0.22,5.5, 0.2) ) );\r\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-8.5-lh,  mod( pd.z, 41.) - 20.5 ), vec3(0.24,3.5, 0.2) ) );\r\n   \r\n    if( lh > 0.5 ) {\r\n\t    dL = opU( dL, sdBox( vec3(pdm.x-12.5,pdm.y-2.75-lh,  mod( pd.z, 13.) - 6.5 ), vec3(0.1,0.25, 3.2) ) );\r\n    }\r\n    \r\n    vec3 pm = vec3( mod( pd.x + floor( pd.z * 4. )*0.25, 0.5 ) - 0.25, pd.y, mod( pd.z, 0.25 ) - 0.125 );\r\n\td = udRoundBox( pm, vec3( 0.245,0.1, 0.12 ), 0.005 ); \r\n    \r\n    d = opS( d, -(p.x+8.) );\r\n    d = opU( d, pd.y );\r\n\r\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\r\n    \r\n    // car\r\n    if( ch > 0.75 ) {\r\n        pdc.x += (ch-0.75)*4.;\r\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ),    0.025 ) );\r\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.2,  pdc.y-0.65,  pdc.z+6.05 ), 0.025 ) );\r\n\r\n        d = opU( d,  mapCar( (pdc-vec3(5.,-0.025,-2.3))*0.45 ) );\r\n \t}\r\n    \r\n    d = opU( d, 13.-pd.x );\r\n    d = opU( d, sdCylinder( vec3(pdm.x-8.5, pdm.y, pdm.z), vec2(0.075,4.5)) );\r\n    d = opU( d, dL );\r\n    \r\n\treturn d;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n\r\nvec3 calcNormalSimple( in vec3 pos ) {   \r\n    const vec2 e = vec2(1.0,-1.0)*0.005;\r\n\r\n    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + \r\n\t\t\t\t\t    e.yyx*map( pos + e.yyx )   + \r\n\t\t\t\t\t    e.yxy*map( pos + e.yxy )   + \r\n\t\t\t\t\t    e.xxx*map( pos + e.xxx )   );  \r\n    return n;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos ) {\r\n    vec3 n = calcNormalSimple( pos );\r\n    if( pos.y > 0.12 ) return n;\r\n\r\n#ifdef BUMPMAP\r\n    vec2 oc = floor( vec2(pos.x+floor( pos.z * 4. )*0.25, pos.z) * vec2( 2., 4. ) );\r\n\r\n    if( abs(pos.x)<8. ) {\r\n\t\toc = pos.xz;\r\n    }\r\n    \r\n     vec3 p = pos * 250.;\r\n   \t vec3 xn = 0.05*vec3(noise(p.xz)-0.5,0.,noise(p.zx)-0.5);\r\n     xn += 0.1*vec3(fbm(oc.xy)-0.5,0.,fbm(oc.yx)-0.5);\r\n    \r\n    n = normalize( xn + n );\r\n#endif\r\n    \r\n    return n;\r\n}\r\n\r\nvec3 int1, int2, nor1;\r\nvec4 lint1, lint2;\r\n\r\nfloat intersect( in vec3 ro, in vec3 rd ) {\r\n\tconst float precis = 0.001;\r\n    float h = precis*2.0;\r\n    float t = 0.;\r\n    int1 = int2 = vec3( -500. );\r\n    lint1 = lint2 = vec4( -500. );\r\n    float mld = 100.;\r\n    \r\n\tfor( int i=0; i < MARCHSTEPS; i++ ) {\r\n        h = map( ro+rd*t );\r\n\t\tif(dL < mld){\r\n\t\t\tmld=dL;\r\n            lint1.xyz = ro+rd*t;\r\n\t\t\tlint1.w = abs(dL);\r\n\t\t}\r\n        if( h < precis ) {\r\n            int1.xyz = ro+rd*t;\r\n            break;\r\n        } \r\n        t += max(h, precis*2.);\r\n    }\r\n    \r\n    if( int1.z < -400. || t > 300.) {\r\n        // check intersection with plane y = -0.1;\r\n        float d = -(ro.y + 0.1)/rd.y;\r\n\t\tif( d > 0. ) {\r\n\t\t\tint1.xyz = ro+rd*d;\r\n\t    } else {\r\n        \treturn -1.;\r\n    \t}\r\n    }\r\n    \r\n    ro = ro + rd*t;\r\n    nor1 = calcNormal(ro);\r\n    ro += 0.01*nor1;\r\n    rd = reflect( rd, nor1 );\r\n    t = 0.0;\r\n    h = precis*2.0;\r\n    mld = 100.;\r\n    \r\n    for( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\r\n        h = map( ro+rd*t );\r\n\t\tif(dL < mld){\r\n\t\t\tmld=dL;            \r\n            lint2.xyz = ro+rd*t;\r\n\t\t\tlint2.w = abs(dL);\r\n\t\t}\r\n        if( h < precis ) {\r\n   \t\t\tint2.xyz = ro+rd*t;\r\n            return 1.;\r\n        }   \r\n        t += max(h, precis*2.);\r\n    }\r\n\r\n    return 0.;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// shade\r\n\r\nvec3 shade( in vec3 ro, in vec3 pos, in vec3 nor ) {\r\n    vec3  col = vec3(0.5);\r\n    \r\n    if( abs(pos.x) > 15. || abs(pos.x) < 8. ) col = vec3( 0.02 );\r\n    if( pos.y < 0.01 ) {\r\n        if( abs( int1.x ) < 0.1 ) col = vec3( 0.9 );\r\n        if( abs( abs( int1.x )-7.4 ) < 0.1 ) col = vec3( 0.9 );\r\n    }    \r\n    \r\n    float sh = clamp( dot( nor, normalize( vec3( -0.3, 0.3, -0.5 ) ) ), 0., 1.);\r\n  \tcol *= (sh * backgroundColor);  \r\n \r\n    if( abs( pos.x ) > 12.9 && pos.y > 9.) { // windows\r\n        float ha = hash(  133.1234*floor( pos.y / 3. ) + floor( (pos.z) / 3. ) );\r\n        if( ha > 0.95) {\r\n            col = ( (ha-0.95)*10.) * vec3( 1., 0.7, 0.4 );\r\n        }\r\n    }\r\n    \r\n\tcol = mix(  backgroundColor, col, exp( min(max(0.1*pos.y,0.25)-0.065*distance(pos, ro),0.) ) );\r\n  \r\n    return col;\r\n}\r\n\r\nvec3 getLightColor( in vec3 pos ) {\r\n    vec3 lcol = vec3( 1., .7, .5 );\r\n    \r\n\tvec3 pd = pos;\r\n    pd.x = abs( pd.x );\r\n    pd.z *= -sign( pos.x );\r\n    \r\n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\r\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\r\n\r\n    if( ch > 0.75 ) { // car\r\n        pdc.x += (ch-0.75)*4.;\r\n        if(  sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ), 0.25) < 2. ) {\r\n            lcol = vec3( 1., 0.05, 0.01 );\r\n        }\r\n    }\r\n    if( pd.y > 2. && abs(pd.x) > 10. && pd.y < 5. ) {\r\n        float fl = floor( pd.z/13. );\r\n        lcol = 0.4*lcol+0.5*vec3( hash( .1562+fl ), hash( .423134+fl ), 0. );\r\n    }\r\n    if(  abs(pd.x) > 10. && pd.y > 5. ) {\r\n        float fl = floor( pd.z/2. );\r\n        lcol = 0.5*lcol+0.5*vec3( hash( .1562+fl ),  hash( .923134+fl ), hash( .423134+fl ) );\r\n    }\r\n   \r\n    return lcol;\r\n}\r\n\r\nfloat randomStart(vec2 co){return 0.8+0.2*hash(dot(co,vec2(123.42,117.853))*412.453);}\r\n\r\n//----------------------------------------------------------------------\r\n// main\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n\tvec2 p = -1.0 + 2.0*q;\r\n\tp.x *= iResolution.x / iResolution.y;\r\n        \r\n    if (q.y < .12 || q.y >= .88) {\r\n\t\tfragColor=vec4(0.,0.,0.,1.);\r\n\t\treturn;\r\n    } else {\r\n    \r\n        // camera\r\n        float z = time;\r\n        float x = -10.9+1.*sin(time*0.2);\r\n        vec3 ro = vec3(x,  1.3+.3*cos(time*0.26), z-1.);\r\n        vec3 ta = vec3(-8.,1.3+.4*cos(time*0.26), z+4.+cos(time*0.04));\r\n\r\n        vec3 ww = normalize( ta - ro );\r\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n        vec3 vv = normalize( cross(uu,ww));\r\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\r\n\r\n        vec3 col = backgroundColor;\r\n\r\n        // raymarch\r\n        float ints = intersect(ro+randomStart(p)*rd ,rd );\r\n        if(  ints > -0.5 ) {\r\n\r\n            // calculate reflectance\r\n            float r = 0.09;     \t        \r\n            if( int1.y > 0.129 ) r = 0.025 * hash(  133.1234*floor( int1.y / 3. ) + floor( int1.z / 3. ) );\r\n            if( abs(int1.x) < 8. ) {\r\n                if( int1.y < 0.01 ) { // road\r\n                    r = 0.007*fbm(int1.xz);\r\n                } else { // car\r\n                    r = 0.02;\r\n                }\r\n            }\r\n            if( abs( int1.x ) < 0.1 ) r *= 4.;\r\n            if( abs( abs( int1.x )-7.4 ) < 0.1 ) r *= 4.;\r\n\r\n            r *= 2.;\r\n\r\n            col = shade( ro, int1.xyz, nor1 );\r\n\r\n            if( ints > 0.5 ) {\r\n                col += r * shade( int1.xyz, int2.xyz, calcNormalSimple(int2.xyz) );\r\n            }  \r\n            if( lint2.w > 0. ) {            \r\n                col += (r*LIGHTINTENSITY*exp(-lint2.w*7.0)) * getLightColor(lint2.xyz);\r\n            } \r\n        } \r\n\r\n        // Rain (by Dave Hoskins)\r\n        vec2 st = 256. * ( p* vec2(.5, .01)+vec2(time*.13-q.y*.6, time*.13) );\r\n        float f = noise( st ) * noise( st*0.773) * 1.55;\r\n        f = 0.25+ clamp(pow(abs(f), 13.0) * 13.0, 0.0, q.y*.14);\r\n\r\n        if( lint1.w > 0. ) {\r\n            col += (f*LIGHTINTENSITY*exp(-lint1.w*7.0)) * getLightColor(lint1.xyz);\r\n        }  \r\n\r\n        col += 0.25*f*(0.2+backgroundColor);\r\n\r\n        // post processing\r\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n        col *= 1.2*vec3(1.,0.99,0.95);   \r\n        col = clamp(1.06*col-0.03, 0., 1.);  \r\n        q.y = (q.y-.12)*(1./0.76);\r\n        col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 ); \r\n\r\n        fragColor = vec4( col, 1.0 );\r\n    }\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by Reinder Nijhoff 2014\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/Xtf3zn\r\n//\r\n// car model is made by Eiffie\r\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\r\n\r\n#define BUMPMAP\r\n#define MARCHSTEPS 128\r\n#define MARCHSTEPSREFLECTION 48\r\n#define LIGHTINTENSITY 5.\r\n\r\n//----------------------------------------------------------------------\r\n\r\nconst vec3 backgroundColor = vec3(0.2,0.4,0.6) * 0.09;\r\n#define time (iTime + 90.)\r\n\r\n//----------------------------------------------------------------------\r\n// noises\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*687.3123);\r\n}\r\n\r\nfloat noise( in vec2 x ) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0;\r\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\r\n}\r\n\r\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\r\n\r\nfloat fbm( vec2 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n    f += 0.1250*noise( p ); p = m2*p*2.01;\r\n//    f += 0.0625*noise( p );\r\n    \r\n    return f/0.9375;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// distance primitives\r\n\r\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\r\n  return length(max(abs(p)-b,0.0))-r;\r\n}\r\n\r\nfloat sdBox( in vec3 p, in vec3 b ) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat sdSphere( in vec3 p, in float s ) {\r\n    return length(p)-s;\r\n}\r\n\r\nfloat sdCylinder( in vec3 p, in vec2 h ) {\r\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// distance operators\r\n\r\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\r\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\r\nfloat smin( float a, float b, float k ) { return -log(exp(-k*a)+exp(-k*b))/k; } //from iq\r\n\r\n//----------------------------------------------------------------------\r\n// Map functions\r\n\r\n// car model is made by Eiffie\r\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\r\n\r\nfloat mapCar(in vec3 p0){ \r\n\tvec3 p=p0+vec3(0.0,1.24,0.0);\r\n\tfloat r=length(p.yz);\r\n\tfloat d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\r\n\td=max(d,p.z-1.0);\r\n\tp=p0+vec3(0.0,-0.22,0.39);\r\n\tp.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\r\n\tr=length(p.yz);\r\n\td=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\r\n\td=max(d,-max(p.x-0.165,r-0.24));\r\n\tfloat d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\r\n\td=min(d,d2);\r\n\r\n\treturn d;\r\n}\r\n\r\nfloat dL; // minimal distance to light\r\n\r\nfloat map( const in vec3 p ) {\r\n\tvec3 pd = p;\r\n    float d;\r\n    \r\n    pd.x = abs( pd.x );\r\n    pd.z *= -sign( p.x );\r\n    \r\n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\r\n    float lh = hash( floor( pd.z/13. ) );\r\n    \r\n    vec3 pdm = vec3( pd.x, pd.y, mod( pd.z, 10.) - 5. );\r\n    dL = sdSphere( vec3(pdm.x-8.1,pdm.y-4.5,pdm.z), 0.1 );\r\n    \r\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-9.5-lh,  mod( pd.z, 91.) - 45.5 ), vec3(0.2,4.5, 0.2) ) );\r\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-11.5+lh, mod( pd.z, 31.) - 15.5 ), vec3(0.22,5.5, 0.2) ) );\r\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-8.5-lh,  mod( pd.z, 41.) - 20.5 ), vec3(0.24,3.5, 0.2) ) );\r\n   \r\n    if( lh > 0.5 ) {\r\n\t    dL = opU( dL, sdBox( vec3(pdm.x-12.5,pdm.y-2.75-lh,  mod( pd.z, 13.) - 6.5 ), vec3(0.1,0.25, 3.2) ) );\r\n    }\r\n    \r\n    vec3 pm = vec3( mod( pd.x + floor( pd.z * 4. )*0.25, 0.5 ) - 0.25, pd.y, mod( pd.z, 0.25 ) - 0.125 );\r\n\td = udRoundBox( pm, vec3( 0.245,0.1, 0.12 ), 0.005 ); \r\n    \r\n    d = opS( d, -(p.x+8.) );\r\n    d = opU( d, pd.y );\r\n\r\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\r\n    \r\n    // car\r\n    if( ch > 0.75 ) {\r\n        pdc.x += (ch-0.75)*4.;\r\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ),    0.025 ) );\r\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.2,  pdc.y-0.65,  pdc.z+6.05 ), 0.025 ) );\r\n\r\n        d = opU( d,  mapCar( (pdc-vec3(5.,-0.025,-2.3))*0.45 ) );\r\n \t}\r\n    \r\n    d = opU( d, 13.-pd.x );\r\n    d = opU( d, sdCylinder( vec3(pdm.x-8.5, pdm.y, pdm.z), vec2(0.075,4.5)) );\r\n    d = opU( d, dL );\r\n    \r\n\treturn d;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n\r\nvec3 calcNormalSimple( in vec3 pos ) {   \r\n    const vec2 e = vec2(1.0,-1.0)*0.005;\r\n\r\n    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + \r\n\t\t\t\t\t    e.yyx*map( pos + e.yyx )   + \r\n\t\t\t\t\t    e.yxy*map( pos + e.yxy )   + \r\n\t\t\t\t\t    e.xxx*map( pos + e.xxx )   );  \r\n    return n;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos ) {\r\n    vec3 n = calcNormalSimple( pos );\r\n    if( pos.y > 0.12 ) return n;\r\n\r\n#ifdef BUMPMAP\r\n    vec2 oc = floor( vec2(pos.x+floor( pos.z * 4. )*0.25, pos.z) * vec2( 2., 4. ) );\r\n\r\n    if( abs(pos.x)<8. ) {\r\n\t\toc = pos.xz;\r\n    }\r\n    \r\n     vec3 p = pos * 250.;\r\n   \t vec3 xn = 0.05*vec3(noise(p.xz)-0.5,0.,noise(p.zx)-0.5);\r\n     xn += 0.1*vec3(fbm(oc.xy)-0.5,0.,fbm(oc.yx)-0.5);\r\n    \r\n    n = normalize( xn + n );\r\n#endif\r\n    \r\n    return n;\r\n}\r\n\r\nvec3 int1, int2, nor1;\r\nvec4 lint1, lint2;\r\n\r\nfloat intersect( in vec3 ro, in vec3 rd ) {\r\n\tconst float precis = 0.001;\r\n    float h = precis*2.0;\r\n    float t = 0.;\r\n    int1 = int2 = vec3( -500. );\r\n    lint1 = lint2 = vec4( -500. );\r\n    float mld = 100.;\r\n    \r\n\tfor( int i=0; i < MARCHSTEPS; i++ ) {\r\n        h = map( ro+rd*t );\r\n\t\tif(dL < mld){\r\n\t\t\tmld=dL;\r\n            lint1.xyz = ro+rd*t;\r\n\t\t\tlint1.w = abs(dL);\r\n\t\t}\r\n        if( h < precis ) {\r\n            int1.xyz = ro+rd*t;\r\n            break;\r\n        } \r\n        t += max(h, precis*2.);\r\n    }\r\n    \r\n    if( int1.z < -400. || t > 300.) {\r\n        // check intersection with plane y = -0.1;\r\n        float d = -(ro.y + 0.1)/rd.y;\r\n\t\tif( d > 0. ) {\r\n\t\t\tint1.xyz = ro+rd*d;\r\n\t    } else {\r\n        \treturn -1.;\r\n    \t}\r\n    }\r\n    \r\n    ro = ro + rd*t;\r\n    nor1 = calcNormal(ro);\r\n    ro += 0.01*nor1;\r\n    rd = reflect( rd, nor1 );\r\n    t = 0.0;\r\n    h = precis*2.0;\r\n    mld = 100.;\r\n    \r\n    for( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\r\n        h = map( ro+rd*t );\r\n\t\tif(dL < mld){\r\n\t\t\tmld=dL;            \r\n            lint2.xyz = ro+rd*t;\r\n\t\t\tlint2.w = abs(dL);\r\n\t\t}\r\n        if( h < precis ) {\r\n   \t\t\tint2.xyz = ro+rd*t;\r\n            return 1.;\r\n        }   \r\n        t += max(h, precis*2.);\r\n    }\r\n\r\n    return 0.;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n// shade\r\n\r\nvec3 shade( in vec3 ro, in vec3 pos, in vec3 nor ) {\r\n    vec3  col = vec3(0.5);\r\n    \r\n    if( abs(pos.x) > 15. || abs(pos.x) < 8. ) col = vec3( 0.02 );\r\n    if( pos.y < 0.01 ) {\r\n        if( abs( int1.x ) < 0.1 ) col = vec3( 0.9 );\r\n        if( abs( abs( int1.x )-7.4 ) < 0.1 ) col = vec3( 0.9 );\r\n    }    \r\n    \r\n    float sh = clamp( dot( nor, normalize( vec3( -0.3, 0.3, -0.5 ) ) ), 0., 1.);\r\n  \tcol *= (sh * backgroundColor);  \r\n \r\n    if( abs( pos.x ) > 12.9 && pos.y > 9.) { // windows\r\n        float ha = hash(  133.1234*floor( pos.y / 3. ) + floor( (pos.z) / 3. ) );\r\n        if( ha > 0.95) {\r\n            col = ( (ha-0.95)*10.) * vec3( 1., 0.7, 0.4 );\r\n        }\r\n    }\r\n    \r\n\tcol = mix(  backgroundColor, col, exp( min(max(0.1*pos.y,0.25)-0.065*distance(pos, ro),0.) ) );\r\n  \r\n    return col;\r\n}\r\n\r\nvec3 getLightColor( in vec3 pos ) {\r\n    vec3 lcol = vec3( 1., .7, .5 );\r\n    \r\n\tvec3 pd = pos;\r\n    pd.x = abs( pd.x );\r\n    pd.z *= -sign( pos.x );\r\n    \r\n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\r\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\r\n\r\n    if( ch > 0.75 ) { // car\r\n        pdc.x += (ch-0.75)*4.;\r\n        if(  sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ), 0.25) < 2. ) {\r\n            lcol = vec3( 1., 0.05, 0.01 );\r\n        }\r\n    }\r\n    if( pd.y > 2. && abs(pd.x) > 10. && pd.y < 5. ) {\r\n        float fl = floor( pd.z/13. );\r\n        lcol = 0.4*lcol+0.5*vec3( hash( .1562+fl ), hash( .423134+fl ), 0. );\r\n    }\r\n    if(  abs(pd.x) > 10. && pd.y > 5. ) {\r\n        float fl = floor( pd.z/2. );\r\n        lcol = 0.5*lcol+0.5*vec3( hash( .1562+fl ),  hash( .923134+fl ), hash( .423134+fl ) );\r\n    }\r\n   \r\n    return lcol;\r\n}\r\n\r\nfloat randomStart(vec2 co){return 0.8+0.2*hash(dot(co,vec2(123.42,117.853))*412.453);}\r\n\r\n//----------------------------------------------------------------------\r\n// main\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n\tvec2 p = -1.0 + 2.0*q;\r\n\tp.x *= iResolution.x / iResolution.y;\r\n        \r\n    if (q.y < .12 || q.y >= .88) {\r\n\t\tfragColor=vec4(0.,0.,0.,1.);\r\n\t\treturn;\r\n    } else {\r\n    \r\n        // camera\r\n        float z = time;\r\n        float x = -10.9+1.*sin(time*0.2);\r\n        vec3 ro = vec3(x,  1.3+.3*cos(time*0.26), z-1.);\r\n        vec3 ta = vec3(-8.,1.3+.4*cos(time*0.26), z+4.+cos(time*0.04));\r\n\r\n        vec3 ww = normalize( ta - ro );\r\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n        vec3 vv = normalize( cross(uu,ww));\r\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\r\n\r\n        vec3 col = backgroundColor;\r\n\r\n        // raymarch\r\n        float ints = intersect(ro+randomStart(p)*rd ,rd );\r\n        if(  ints > -0.5 ) {\r\n\r\n            // calculate reflectance\r\n            float r = 0.09;     \t        \r\n            if( int1.y > 0.129 ) r = 0.025 * hash(  133.1234*floor( int1.y / 3. ) + floor( int1.z / 3. ) );\r\n            if( abs(int1.x) < 8. ) {\r\n                if( int1.y < 0.01 ) { // road\r\n                    r = 0.007*fbm(int1.xz);\r\n                } else { // car\r\n                    r = 0.02;\r\n                }\r\n            }\r\n            if( abs( int1.x ) < 0.1 ) r *= 4.;\r\n            if( abs( abs( int1.x )-7.4 ) < 0.1 ) r *= 4.;\r\n\r\n            r *= 2.;\r\n\r\n            col = shade( ro, int1.xyz, nor1 );\r\n\r\n            if( ints > 0.5 ) {\r\n                col += r * shade( int1.xyz, int2.xyz, calcNormalSimple(int2.xyz) );\r\n            }  \r\n            if( lint2.w > 0. ) {            \r\n                col += (r*LIGHTINTENSITY*exp(-lint2.w*7.0)) * getLightColor(lint2.xyz);\r\n            } \r\n        } \r\n\r\n        // Rain (by Dave Hoskins)\r\n        vec2 st = 256. * ( p* vec2(.5, .01)+vec2(time*.13-q.y*.6, time*.13) );\r\n        float f = noise( st ) * noise( st*0.773) * 1.55;\r\n        f = 0.25+ clamp(pow(abs(f), 13.0) * 13.0, 0.0, q.y*.14);\r\n\r\n        if( lint1.w > 0. ) {\r\n            col += (f*LIGHTINTENSITY*exp(-lint1.w*7.0)) * getLightColor(lint1.xyz);\r\n        }  \r\n\r\n        col += 0.25*f*(0.2+backgroundColor);\r\n\r\n        // post processing\r\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n        col *= 1.2*vec3(1.,0.99,0.95);   \r\n        col = clamp(1.06*col-0.03, 0., 1.);  \r\n        q.y = (q.y-.12)*(1./0.76);\r\n        col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 ); \r\n\r\n        fragColor = vec4( col, 1.0 );\r\n    }\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//bloom and DOF. Check buffer's #define to tweak the shape\r\nfloat [] blurWeights = float[](0.002216,\r\n   0.008764,\r\n   0.026995,\r\n   0.064759,\r\n   0.120985,\r\n   0.176033,\r\n   0.199471,\r\n   0.176033,\r\n   0.120985,\r\n   0.064759,\r\n   0.026995,\r\n   0.008764,\r\n   0.002216);\r\n\r\nvec4 blur (vec2 uv)\r\n{\r\n    vec4 res;\r\n\tfor (int x = - 6; x < 6; x ++)\r\n    {\r\n    \tfor (int y = -6 ; y < 6; y ++)\r\n        {\r\n            res += blurWeights[x+6]*blurWeights[y+6] * texture( iChannel0, ( uv * iResolution.xy + vec2 (x,y) ) / iResolution.xy);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n  \r\n   \tvec4 buf = texture( iChannel0, ( uv));\r\n    vec3 blr = blur(uv).rgb;\r\n    float near =3.; float mid = 9.; float far = 15.;\r\n    float curve = smoothstep(0.,near,buf.w)* smoothstep(far,mid,buf.w);\r\n    vec3 col = mix (blr,buf.rgb,curve);\r\n    col.rgb += 0.5*blr;\r\n\r\n    fragColor = vec4 (col,1.);\r\n}","inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"//bloom and DOF. Check buffer's #define to tweak the shape\r\nfloat [] blurWeights = float[](0.002216,\r\n   0.008764,\r\n   0.026995,\r\n   0.064759,\r\n   0.120985,\r\n   0.176033,\r\n   0.199471,\r\n   0.176033,\r\n   0.120985,\r\n   0.064759,\r\n   0.026995,\r\n   0.008764,\r\n   0.002216);\r\n\r\nvec4 blur (vec2 uv)\r\n{\r\n    vec4 res;\r\n\tfor (int x = - 6; x < 6; x ++)\r\n    {\r\n    \tfor (int y = -6 ; y < 6; y ++)\r\n        {\r\n            res += blurWeights[x+6]*blurWeights[y+6] * texture( iChannel0, ( uv * iResolution.xy + vec2 (x,y) ) / iResolution.xy);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n  \r\n   \tvec4 buf = texture( iChannel0, ( uv));\r\n    vec3 blr = blur(uv).rgb;\r\n    float near =3.; float mid = 9.; float far = 15.;\r\n    float curve = smoothstep(0.,near,buf.w)* smoothstep(far,mid,buf.w);\r\n    vec3 col = mix (blr,buf.rgb,curve);\r\n    col.rgb += 0.5*blr;\r\n\r\n    fragColor = vec4 (col,1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0}],"Info":{"Name":"Colored lines","id":null,"date":null,"viewed":0,"name":"Colored lines","description":"","likes":0,"published":null,"tags":[""]},"ver":null,"info":{"Name":"Colored lines","id":null,"date":null,"viewed":0,"name":"Colored lines","description":"","likes":0,"published":null,"tags":[""]},"renderpass":[{"Code":"//bloom and DOF. Check buffer's #define to tweak the shape\r\nfloat [] blurWeights = float[](0.002216,\r\n   0.008764,\r\n   0.026995,\r\n   0.064759,\r\n   0.120985,\r\n   0.176033,\r\n   0.199471,\r\n   0.176033,\r\n   0.120985,\r\n   0.064759,\r\n   0.026995,\r\n   0.008764,\r\n   0.002216);\r\n\r\nvec4 blur (vec2 uv)\r\n{\r\n    vec4 res;\r\n\tfor (int x = - 6; x < 6; x ++)\r\n    {\r\n    \tfor (int y = -6 ; y < 6; y ++)\r\n        {\r\n            res += blurWeights[x+6]*blurWeights[y+6] * texture( iChannel0, ( uv * iResolution.xy + vec2 (x,y) ) / iResolution.xy);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n  \r\n   \tvec4 buf = texture( iChannel0, ( uv));\r\n    vec3 blr = blur(uv).rgb;\r\n    float near =3.; float mid = 9.; float far = 15.;\r\n    float curve = smoothstep(0.,near,buf.w)* smoothstep(far,mid,buf.w);\r\n    vec3 col = mix (blr,buf.rgb,curve);\r\n    col.rgb += 0.5*blr;\r\n\r\n    fragColor = vec4 (col,1.);\r\n}","inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"//bloom and DOF. Check buffer's #define to tweak the shape\r\nfloat [] blurWeights = float[](0.002216,\r\n   0.008764,\r\n   0.026995,\r\n   0.064759,\r\n   0.120985,\r\n   0.176033,\r\n   0.199471,\r\n   0.176033,\r\n   0.120985,\r\n   0.064759,\r\n   0.026995,\r\n   0.008764,\r\n   0.002216);\r\n\r\nvec4 blur (vec2 uv)\r\n{\r\n    vec4 res;\r\n\tfor (int x = - 6; x < 6; x ++)\r\n    {\r\n    \tfor (int y = -6 ; y < 6; y ++)\r\n        {\r\n            res += blurWeights[x+6]*blurWeights[y+6] * texture( iChannel0, ( uv * iResolution.xy + vec2 (x,y) ) / iResolution.xy);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n  \r\n   \tvec4 buf = texture( iChannel0, ( uv));\r\n    vec3 blr = blur(uv).rgb;\r\n    float near =3.; float mid = 9.; float far = 15.;\r\n    float curve = smoothstep(0.,near,buf.w)* smoothstep(far,mid,buf.w);\r\n    vec3 col = mix (blr,buf.rgb,curve);\r\n    col.rgb += 0.5*blr;\r\n\r\n    fragColor = vec4 (col,1.);\r\n}","name":"Image","description":null,"type":"image"},{"Code":"//Marching parameters\r\n#define MAXSTEPS 50\r\n#define HITTHRESHOLD 0.009\r\n#define FAR 25.\r\n//AA : change to 1 to turn it off\r\n#define AA 2\r\n//IFS iterations : try 2 or 3\r\n#define NIFS 6\r\n//scale and translate for the IFS in-loop transformation\r\n#define SCALE 2.3\r\n#define TRANSLATE 3.5\r\n\r\nmat2x2 rot(float angle)\r\n{\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return mat2x2(c, -s,\r\n\t\t\t\t  s, c);\r\n}\r\n\r\nvec4 sd2d(vec2 p, float o)\r\n{\r\n    float time = 0.2*o+0.6*iTime;\r\n \tfloat s =0.5;\r\n    p*= s;\r\n    float RADIUS =(1.+sin(iTime));\r\n    int i;\r\n    vec3 col;  \r\n    p = p*rot(-0.4*time);// twist\r\n\r\n    for ( i = 0; i<NIFS; i++)\r\n    {        \r\n        if (p.x<0.) {p.x = -p.x;col.r++;}\r\n\t\tp = p*rot(0.9*sin(time));\r\n        if (p.y<0.) {p.y = -p.y;col.g++; }\r\n        if (p.x-p.y<0.){ p.xy = p.yx;col.b++;}        \r\n      \tp = p*SCALE-TRANSLATE;\r\n        p = p*rot(0.3*(iTime));\r\n    }\r\n    \r\n    float d = 0.425*(length(p)-RADIUS) * pow(SCALE, float(-i))/s;\r\n    col/=float(NIFS);\r\n    vec3 oc = mix(vec3(0.7,col.g,0.2),vec3(0.2,col.r,0.7), col.b);\r\n    \r\n    return vec4(oc,d);\r\n}\r\n\r\nvec4 map (vec3 p)\r\n{\r\n\treturn sd2d(p.xz,p.y);\r\n}\r\n\r\nfloat shadow(vec3 ro, vec3 rd)\r\n{\r\n    float h = 0.;\r\n    float k =3.5;//shadowSmooth\r\n    float res = 1.;\r\n    float t = 0.2; //bias\r\n    for (int i = 0; t < 15.; i++) // t < shadowMaxDist\r\n    {\r\n        h = map(ro + rd * t).w;\r\n\t\tres = min(res, k*h / t);\r\n        if (h < HITTHRESHOLD)\r\n        {\r\n           break;\r\n        }\r\n        t = t + h;\r\n    }\r\n    return clamp(res+0.05,0.,1.);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{ \r\n    //camera\r\n    float height = -0.4;\r\n    float rot=iTime*0.1;\r\n    float dist= 9.+1.*sin(0.5*iTime);\r\n    vec3 ro = dist * vec3(cos(rot),height,sin(rot));\r\n   \tvec3 lookAt = vec3 (0.,0.,0.);\r\n    vec3 fw = normalize(lookAt-ro);\r\n    //tilting camera for a \"weirder\" feel when rotating around Y axis\r\n    vec3 right = normalize(cross(vec3(0.,1.,1.0), fw));\r\n    vec3 up = normalize(cross (fw, right));\r\n    right = normalize(cross(up,fw));\r\n    \r\n    //light\r\n    rot+=sin(iTime)*0.2;\r\n    vec3 lightPos =  dist * vec3(cos(rot),height,sin(rot));\r\n    \r\n    //raymarch\r\n    vec3 pos, closest;\r\n    float t;\r\n    float smallest;\r\n    int i;\r\n    vec3 sdfCol; \r\n    vec3 col;\r\n    \r\n    for (int x=0; x<AA;x++)\r\n    for (int y=0; y<AA;y++)\r\n    {\r\n        t = 0.; smallest = 500.;\r\n        vec2 o = vec2(float(x),float(y)) / float(AA) - 0.5;\r\n        vec2 uv = (fragCoord+o)/iResolution.xy;\r\n        uv -= 0.5;\r\n        uv.x *= iResolution.x/iResolution.y; \r\n        vec3 rd = normalize( fw *0.5 + right * uv.x + up * uv.y);  \r\n        \r\n        for ( i=0; i<MAXSTEPS; i++)\r\n        {\r\n            pos = ro + rd *t;   \r\n            vec4 mr = map(pos);\r\n            float d = mr.w;\r\n            if (d < smallest) smallest = d; closest = pos; sdfCol = mr.rgb;\r\n            if (abs(d)<HITTHRESHOLD || t> FAR) {break;}\r\n            t +=d;\r\n        }   \r\n        pos = closest;\r\n        vec3 c;\r\n        if (t<FAR)\r\n        { \r\n            c = sdfCol; \r\n            vec3 toLight = normalize(lightPos-pos);\r\n            float s = shadow(pos,toLight);\r\n            c*=s; \r\n          \tc = mix(c, 1.5*c,1.-s);\r\n        }\r\n        else \r\n        {\r\n            c = vec3(0.);                \r\n        }     \r\n        col += c;\r\n    }\r\n    col/=float(AA*AA);\r\n    \r\n    fragColor = vec4 (col,t);\r\n}\r\n","inputs":[],"outputs":[],"code":"//Marching parameters\r\n#define MAXSTEPS 50\r\n#define HITTHRESHOLD 0.009\r\n#define FAR 25.\r\n//AA : change to 1 to turn it off\r\n#define AA 2\r\n//IFS iterations : try 2 or 3\r\n#define NIFS 6\r\n//scale and translate for the IFS in-loop transformation\r\n#define SCALE 2.3\r\n#define TRANSLATE 3.5\r\n\r\nmat2x2 rot(float angle)\r\n{\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return mat2x2(c, -s,\r\n\t\t\t\t  s, c);\r\n}\r\n\r\nvec4 sd2d(vec2 p, float o)\r\n{\r\n    float time = 0.2*o+0.6*iTime;\r\n \tfloat s =0.5;\r\n    p*= s;\r\n    float RADIUS =(1.+sin(iTime));\r\n    int i;\r\n    vec3 col;  \r\n    p = p*rot(-0.4*time);// twist\r\n\r\n    for ( i = 0; i<NIFS; i++)\r\n    {        \r\n        if (p.x<0.) {p.x = -p.x;col.r++;}\r\n\t\tp = p*rot(0.9*sin(time));\r\n        if (p.y<0.) {p.y = -p.y;col.g++; }\r\n        if (p.x-p.y<0.){ p.xy = p.yx;col.b++;}        \r\n      \tp = p*SCALE-TRANSLATE;\r\n        p = p*rot(0.3*(iTime));\r\n    }\r\n    \r\n    float d = 0.425*(length(p)-RADIUS) * pow(SCALE, float(-i))/s;\r\n    col/=float(NIFS);\r\n    vec3 oc = mix(vec3(0.7,col.g,0.2),vec3(0.2,col.r,0.7), col.b);\r\n    \r\n    return vec4(oc,d);\r\n}\r\n\r\nvec4 map (vec3 p)\r\n{\r\n\treturn sd2d(p.xz,p.y);\r\n}\r\n\r\nfloat shadow(vec3 ro, vec3 rd)\r\n{\r\n    float h = 0.;\r\n    float k =3.5;//shadowSmooth\r\n    float res = 1.;\r\n    float t = 0.2; //bias\r\n    for (int i = 0; t < 15.; i++) // t < shadowMaxDist\r\n    {\r\n        h = map(ro + rd * t).w;\r\n\t\tres = min(res, k*h / t);\r\n        if (h < HITTHRESHOLD)\r\n        {\r\n           break;\r\n        }\r\n        t = t + h;\r\n    }\r\n    return clamp(res+0.05,0.,1.);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{ \r\n    //camera\r\n    float height = -0.4;\r\n    float rot=iTime*0.1;\r\n    float dist= 9.+1.*sin(0.5*iTime);\r\n    vec3 ro = dist * vec3(cos(rot),height,sin(rot));\r\n   \tvec3 lookAt = vec3 (0.,0.,0.);\r\n    vec3 fw = normalize(lookAt-ro);\r\n    //tilting camera for a \"weirder\" feel when rotating around Y axis\r\n    vec3 right = normalize(cross(vec3(0.,1.,1.0), fw));\r\n    vec3 up = normalize(cross (fw, right));\r\n    right = normalize(cross(up,fw));\r\n    \r\n    //light\r\n    rot+=sin(iTime)*0.2;\r\n    vec3 lightPos =  dist * vec3(cos(rot),height,sin(rot));\r\n    \r\n    //raymarch\r\n    vec3 pos, closest;\r\n    float t;\r\n    float smallest;\r\n    int i;\r\n    vec3 sdfCol; \r\n    vec3 col;\r\n    \r\n    for (int x=0; x<AA;x++)\r\n    for (int y=0; y<AA;y++)\r\n    {\r\n        t = 0.; smallest = 500.;\r\n        vec2 o = vec2(float(x),float(y)) / float(AA) - 0.5;\r\n        vec2 uv = (fragCoord+o)/iResolution.xy;\r\n        uv -= 0.5;\r\n        uv.x *= iResolution.x/iResolution.y; \r\n        vec3 rd = normalize( fw *0.5 + right * uv.x + up * uv.y);  \r\n        \r\n        for ( i=0; i<MAXSTEPS; i++)\r\n        {\r\n            pos = ro + rd *t;   \r\n            vec4 mr = map(pos);\r\n            float d = mr.w;\r\n            if (d < smallest) smallest = d; closest = pos; sdfCol = mr.rgb;\r\n            if (abs(d)<HITTHRESHOLD || t> FAR) {break;}\r\n            t +=d;\r\n        }   \r\n        pos = closest;\r\n        vec3 c;\r\n        if (t<FAR)\r\n        { \r\n            c = sdfCol; \r\n            vec3 toLight = normalize(lightPos-pos);\r\n            float s = shadow(pos,toLight);\r\n            c*=s; \r\n          \tc = mix(c, 1.5*c,1.-s);\r\n        }\r\n        else \r\n        {\r\n            c = vec3(0.);                \r\n        }     \r\n        col += c;\r\n    }\r\n    col/=float(AA*AA);\r\n    \r\n    fragColor = vec4 (col,t);\r\n}\r\n","name":"Buf A","description":null,"type":null}]},{"Ver":null,"ImageRenderpass":{"Code":"// Weather. By David Hoskins, May 2014.\r\n// @ https://www.shadertoy.com/view/4dsXWn\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Who needs mathematically correct simulations?! :)\r\n// It ray-casts to the bottom layer then steps through to the top layer.\r\n// It uses the same number of steps for all positions.\r\n// The larger steps at the horizon don't cause problems as they are far away.\r\n// So the detail is where it matters.\r\n// Unfortunately this can't be used to go through the cloud layer,\r\n// but it's fast and has a massive draw distance.\r\n\r\nvec3 sunLight  = normalize( vec3(  0.35, 0.14,  0.3 ) );\r\nconst vec3 sunColour = vec3(1.0, .7, .55);\r\nfloat gTime, cloudy;\r\nvec3 flash;\r\n\r\n#define CLOUD_LOWER 2800.0\r\n#define CLOUD_UPPER 3800.0\r\n\r\n#define TEXTURE_NOISE\r\n\r\n#define MOD2 vec2(.16632,.17369)\r\n#define MOD3 vec3(.16532,.17369,.15787)\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Hash( float p )\r\n{\r\n\tvec2 p2 = fract(vec2(p) * MOD2);\r\n    p2 += dot(p2.yx, p2.xy+19.19);\r\n\treturn fract(p2.x * p2.y);\r\n}\r\nfloat Hash(vec3 p)\r\n{\r\n\tp  = fract(p * MOD3);\r\n    p += dot(p.xyz, p.yzx + 19.19);\r\n    return fract(p.x * p.y * p.z);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n#ifdef TEXTURE_NOISE\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Noise( in vec2 f )\r\n{\r\n    vec2 p = floor(f);\r\n    f = fract(f);\r\n    f = f*f*(3.0-2.0*f);\r\n    float res = textureLod(iChannel0, (p+f+.5)/256.0, 0.0).x;\r\n    return res;\r\n}\r\nfloat Noise( in vec3 x )\r\n{\r\n    #if 0\r\n    return texture(iChannel2, x*0.05).x;\r\n    #else\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n    #endif\r\n}\r\n#else\r\n\r\n//--------------------------------------------------------------------------\r\n\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0;\r\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\r\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\r\n    return res;\r\n}\r\nfloat Noise(in vec3 p)\r\n{\r\n    vec3 i = floor(p);\r\n\tvec3 f = fract(p); \r\n\tf *= f * (3.0-2.0*f);\r\n\r\n    return mix(\r\n\t\tmix(mix(Hash(i + vec3(0.,0.,0.)), Hash(i + vec3(1.,0.,0.)),f.x),\r\n\t\t\tmix(Hash(i + vec3(0.,1.,0.)), Hash(i + vec3(1.,1.,0.)),f.x),\r\n\t\t\tf.y),\r\n\t\tmix(mix(Hash(i + vec3(0.,0.,1.)), Hash(i + vec3(1.,0.,1.)),f.x),\r\n\t\t\tmix(Hash(i + vec3(0.,1.,1.)), Hash(i + vec3(1.,1.,1.)),f.x),\r\n\t\t\tf.y),\r\n\t\tf.z);\r\n}\r\n#endif\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n                    -0.80,  0.36, -0.48,\r\n                    -0.60, -0.48,  0.64 ) * 1.7;\r\n//--------------------------------------------------------------------------\r\nfloat FBM( vec3 p )\r\n{\r\n\tp*= .0005;\r\n    float f;\r\n\t\r\n\tf = 0.5000 * Noise(p); p = m*p; //p.y -= gTime*.2;\r\n\tf += 0.2500 * Noise(p); p = m*p; //p.y += gTime*.06;\r\n\tf += 0.1250 * Noise(p); p = m*p;\r\n\tf += 0.0625   * Noise(p); p = m*p;\r\n\tf += 0.03125  * Noise(p); p = m*p;\r\n\tf += 0.015625 * Noise(p);\r\n    return f;\r\n}\r\n//--------------------------------------------------------------------------\r\nfloat FBMSH( vec3 p )\r\n{\r\n\tp*= .0005;\r\n        \r\n    float f;\r\n\t\r\n\tf = 0.5000 * Noise(p); p = m*p; //p.y -= gTime*.2;\r\n\tf += 0.2500 * Noise(p); p = m*p; //p.y += gTime*.06;\r\n\tf += 0.1250 * Noise(p); p = m*p;\r\n\tf += 0.0625   * Noise(p); p = m*p;\r\n//\tf += 0.03125  * Noise(p); p = m*p;\r\n///\tf += 0.015625 * Noise(p);\r\n    return f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat MapSH(vec3 p)\r\n{\r\n\t\r\n\tfloat h = -(FBM(p)-cloudy-.6);\r\n    //h *= smoothstep(CLOUD_LOWER, CLOUD_LOWER+100., p.y);\r\n    //h *= smoothstep(CLOUD_LOWER-500., CLOUD_LOWER, p.y);\r\n    h *= smoothstep(CLOUD_UPPER+100., CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n\r\nfloat SeaNoise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0;\r\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\r\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\r\n    return res;\r\n}\r\nfloat SeaFBM( vec2 p )\r\n{\r\n    p*= .001;\r\n    float f;\r\n\tf = (sin(sin(p.x *1.22+gTime) + cos(p.y *.14)+p.x*.15+p.y*1.33-gTime)) * 1.0;\r\n    \r\n\tf += (sin(p.x *.9+gTime + p.y *.3-gTime)) * 1.0;\r\n    f += (cos(p.x *.7-gTime - p.y *.4-gTime)) * .5;\r\n    f += 1.5000 * (.5-abs(SeaNoise(p)-.5)); p =  p * 2.05;\r\n    f += .75000 * (.5-abs(SeaNoise(p)-.5)); p =  p * 2.02;\r\n    f += 0.2500 * SeaNoise(p); p =  p * 2.07;\r\n    f += 0.1250 * SeaNoise(p); p =  p * 2.13;\r\n    //f += 0.0625 * Noise(p);\r\n\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Map(vec3 p)\r\n{\r\n\tfloat h = -(FBM(p)-cloudy-.6);\r\n    \r\n\treturn h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat SeaMap(in vec2 pos)\r\n{\r\n\r\n\treturn SeaFBM(pos) * (20.0 + cloudy*170.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 SeaNormal( in vec3 pos, in float d, out float height)\r\n{\r\n\tfloat p = .005 * d * d / iResolution.x;\r\n\tvec3 nor  \t= vec3(0.0,\t\t    SeaMap(pos.xz), 0.0);\r\n\tvec3 v2\t\t= nor-vec3(p,\t\tSeaMap(pos.xz+vec2(p,0.0)), 0.0);\r\n\tvec3 v3\t\t= nor-vec3(0.0,\t\tSeaMap(pos.xz+vec2(0.0,-p)), -p);\r\n    height = nor.y;\r\n\tnor = cross(v2, v3);\r\n\treturn normalize(nor);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat GetLighting(vec3 p, vec3 s)\r\n{\r\n    float l = MapSH(p)-MapSH(p+s*200.);\r\n    return clamp(-l*2., 0.05, 1.0);\r\n}\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 pos,in vec3 rd, out vec2 outPos)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\t// Do the blue and sun...\t\r\n\tvec3  sky = mix(vec3(.0, .1, .4), vec3(.3, .6, .8), 1.0-rd.y);\r\n\tsky = sky + sunColour * min(pow(sunAmount, 1500.0) * 5.0, 1.0);\r\n\tsky = sky + sunColour * min(pow(sunAmount, 10.0) * .6, 1.0);\r\n\t\r\n\t// Find the start and end of the cloud layer...\r\n\tfloat beg = ((CLOUD_LOWER-pos.y) / rd.y);\r\n\tfloat end = ((CLOUD_UPPER-pos.y) / rd.y);\r\n\t\r\n\t// Start position...\r\n\tvec3 p = vec3(pos.x + rd.x * beg, 0.0, pos.z + rd.z * beg);\r\n\toutPos = p.xz;\r\n    beg +=  Hash(p)*150.0;\r\n\r\n\t// Trace clouds through that layer...\r\n\tfloat d = 0.0;\r\n\tvec3 add = rd * ((end-beg) / 55.0);\r\n\tvec2 shade;\r\n\tvec2 shadeSum = vec2(0.0, .0);\r\n\tshade.x = 1.0;\r\n\t// I think this is as small as the loop can be\r\n\t// for a reasonable cloud density illusion.\r\n\tfor (int i = 0; i < 55; i++)\r\n\t{\r\n\t\tif (shadeSum.y >= 1.0) break;\r\n\t\tfloat h = Map(p);\r\n\t\tshade.y = max(h, 0.0); \r\n\r\n        shade.x = GetLighting(p, sunLight);\r\n\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);\r\n\r\n\t\tp += add;\r\n\t}\r\n\t//shadeSum.x /= 10.0;\r\n\t//shadeSum = min(shadeSum, 1.0);\r\n\t\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, .6)), sunColour, (1.0-shadeSum.y)*.4);\r\n    //vec3 clouds = vec3(shadeSum.x);\r\n\t\r\n\t//clouds += min((1.0-sqrt(shadeSum.y)) * pow(sunAmount, 4.0), 1.0) * 2.0;\r\n   \r\n    clouds += flash * (shadeSum.y+shadeSum.x+.2) * .5;\r\n\r\n\tsky = mix(sky, min(clouds, 1.0), shadeSum.y);\r\n\t\r\n\treturn clamp(sky, 0.0, 1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 GetSea(in vec3 pos,in vec3 rd, out vec2 outPos)\r\n{\r\n\tvec3 sea;\r\n\tfloat d = -pos.y/rd.y;\r\n\tvec3 p = vec3(pos.x + rd.x * d, 0.0, pos.z + rd.z * d);\r\n\toutPos = p.xz;\r\n\t\r\n\tfloat dis = length(p-pos);\r\n    float h = 0.0;\r\n\tvec3 nor = SeaNormal(p, dis, h);\r\n\r\n\tvec3 ref = reflect(rd, nor);\r\n\tref.y = max(ref.y, 0.0015);\r\n\tsea = GetSky(p, ref, p.xz);\r\n\th = h*.005 / (1.0+max(dis*.02-300.0, 0.0));\r\n   \tfloat fresnel = max(dot(nor, -rd),0.0);\r\n    fresnel = pow(fresnel, .3)*1.1;\r\n    \r\n\tsea = mix(sea*.6, (vec3(.3, .4, .45)+h*h) * max(dot(nor, sunLight), 0.0), min(fresnel, 1.0));\r\n\t\r\n\tfloat glit = max(dot(ref, sunLight), 0.0);\r\n\tsea += sunColour * pow(glit, 220.0) * max(-cloudy*100.0, 0.0);\r\n\t\r\n\treturn sea;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n    return vec3(4000.0 * sin(.16*t)+12290.0, 0.0, 8800.0 * cos(.145*t+.3));\r\n} \r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat m = (iMouse.x/iResolution.x)*30.0;\r\n\tgTime = iTime*.5 + m + 75.5;\r\n\tcloudy = cos(gTime * .25+.4) * .26;\r\n    float lightning = 0.0;\r\n    \r\n    if (cloudy >= .2)\r\n    {\r\n        float f = mod(gTime+1.5, 2.5);\r\n        if (f < .8)\r\n        {\r\n            f = smoothstep(.8, .0, f)* 1.5;\r\n        \tlightning = mod(-gTime*(1.5-Hash(gTime*.3)*.002), 1.0) * f;\r\n        }\r\n    }\r\n    \r\n    flash = clamp(vec3(1., 1.0, 1.2) * lightning, 0.0, 1.0);\r\n       \r\n\t\r\n    vec2 xy = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\r\n\t\r\n\tvec3 cameraPos = CameraPath(gTime - 2.0);\r\n\tvec3 camTar\t   = CameraPath(gTime - .0);\r\n\tcamTar.y = cameraPos.y = sin(gTime) * 200.0 + 300.0;\r\n\tcamTar.y += 370.0;\r\n\t\r\n\tfloat roll = .1 * sin(gTime * .25);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = cross(cw,cp);\r\n\tvec3 cv = cross(cu,cw);\r\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\r\n\tmat3 camMat = mat3(cu, cv, cw);\r\n\r\n\tvec3 col;\r\n\tvec2 pos;\r\n\tif (dir.y > 0.0)\r\n\t{\r\n\t\tcol = GetSky(cameraPos, dir, pos);\r\n\t}else\r\n\t{\r\n\t\tcol = GetSea(cameraPos, dir, pos);\r\n\t}\r\n\tfloat l = exp(-length(pos) * .00002);\r\n\tcol = mix(vec3(.6-cloudy*1.2)+flash*.3, col, max(l, .2));\r\n\t\r\n\t// Do the lens flares...\r\n\tfloat bri = dot(cw, sunLight) * 2.7 * clamp(-cloudy+.2, 0.0, .2);\r\n\tif (bri > 0.0)\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\r\n\t\tvec2 uvT = uv-sunPos;\r\n\t\tuvT = uvT*(length(uvT));\r\n\t\tbri = pow(bri, 6.0)*.6;\r\n\r\n\t\tfloat glare1 = max(1.2-length(uvT+sunPos*2.)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2-length(uvT+sunPos*.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, uv, -2.3);\r\n\t\tfloat glare3 = max(1.2-length(uvT+sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * sunColour * vec3(1.0, .5, .2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(.8, .8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * sunColour * pow(glare3, 4.0)*10.0;\r\n\t}\r\n\t\r\n\tvec2 st =  uv * vec2(.5+(xy.y+1.0)*.3, .02)+vec2(gTime*.5+xy.y*.2, gTime*.2);\r\n\t// Rain...\r\n#ifdef TEXTURE_NOISE\r\n \tfloat f = texture(iChannel0, st, -100.0).y * texture(iChannel0, st*.773, -100.0).x * 1.55;\r\n#else\r\n\tfloat f = Noise( st*200.5 ) * Noise( st*120.5 ) * 1.3;\r\n#endif\r\n\tfloat rain = clamp(cloudy-.15, 0.0, 1.0);\r\n\tf = clamp(pow(abs(f), 15.0) * 5.0 * (rain*rain*125.0), 0.0, (xy.y+.1)*.6);\r\n\tcol = mix(col, vec3(0.15, .15, .15)+flash, f);\r\n\tcol = clamp(col, 0.0,1.0);\r\n\r\n\t// Stretch RGB upwards... \r\n\t//col = (1.0 - exp(-col * 2.0)) * 1.1565;\r\n\t//col = (1.0 - exp(-col * 3.0)) * 1.052;\r\n\tcol = pow(col, vec3(.7));\r\n\t//col = (col*col*(3.0-2.0*col));\r\n\r\n\t// Vignette...\r\n\tcol *= .55+0.45*pow(70.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.15 );\t\r\n\t\r\n\tfragColor=vec4(col, 1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"// Weather. By David Hoskins, May 2014.\r\n// @ https://www.shadertoy.com/view/4dsXWn\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Who needs mathematically correct simulations?! :)\r\n// It ray-casts to the bottom layer then steps through to the top layer.\r\n// It uses the same number of steps for all positions.\r\n// The larger steps at the horizon don't cause problems as they are far away.\r\n// So the detail is where it matters.\r\n// Unfortunately this can't be used to go through the cloud layer,\r\n// but it's fast and has a massive draw distance.\r\n\r\nvec3 sunLight  = normalize( vec3(  0.35, 0.14,  0.3 ) );\r\nconst vec3 sunColour = vec3(1.0, .7, .55);\r\nfloat gTime, cloudy;\r\nvec3 flash;\r\n\r\n#define CLOUD_LOWER 2800.0\r\n#define CLOUD_UPPER 3800.0\r\n\r\n#define TEXTURE_NOISE\r\n\r\n#define MOD2 vec2(.16632,.17369)\r\n#define MOD3 vec3(.16532,.17369,.15787)\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Hash( float p )\r\n{\r\n\tvec2 p2 = fract(vec2(p) * MOD2);\r\n    p2 += dot(p2.yx, p2.xy+19.19);\r\n\treturn fract(p2.x * p2.y);\r\n}\r\nfloat Hash(vec3 p)\r\n{\r\n\tp  = fract(p * MOD3);\r\n    p += dot(p.xyz, p.yzx + 19.19);\r\n    return fract(p.x * p.y * p.z);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n#ifdef TEXTURE_NOISE\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Noise( in vec2 f )\r\n{\r\n    vec2 p = floor(f);\r\n    f = fract(f);\r\n    f = f*f*(3.0-2.0*f);\r\n    float res = textureLod(iChannel0, (p+f+.5)/256.0, 0.0).x;\r\n    return res;\r\n}\r\nfloat Noise( in vec3 x )\r\n{\r\n    #if 0\r\n    return texture(iChannel2, x*0.05).x;\r\n    #else\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n    #endif\r\n}\r\n#else\r\n\r\n//--------------------------------------------------------------------------\r\n\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0;\r\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\r\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\r\n    return res;\r\n}\r\nfloat Noise(in vec3 p)\r\n{\r\n    vec3 i = floor(p);\r\n\tvec3 f = fract(p); \r\n\tf *= f * (3.0-2.0*f);\r\n\r\n    return mix(\r\n\t\tmix(mix(Hash(i + vec3(0.,0.,0.)), Hash(i + vec3(1.,0.,0.)),f.x),\r\n\t\t\tmix(Hash(i + vec3(0.,1.,0.)), Hash(i + vec3(1.,1.,0.)),f.x),\r\n\t\t\tf.y),\r\n\t\tmix(mix(Hash(i + vec3(0.,0.,1.)), Hash(i + vec3(1.,0.,1.)),f.x),\r\n\t\t\tmix(Hash(i + vec3(0.,1.,1.)), Hash(i + vec3(1.,1.,1.)),f.x),\r\n\t\t\tf.y),\r\n\t\tf.z);\r\n}\r\n#endif\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n                    -0.80,  0.36, -0.48,\r\n                    -0.60, -0.48,  0.64 ) * 1.7;\r\n//--------------------------------------------------------------------------\r\nfloat FBM( vec3 p )\r\n{\r\n\tp*= .0005;\r\n    float f;\r\n\t\r\n\tf = 0.5000 * Noise(p); p = m*p; //p.y -= gTime*.2;\r\n\tf += 0.2500 * Noise(p); p = m*p; //p.y += gTime*.06;\r\n\tf += 0.1250 * Noise(p); p = m*p;\r\n\tf += 0.0625   * Noise(p); p = m*p;\r\n\tf += 0.03125  * Noise(p); p = m*p;\r\n\tf += 0.015625 * Noise(p);\r\n    return f;\r\n}\r\n//--------------------------------------------------------------------------\r\nfloat FBMSH( vec3 p )\r\n{\r\n\tp*= .0005;\r\n        \r\n    float f;\r\n\t\r\n\tf = 0.5000 * Noise(p); p = m*p; //p.y -= gTime*.2;\r\n\tf += 0.2500 * Noise(p); p = m*p; //p.y += gTime*.06;\r\n\tf += 0.1250 * Noise(p); p = m*p;\r\n\tf += 0.0625   * Noise(p); p = m*p;\r\n//\tf += 0.03125  * Noise(p); p = m*p;\r\n///\tf += 0.015625 * Noise(p);\r\n    return f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat MapSH(vec3 p)\r\n{\r\n\t\r\n\tfloat h = -(FBM(p)-cloudy-.6);\r\n    //h *= smoothstep(CLOUD_LOWER, CLOUD_LOWER+100., p.y);\r\n    //h *= smoothstep(CLOUD_LOWER-500., CLOUD_LOWER, p.y);\r\n    h *= smoothstep(CLOUD_UPPER+100., CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n\r\nfloat SeaNoise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0;\r\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\r\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\r\n    return res;\r\n}\r\nfloat SeaFBM( vec2 p )\r\n{\r\n    p*= .001;\r\n    float f;\r\n\tf = (sin(sin(p.x *1.22+gTime) + cos(p.y *.14)+p.x*.15+p.y*1.33-gTime)) * 1.0;\r\n    \r\n\tf += (sin(p.x *.9+gTime + p.y *.3-gTime)) * 1.0;\r\n    f += (cos(p.x *.7-gTime - p.y *.4-gTime)) * .5;\r\n    f += 1.5000 * (.5-abs(SeaNoise(p)-.5)); p =  p * 2.05;\r\n    f += .75000 * (.5-abs(SeaNoise(p)-.5)); p =  p * 2.02;\r\n    f += 0.2500 * SeaNoise(p); p =  p * 2.07;\r\n    f += 0.1250 * SeaNoise(p); p =  p * 2.13;\r\n    //f += 0.0625 * Noise(p);\r\n\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Map(vec3 p)\r\n{\r\n\tfloat h = -(FBM(p)-cloudy-.6);\r\n    \r\n\treturn h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat SeaMap(in vec2 pos)\r\n{\r\n\r\n\treturn SeaFBM(pos) * (20.0 + cloudy*170.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 SeaNormal( in vec3 pos, in float d, out float height)\r\n{\r\n\tfloat p = .005 * d * d / iResolution.x;\r\n\tvec3 nor  \t= vec3(0.0,\t\t    SeaMap(pos.xz), 0.0);\r\n\tvec3 v2\t\t= nor-vec3(p,\t\tSeaMap(pos.xz+vec2(p,0.0)), 0.0);\r\n\tvec3 v3\t\t= nor-vec3(0.0,\t\tSeaMap(pos.xz+vec2(0.0,-p)), -p);\r\n    height = nor.y;\r\n\tnor = cross(v2, v3);\r\n\treturn normalize(nor);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat GetLighting(vec3 p, vec3 s)\r\n{\r\n    float l = MapSH(p)-MapSH(p+s*200.);\r\n    return clamp(-l*2., 0.05, 1.0);\r\n}\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 pos,in vec3 rd, out vec2 outPos)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\t// Do the blue and sun...\t\r\n\tvec3  sky = mix(vec3(.0, .1, .4), vec3(.3, .6, .8), 1.0-rd.y);\r\n\tsky = sky + sunColour * min(pow(sunAmount, 1500.0) * 5.0, 1.0);\r\n\tsky = sky + sunColour * min(pow(sunAmount, 10.0) * .6, 1.0);\r\n\t\r\n\t// Find the start and end of the cloud layer...\r\n\tfloat beg = ((CLOUD_LOWER-pos.y) / rd.y);\r\n\tfloat end = ((CLOUD_UPPER-pos.y) / rd.y);\r\n\t\r\n\t// Start position...\r\n\tvec3 p = vec3(pos.x + rd.x * beg, 0.0, pos.z + rd.z * beg);\r\n\toutPos = p.xz;\r\n    beg +=  Hash(p)*150.0;\r\n\r\n\t// Trace clouds through that layer...\r\n\tfloat d = 0.0;\r\n\tvec3 add = rd * ((end-beg) / 55.0);\r\n\tvec2 shade;\r\n\tvec2 shadeSum = vec2(0.0, .0);\r\n\tshade.x = 1.0;\r\n\t// I think this is as small as the loop can be\r\n\t// for a reasonable cloud density illusion.\r\n\tfor (int i = 0; i < 55; i++)\r\n\t{\r\n\t\tif (shadeSum.y >= 1.0) break;\r\n\t\tfloat h = Map(p);\r\n\t\tshade.y = max(h, 0.0); \r\n\r\n        shade.x = GetLighting(p, sunLight);\r\n\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);\r\n\r\n\t\tp += add;\r\n\t}\r\n\t//shadeSum.x /= 10.0;\r\n\t//shadeSum = min(shadeSum, 1.0);\r\n\t\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, .6)), sunColour, (1.0-shadeSum.y)*.4);\r\n    //vec3 clouds = vec3(shadeSum.x);\r\n\t\r\n\t//clouds += min((1.0-sqrt(shadeSum.y)) * pow(sunAmount, 4.0), 1.0) * 2.0;\r\n   \r\n    clouds += flash * (shadeSum.y+shadeSum.x+.2) * .5;\r\n\r\n\tsky = mix(sky, min(clouds, 1.0), shadeSum.y);\r\n\t\r\n\treturn clamp(sky, 0.0, 1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 GetSea(in vec3 pos,in vec3 rd, out vec2 outPos)\r\n{\r\n\tvec3 sea;\r\n\tfloat d = -pos.y/rd.y;\r\n\tvec3 p = vec3(pos.x + rd.x * d, 0.0, pos.z + rd.z * d);\r\n\toutPos = p.xz;\r\n\t\r\n\tfloat dis = length(p-pos);\r\n    float h = 0.0;\r\n\tvec3 nor = SeaNormal(p, dis, h);\r\n\r\n\tvec3 ref = reflect(rd, nor);\r\n\tref.y = max(ref.y, 0.0015);\r\n\tsea = GetSky(p, ref, p.xz);\r\n\th = h*.005 / (1.0+max(dis*.02-300.0, 0.0));\r\n   \tfloat fresnel = max(dot(nor, -rd),0.0);\r\n    fresnel = pow(fresnel, .3)*1.1;\r\n    \r\n\tsea = mix(sea*.6, (vec3(.3, .4, .45)+h*h) * max(dot(nor, sunLight), 0.0), min(fresnel, 1.0));\r\n\t\r\n\tfloat glit = max(dot(ref, sunLight), 0.0);\r\n\tsea += sunColour * pow(glit, 220.0) * max(-cloudy*100.0, 0.0);\r\n\t\r\n\treturn sea;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n    return vec3(4000.0 * sin(.16*t)+12290.0, 0.0, 8800.0 * cos(.145*t+.3));\r\n} \r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat m = (iMouse.x/iResolution.x)*30.0;\r\n\tgTime = iTime*.5 + m + 75.5;\r\n\tcloudy = cos(gTime * .25+.4) * .26;\r\n    float lightning = 0.0;\r\n    \r\n    if (cloudy >= .2)\r\n    {\r\n        float f = mod(gTime+1.5, 2.5);\r\n        if (f < .8)\r\n        {\r\n            f = smoothstep(.8, .0, f)* 1.5;\r\n        \tlightning = mod(-gTime*(1.5-Hash(gTime*.3)*.002), 1.0) * f;\r\n        }\r\n    }\r\n    \r\n    flash = clamp(vec3(1., 1.0, 1.2) * lightning, 0.0, 1.0);\r\n       \r\n\t\r\n    vec2 xy = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\r\n\t\r\n\tvec3 cameraPos = CameraPath(gTime - 2.0);\r\n\tvec3 camTar\t   = CameraPath(gTime - .0);\r\n\tcamTar.y = cameraPos.y = sin(gTime) * 200.0 + 300.0;\r\n\tcamTar.y += 370.0;\r\n\t\r\n\tfloat roll = .1 * sin(gTime * .25);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = cross(cw,cp);\r\n\tvec3 cv = cross(cu,cw);\r\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\r\n\tmat3 camMat = mat3(cu, cv, cw);\r\n\r\n\tvec3 col;\r\n\tvec2 pos;\r\n\tif (dir.y > 0.0)\r\n\t{\r\n\t\tcol = GetSky(cameraPos, dir, pos);\r\n\t}else\r\n\t{\r\n\t\tcol = GetSea(cameraPos, dir, pos);\r\n\t}\r\n\tfloat l = exp(-length(pos) * .00002);\r\n\tcol = mix(vec3(.6-cloudy*1.2)+flash*.3, col, max(l, .2));\r\n\t\r\n\t// Do the lens flares...\r\n\tfloat bri = dot(cw, sunLight) * 2.7 * clamp(-cloudy+.2, 0.0, .2);\r\n\tif (bri > 0.0)\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\r\n\t\tvec2 uvT = uv-sunPos;\r\n\t\tuvT = uvT*(length(uvT));\r\n\t\tbri = pow(bri, 6.0)*.6;\r\n\r\n\t\tfloat glare1 = max(1.2-length(uvT+sunPos*2.)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2-length(uvT+sunPos*.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, uv, -2.3);\r\n\t\tfloat glare3 = max(1.2-length(uvT+sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * sunColour * vec3(1.0, .5, .2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(.8, .8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * sunColour * pow(glare3, 4.0)*10.0;\r\n\t}\r\n\t\r\n\tvec2 st =  uv * vec2(.5+(xy.y+1.0)*.3, .02)+vec2(gTime*.5+xy.y*.2, gTime*.2);\r\n\t// Rain...\r\n#ifdef TEXTURE_NOISE\r\n \tfloat f = texture(iChannel0, st, -100.0).y * texture(iChannel0, st*.773, -100.0).x * 1.55;\r\n#else\r\n\tfloat f = Noise( st*200.5 ) * Noise( st*120.5 ) * 1.3;\r\n#endif\r\n\tfloat rain = clamp(cloudy-.15, 0.0, 1.0);\r\n\tf = clamp(pow(abs(f), 15.0) * 5.0 * (rain*rain*125.0), 0.0, (xy.y+.1)*.6);\r\n\tcol = mix(col, vec3(0.15, .15, .15)+flash, f);\r\n\tcol = clamp(col, 0.0,1.0);\r\n\r\n\t// Stretch RGB upwards... \r\n\t//col = (1.0 - exp(-col * 2.0)) * 1.1565;\r\n\t//col = (1.0 - exp(-col * 3.0)) * 1.052;\r\n\tcol = pow(col, vec3(.7));\r\n\t//col = (col*col*(3.0-2.0*col));\r\n\r\n\t// Vignette...\r\n\tcol *= .55+0.45*pow(70.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.15 );\t\r\n\t\r\n\tfragColor=vec4(col, 1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":null,"published":0}],"Info":{"Name":"Weather","id":null,"date":null,"viewed":0,"name":"Weather","description":"Adjust cloud layer thickness with the upper and lower defines.\r\nMouse X to move through time.\r\nIt ray-casts to the bottom layer then steps through to the top layer. The larger steps at the horizon are not really noticeable.","likes":0,"published":null,"tags":["3d"," fractal"," noise"," clouds"," weather"," soundcloud"]},"ver":null,"info":{"Name":"Weather","id":null,"date":null,"viewed":0,"name":"Weather","description":"Adjust cloud layer thickness with the upper and lower defines.\r\nMouse X to move through time.\r\nIt ray-casts to the bottom layer then steps through to the top layer. The larger steps at the horizon are not really noticeable.","likes":0,"published":null,"tags":["3d"," fractal"," noise"," clouds"," weather"," soundcloud"]},"renderpass":[{"Code":"// Weather. By David Hoskins, May 2014.\r\n// @ https://www.shadertoy.com/view/4dsXWn\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Who needs mathematically correct simulations?! :)\r\n// It ray-casts to the bottom layer then steps through to the top layer.\r\n// It uses the same number of steps for all positions.\r\n// The larger steps at the horizon don't cause problems as they are far away.\r\n// So the detail is where it matters.\r\n// Unfortunately this can't be used to go through the cloud layer,\r\n// but it's fast and has a massive draw distance.\r\n\r\nvec3 sunLight  = normalize( vec3(  0.35, 0.14,  0.3 ) );\r\nconst vec3 sunColour = vec3(1.0, .7, .55);\r\nfloat gTime, cloudy;\r\nvec3 flash;\r\n\r\n#define CLOUD_LOWER 2800.0\r\n#define CLOUD_UPPER 3800.0\r\n\r\n#define TEXTURE_NOISE\r\n\r\n#define MOD2 vec2(.16632,.17369)\r\n#define MOD3 vec3(.16532,.17369,.15787)\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Hash( float p )\r\n{\r\n\tvec2 p2 = fract(vec2(p) * MOD2);\r\n    p2 += dot(p2.yx, p2.xy+19.19);\r\n\treturn fract(p2.x * p2.y);\r\n}\r\nfloat Hash(vec3 p)\r\n{\r\n\tp  = fract(p * MOD3);\r\n    p += dot(p.xyz, p.yzx + 19.19);\r\n    return fract(p.x * p.y * p.z);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n#ifdef TEXTURE_NOISE\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Noise( in vec2 f )\r\n{\r\n    vec2 p = floor(f);\r\n    f = fract(f);\r\n    f = f*f*(3.0-2.0*f);\r\n    float res = textureLod(iChannel0, (p+f+.5)/256.0, 0.0).x;\r\n    return res;\r\n}\r\nfloat Noise( in vec3 x )\r\n{\r\n    #if 0\r\n    return texture(iChannel2, x*0.05).x;\r\n    #else\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n    #endif\r\n}\r\n#else\r\n\r\n//--------------------------------------------------------------------------\r\n\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0;\r\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\r\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\r\n    return res;\r\n}\r\nfloat Noise(in vec3 p)\r\n{\r\n    vec3 i = floor(p);\r\n\tvec3 f = fract(p); \r\n\tf *= f * (3.0-2.0*f);\r\n\r\n    return mix(\r\n\t\tmix(mix(Hash(i + vec3(0.,0.,0.)), Hash(i + vec3(1.,0.,0.)),f.x),\r\n\t\t\tmix(Hash(i + vec3(0.,1.,0.)), Hash(i + vec3(1.,1.,0.)),f.x),\r\n\t\t\tf.y),\r\n\t\tmix(mix(Hash(i + vec3(0.,0.,1.)), Hash(i + vec3(1.,0.,1.)),f.x),\r\n\t\t\tmix(Hash(i + vec3(0.,1.,1.)), Hash(i + vec3(1.,1.,1.)),f.x),\r\n\t\t\tf.y),\r\n\t\tf.z);\r\n}\r\n#endif\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n                    -0.80,  0.36, -0.48,\r\n                    -0.60, -0.48,  0.64 ) * 1.7;\r\n//--------------------------------------------------------------------------\r\nfloat FBM( vec3 p )\r\n{\r\n\tp*= .0005;\r\n    float f;\r\n\t\r\n\tf = 0.5000 * Noise(p); p = m*p; //p.y -= gTime*.2;\r\n\tf += 0.2500 * Noise(p); p = m*p; //p.y += gTime*.06;\r\n\tf += 0.1250 * Noise(p); p = m*p;\r\n\tf += 0.0625   * Noise(p); p = m*p;\r\n\tf += 0.03125  * Noise(p); p = m*p;\r\n\tf += 0.015625 * Noise(p);\r\n    return f;\r\n}\r\n//--------------------------------------------------------------------------\r\nfloat FBMSH( vec3 p )\r\n{\r\n\tp*= .0005;\r\n        \r\n    float f;\r\n\t\r\n\tf = 0.5000 * Noise(p); p = m*p; //p.y -= gTime*.2;\r\n\tf += 0.2500 * Noise(p); p = m*p; //p.y += gTime*.06;\r\n\tf += 0.1250 * Noise(p); p = m*p;\r\n\tf += 0.0625   * Noise(p); p = m*p;\r\n//\tf += 0.03125  * Noise(p); p = m*p;\r\n///\tf += 0.015625 * Noise(p);\r\n    return f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat MapSH(vec3 p)\r\n{\r\n\t\r\n\tfloat h = -(FBM(p)-cloudy-.6);\r\n    //h *= smoothstep(CLOUD_LOWER, CLOUD_LOWER+100., p.y);\r\n    //h *= smoothstep(CLOUD_LOWER-500., CLOUD_LOWER, p.y);\r\n    h *= smoothstep(CLOUD_UPPER+100., CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n\r\nfloat SeaNoise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0;\r\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\r\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\r\n    return res;\r\n}\r\nfloat SeaFBM( vec2 p )\r\n{\r\n    p*= .001;\r\n    float f;\r\n\tf = (sin(sin(p.x *1.22+gTime) + cos(p.y *.14)+p.x*.15+p.y*1.33-gTime)) * 1.0;\r\n    \r\n\tf += (sin(p.x *.9+gTime + p.y *.3-gTime)) * 1.0;\r\n    f += (cos(p.x *.7-gTime - p.y *.4-gTime)) * .5;\r\n    f += 1.5000 * (.5-abs(SeaNoise(p)-.5)); p =  p * 2.05;\r\n    f += .75000 * (.5-abs(SeaNoise(p)-.5)); p =  p * 2.02;\r\n    f += 0.2500 * SeaNoise(p); p =  p * 2.07;\r\n    f += 0.1250 * SeaNoise(p); p =  p * 2.13;\r\n    //f += 0.0625 * Noise(p);\r\n\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Map(vec3 p)\r\n{\r\n\tfloat h = -(FBM(p)-cloudy-.6);\r\n    \r\n\treturn h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat SeaMap(in vec2 pos)\r\n{\r\n\r\n\treturn SeaFBM(pos) * (20.0 + cloudy*170.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 SeaNormal( in vec3 pos, in float d, out float height)\r\n{\r\n\tfloat p = .005 * d * d / iResolution.x;\r\n\tvec3 nor  \t= vec3(0.0,\t\t    SeaMap(pos.xz), 0.0);\r\n\tvec3 v2\t\t= nor-vec3(p,\t\tSeaMap(pos.xz+vec2(p,0.0)), 0.0);\r\n\tvec3 v3\t\t= nor-vec3(0.0,\t\tSeaMap(pos.xz+vec2(0.0,-p)), -p);\r\n    height = nor.y;\r\n\tnor = cross(v2, v3);\r\n\treturn normalize(nor);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat GetLighting(vec3 p, vec3 s)\r\n{\r\n    float l = MapSH(p)-MapSH(p+s*200.);\r\n    return clamp(-l*2., 0.05, 1.0);\r\n}\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 pos,in vec3 rd, out vec2 outPos)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\t// Do the blue and sun...\t\r\n\tvec3  sky = mix(vec3(.0, .1, .4), vec3(.3, .6, .8), 1.0-rd.y);\r\n\tsky = sky + sunColour * min(pow(sunAmount, 1500.0) * 5.0, 1.0);\r\n\tsky = sky + sunColour * min(pow(sunAmount, 10.0) * .6, 1.0);\r\n\t\r\n\t// Find the start and end of the cloud layer...\r\n\tfloat beg = ((CLOUD_LOWER-pos.y) / rd.y);\r\n\tfloat end = ((CLOUD_UPPER-pos.y) / rd.y);\r\n\t\r\n\t// Start position...\r\n\tvec3 p = vec3(pos.x + rd.x * beg, 0.0, pos.z + rd.z * beg);\r\n\toutPos = p.xz;\r\n    beg +=  Hash(p)*150.0;\r\n\r\n\t// Trace clouds through that layer...\r\n\tfloat d = 0.0;\r\n\tvec3 add = rd * ((end-beg) / 55.0);\r\n\tvec2 shade;\r\n\tvec2 shadeSum = vec2(0.0, .0);\r\n\tshade.x = 1.0;\r\n\t// I think this is as small as the loop can be\r\n\t// for a reasonable cloud density illusion.\r\n\tfor (int i = 0; i < 55; i++)\r\n\t{\r\n\t\tif (shadeSum.y >= 1.0) break;\r\n\t\tfloat h = Map(p);\r\n\t\tshade.y = max(h, 0.0); \r\n\r\n        shade.x = GetLighting(p, sunLight);\r\n\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);\r\n\r\n\t\tp += add;\r\n\t}\r\n\t//shadeSum.x /= 10.0;\r\n\t//shadeSum = min(shadeSum, 1.0);\r\n\t\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, .6)), sunColour, (1.0-shadeSum.y)*.4);\r\n    //vec3 clouds = vec3(shadeSum.x);\r\n\t\r\n\t//clouds += min((1.0-sqrt(shadeSum.y)) * pow(sunAmount, 4.0), 1.0) * 2.0;\r\n   \r\n    clouds += flash * (shadeSum.y+shadeSum.x+.2) * .5;\r\n\r\n\tsky = mix(sky, min(clouds, 1.0), shadeSum.y);\r\n\t\r\n\treturn clamp(sky, 0.0, 1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 GetSea(in vec3 pos,in vec3 rd, out vec2 outPos)\r\n{\r\n\tvec3 sea;\r\n\tfloat d = -pos.y/rd.y;\r\n\tvec3 p = vec3(pos.x + rd.x * d, 0.0, pos.z + rd.z * d);\r\n\toutPos = p.xz;\r\n\t\r\n\tfloat dis = length(p-pos);\r\n    float h = 0.0;\r\n\tvec3 nor = SeaNormal(p, dis, h);\r\n\r\n\tvec3 ref = reflect(rd, nor);\r\n\tref.y = max(ref.y, 0.0015);\r\n\tsea = GetSky(p, ref, p.xz);\r\n\th = h*.005 / (1.0+max(dis*.02-300.0, 0.0));\r\n   \tfloat fresnel = max(dot(nor, -rd),0.0);\r\n    fresnel = pow(fresnel, .3)*1.1;\r\n    \r\n\tsea = mix(sea*.6, (vec3(.3, .4, .45)+h*h) * max(dot(nor, sunLight), 0.0), min(fresnel, 1.0));\r\n\t\r\n\tfloat glit = max(dot(ref, sunLight), 0.0);\r\n\tsea += sunColour * pow(glit, 220.0) * max(-cloudy*100.0, 0.0);\r\n\t\r\n\treturn sea;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n    return vec3(4000.0 * sin(.16*t)+12290.0, 0.0, 8800.0 * cos(.145*t+.3));\r\n} \r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat m = (iMouse.x/iResolution.x)*30.0;\r\n\tgTime = iTime*.5 + m + 75.5;\r\n\tcloudy = cos(gTime * .25+.4) * .26;\r\n    float lightning = 0.0;\r\n    \r\n    if (cloudy >= .2)\r\n    {\r\n        float f = mod(gTime+1.5, 2.5);\r\n        if (f < .8)\r\n        {\r\n            f = smoothstep(.8, .0, f)* 1.5;\r\n        \tlightning = mod(-gTime*(1.5-Hash(gTime*.3)*.002), 1.0) * f;\r\n        }\r\n    }\r\n    \r\n    flash = clamp(vec3(1., 1.0, 1.2) * lightning, 0.0, 1.0);\r\n       \r\n\t\r\n    vec2 xy = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\r\n\t\r\n\tvec3 cameraPos = CameraPath(gTime - 2.0);\r\n\tvec3 camTar\t   = CameraPath(gTime - .0);\r\n\tcamTar.y = cameraPos.y = sin(gTime) * 200.0 + 300.0;\r\n\tcamTar.y += 370.0;\r\n\t\r\n\tfloat roll = .1 * sin(gTime * .25);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = cross(cw,cp);\r\n\tvec3 cv = cross(cu,cw);\r\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\r\n\tmat3 camMat = mat3(cu, cv, cw);\r\n\r\n\tvec3 col;\r\n\tvec2 pos;\r\n\tif (dir.y > 0.0)\r\n\t{\r\n\t\tcol = GetSky(cameraPos, dir, pos);\r\n\t}else\r\n\t{\r\n\t\tcol = GetSea(cameraPos, dir, pos);\r\n\t}\r\n\tfloat l = exp(-length(pos) * .00002);\r\n\tcol = mix(vec3(.6-cloudy*1.2)+flash*.3, col, max(l, .2));\r\n\t\r\n\t// Do the lens flares...\r\n\tfloat bri = dot(cw, sunLight) * 2.7 * clamp(-cloudy+.2, 0.0, .2);\r\n\tif (bri > 0.0)\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\r\n\t\tvec2 uvT = uv-sunPos;\r\n\t\tuvT = uvT*(length(uvT));\r\n\t\tbri = pow(bri, 6.0)*.6;\r\n\r\n\t\tfloat glare1 = max(1.2-length(uvT+sunPos*2.)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2-length(uvT+sunPos*.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, uv, -2.3);\r\n\t\tfloat glare3 = max(1.2-length(uvT+sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * sunColour * vec3(1.0, .5, .2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(.8, .8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * sunColour * pow(glare3, 4.0)*10.0;\r\n\t}\r\n\t\r\n\tvec2 st =  uv * vec2(.5+(xy.y+1.0)*.3, .02)+vec2(gTime*.5+xy.y*.2, gTime*.2);\r\n\t// Rain...\r\n#ifdef TEXTURE_NOISE\r\n \tfloat f = texture(iChannel0, st, -100.0).y * texture(iChannel0, st*.773, -100.0).x * 1.55;\r\n#else\r\n\tfloat f = Noise( st*200.5 ) * Noise( st*120.5 ) * 1.3;\r\n#endif\r\n\tfloat rain = clamp(cloudy-.15, 0.0, 1.0);\r\n\tf = clamp(pow(abs(f), 15.0) * 5.0 * (rain*rain*125.0), 0.0, (xy.y+.1)*.6);\r\n\tcol = mix(col, vec3(0.15, .15, .15)+flash, f);\r\n\tcol = clamp(col, 0.0,1.0);\r\n\r\n\t// Stretch RGB upwards... \r\n\t//col = (1.0 - exp(-col * 2.0)) * 1.1565;\r\n\t//col = (1.0 - exp(-col * 3.0)) * 1.052;\r\n\tcol = pow(col, vec3(.7));\r\n\t//col = (col*col*(3.0-2.0*col));\r\n\r\n\t// Vignette...\r\n\tcol *= .55+0.45*pow(70.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.15 );\t\r\n\t\r\n\tfragColor=vec4(col, 1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"// Weather. By David Hoskins, May 2014.\r\n// @ https://www.shadertoy.com/view/4dsXWn\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Who needs mathematically correct simulations?! :)\r\n// It ray-casts to the bottom layer then steps through to the top layer.\r\n// It uses the same number of steps for all positions.\r\n// The larger steps at the horizon don't cause problems as they are far away.\r\n// So the detail is where it matters.\r\n// Unfortunately this can't be used to go through the cloud layer,\r\n// but it's fast and has a massive draw distance.\r\n\r\nvec3 sunLight  = normalize( vec3(  0.35, 0.14,  0.3 ) );\r\nconst vec3 sunColour = vec3(1.0, .7, .55);\r\nfloat gTime, cloudy;\r\nvec3 flash;\r\n\r\n#define CLOUD_LOWER 2800.0\r\n#define CLOUD_UPPER 3800.0\r\n\r\n#define TEXTURE_NOISE\r\n\r\n#define MOD2 vec2(.16632,.17369)\r\n#define MOD3 vec3(.16532,.17369,.15787)\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Hash( float p )\r\n{\r\n\tvec2 p2 = fract(vec2(p) * MOD2);\r\n    p2 += dot(p2.yx, p2.xy+19.19);\r\n\treturn fract(p2.x * p2.y);\r\n}\r\nfloat Hash(vec3 p)\r\n{\r\n\tp  = fract(p * MOD3);\r\n    p += dot(p.xyz, p.yzx + 19.19);\r\n    return fract(p.x * p.y * p.z);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n#ifdef TEXTURE_NOISE\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Noise( in vec2 f )\r\n{\r\n    vec2 p = floor(f);\r\n    f = fract(f);\r\n    f = f*f*(3.0-2.0*f);\r\n    float res = textureLod(iChannel0, (p+f+.5)/256.0, 0.0).x;\r\n    return res;\r\n}\r\nfloat Noise( in vec3 x )\r\n{\r\n    #if 0\r\n    return texture(iChannel2, x*0.05).x;\r\n    #else\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n    #endif\r\n}\r\n#else\r\n\r\n//--------------------------------------------------------------------------\r\n\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0;\r\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\r\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\r\n    return res;\r\n}\r\nfloat Noise(in vec3 p)\r\n{\r\n    vec3 i = floor(p);\r\n\tvec3 f = fract(p); \r\n\tf *= f * (3.0-2.0*f);\r\n\r\n    return mix(\r\n\t\tmix(mix(Hash(i + vec3(0.,0.,0.)), Hash(i + vec3(1.,0.,0.)),f.x),\r\n\t\t\tmix(Hash(i + vec3(0.,1.,0.)), Hash(i + vec3(1.,1.,0.)),f.x),\r\n\t\t\tf.y),\r\n\t\tmix(mix(Hash(i + vec3(0.,0.,1.)), Hash(i + vec3(1.,0.,1.)),f.x),\r\n\t\t\tmix(Hash(i + vec3(0.,1.,1.)), Hash(i + vec3(1.,1.,1.)),f.x),\r\n\t\t\tf.y),\r\n\t\tf.z);\r\n}\r\n#endif\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n                    -0.80,  0.36, -0.48,\r\n                    -0.60, -0.48,  0.64 ) * 1.7;\r\n//--------------------------------------------------------------------------\r\nfloat FBM( vec3 p )\r\n{\r\n\tp*= .0005;\r\n    float f;\r\n\t\r\n\tf = 0.5000 * Noise(p); p = m*p; //p.y -= gTime*.2;\r\n\tf += 0.2500 * Noise(p); p = m*p; //p.y += gTime*.06;\r\n\tf += 0.1250 * Noise(p); p = m*p;\r\n\tf += 0.0625   * Noise(p); p = m*p;\r\n\tf += 0.03125  * Noise(p); p = m*p;\r\n\tf += 0.015625 * Noise(p);\r\n    return f;\r\n}\r\n//--------------------------------------------------------------------------\r\nfloat FBMSH( vec3 p )\r\n{\r\n\tp*= .0005;\r\n        \r\n    float f;\r\n\t\r\n\tf = 0.5000 * Noise(p); p = m*p; //p.y -= gTime*.2;\r\n\tf += 0.2500 * Noise(p); p = m*p; //p.y += gTime*.06;\r\n\tf += 0.1250 * Noise(p); p = m*p;\r\n\tf += 0.0625   * Noise(p); p = m*p;\r\n//\tf += 0.03125  * Noise(p); p = m*p;\r\n///\tf += 0.015625 * Noise(p);\r\n    return f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat MapSH(vec3 p)\r\n{\r\n\t\r\n\tfloat h = -(FBM(p)-cloudy-.6);\r\n    //h *= smoothstep(CLOUD_LOWER, CLOUD_LOWER+100., p.y);\r\n    //h *= smoothstep(CLOUD_LOWER-500., CLOUD_LOWER, p.y);\r\n    h *= smoothstep(CLOUD_UPPER+100., CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n\r\nfloat SeaNoise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0;\r\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\r\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\r\n    return res;\r\n}\r\nfloat SeaFBM( vec2 p )\r\n{\r\n    p*= .001;\r\n    float f;\r\n\tf = (sin(sin(p.x *1.22+gTime) + cos(p.y *.14)+p.x*.15+p.y*1.33-gTime)) * 1.0;\r\n    \r\n\tf += (sin(p.x *.9+gTime + p.y *.3-gTime)) * 1.0;\r\n    f += (cos(p.x *.7-gTime - p.y *.4-gTime)) * .5;\r\n    f += 1.5000 * (.5-abs(SeaNoise(p)-.5)); p =  p * 2.05;\r\n    f += .75000 * (.5-abs(SeaNoise(p)-.5)); p =  p * 2.02;\r\n    f += 0.2500 * SeaNoise(p); p =  p * 2.07;\r\n    f += 0.1250 * SeaNoise(p); p =  p * 2.13;\r\n    //f += 0.0625 * Noise(p);\r\n\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Map(vec3 p)\r\n{\r\n\tfloat h = -(FBM(p)-cloudy-.6);\r\n    \r\n\treturn h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat SeaMap(in vec2 pos)\r\n{\r\n\r\n\treturn SeaFBM(pos) * (20.0 + cloudy*170.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 SeaNormal( in vec3 pos, in float d, out float height)\r\n{\r\n\tfloat p = .005 * d * d / iResolution.x;\r\n\tvec3 nor  \t= vec3(0.0,\t\t    SeaMap(pos.xz), 0.0);\r\n\tvec3 v2\t\t= nor-vec3(p,\t\tSeaMap(pos.xz+vec2(p,0.0)), 0.0);\r\n\tvec3 v3\t\t= nor-vec3(0.0,\t\tSeaMap(pos.xz+vec2(0.0,-p)), -p);\r\n    height = nor.y;\r\n\tnor = cross(v2, v3);\r\n\treturn normalize(nor);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat GetLighting(vec3 p, vec3 s)\r\n{\r\n    float l = MapSH(p)-MapSH(p+s*200.);\r\n    return clamp(-l*2., 0.05, 1.0);\r\n}\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 pos,in vec3 rd, out vec2 outPos)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\t// Do the blue and sun...\t\r\n\tvec3  sky = mix(vec3(.0, .1, .4), vec3(.3, .6, .8), 1.0-rd.y);\r\n\tsky = sky + sunColour * min(pow(sunAmount, 1500.0) * 5.0, 1.0);\r\n\tsky = sky + sunColour * min(pow(sunAmount, 10.0) * .6, 1.0);\r\n\t\r\n\t// Find the start and end of the cloud layer...\r\n\tfloat beg = ((CLOUD_LOWER-pos.y) / rd.y);\r\n\tfloat end = ((CLOUD_UPPER-pos.y) / rd.y);\r\n\t\r\n\t// Start position...\r\n\tvec3 p = vec3(pos.x + rd.x * beg, 0.0, pos.z + rd.z * beg);\r\n\toutPos = p.xz;\r\n    beg +=  Hash(p)*150.0;\r\n\r\n\t// Trace clouds through that layer...\r\n\tfloat d = 0.0;\r\n\tvec3 add = rd * ((end-beg) / 55.0);\r\n\tvec2 shade;\r\n\tvec2 shadeSum = vec2(0.0, .0);\r\n\tshade.x = 1.0;\r\n\t// I think this is as small as the loop can be\r\n\t// for a reasonable cloud density illusion.\r\n\tfor (int i = 0; i < 55; i++)\r\n\t{\r\n\t\tif (shadeSum.y >= 1.0) break;\r\n\t\tfloat h = Map(p);\r\n\t\tshade.y = max(h, 0.0); \r\n\r\n        shade.x = GetLighting(p, sunLight);\r\n\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);\r\n\r\n\t\tp += add;\r\n\t}\r\n\t//shadeSum.x /= 10.0;\r\n\t//shadeSum = min(shadeSum, 1.0);\r\n\t\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, .6)), sunColour, (1.0-shadeSum.y)*.4);\r\n    //vec3 clouds = vec3(shadeSum.x);\r\n\t\r\n\t//clouds += min((1.0-sqrt(shadeSum.y)) * pow(sunAmount, 4.0), 1.0) * 2.0;\r\n   \r\n    clouds += flash * (shadeSum.y+shadeSum.x+.2) * .5;\r\n\r\n\tsky = mix(sky, min(clouds, 1.0), shadeSum.y);\r\n\t\r\n\treturn clamp(sky, 0.0, 1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 GetSea(in vec3 pos,in vec3 rd, out vec2 outPos)\r\n{\r\n\tvec3 sea;\r\n\tfloat d = -pos.y/rd.y;\r\n\tvec3 p = vec3(pos.x + rd.x * d, 0.0, pos.z + rd.z * d);\r\n\toutPos = p.xz;\r\n\t\r\n\tfloat dis = length(p-pos);\r\n    float h = 0.0;\r\n\tvec3 nor = SeaNormal(p, dis, h);\r\n\r\n\tvec3 ref = reflect(rd, nor);\r\n\tref.y = max(ref.y, 0.0015);\r\n\tsea = GetSky(p, ref, p.xz);\r\n\th = h*.005 / (1.0+max(dis*.02-300.0, 0.0));\r\n   \tfloat fresnel = max(dot(nor, -rd),0.0);\r\n    fresnel = pow(fresnel, .3)*1.1;\r\n    \r\n\tsea = mix(sea*.6, (vec3(.3, .4, .45)+h*h) * max(dot(nor, sunLight), 0.0), min(fresnel, 1.0));\r\n\t\r\n\tfloat glit = max(dot(ref, sunLight), 0.0);\r\n\tsea += sunColour * pow(glit, 220.0) * max(-cloudy*100.0, 0.0);\r\n\t\r\n\treturn sea;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n    return vec3(4000.0 * sin(.16*t)+12290.0, 0.0, 8800.0 * cos(.145*t+.3));\r\n} \r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat m = (iMouse.x/iResolution.x)*30.0;\r\n\tgTime = iTime*.5 + m + 75.5;\r\n\tcloudy = cos(gTime * .25+.4) * .26;\r\n    float lightning = 0.0;\r\n    \r\n    if (cloudy >= .2)\r\n    {\r\n        float f = mod(gTime+1.5, 2.5);\r\n        if (f < .8)\r\n        {\r\n            f = smoothstep(.8, .0, f)* 1.5;\r\n        \tlightning = mod(-gTime*(1.5-Hash(gTime*.3)*.002), 1.0) * f;\r\n        }\r\n    }\r\n    \r\n    flash = clamp(vec3(1., 1.0, 1.2) * lightning, 0.0, 1.0);\r\n       \r\n\t\r\n    vec2 xy = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\r\n\t\r\n\tvec3 cameraPos = CameraPath(gTime - 2.0);\r\n\tvec3 camTar\t   = CameraPath(gTime - .0);\r\n\tcamTar.y = cameraPos.y = sin(gTime) * 200.0 + 300.0;\r\n\tcamTar.y += 370.0;\r\n\t\r\n\tfloat roll = .1 * sin(gTime * .25);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = cross(cw,cp);\r\n\tvec3 cv = cross(cu,cw);\r\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\r\n\tmat3 camMat = mat3(cu, cv, cw);\r\n\r\n\tvec3 col;\r\n\tvec2 pos;\r\n\tif (dir.y > 0.0)\r\n\t{\r\n\t\tcol = GetSky(cameraPos, dir, pos);\r\n\t}else\r\n\t{\r\n\t\tcol = GetSea(cameraPos, dir, pos);\r\n\t}\r\n\tfloat l = exp(-length(pos) * .00002);\r\n\tcol = mix(vec3(.6-cloudy*1.2)+flash*.3, col, max(l, .2));\r\n\t\r\n\t// Do the lens flares...\r\n\tfloat bri = dot(cw, sunLight) * 2.7 * clamp(-cloudy+.2, 0.0, .2);\r\n\tif (bri > 0.0)\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\r\n\t\tvec2 uvT = uv-sunPos;\r\n\t\tuvT = uvT*(length(uvT));\r\n\t\tbri = pow(bri, 6.0)*.6;\r\n\r\n\t\tfloat glare1 = max(1.2-length(uvT+sunPos*2.)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2-length(uvT+sunPos*.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, uv, -2.3);\r\n\t\tfloat glare3 = max(1.2-length(uvT+sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * sunColour * vec3(1.0, .5, .2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(.8, .8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * sunColour * pow(glare3, 4.0)*10.0;\r\n\t}\r\n\t\r\n\tvec2 st =  uv * vec2(.5+(xy.y+1.0)*.3, .02)+vec2(gTime*.5+xy.y*.2, gTime*.2);\r\n\t// Rain...\r\n#ifdef TEXTURE_NOISE\r\n \tfloat f = texture(iChannel0, st, -100.0).y * texture(iChannel0, st*.773, -100.0).x * 1.55;\r\n#else\r\n\tfloat f = Noise( st*200.5 ) * Noise( st*120.5 ) * 1.3;\r\n#endif\r\n\tfloat rain = clamp(cloudy-.15, 0.0, 1.0);\r\n\tf = clamp(pow(abs(f), 15.0) * 5.0 * (rain*rain*125.0), 0.0, (xy.y+.1)*.6);\r\n\tcol = mix(col, vec3(0.15, .15, .15)+flash, f);\r\n\tcol = clamp(col, 0.0,1.0);\r\n\r\n\t// Stretch RGB upwards... \r\n\t//col = (1.0 - exp(-col * 2.0)) * 1.1565;\r\n\t//col = (1.0 - exp(-col * 3.0)) * 1.052;\r\n\tcol = pow(col, vec3(.7));\r\n\t//col = (col*col*(3.0-2.0*col));\r\n\r\n\t// Vignette...\r\n\tcol *= .55+0.45*pow(70.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.15 );\t\r\n\t\r\n\tfragColor=vec4(col, 1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// todo: implement sweep amt\r\nvec2 mouse;\r\n\r\n////////////////////////////////////////////////////////////////\r\n// BOILERPLATE UTILITIES...................\r\nconst float pi = 3.14159;\r\nconst float pi2 = pi * 2.;\r\n\r\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\r\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\r\nfloat opI( float d1, float d2) { return max(d1,d2); }\r\n\r\n\r\n// from \"Magic Fractal\" by dgreensp\r\n// https://www.shadertoy.com/view/4ljGDd\r\nfloat magicBox(vec3 p) {\r\n    const int MAGIC_BOX_ITERS = 13;\r\n    const float MAGIC_BOX_MAGIC = 0.55;\r\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\r\n    // Take p anywhere in space and calculate the corresponding position\r\n    // inside the box, 0<(x,y,z)<1\r\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\r\n    \r\n    float lastLength = length(p);\r\n    float tot = 0.0;\r\n    // This is the fractal.  More iterations gives a more detailed\r\n    // fractal at the expense of more computation.\r\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\r\n      // The number subtracted here is a \"magic\" paremeter that\r\n      // produces rather different fractals for different values.\r\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\r\n      float newLength = length(p);\r\n      tot += abs(newLength-lastLength);\r\n      lastLength = newLength;\r\n    }\r\n\r\n    return tot;\r\n}\r\n\r\n\r\nfloat magicBox(vec2 uv){\r\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\r\n    // volume along the same axes as the fractal's bounding box.\r\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\r\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\r\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\r\n    vec3 p = 0.5*M*vec3(uv, 0.0);\r\n    return magicBox(p);\r\n}\r\n\r\n\r\n\r\n\r\nmat2 rot2D(float r)\r\n{\r\n    float c = cos(r), s = sin(r);\r\n    return mat2(c, s, -s, c);\r\n}\r\nfloat nsin(float a){return .5+.5*sin(a);}\r\nfloat ncos(float a){return .5+.5*cos(a);}\r\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\r\nfloat rand(vec2 co){\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\nfloat rand(float n){\r\n \treturn fract(cos(n*89.42)*343.42);\r\n}\r\nfloat dtoa(float d, float amount)\r\n{\r\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\r\n}\r\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\r\n{\r\n    vec2 d = max(tl-uv, uv-br);\r\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\r\n}\r\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\r\n{\r\n    return length(uv - origin) - radius;\r\n}\r\n// 0-1 1-0\r\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\r\n{\r\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\r\n}\r\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\r\nvec2 hash( vec2 p )\r\n{\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n// returns -.5 to 1.5. i think.\r\nfloat noise( in vec2 p )\r\n{\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\r\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\r\n    return dot( n, vec3(70.0) );\t\r\n}\r\nfloat noise01(vec2 p)\r\n{\r\n    return clamp((noise(p)+.5)*.5, 0.,1.);\r\n}\r\n// debug function to convert distance to color, revealing sign.\r\nvec3 dtocolor(vec3 inpColor, float dist)\r\n{\r\n    vec3 ret;\r\n    if(dist > 0.)\r\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\r\n    else\r\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\r\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\r\n    return ret;\r\n}\r\n\r\nfloat smoothf(float x)\r\n{\r\n    return x*x*x*(x*(x*6. - 15.) + 10.);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////\r\n// APP CODE ...................\r\n\r\n// this function will produce a line with brush strokes. the inputs are such\r\n// that you can apply it to pretty much any line; the geometry is separated from this function.\r\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\r\n{\r\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\r\n\r\n    if(iMouse.z > 0.)\r\n    {\r\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\r\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\r\n    \tfloat okthen = 42.;// NOP\r\n    }\r\n    \r\n    // warp the position-in-line, to control the curve of the brush falloff.\r\n    if(posInLineY > 0.)\r\n    {\r\n        float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x);\r\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\r\n    }\r\n\r\n    // brush stroke fibers effect.\r\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\r\n    float strokeTexture = 0.\r\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\r\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\r\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\r\n        ;\r\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\r\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\r\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\r\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\r\n    // fade out the end of the stroke by shifting the noise curve below 0\r\n    const float strokeAlphaBoost = 1.09;\r\n    if(posInLineY > 0.)\r\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\r\n    else\r\n        strokeAlpha *= strokeAlphaBoost;\r\n\r\n    strokeAlpha = smoothf(strokeAlpha);\r\n    \r\n    // paper bleed effect.\r\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\r\n//    amt = 500.;// disable paper bleed    \r\n    \r\n    // blotches (per stroke)\r\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\r\n    //blotchAmt *= 0.4;\r\n    //strokeAlpha += blotchAmt;\r\n\r\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\r\n    alpha = clamp(alpha, 0.,1.);\r\n    return mix(inpColor, brushColor.rgb, alpha);\r\n}\r\n\r\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\r\n{\r\n    // flatten the line to be axis-aligned.\r\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\r\n    mat2 rotMat = rot2D(lineAngle);\r\n\r\n    float lineLength = distance(p2_, p1_);\r\n    // make an axis-aligned line from this line.\r\n    vec2 tl = (p1_ * rotMat);// top left\r\n    vec2 br = tl + vec2(0,lineLength);// bottom right\r\n    vec2 uvLine = uv * rotMat;\r\n\r\n    // make line slightly narrower at end.\r\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\r\n    \r\n    // wobble it around, humanize\r\n    float res = min(iResolution.y,iResolution.x);\r\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\r\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\r\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n\r\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\r\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\r\n    uvLine = tl - uvLine;\r\n    \r\n    vec2 lineSize = vec2(lineWidth, lineLength);\r\n    \r\n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\r\n                                d, inpColor, brushColor);\r\n    return ret;\r\n}\r\n\r\n// returns:\r\n// xy = uvLine\r\n// z = radius\r\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\r\n{\r\n    vec2 humanizedUVLine = uvLine;\r\n    \r\n\t// offsetting the circle along its path creates a twisting effect.\r\n    float twistAmt = .24;\r\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\r\n    humanizedUVLine.x += linePosY * twistAmt;\r\n    \r\n    // perturb radius / x\r\n    float humanizedRadius = radius_;\r\n    float res = min(iResolution.y,iResolution.x);\r\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\r\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\r\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\r\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n    \r\n    return vec3(humanizedUVLine, humanizedRadius);\r\n}\r\n\r\n// there's something about calling an Enso a \"donut\" that makes me giggle.\r\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\r\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\r\n{\r\n\tvec2 uvLine = uv - o;\r\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\r\n    angle = mod(angle-angleStart+pi, pi2);\r\n    if(!clockwise)\r\n        angle = pi2 - angle;\r\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\r\n    uvLine = vec2(\r\n        radius_ - length(uvLine),\r\n        angle / pi2 * lineLength\r\n    );\r\n    \r\n    // make line slightly narrower at end.\r\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\r\n    \r\n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n    vec2 humanizedUVLine = hu.xy;\r\n    float humanizedRadius = hu.z;\r\n\r\n    float d = opS(sdCircle(uv, o, humanizedRadius),\r\n                  sdCircle(uv, o, humanizedRadius));\r\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\r\n\r\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\r\n    \r\n    // do the same but for before the beginning of the line. distance field is just a single point\r\n    vec3 ret2 = vec3(1);\r\n    if(angle > pi)\r\n    {\r\n        uvLine.y -= lineLength;\r\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n        humanizedUVLine = hu.xy;\r\n        humanizedRadius = hu.z;\r\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\r\n        d = distance(uv, strokeStartPos);\r\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\r\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\r\n\t}\r\n    return min(ret, ret2);\r\n}\r\n\r\n\r\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\r\n{\r\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\r\n    ret *= newSize;// scale up to new dimensions\r\n    float aspect = iResolution.x / iResolution.y;\r\n    ret.x *= aspect;// orig aspect ratio\r\n    float newWidth = newSize.x * aspect;\r\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvSignature = (fragCoord / iResolution.y * 2.0) - 1.;\r\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\r\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\r\n    \r\n    vec3 col = vec3(1.,1.,0.875);// bg\r\n    float dist;\r\n    \r\n\t// geometry on display...\r\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red fixed line\r\n                           vec2(-1.4, -.4+yo),\r\n                           vec2(2.6, -.4+yo), 0.3);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red fixed line\r\n                           vec2(1.3, 0.+yo),\r\n                           vec2(-2.9, 0.+yo), 0.03);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red fixed line\r\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\r\n                           vec2(-2.9, .3+yo), 0.1);\r\n\r\n\r\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\r\n                                vec2(0,0),// origin\r\n                                0.6,// radius\r\n                                0.2,// angle of brush start\r\n                                0.5,// sweep amt 0-1\r\n                                0.3,// width\r\n                                false);// clockwise\r\n    \r\n    // paint blotches\r\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\r\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\r\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\r\n    col *= 1.-blotchAmt;\r\n    \r\n\t// signature\r\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\r\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.);\r\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\r\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\r\n\r\n    // grain\r\n    col.rgb += (rand(uv)-.5)*.08;\r\n    col.rgb = saturate(col.rgb);\r\n\r\n    // vignette\r\n    vec2 uvScreen = (fragCoord / iResolution.xy * 2.)-1.;\r\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\r\n    col *= vignetteAmt;\r\n    \r\n    fragColor = vec4(col, 1.);\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"// todo: implement sweep amt\r\nvec2 mouse;\r\n\r\n////////////////////////////////////////////////////////////////\r\n// BOILERPLATE UTILITIES...................\r\nconst float pi = 3.14159;\r\nconst float pi2 = pi * 2.;\r\n\r\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\r\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\r\nfloat opI( float d1, float d2) { return max(d1,d2); }\r\n\r\n\r\n// from \"Magic Fractal\" by dgreensp\r\n// https://www.shadertoy.com/view/4ljGDd\r\nfloat magicBox(vec3 p) {\r\n    const int MAGIC_BOX_ITERS = 13;\r\n    const float MAGIC_BOX_MAGIC = 0.55;\r\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\r\n    // Take p anywhere in space and calculate the corresponding position\r\n    // inside the box, 0<(x,y,z)<1\r\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\r\n    \r\n    float lastLength = length(p);\r\n    float tot = 0.0;\r\n    // This is the fractal.  More iterations gives a more detailed\r\n    // fractal at the expense of more computation.\r\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\r\n      // The number subtracted here is a \"magic\" paremeter that\r\n      // produces rather different fractals for different values.\r\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\r\n      float newLength = length(p);\r\n      tot += abs(newLength-lastLength);\r\n      lastLength = newLength;\r\n    }\r\n\r\n    return tot;\r\n}\r\n\r\n\r\nfloat magicBox(vec2 uv){\r\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\r\n    // volume along the same axes as the fractal's bounding box.\r\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\r\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\r\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\r\n    vec3 p = 0.5*M*vec3(uv, 0.0);\r\n    return magicBox(p);\r\n}\r\n\r\n\r\n\r\n\r\nmat2 rot2D(float r)\r\n{\r\n    float c = cos(r), s = sin(r);\r\n    return mat2(c, s, -s, c);\r\n}\r\nfloat nsin(float a){return .5+.5*sin(a);}\r\nfloat ncos(float a){return .5+.5*cos(a);}\r\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\r\nfloat rand(vec2 co){\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\nfloat rand(float n){\r\n \treturn fract(cos(n*89.42)*343.42);\r\n}\r\nfloat dtoa(float d, float amount)\r\n{\r\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\r\n}\r\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\r\n{\r\n    vec2 d = max(tl-uv, uv-br);\r\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\r\n}\r\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\r\n{\r\n    return length(uv - origin) - radius;\r\n}\r\n// 0-1 1-0\r\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\r\n{\r\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\r\n}\r\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\r\nvec2 hash( vec2 p )\r\n{\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n// returns -.5 to 1.5. i think.\r\nfloat noise( in vec2 p )\r\n{\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\r\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\r\n    return dot( n, vec3(70.0) );\t\r\n}\r\nfloat noise01(vec2 p)\r\n{\r\n    return clamp((noise(p)+.5)*.5, 0.,1.);\r\n}\r\n// debug function to convert distance to color, revealing sign.\r\nvec3 dtocolor(vec3 inpColor, float dist)\r\n{\r\n    vec3 ret;\r\n    if(dist > 0.)\r\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\r\n    else\r\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\r\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\r\n    return ret;\r\n}\r\n\r\nfloat smoothf(float x)\r\n{\r\n    return x*x*x*(x*(x*6. - 15.) + 10.);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////\r\n// APP CODE ...................\r\n\r\n// this function will produce a line with brush strokes. the inputs are such\r\n// that you can apply it to pretty much any line; the geometry is separated from this function.\r\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\r\n{\r\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\r\n\r\n    if(iMouse.z > 0.)\r\n    {\r\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\r\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\r\n    \tfloat okthen = 42.;// NOP\r\n    }\r\n    \r\n    // warp the position-in-line, to control the curve of the brush falloff.\r\n    if(posInLineY > 0.)\r\n    {\r\n        float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x);\r\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\r\n    }\r\n\r\n    // brush stroke fibers effect.\r\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\r\n    float strokeTexture = 0.\r\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\r\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\r\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\r\n        ;\r\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\r\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\r\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\r\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\r\n    // fade out the end of the stroke by shifting the noise curve below 0\r\n    const float strokeAlphaBoost = 1.09;\r\n    if(posInLineY > 0.)\r\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\r\n    else\r\n        strokeAlpha *= strokeAlphaBoost;\r\n\r\n    strokeAlpha = smoothf(strokeAlpha);\r\n    \r\n    // paper bleed effect.\r\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\r\n//    amt = 500.;// disable paper bleed    \r\n    \r\n    // blotches (per stroke)\r\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\r\n    //blotchAmt *= 0.4;\r\n    //strokeAlpha += blotchAmt;\r\n\r\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\r\n    alpha = clamp(alpha, 0.,1.);\r\n    return mix(inpColor, brushColor.rgb, alpha);\r\n}\r\n\r\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\r\n{\r\n    // flatten the line to be axis-aligned.\r\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\r\n    mat2 rotMat = rot2D(lineAngle);\r\n\r\n    float lineLength = distance(p2_, p1_);\r\n    // make an axis-aligned line from this line.\r\n    vec2 tl = (p1_ * rotMat);// top left\r\n    vec2 br = tl + vec2(0,lineLength);// bottom right\r\n    vec2 uvLine = uv * rotMat;\r\n\r\n    // make line slightly narrower at end.\r\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\r\n    \r\n    // wobble it around, humanize\r\n    float res = min(iResolution.y,iResolution.x);\r\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\r\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\r\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n\r\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\r\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\r\n    uvLine = tl - uvLine;\r\n    \r\n    vec2 lineSize = vec2(lineWidth, lineLength);\r\n    \r\n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\r\n                                d, inpColor, brushColor);\r\n    return ret;\r\n}\r\n\r\n// returns:\r\n// xy = uvLine\r\n// z = radius\r\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\r\n{\r\n    vec2 humanizedUVLine = uvLine;\r\n    \r\n\t// offsetting the circle along its path creates a twisting effect.\r\n    float twistAmt = .24;\r\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\r\n    humanizedUVLine.x += linePosY * twistAmt;\r\n    \r\n    // perturb radius / x\r\n    float humanizedRadius = radius_;\r\n    float res = min(iResolution.y,iResolution.x);\r\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\r\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\r\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\r\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n    \r\n    return vec3(humanizedUVLine, humanizedRadius);\r\n}\r\n\r\n// there's something about calling an Enso a \"donut\" that makes me giggle.\r\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\r\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\r\n{\r\n\tvec2 uvLine = uv - o;\r\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\r\n    angle = mod(angle-angleStart+pi, pi2);\r\n    if(!clockwise)\r\n        angle = pi2 - angle;\r\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\r\n    uvLine = vec2(\r\n        radius_ - length(uvLine),\r\n        angle / pi2 * lineLength\r\n    );\r\n    \r\n    // make line slightly narrower at end.\r\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\r\n    \r\n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n    vec2 humanizedUVLine = hu.xy;\r\n    float humanizedRadius = hu.z;\r\n\r\n    float d = opS(sdCircle(uv, o, humanizedRadius),\r\n                  sdCircle(uv, o, humanizedRadius));\r\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\r\n\r\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\r\n    \r\n    // do the same but for before the beginning of the line. distance field is just a single point\r\n    vec3 ret2 = vec3(1);\r\n    if(angle > pi)\r\n    {\r\n        uvLine.y -= lineLength;\r\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n        humanizedUVLine = hu.xy;\r\n        humanizedRadius = hu.z;\r\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\r\n        d = distance(uv, strokeStartPos);\r\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\r\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\r\n\t}\r\n    return min(ret, ret2);\r\n}\r\n\r\n\r\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\r\n{\r\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\r\n    ret *= newSize;// scale up to new dimensions\r\n    float aspect = iResolution.x / iResolution.y;\r\n    ret.x *= aspect;// orig aspect ratio\r\n    float newWidth = newSize.x * aspect;\r\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvSignature = (fragCoord / iResolution.y * 2.0) - 1.;\r\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\r\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\r\n    \r\n    vec3 col = vec3(1.,1.,0.875);// bg\r\n    float dist;\r\n    \r\n\t// geometry on display...\r\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red fixed line\r\n                           vec2(-1.4, -.4+yo),\r\n                           vec2(2.6, -.4+yo), 0.3);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red fixed line\r\n                           vec2(1.3, 0.+yo),\r\n                           vec2(-2.9, 0.+yo), 0.03);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red fixed line\r\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\r\n                           vec2(-2.9, .3+yo), 0.1);\r\n\r\n\r\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\r\n                                vec2(0,0),// origin\r\n                                0.6,// radius\r\n                                0.2,// angle of brush start\r\n                                0.5,// sweep amt 0-1\r\n                                0.3,// width\r\n                                false);// clockwise\r\n    \r\n    // paint blotches\r\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\r\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\r\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\r\n    col *= 1.-blotchAmt;\r\n    \r\n\t// signature\r\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\r\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.);\r\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\r\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\r\n\r\n    // grain\r\n    col.rgb += (rand(uv)-.5)*.08;\r\n    col.rgb = saturate(col.rgb);\r\n\r\n    // vignette\r\n    vec2 uvScreen = (fragCoord / iResolution.xy * 2.)-1.;\r\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\r\n    col *= vignetteAmt;\r\n    \r\n    fragColor = vec4(col, 1.);\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Brush Experiment 3","id":null,"date":null,"viewed":0,"name":"Brush Experiment 3","description":"Expanding on experiment 2, but for drawing circles. Mouse X controls falloff. Code is heavily commented showing the concept, not optimized at all.","likes":0,"published":null,"tags":["2d"," brush"," calligraphy"]},"ver":null,"info":{"Name":"Brush Experiment 3","id":null,"date":null,"viewed":0,"name":"Brush Experiment 3","description":"Expanding on experiment 2, but for drawing circles. Mouse X controls falloff. Code is heavily commented showing the concept, not optimized at all.","likes":0,"published":null,"tags":["2d"," brush"," calligraphy"]},"renderpass":[{"Code":"// todo: implement sweep amt\r\nvec2 mouse;\r\n\r\n////////////////////////////////////////////////////////////////\r\n// BOILERPLATE UTILITIES...................\r\nconst float pi = 3.14159;\r\nconst float pi2 = pi * 2.;\r\n\r\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\r\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\r\nfloat opI( float d1, float d2) { return max(d1,d2); }\r\n\r\n\r\n// from \"Magic Fractal\" by dgreensp\r\n// https://www.shadertoy.com/view/4ljGDd\r\nfloat magicBox(vec3 p) {\r\n    const int MAGIC_BOX_ITERS = 13;\r\n    const float MAGIC_BOX_MAGIC = 0.55;\r\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\r\n    // Take p anywhere in space and calculate the corresponding position\r\n    // inside the box, 0<(x,y,z)<1\r\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\r\n    \r\n    float lastLength = length(p);\r\n    float tot = 0.0;\r\n    // This is the fractal.  More iterations gives a more detailed\r\n    // fractal at the expense of more computation.\r\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\r\n      // The number subtracted here is a \"magic\" paremeter that\r\n      // produces rather different fractals for different values.\r\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\r\n      float newLength = length(p);\r\n      tot += abs(newLength-lastLength);\r\n      lastLength = newLength;\r\n    }\r\n\r\n    return tot;\r\n}\r\n\r\n\r\nfloat magicBox(vec2 uv){\r\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\r\n    // volume along the same axes as the fractal's bounding box.\r\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\r\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\r\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\r\n    vec3 p = 0.5*M*vec3(uv, 0.0);\r\n    return magicBox(p);\r\n}\r\n\r\n\r\n\r\n\r\nmat2 rot2D(float r)\r\n{\r\n    float c = cos(r), s = sin(r);\r\n    return mat2(c, s, -s, c);\r\n}\r\nfloat nsin(float a){return .5+.5*sin(a);}\r\nfloat ncos(float a){return .5+.5*cos(a);}\r\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\r\nfloat rand(vec2 co){\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\nfloat rand(float n){\r\n \treturn fract(cos(n*89.42)*343.42);\r\n}\r\nfloat dtoa(float d, float amount)\r\n{\r\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\r\n}\r\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\r\n{\r\n    vec2 d = max(tl-uv, uv-br);\r\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\r\n}\r\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\r\n{\r\n    return length(uv - origin) - radius;\r\n}\r\n// 0-1 1-0\r\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\r\n{\r\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\r\n}\r\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\r\nvec2 hash( vec2 p )\r\n{\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n// returns -.5 to 1.5. i think.\r\nfloat noise( in vec2 p )\r\n{\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\r\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\r\n    return dot( n, vec3(70.0) );\t\r\n}\r\nfloat noise01(vec2 p)\r\n{\r\n    return clamp((noise(p)+.5)*.5, 0.,1.);\r\n}\r\n// debug function to convert distance to color, revealing sign.\r\nvec3 dtocolor(vec3 inpColor, float dist)\r\n{\r\n    vec3 ret;\r\n    if(dist > 0.)\r\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\r\n    else\r\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\r\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\r\n    return ret;\r\n}\r\n\r\nfloat smoothf(float x)\r\n{\r\n    return x*x*x*(x*(x*6. - 15.) + 10.);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////\r\n// APP CODE ...................\r\n\r\n// this function will produce a line with brush strokes. the inputs are such\r\n// that you can apply it to pretty much any line; the geometry is separated from this function.\r\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\r\n{\r\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\r\n\r\n    if(iMouse.z > 0.)\r\n    {\r\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\r\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\r\n    \tfloat okthen = 42.;// NOP\r\n    }\r\n    \r\n    // warp the position-in-line, to control the curve of the brush falloff.\r\n    if(posInLineY > 0.)\r\n    {\r\n        float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x);\r\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\r\n    }\r\n\r\n    // brush stroke fibers effect.\r\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\r\n    float strokeTexture = 0.\r\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\r\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\r\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\r\n        ;\r\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\r\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\r\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\r\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\r\n    // fade out the end of the stroke by shifting the noise curve below 0\r\n    const float strokeAlphaBoost = 1.09;\r\n    if(posInLineY > 0.)\r\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\r\n    else\r\n        strokeAlpha *= strokeAlphaBoost;\r\n\r\n    strokeAlpha = smoothf(strokeAlpha);\r\n    \r\n    // paper bleed effect.\r\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\r\n//    amt = 500.;// disable paper bleed    \r\n    \r\n    // blotches (per stroke)\r\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\r\n    //blotchAmt *= 0.4;\r\n    //strokeAlpha += blotchAmt;\r\n\r\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\r\n    alpha = clamp(alpha, 0.,1.);\r\n    return mix(inpColor, brushColor.rgb, alpha);\r\n}\r\n\r\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\r\n{\r\n    // flatten the line to be axis-aligned.\r\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\r\n    mat2 rotMat = rot2D(lineAngle);\r\n\r\n    float lineLength = distance(p2_, p1_);\r\n    // make an axis-aligned line from this line.\r\n    vec2 tl = (p1_ * rotMat);// top left\r\n    vec2 br = tl + vec2(0,lineLength);// bottom right\r\n    vec2 uvLine = uv * rotMat;\r\n\r\n    // make line slightly narrower at end.\r\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\r\n    \r\n    // wobble it around, humanize\r\n    float res = min(iResolution.y,iResolution.x);\r\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\r\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\r\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n\r\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\r\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\r\n    uvLine = tl - uvLine;\r\n    \r\n    vec2 lineSize = vec2(lineWidth, lineLength);\r\n    \r\n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\r\n                                d, inpColor, brushColor);\r\n    return ret;\r\n}\r\n\r\n// returns:\r\n// xy = uvLine\r\n// z = radius\r\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\r\n{\r\n    vec2 humanizedUVLine = uvLine;\r\n    \r\n\t// offsetting the circle along its path creates a twisting effect.\r\n    float twistAmt = .24;\r\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\r\n    humanizedUVLine.x += linePosY * twistAmt;\r\n    \r\n    // perturb radius / x\r\n    float humanizedRadius = radius_;\r\n    float res = min(iResolution.y,iResolution.x);\r\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\r\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\r\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\r\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n    \r\n    return vec3(humanizedUVLine, humanizedRadius);\r\n}\r\n\r\n// there's something about calling an Enso a \"donut\" that makes me giggle.\r\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\r\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\r\n{\r\n\tvec2 uvLine = uv - o;\r\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\r\n    angle = mod(angle-angleStart+pi, pi2);\r\n    if(!clockwise)\r\n        angle = pi2 - angle;\r\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\r\n    uvLine = vec2(\r\n        radius_ - length(uvLine),\r\n        angle / pi2 * lineLength\r\n    );\r\n    \r\n    // make line slightly narrower at end.\r\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\r\n    \r\n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n    vec2 humanizedUVLine = hu.xy;\r\n    float humanizedRadius = hu.z;\r\n\r\n    float d = opS(sdCircle(uv, o, humanizedRadius),\r\n                  sdCircle(uv, o, humanizedRadius));\r\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\r\n\r\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\r\n    \r\n    // do the same but for before the beginning of the line. distance field is just a single point\r\n    vec3 ret2 = vec3(1);\r\n    if(angle > pi)\r\n    {\r\n        uvLine.y -= lineLength;\r\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n        humanizedUVLine = hu.xy;\r\n        humanizedRadius = hu.z;\r\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\r\n        d = distance(uv, strokeStartPos);\r\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\r\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\r\n\t}\r\n    return min(ret, ret2);\r\n}\r\n\r\n\r\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\r\n{\r\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\r\n    ret *= newSize;// scale up to new dimensions\r\n    float aspect = iResolution.x / iResolution.y;\r\n    ret.x *= aspect;// orig aspect ratio\r\n    float newWidth = newSize.x * aspect;\r\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvSignature = (fragCoord / iResolution.y * 2.0) - 1.;\r\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\r\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\r\n    \r\n    vec3 col = vec3(1.,1.,0.875);// bg\r\n    float dist;\r\n    \r\n\t// geometry on display...\r\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red fixed line\r\n                           vec2(-1.4, -.4+yo),\r\n                           vec2(2.6, -.4+yo), 0.3);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red fixed line\r\n                           vec2(1.3, 0.+yo),\r\n                           vec2(-2.9, 0.+yo), 0.03);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red fixed line\r\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\r\n                           vec2(-2.9, .3+yo), 0.1);\r\n\r\n\r\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\r\n                                vec2(0,0),// origin\r\n                                0.6,// radius\r\n                                0.2,// angle of brush start\r\n                                0.5,// sweep amt 0-1\r\n                                0.3,// width\r\n                                false);// clockwise\r\n    \r\n    // paint blotches\r\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\r\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\r\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\r\n    col *= 1.-blotchAmt;\r\n    \r\n\t// signature\r\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\r\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.);\r\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\r\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\r\n\r\n    // grain\r\n    col.rgb += (rand(uv)-.5)*.08;\r\n    col.rgb = saturate(col.rgb);\r\n\r\n    // vignette\r\n    vec2 uvScreen = (fragCoord / iResolution.xy * 2.)-1.;\r\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\r\n    col *= vignetteAmt;\r\n    \r\n    fragColor = vec4(col, 1.);\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"// todo: implement sweep amt\r\nvec2 mouse;\r\n\r\n////////////////////////////////////////////////////////////////\r\n// BOILERPLATE UTILITIES...................\r\nconst float pi = 3.14159;\r\nconst float pi2 = pi * 2.;\r\n\r\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\r\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\r\nfloat opI( float d1, float d2) { return max(d1,d2); }\r\n\r\n\r\n// from \"Magic Fractal\" by dgreensp\r\n// https://www.shadertoy.com/view/4ljGDd\r\nfloat magicBox(vec3 p) {\r\n    const int MAGIC_BOX_ITERS = 13;\r\n    const float MAGIC_BOX_MAGIC = 0.55;\r\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\r\n    // Take p anywhere in space and calculate the corresponding position\r\n    // inside the box, 0<(x,y,z)<1\r\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\r\n    \r\n    float lastLength = length(p);\r\n    float tot = 0.0;\r\n    // This is the fractal.  More iterations gives a more detailed\r\n    // fractal at the expense of more computation.\r\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\r\n      // The number subtracted here is a \"magic\" paremeter that\r\n      // produces rather different fractals for different values.\r\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\r\n      float newLength = length(p);\r\n      tot += abs(newLength-lastLength);\r\n      lastLength = newLength;\r\n    }\r\n\r\n    return tot;\r\n}\r\n\r\n\r\nfloat magicBox(vec2 uv){\r\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\r\n    // volume along the same axes as the fractal's bounding box.\r\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\r\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\r\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\r\n    vec3 p = 0.5*M*vec3(uv, 0.0);\r\n    return magicBox(p);\r\n}\r\n\r\n\r\n\r\n\r\nmat2 rot2D(float r)\r\n{\r\n    float c = cos(r), s = sin(r);\r\n    return mat2(c, s, -s, c);\r\n}\r\nfloat nsin(float a){return .5+.5*sin(a);}\r\nfloat ncos(float a){return .5+.5*cos(a);}\r\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\r\nfloat rand(vec2 co){\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\nfloat rand(float n){\r\n \treturn fract(cos(n*89.42)*343.42);\r\n}\r\nfloat dtoa(float d, float amount)\r\n{\r\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\r\n}\r\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\r\n{\r\n    vec2 d = max(tl-uv, uv-br);\r\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\r\n}\r\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\r\n{\r\n    return length(uv - origin) - radius;\r\n}\r\n// 0-1 1-0\r\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\r\n{\r\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\r\n}\r\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\r\nvec2 hash( vec2 p )\r\n{\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n// returns -.5 to 1.5. i think.\r\nfloat noise( in vec2 p )\r\n{\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\r\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\r\n    return dot( n, vec3(70.0) );\t\r\n}\r\nfloat noise01(vec2 p)\r\n{\r\n    return clamp((noise(p)+.5)*.5, 0.,1.);\r\n}\r\n// debug function to convert distance to color, revealing sign.\r\nvec3 dtocolor(vec3 inpColor, float dist)\r\n{\r\n    vec3 ret;\r\n    if(dist > 0.)\r\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\r\n    else\r\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\r\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\r\n    return ret;\r\n}\r\n\r\nfloat smoothf(float x)\r\n{\r\n    return x*x*x*(x*(x*6. - 15.) + 10.);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////\r\n// APP CODE ...................\r\n\r\n// this function will produce a line with brush strokes. the inputs are such\r\n// that you can apply it to pretty much any line; the geometry is separated from this function.\r\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\r\n{\r\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\r\n\r\n    if(iMouse.z > 0.)\r\n    {\r\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\r\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\r\n    \tfloat okthen = 42.;// NOP\r\n    }\r\n    \r\n    // warp the position-in-line, to control the curve of the brush falloff.\r\n    if(posInLineY > 0.)\r\n    {\r\n        float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x);\r\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\r\n    }\r\n\r\n    // brush stroke fibers effect.\r\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\r\n    float strokeTexture = 0.\r\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\r\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\r\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\r\n        ;\r\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\r\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\r\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\r\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\r\n    // fade out the end of the stroke by shifting the noise curve below 0\r\n    const float strokeAlphaBoost = 1.09;\r\n    if(posInLineY > 0.)\r\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\r\n    else\r\n        strokeAlpha *= strokeAlphaBoost;\r\n\r\n    strokeAlpha = smoothf(strokeAlpha);\r\n    \r\n    // paper bleed effect.\r\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\r\n//    amt = 500.;// disable paper bleed    \r\n    \r\n    // blotches (per stroke)\r\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\r\n    //blotchAmt *= 0.4;\r\n    //strokeAlpha += blotchAmt;\r\n\r\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\r\n    alpha = clamp(alpha, 0.,1.);\r\n    return mix(inpColor, brushColor.rgb, alpha);\r\n}\r\n\r\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\r\n{\r\n    // flatten the line to be axis-aligned.\r\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\r\n    mat2 rotMat = rot2D(lineAngle);\r\n\r\n    float lineLength = distance(p2_, p1_);\r\n    // make an axis-aligned line from this line.\r\n    vec2 tl = (p1_ * rotMat);// top left\r\n    vec2 br = tl + vec2(0,lineLength);// bottom right\r\n    vec2 uvLine = uv * rotMat;\r\n\r\n    // make line slightly narrower at end.\r\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\r\n    \r\n    // wobble it around, humanize\r\n    float res = min(iResolution.y,iResolution.x);\r\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\r\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\r\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n\r\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\r\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\r\n    uvLine = tl - uvLine;\r\n    \r\n    vec2 lineSize = vec2(lineWidth, lineLength);\r\n    \r\n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\r\n                                d, inpColor, brushColor);\r\n    return ret;\r\n}\r\n\r\n// returns:\r\n// xy = uvLine\r\n// z = radius\r\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\r\n{\r\n    vec2 humanizedUVLine = uvLine;\r\n    \r\n\t// offsetting the circle along its path creates a twisting effect.\r\n    float twistAmt = .24;\r\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\r\n    humanizedUVLine.x += linePosY * twistAmt;\r\n    \r\n    // perturb radius / x\r\n    float humanizedRadius = radius_;\r\n    float res = min(iResolution.y,iResolution.x);\r\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\r\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\r\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\r\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n    \r\n    return vec3(humanizedUVLine, humanizedRadius);\r\n}\r\n\r\n// there's something about calling an Enso a \"donut\" that makes me giggle.\r\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\r\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\r\n{\r\n\tvec2 uvLine = uv - o;\r\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\r\n    angle = mod(angle-angleStart+pi, pi2);\r\n    if(!clockwise)\r\n        angle = pi2 - angle;\r\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\r\n    uvLine = vec2(\r\n        radius_ - length(uvLine),\r\n        angle / pi2 * lineLength\r\n    );\r\n    \r\n    // make line slightly narrower at end.\r\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\r\n    \r\n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n    vec2 humanizedUVLine = hu.xy;\r\n    float humanizedRadius = hu.z;\r\n\r\n    float d = opS(sdCircle(uv, o, humanizedRadius),\r\n                  sdCircle(uv, o, humanizedRadius));\r\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\r\n\r\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\r\n    \r\n    // do the same but for before the beginning of the line. distance field is just a single point\r\n    vec3 ret2 = vec3(1);\r\n    if(angle > pi)\r\n    {\r\n        uvLine.y -= lineLength;\r\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n        humanizedUVLine = hu.xy;\r\n        humanizedRadius = hu.z;\r\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\r\n        d = distance(uv, strokeStartPos);\r\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\r\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\r\n\t}\r\n    return min(ret, ret2);\r\n}\r\n\r\n\r\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\r\n{\r\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\r\n    ret *= newSize;// scale up to new dimensions\r\n    float aspect = iResolution.x / iResolution.y;\r\n    ret.x *= aspect;// orig aspect ratio\r\n    float newWidth = newSize.x * aspect;\r\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvSignature = (fragCoord / iResolution.y * 2.0) - 1.;\r\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\r\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\r\n    \r\n    vec3 col = vec3(1.,1.,0.875);// bg\r\n    float dist;\r\n    \r\n\t// geometry on display...\r\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red fixed line\r\n                           vec2(-1.4, -.4+yo),\r\n                           vec2(2.6, -.4+yo), 0.3);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red fixed line\r\n                           vec2(1.3, 0.+yo),\r\n                           vec2(-2.9, 0.+yo), 0.03);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red fixed line\r\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\r\n                           vec2(-2.9, .3+yo), 0.1);\r\n\r\n\r\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\r\n                                vec2(0,0),// origin\r\n                                0.6,// radius\r\n                                0.2,// angle of brush start\r\n                                0.5,// sweep amt 0-1\r\n                                0.3,// width\r\n                                false);// clockwise\r\n    \r\n    // paint blotches\r\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\r\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\r\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\r\n    col *= 1.-blotchAmt;\r\n    \r\n\t// signature\r\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\r\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.);\r\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\r\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\r\n\r\n    // grain\r\n    col.rgb += (rand(uv)-.5)*.08;\r\n    col.rgb = saturate(col.rgb);\r\n\r\n    // vignette\r\n    vec2 uvScreen = (fragCoord / iResolution.xy * 2.)-1.;\r\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\r\n    col *= vignetteAmt;\r\n    \r\n    fragColor = vec4(col, 1.);\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*\r\n\tDesert Canyon\r\n\t-------------\r\n\r\n\tJust a simple canyon fly through. Since the laws of physics aren't adhered to (damn stray floating \r\n\trocks), you can safely assume the setting is a dry, rocky desert on a different planet... in an \r\n\talternate reality. :)\r\n\r\n\tI thought I'd do a daytime scene for a change. I like the way they look, but I find they require\r\n\tmore effort to light up correctly. In this particular example, I had to find the balance between\r\n\tindoor and outdoor lighting, but keep it simple enough to allow reasonable frame rates for swift \r\n\tcamera movement. For that reason, I was really thankful to have some of Dave Hoskins's and IQ's \r\n\texamples to refer to.\r\n\r\n\tThe inspiration for this particular scene came from Dr2's flyby examples. This is obviously less\r\n\tcomplicated, since his involve flybys with actual planes. Really cool, if you've never seen them.\r\n\r\n\tAnyway, I'll put up a more interesting one at a later date.\r\n\t\r\n\r\n\tOutdoor terrain shaders:\r\n\r\n\tElevated - iq\r\n\thttps://www.shadertoy.com/view/MdX3Rr\r\n\tBased on his (RGBA's) famous demo, Elevated.\r\n\thttp://www.pouet.net/prod.php?which=52938\r\n\r\n\t// How a canyon's really done. :)\r\n\tCanyon - iq\r\n\thttps://www.shadertoy.com/view/MdBGzG\r\n\r\n\t// Too many good ones to choose from, but here's one.\r\n\t// Mountains - Dave_Hoskins\r\n\thttps://www.shadertoy.com/view/4slGD4\r\n\r\n\t// Awesome.\r\n    River Flight - Dr2\r\n    https://www.shadertoy.com/view/4sSXDG\r\n\r\n*/\r\n\r\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \r\n// additional scenery starts to slow things down on my slower machine.\r\n#define FAR 65.\r\n\r\n// Frequencies and amplitudes of the \"path\" function, used to shape the tunnel and guide the camera.\r\nconst float freqA = .15/3.75;\r\nconst float freqB = .25/2.75;\r\nconst float ampA = 20.;\r\nconst float ampB = 4.;\r\n\r\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\r\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\r\n\r\n// 1x1 and 3x1 hash functions.\r\nfloat hash(float n){ return fract(cos(n)*45758.5453); }\r\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\r\n\r\n// Grey scale.\r\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\r\n\r\n/*\r\n// IQ's smooth minium function. \r\nfloat sminP(float a, float b , float s){\r\n    \r\n    float h = clamp(.5 + .5*(b - a)/s, 0., 1.);\r\n    return mix(b, a, h) - h*(1.0-h)*s;\r\n}\r\n*/\r\n\r\n// Smooth maximum, based on the function above.\r\nfloat smaxP(float a, float b, float s){\r\n    \r\n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\r\n    return mix(b, a, h) + h*(1. - h)*s;\r\n}\r\n\r\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\r\nvec2 path(in float z){ return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB) + 3.*(sin(z*0.025)  - 1.)); }\r\n\r\n// The canyon, complete with hills, gorges and tunnels. I would have liked to provide a far\r\n// more interesting scene, but had to keep things simple in order to accommodate slower machines.\r\nfloat map(in vec3 p){\r\n    \r\n    // Indexing into the pebbled texture to provide some rocky surface detatiling. I like this\r\n    // texture but I'd much rather produce my own. From what I hear, Shadertoy will be providing\r\n    // fixed offscreen buffer sizes (like 512 by 512, for instance) at a later date. When that\r\n    // happens, I'll really be able to do some damage. :)\r\n    float tx = textureLod(iChannel0, p.xz/16. + p.xy/80., 0.).x;\r\n  \r\n    // A couple of sinusoidal layers to produce the rocky hills.\r\n    vec3 q = p*.25;\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(.111));\r\n    \r\n    \r\n    // The terrain, so to speak. Just a flat XZ plane, at zero height, with some hills added.\r\n    float d = p.y + h*6.;\r\n  \r\n    // Reusing \"h\" to provide an undulating base layer on the tunnel walls.\r\n    q = sin(p*.5 + h);\r\n    h = q.x*q.y*q.z;\r\n  \r\n\t// Producing a single winding tunnel. If you're not familiar with the process, this is it.\r\n    // We're also adding some detailing to the walls via \"h\" and the rocky \"tx\" value.\r\n    p.xy -= path(p.z);\r\n    float tnl = 1.5 - length(p.xy*vec2(.33, .66)) + h + (1. - tx)*.25;\r\n\r\n\t// Smoothly combine the terrain with the tunnel - using a smooth maximum - then add some\r\n    // detailing. I've also added a portion of the tunnel term onto the end, just because\r\n    // I liked the way it looked more. \r\n    return smaxP(d, tnl, 2.) - tx*.5 + tnl*.8; \r\n\r\n}\r\n\r\n\r\n// Log-Bisection Tracing\r\n// https://www.shadertoy.com/view/4sSXzD\r\n//\r\n// Log-Bisection Tracing by nimitz (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Contact: nmz@Stormoid.com\r\n//\r\n// Notes: This is a trimmed down version of Nitmitz's original. If you're interested in the function \r\n// itself, refer to the original function in the link above. There, you'll find a good explanation as to \r\n// how it works too.\r\n//\r\n// For what it's worth, I've tried most of the standard raymarching methods around, and for difficult \r\n// surfaces to hone in on, like the one in this particular example, \"Log Bisection\" is my favorite.\r\n\r\nfloat logBisectTrace(in vec3 ro, in vec3 rd){\r\n\r\n\r\n    float t = 0., told = 0., mid, dn;\r\n    float d = map(rd*t + ro);\r\n    float sgn = sign(d);\r\n\r\n    for (int i=0; i<96; i++){\r\n\r\n        // If the threshold is crossed with no detection, use the bisection method.\r\n        // Also, break for the usual reasons. Note that there's only one \"break\"\r\n        // statement in the loop. I heard GPUs like that... but who knows?\r\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\r\n \r\n        told = t;\r\n        \r\n        // Branchless version of the following:   \r\n        // if(d>1.) t += d; else t += log(abs(d) + 1.1);     \r\n        t += step(d, 1.)*(log(abs(d) + 1.1) - d) + d;\r\n        //t += log(abs(d) + 1.1);\r\n        //t += d;//step(-1., -d)*(d - d*.5) + d*.5;\r\n        \r\n        d = map(rd*t + ro);\r\n    }\r\n    \r\n    // If a threshold was crossed without a solution, use the bisection method.\r\n    if (sign(d) != sgn){\r\n    \r\n        // Based on suggestions from CeeJayDK, with some minor changes.\r\n\r\n        dn = sign(map(rd*told + ro));\r\n        \r\n        vec2 iv = vec2(told, t); // Near, Far\r\n\r\n        // 6 iterations seems to be more than enough, for most cases...\r\n        // but there's an early exit, so I've added a couple more.\r\n        for (int ii=0; ii<8; ii++){ \r\n            //Evaluate midpoint\r\n            mid = dot(iv, vec2(.5));\r\n            float d = map(rd*mid + ro);\r\n            if (abs(d) < 0.001)break;\r\n            // Suggestion from movAX13h - Shadertoy is one of those rare\r\n            // sites with helpful commenters. :)\r\n            // Set mid to near or far, depending on which side we're on.\r\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\r\n        }\r\n\r\n        t = mid; \r\n        \r\n    }\r\n    \r\n\r\n    return min(t, FAR);\r\n}\r\n\r\n\r\n// Tetrahedral normal, courtesy of IQ.\r\nvec3 normal(in vec3 p)\r\n{  \r\n    vec2 e = vec2(-1, 1)*.001;   \r\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \r\n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \r\n}\r\n\r\n\r\n// Tri-Planar blending function. Based on an old Nvidia writeup:\r\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\r\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\r\n   \r\n    n = max(n*n, .001);\r\n    n /= (n.x + n.y + n.z );  \r\n    \r\n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\r\n}\r\n\r\n\r\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\r\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\r\n   \r\n    const float eps = .001;\r\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x - eps, p.y, p.z), nor)),\r\n                      getGrey(tex3D(tex, vec3(p.x, p.y - eps, p.z), nor)),\r\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z - eps), nor)));\r\n    \r\n    grad = (grad - getGrey(tex3D(tex, p, nor)))/eps; \r\n            \r\n    grad -= nor*dot(nor, grad);          \r\n                      \r\n    return normalize(nor + grad*bumpfactor);\r\n\t\r\n}\r\n\r\n// The iterations should be higher for proper accuracy, but in this case, I wanted less accuracy, just to leave\r\n// behind some subtle trails of light in the caves. They're fake, but they look a little like light streaming \r\n// through some cracks... kind of.\r\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\r\n\r\n    float shade = 1.;\r\n    // Increase this and the shadows will be more accurate, but the wispy light trails in the caves will disappear.\r\n    // Plus more iterations slow things down, so it works out, in this case.\r\n    const int maxIterationsShad = 10; \r\n\r\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \r\n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\r\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\r\n    float dist = start;\r\n    float stepDist = end/float(maxIterationsShad);\r\n\r\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \r\n    // number to give a decent shadow is the best one to choose. \r\n    for (int i=0; i<maxIterationsShad; i++){\r\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\r\n        // you may hit a surface not between the surface and the light.\r\n        float h = map(ro + rd*dist);\r\n        //shade = min(shade, k*h/dist);\r\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\r\n        \r\n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \r\n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\r\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\r\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\r\n        \r\n        // In this particular instance the light source is a long way away. However, we're only taking a few small steps\r\n        // toward the light and checking whether anything \"locally\" gets in the way. If a part of the scene a long distance away\r\n        // is between our hit point and the light source, it won't be accounted for. Technically that's not correct, but the local\r\n        // shadows give that illusion... kind of.\r\n        dist += clamp(h, .2, stepDist*2.);\r\n        \r\n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\r\n        if (abs(h)<.001 || dist > end) break; \r\n    }\r\n\r\n    // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \r\n    // look too brutal to me.\r\n    return min(max(shade, 0.) + .1, 1.); \r\n}\r\n\r\n\r\n\r\n\r\n\r\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \r\n// function and have been looking for an excuse to use it. For a better version, and usage, \r\n// refer to XT95's examples below:\r\n//\r\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\r\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\r\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist )\r\n{\r\n\tfloat ao = 0., l;\r\n\tconst float nbIte = 6.;\r\n\t//const float falloff = .9;\r\n    for(float i=1.; i< nbIte+.5; i++){\r\n    \r\n        l = (i + hash(i))*.5/nbIte*maxDist;\r\n        \r\n        ao += (l - map( p + n*l))/(1. + l);// / pow(1.+l, falloff);\r\n    }\r\n\t\r\n    return clamp(1. - ao/nbIte, 0., 1.);\r\n}\r\n\r\n// More concise, self contained version of IQ's original 3D noise function.\r\nfloat noise3D(in vec3 p){\r\n    \r\n    // Just some random figures, analogous to stride. You can change this, if you want.\r\n\tconst vec3 s = vec3(7, 157, 113);\r\n\t\r\n\tvec3 ip = floor(p); // Unique unit cell ID.\r\n    \r\n    // Setting up the stride vector for randomization and interpolation, kind of. \r\n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\r\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\r\n    \r\n\tp -= ip; // Cell's fractional component.\r\n\t\r\n    // A bit of cubic smoothing, to give the noise that rounded look.\r\n    p = p*p*(3. - 2.*p);\r\n    \r\n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\r\n    // then interpolating along X. There are countless ways to randomize, but this is\r\n    // the way most are familar with: fract(sin(x)*largeNumber).\r\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\r\n\t\r\n    // Interpolating along Y.\r\n    h.xy = mix(h.xz, h.yw, p.y);\r\n    \r\n    // Interpolating along Z, and returning the 3D noise value.\r\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\r\n\t\r\n}\r\n\r\n// Simple fBm to produce some clouds.\r\nfloat fbm(in vec3 p){\r\n    \r\n    // Four layers of 3D noise.\r\n    return .5333*noise3D(p) + .2667*noise3D(p*2.02) + .1333*noise3D(p*4.03) + .0667*noise3D(p*8.03);\r\n\r\n}\r\n\r\n\r\n// Pretty standard way to make a sky. \r\nvec3 getSky(in vec3 ro, in vec3 rd, vec3 sunDir){\r\n\r\n\t\r\n\tfloat sun = max(dot(rd, sunDir), 0.); // Sun strength.\r\n\tfloat horiz = pow(1.0-max(rd.y, 0.), 3.)*.35; // Horizon strength.\r\n\t\r\n\t// The blueish sky color. Tinging the sky redish around the sun. \t\t\r\n\tvec3 col = mix(vec3(.25, .35, .5), vec3(.4, .375, .35), sun*.75);//.zyx;\r\n    // Mixing in the sun color near the horizon.\r\n\tcol = mix(col, vec3(1, .9, .7), horiz);\r\n    \r\n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\r\n    // layers, rather than just the one. Much better.\r\n\tcol += .25*vec3(1, .7, .4)*pow(sun, 5.);\r\n\tcol += .25*vec3(1, .8, .6)*pow(sun, 64.);\r\n\tcol += .2*vec3(1, .9, .7)*max(pow(sun, 512.), .3);\r\n    \r\n    // Add a touch of speckle, to match up with the slightly speckly ground.\r\n    col = clamp(col + hash(rd)*.05 - .025, 0., 1.);\r\n\t\r\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\r\n    // since we're in the desert, and all that.\r\n\tvec3 sc = ro + rd*FAR*100.; sc.y *= 3.;\r\n    \r\n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\r\n\treturn mix( col, vec3(1, .95, 1), .5*smoothstep(.5, 1., fbm(.001*sc)) * clamp(rd.y*4., 0., 1.) );\r\n\t\r\n\r\n}\r\n\r\n// Cool curve function, by Shadertoy user, Nimitz.\r\n//\r\n// It gives you a scalar curvature value for an object's signed distance function, which \r\n// is pretty handy for all kinds of things. Here's it's used to darken the crevices.\r\n//\r\n// From an intuitive sense, the function returns a weighted difference between a surface \r\n// value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\r\n// calculations, I'm assuming. Almost common sense... almost. :)\r\n//\r\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\r\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\r\nfloat curve(in vec3 p){\r\n\r\n    const float eps = .05, amp = 4., ampInit = .5;\r\n\r\n    vec2 e = vec2(-1, 1)*eps; // 0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    \r\n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\r\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\r\n    \r\n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\r\n}\r\n\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\r\n\r\n\t\r\n\t// Screen coordinates.\r\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\r\n\t\r\n\t// Camera Setup.\r\n\tvec3 lookAt = vec3(0, 0, iTime*8.);  // \"Look At\" position.\r\n\tvec3 ro = lookAt + vec3(0, 0, -.25); // Camera position, doubling as the ray origin.\r\n \r\n\t// Using the Z-value to perturb the XY-plane.\r\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \r\n\t// synchronized with the distance function.\r\n\tlookAt.xy += path(lookAt.z);\r\n\tro.xy += path(ro.z);\r\n\r\n    // Using the above to produce the unit ray-direction vector.\r\n    float FOV = 3.14159/3.; // FOV - Field of view.\r\n    vec3 forward = normalize(lookAt - ro);\r\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \r\n    vec3 up = cross(forward, right);\r\n\r\n    // rd - Ray direction.\r\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\r\n    \r\n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\r\n    // Naturally, it's synchronized with the path in some kind of way.\r\n\trd.xy = rot2( path(lookAt.z).x/64. )*rd.xy;\r\n    \r\n    \r\n\t\r\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\r\n    // like some of the angular subtleties of point lights, so this is a point light a\r\n    // long distance away. Fake, and probably not advisable, but no one will notice.\r\n    vec3 lp = vec3(FAR*.5, FAR, FAR) + vec3(0, 0, ro.z);\r\n \r\n\r\n\t// Raymarching, using Nimitz's \"Log Bisection\" method. Very handy on stubborn surfaces. :)\r\n\tfloat t = logBisectTrace(ro, rd);\r\n    \r\n    // Standard sky routine. Worth learning. For outdoor scenes, you render the sky, then the\r\n    // terrain, then mix together with a fog falloff. Pretty straight forward.\r\n    vec3 sky = getSky(ro, rd, normalize(lp - ro));\r\n    \r\n    // The terrain color. Can't remember why I set it to sky. I'm sure I had my reasons.\r\n    vec3 col = sky;\r\n    \r\n    // If we've hit the ground, color it up.\r\n    if (t < FAR){\r\n    \r\n        vec3 sp = ro+t*rd; // Surface point.\r\n        vec3 sn = normal(sp); // Surface normal.\r\n\r\n        \r\n        // Light direction vector. From the sun to the surface point. We're not performing\r\n        // light distance attenuation, since it'll probably have minimal effect.\r\n        vec3 ld = lp-sp;\r\n        ld /= max(length(ld), 0.001); // Normalize the light direct vector.\r\n\r\n        \r\n        // Texture scale factor.        \r\n        const float tSize1 = 1./6.;\r\n        \r\n        // Bump mapping with the sandstone texture to provide a bit of gritty detailing.\r\n        // This might seem counter intuitive, but I've turned off mip mapping and set the\r\n        // texture to linear, in order to give some grainyness. I'm dividing the bump\r\n        // factor by the distance to smooth it out a little. Mip mapped textures without\r\n        // anisotropy look too smooth at certain viewing angles.\r\n        sn = doBumpMap(iChannel1, sp*tSize1, sn, .007/(1. + t/FAR));//max(1.-length(fwidth(sn)), .001)*hash(sp)/(1.+t/FAR)\r\n        \r\n        float shd = softShadow(sp, ld, .05, FAR, 8.); // Shadows.\r\n        float curv = curve(sp)*.9 +.1; // Surface curvature.\r\n        float ao = calculateAO(sp, sn, 4.); // Ambient occlusion.\r\n        \r\n        float dif = max( dot( ld, sn ), 0.); // Diffuse term.\r\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 5.); // Specular term.\r\n        float fre = clamp(1.0 + dot(rd, sn), 0., 1.); // Fresnel reflection term.\r\n\r\n       \r\n\r\n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\r\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\r\n        // used to give a hard clay consistency... It \"kind of\" works.\r\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\r\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\r\n       \r\n        // Overal global ambience. Without it, the cave sections would be pretty dark. It's made up,\r\n        // but I figured a little reflectance would be in amongst it... Sounds good, anyway. :)\r\n        float amb = fre*fre2 + .06*ao;\r\n        \r\n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\r\n        col = clamp(mix(vec3(.8, .5, .3), vec3(.5, .25, .125),(sp.y+1.)*.15), vec3(.5, .25, .125), vec3(1));\r\n        \r\n        // Give the soil a bit of a sandstone texture. This line's made up.\r\n        col =  smoothstep(-.5, 1., tex3D(iChannel1, sp*tSize1, sn))*(col + .25);\r\n        // One thing I really miss when using Shadertoy is anisotropic filtering, which makes mapped \r\n        // textures appear far more crisp. It requires just a few lines in the backend code, and doesn't \r\n        // appear to effect frame rate, but I'm assuming the developers have their reasons. Anyway, this\r\n        // line attempts to put a little definition back in, but it's definitely not the same thing. :)     \r\n        col = clamp(col + noise3D(sp*48.)*.3 - .15, 0., 1.);\r\n        \r\n        // Edit: This shader needs gamma correction, so I've hacked this and a postprocessing line\r\n        // in to counter the dark shading... I'll do it properly later.\r\n        col = pow(col, vec3(1.5));\r\n        \r\n        // Tweaking the curvature value a bit, then using it to color in the crevices with a \r\n        // brownish color... in a lame attempt to make the surface look dirt-like.\r\n        curv = smoothstep(0., .7, curv);\r\n        col *= vec3(curv, curv*.95, curv*.85);\r\n \r\n        \r\n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\r\n        col += getSky(sp, reflect(rd, sn), ld)*fre*fre2*.5;\r\n        \r\n        \r\n        // Combining all the terms from above. Some diffuse, some specular - both of which are\r\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\r\n        // good enough for the purposes of this demonstation.        \r\n        col = (col*(dif + .1) + fre2*spe)*shd*ao + amb*col;\r\n       \r\n        \r\n    }\r\n    \r\n    \r\n    // Combine the terrain with the sky using some distance fog. This one is designed to fade off very\r\n    // quickly a few units out from the horizon. Account for the clouds, change \"FAR - 15.\" to zero, and \r\n    // the fog will be way more prominent. You could also use \"1./(1 + t*scale),\" etc.\r\n    col = mix(col, sky, sqrt(smoothstep(FAR - 15., FAR, t)));\r\n    \r\n\r\n    // Edit: This shader needs gamma correction, so I've hacked this and a line above in\r\n    // to counter the dark shading... I'll do it properly later.\r\n    col = pow(max(col, 0.), vec3(.75));\r\n\r\n    \r\n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \r\n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\r\n    // term to give it more subtlety.\r\n    u = fragCoord/iResolution.xy;\r\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\r\n\r\n    // Done.\r\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":null,"published":0}],"outputs":[],"code":"/*\r\n\tDesert Canyon\r\n\t-------------\r\n\r\n\tJust a simple canyon fly through. Since the laws of physics aren't adhered to (damn stray floating \r\n\trocks), you can safely assume the setting is a dry, rocky desert on a different planet... in an \r\n\talternate reality. :)\r\n\r\n\tI thought I'd do a daytime scene for a change. I like the way they look, but I find they require\r\n\tmore effort to light up correctly. In this particular example, I had to find the balance between\r\n\tindoor and outdoor lighting, but keep it simple enough to allow reasonable frame rates for swift \r\n\tcamera movement. For that reason, I was really thankful to have some of Dave Hoskins's and IQ's \r\n\texamples to refer to.\r\n\r\n\tThe inspiration for this particular scene came from Dr2's flyby examples. This is obviously less\r\n\tcomplicated, since his involve flybys with actual planes. Really cool, if you've never seen them.\r\n\r\n\tAnyway, I'll put up a more interesting one at a later date.\r\n\t\r\n\r\n\tOutdoor terrain shaders:\r\n\r\n\tElevated - iq\r\n\thttps://www.shadertoy.com/view/MdX3Rr\r\n\tBased on his (RGBA's) famous demo, Elevated.\r\n\thttp://www.pouet.net/prod.php?which=52938\r\n\r\n\t// How a canyon's really done. :)\r\n\tCanyon - iq\r\n\thttps://www.shadertoy.com/view/MdBGzG\r\n\r\n\t// Too many good ones to choose from, but here's one.\r\n\t// Mountains - Dave_Hoskins\r\n\thttps://www.shadertoy.com/view/4slGD4\r\n\r\n\t// Awesome.\r\n    River Flight - Dr2\r\n    https://www.shadertoy.com/view/4sSXDG\r\n\r\n*/\r\n\r\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \r\n// additional scenery starts to slow things down on my slower machine.\r\n#define FAR 65.\r\n\r\n// Frequencies and amplitudes of the \"path\" function, used to shape the tunnel and guide the camera.\r\nconst float freqA = .15/3.75;\r\nconst float freqB = .25/2.75;\r\nconst float ampA = 20.;\r\nconst float ampB = 4.;\r\n\r\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\r\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\r\n\r\n// 1x1 and 3x1 hash functions.\r\nfloat hash(float n){ return fract(cos(n)*45758.5453); }\r\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\r\n\r\n// Grey scale.\r\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\r\n\r\n/*\r\n// IQ's smooth minium function. \r\nfloat sminP(float a, float b , float s){\r\n    \r\n    float h = clamp(.5 + .5*(b - a)/s, 0., 1.);\r\n    return mix(b, a, h) - h*(1.0-h)*s;\r\n}\r\n*/\r\n\r\n// Smooth maximum, based on the function above.\r\nfloat smaxP(float a, float b, float s){\r\n    \r\n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\r\n    return mix(b, a, h) + h*(1. - h)*s;\r\n}\r\n\r\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\r\nvec2 path(in float z){ return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB) + 3.*(sin(z*0.025)  - 1.)); }\r\n\r\n// The canyon, complete with hills, gorges and tunnels. I would have liked to provide a far\r\n// more interesting scene, but had to keep things simple in order to accommodate slower machines.\r\nfloat map(in vec3 p){\r\n    \r\n    // Indexing into the pebbled texture to provide some rocky surface detatiling. I like this\r\n    // texture but I'd much rather produce my own. From what I hear, Shadertoy will be providing\r\n    // fixed offscreen buffer sizes (like 512 by 512, for instance) at a later date. When that\r\n    // happens, I'll really be able to do some damage. :)\r\n    float tx = textureLod(iChannel0, p.xz/16. + p.xy/80., 0.).x;\r\n  \r\n    // A couple of sinusoidal layers to produce the rocky hills.\r\n    vec3 q = p*.25;\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(.111));\r\n    \r\n    \r\n    // The terrain, so to speak. Just a flat XZ plane, at zero height, with some hills added.\r\n    float d = p.y + h*6.;\r\n  \r\n    // Reusing \"h\" to provide an undulating base layer on the tunnel walls.\r\n    q = sin(p*.5 + h);\r\n    h = q.x*q.y*q.z;\r\n  \r\n\t// Producing a single winding tunnel. If you're not familiar with the process, this is it.\r\n    // We're also adding some detailing to the walls via \"h\" and the rocky \"tx\" value.\r\n    p.xy -= path(p.z);\r\n    float tnl = 1.5 - length(p.xy*vec2(.33, .66)) + h + (1. - tx)*.25;\r\n\r\n\t// Smoothly combine the terrain with the tunnel - using a smooth maximum - then add some\r\n    // detailing. I've also added a portion of the tunnel term onto the end, just because\r\n    // I liked the way it looked more. \r\n    return smaxP(d, tnl, 2.) - tx*.5 + tnl*.8; \r\n\r\n}\r\n\r\n\r\n// Log-Bisection Tracing\r\n// https://www.shadertoy.com/view/4sSXzD\r\n//\r\n// Log-Bisection Tracing by nimitz (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Contact: nmz@Stormoid.com\r\n//\r\n// Notes: This is a trimmed down version of Nitmitz's original. If you're interested in the function \r\n// itself, refer to the original function in the link above. There, you'll find a good explanation as to \r\n// how it works too.\r\n//\r\n// For what it's worth, I've tried most of the standard raymarching methods around, and for difficult \r\n// surfaces to hone in on, like the one in this particular example, \"Log Bisection\" is my favorite.\r\n\r\nfloat logBisectTrace(in vec3 ro, in vec3 rd){\r\n\r\n\r\n    float t = 0., told = 0., mid, dn;\r\n    float d = map(rd*t + ro);\r\n    float sgn = sign(d);\r\n\r\n    for (int i=0; i<96; i++){\r\n\r\n        // If the threshold is crossed with no detection, use the bisection method.\r\n        // Also, break for the usual reasons. Note that there's only one \"break\"\r\n        // statement in the loop. I heard GPUs like that... but who knows?\r\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\r\n \r\n        told = t;\r\n        \r\n        // Branchless version of the following:   \r\n        // if(d>1.) t += d; else t += log(abs(d) + 1.1);     \r\n        t += step(d, 1.)*(log(abs(d) + 1.1) - d) + d;\r\n        //t += log(abs(d) + 1.1);\r\n        //t += d;//step(-1., -d)*(d - d*.5) + d*.5;\r\n        \r\n        d = map(rd*t + ro);\r\n    }\r\n    \r\n    // If a threshold was crossed without a solution, use the bisection method.\r\n    if (sign(d) != sgn){\r\n    \r\n        // Based on suggestions from CeeJayDK, with some minor changes.\r\n\r\n        dn = sign(map(rd*told + ro));\r\n        \r\n        vec2 iv = vec2(told, t); // Near, Far\r\n\r\n        // 6 iterations seems to be more than enough, for most cases...\r\n        // but there's an early exit, so I've added a couple more.\r\n        for (int ii=0; ii<8; ii++){ \r\n            //Evaluate midpoint\r\n            mid = dot(iv, vec2(.5));\r\n            float d = map(rd*mid + ro);\r\n            if (abs(d) < 0.001)break;\r\n            // Suggestion from movAX13h - Shadertoy is one of those rare\r\n            // sites with helpful commenters. :)\r\n            // Set mid to near or far, depending on which side we're on.\r\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\r\n        }\r\n\r\n        t = mid; \r\n        \r\n    }\r\n    \r\n\r\n    return min(t, FAR);\r\n}\r\n\r\n\r\n// Tetrahedral normal, courtesy of IQ.\r\nvec3 normal(in vec3 p)\r\n{  \r\n    vec2 e = vec2(-1, 1)*.001;   \r\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \r\n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \r\n}\r\n\r\n\r\n// Tri-Planar blending function. Based on an old Nvidia writeup:\r\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\r\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\r\n   \r\n    n = max(n*n, .001);\r\n    n /= (n.x + n.y + n.z );  \r\n    \r\n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\r\n}\r\n\r\n\r\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\r\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\r\n   \r\n    const float eps = .001;\r\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x - eps, p.y, p.z), nor)),\r\n                      getGrey(tex3D(tex, vec3(p.x, p.y - eps, p.z), nor)),\r\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z - eps), nor)));\r\n    \r\n    grad = (grad - getGrey(tex3D(tex, p, nor)))/eps; \r\n            \r\n    grad -= nor*dot(nor, grad);          \r\n                      \r\n    return normalize(nor + grad*bumpfactor);\r\n\t\r\n}\r\n\r\n// The iterations should be higher for proper accuracy, but in this case, I wanted less accuracy, just to leave\r\n// behind some subtle trails of light in the caves. They're fake, but they look a little like light streaming \r\n// through some cracks... kind of.\r\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\r\n\r\n    float shade = 1.;\r\n    // Increase this and the shadows will be more accurate, but the wispy light trails in the caves will disappear.\r\n    // Plus more iterations slow things down, so it works out, in this case.\r\n    const int maxIterationsShad = 10; \r\n\r\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \r\n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\r\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\r\n    float dist = start;\r\n    float stepDist = end/float(maxIterationsShad);\r\n\r\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \r\n    // number to give a decent shadow is the best one to choose. \r\n    for (int i=0; i<maxIterationsShad; i++){\r\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\r\n        // you may hit a surface not between the surface and the light.\r\n        float h = map(ro + rd*dist);\r\n        //shade = min(shade, k*h/dist);\r\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\r\n        \r\n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \r\n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\r\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\r\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\r\n        \r\n        // In this particular instance the light source is a long way away. However, we're only taking a few small steps\r\n        // toward the light and checking whether anything \"locally\" gets in the way. If a part of the scene a long distance away\r\n        // is between our hit point and the light source, it won't be accounted for. Technically that's not correct, but the local\r\n        // shadows give that illusion... kind of.\r\n        dist += clamp(h, .2, stepDist*2.);\r\n        \r\n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\r\n        if (abs(h)<.001 || dist > end) break; \r\n    }\r\n\r\n    // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \r\n    // look too brutal to me.\r\n    return min(max(shade, 0.) + .1, 1.); \r\n}\r\n\r\n\r\n\r\n\r\n\r\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \r\n// function and have been looking for an excuse to use it. For a better version, and usage, \r\n// refer to XT95's examples below:\r\n//\r\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\r\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\r\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist )\r\n{\r\n\tfloat ao = 0., l;\r\n\tconst float nbIte = 6.;\r\n\t//const float falloff = .9;\r\n    for(float i=1.; i< nbIte+.5; i++){\r\n    \r\n        l = (i + hash(i))*.5/nbIte*maxDist;\r\n        \r\n        ao += (l - map( p + n*l))/(1. + l);// / pow(1.+l, falloff);\r\n    }\r\n\t\r\n    return clamp(1. - ao/nbIte, 0., 1.);\r\n}\r\n\r\n// More concise, self contained version of IQ's original 3D noise function.\r\nfloat noise3D(in vec3 p){\r\n    \r\n    // Just some random figures, analogous to stride. You can change this, if you want.\r\n\tconst vec3 s = vec3(7, 157, 113);\r\n\t\r\n\tvec3 ip = floor(p); // Unique unit cell ID.\r\n    \r\n    // Setting up the stride vector for randomization and interpolation, kind of. \r\n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\r\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\r\n    \r\n\tp -= ip; // Cell's fractional component.\r\n\t\r\n    // A bit of cubic smoothing, to give the noise that rounded look.\r\n    p = p*p*(3. - 2.*p);\r\n    \r\n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\r\n    // then interpolating along X. There are countless ways to randomize, but this is\r\n    // the way most are familar with: fract(sin(x)*largeNumber).\r\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\r\n\t\r\n    // Interpolating along Y.\r\n    h.xy = mix(h.xz, h.yw, p.y);\r\n    \r\n    // Interpolating along Z, and returning the 3D noise value.\r\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\r\n\t\r\n}\r\n\r\n// Simple fBm to produce some clouds.\r\nfloat fbm(in vec3 p){\r\n    \r\n    // Four layers of 3D noise.\r\n    return .5333*noise3D(p) + .2667*noise3D(p*2.02) + .1333*noise3D(p*4.03) + .0667*noise3D(p*8.03);\r\n\r\n}\r\n\r\n\r\n// Pretty standard way to make a sky. \r\nvec3 getSky(in vec3 ro, in vec3 rd, vec3 sunDir){\r\n\r\n\t\r\n\tfloat sun = max(dot(rd, sunDir), 0.); // Sun strength.\r\n\tfloat horiz = pow(1.0-max(rd.y, 0.), 3.)*.35; // Horizon strength.\r\n\t\r\n\t// The blueish sky color. Tinging the sky redish around the sun. \t\t\r\n\tvec3 col = mix(vec3(.25, .35, .5), vec3(.4, .375, .35), sun*.75);//.zyx;\r\n    // Mixing in the sun color near the horizon.\r\n\tcol = mix(col, vec3(1, .9, .7), horiz);\r\n    \r\n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\r\n    // layers, rather than just the one. Much better.\r\n\tcol += .25*vec3(1, .7, .4)*pow(sun, 5.);\r\n\tcol += .25*vec3(1, .8, .6)*pow(sun, 64.);\r\n\tcol += .2*vec3(1, .9, .7)*max(pow(sun, 512.), .3);\r\n    \r\n    // Add a touch of speckle, to match up with the slightly speckly ground.\r\n    col = clamp(col + hash(rd)*.05 - .025, 0., 1.);\r\n\t\r\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\r\n    // since we're in the desert, and all that.\r\n\tvec3 sc = ro + rd*FAR*100.; sc.y *= 3.;\r\n    \r\n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\r\n\treturn mix( col, vec3(1, .95, 1), .5*smoothstep(.5, 1., fbm(.001*sc)) * clamp(rd.y*4., 0., 1.) );\r\n\t\r\n\r\n}\r\n\r\n// Cool curve function, by Shadertoy user, Nimitz.\r\n//\r\n// It gives you a scalar curvature value for an object's signed distance function, which \r\n// is pretty handy for all kinds of things. Here's it's used to darken the crevices.\r\n//\r\n// From an intuitive sense, the function returns a weighted difference between a surface \r\n// value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\r\n// calculations, I'm assuming. Almost common sense... almost. :)\r\n//\r\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\r\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\r\nfloat curve(in vec3 p){\r\n\r\n    const float eps = .05, amp = 4., ampInit = .5;\r\n\r\n    vec2 e = vec2(-1, 1)*eps; // 0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    \r\n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\r\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\r\n    \r\n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\r\n}\r\n\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\r\n\r\n\t\r\n\t// Screen coordinates.\r\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\r\n\t\r\n\t// Camera Setup.\r\n\tvec3 lookAt = vec3(0, 0, iTime*8.);  // \"Look At\" position.\r\n\tvec3 ro = lookAt + vec3(0, 0, -.25); // Camera position, doubling as the ray origin.\r\n \r\n\t// Using the Z-value to perturb the XY-plane.\r\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \r\n\t// synchronized with the distance function.\r\n\tlookAt.xy += path(lookAt.z);\r\n\tro.xy += path(ro.z);\r\n\r\n    // Using the above to produce the unit ray-direction vector.\r\n    float FOV = 3.14159/3.; // FOV - Field of view.\r\n    vec3 forward = normalize(lookAt - ro);\r\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \r\n    vec3 up = cross(forward, right);\r\n\r\n    // rd - Ray direction.\r\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\r\n    \r\n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\r\n    // Naturally, it's synchronized with the path in some kind of way.\r\n\trd.xy = rot2( path(lookAt.z).x/64. )*rd.xy;\r\n    \r\n    \r\n\t\r\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\r\n    // like some of the angular subtleties of point lights, so this is a point light a\r\n    // long distance away. Fake, and probably not advisable, but no one will notice.\r\n    vec3 lp = vec3(FAR*.5, FAR, FAR) + vec3(0, 0, ro.z);\r\n \r\n\r\n\t// Raymarching, using Nimitz's \"Log Bisection\" method. Very handy on stubborn surfaces. :)\r\n\tfloat t = logBisectTrace(ro, rd);\r\n    \r\n    // Standard sky routine. Worth learning. For outdoor scenes, you render the sky, then the\r\n    // terrain, then mix together with a fog falloff. Pretty straight forward.\r\n    vec3 sky = getSky(ro, rd, normalize(lp - ro));\r\n    \r\n    // The terrain color. Can't remember why I set it to sky. I'm sure I had my reasons.\r\n    vec3 col = sky;\r\n    \r\n    // If we've hit the ground, color it up.\r\n    if (t < FAR){\r\n    \r\n        vec3 sp = ro+t*rd; // Surface point.\r\n        vec3 sn = normal(sp); // Surface normal.\r\n\r\n        \r\n        // Light direction vector. From the sun to the surface point. We're not performing\r\n        // light distance attenuation, since it'll probably have minimal effect.\r\n        vec3 ld = lp-sp;\r\n        ld /= max(length(ld), 0.001); // Normalize the light direct vector.\r\n\r\n        \r\n        // Texture scale factor.        \r\n        const float tSize1 = 1./6.;\r\n        \r\n        // Bump mapping with the sandstone texture to provide a bit of gritty detailing.\r\n        // This might seem counter intuitive, but I've turned off mip mapping and set the\r\n        // texture to linear, in order to give some grainyness. I'm dividing the bump\r\n        // factor by the distance to smooth it out a little. Mip mapped textures without\r\n        // anisotropy look too smooth at certain viewing angles.\r\n        sn = doBumpMap(iChannel1, sp*tSize1, sn, .007/(1. + t/FAR));//max(1.-length(fwidth(sn)), .001)*hash(sp)/(1.+t/FAR)\r\n        \r\n        float shd = softShadow(sp, ld, .05, FAR, 8.); // Shadows.\r\n        float curv = curve(sp)*.9 +.1; // Surface curvature.\r\n        float ao = calculateAO(sp, sn, 4.); // Ambient occlusion.\r\n        \r\n        float dif = max( dot( ld, sn ), 0.); // Diffuse term.\r\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 5.); // Specular term.\r\n        float fre = clamp(1.0 + dot(rd, sn), 0., 1.); // Fresnel reflection term.\r\n\r\n       \r\n\r\n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\r\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\r\n        // used to give a hard clay consistency... It \"kind of\" works.\r\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\r\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\r\n       \r\n        // Overal global ambience. Without it, the cave sections would be pretty dark. It's made up,\r\n        // but I figured a little reflectance would be in amongst it... Sounds good, anyway. :)\r\n        float amb = fre*fre2 + .06*ao;\r\n        \r\n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\r\n        col = clamp(mix(vec3(.8, .5, .3), vec3(.5, .25, .125),(sp.y+1.)*.15), vec3(.5, .25, .125), vec3(1));\r\n        \r\n        // Give the soil a bit of a sandstone texture. This line's made up.\r\n        col =  smoothstep(-.5, 1., tex3D(iChannel1, sp*tSize1, sn))*(col + .25);\r\n        // One thing I really miss when using Shadertoy is anisotropic filtering, which makes mapped \r\n        // textures appear far more crisp. It requires just a few lines in the backend code, and doesn't \r\n        // appear to effect frame rate, but I'm assuming the developers have their reasons. Anyway, this\r\n        // line attempts to put a little definition back in, but it's definitely not the same thing. :)     \r\n        col = clamp(col + noise3D(sp*48.)*.3 - .15, 0., 1.);\r\n        \r\n        // Edit: This shader needs gamma correction, so I've hacked this and a postprocessing line\r\n        // in to counter the dark shading... I'll do it properly later.\r\n        col = pow(col, vec3(1.5));\r\n        \r\n        // Tweaking the curvature value a bit, then using it to color in the crevices with a \r\n        // brownish color... in a lame attempt to make the surface look dirt-like.\r\n        curv = smoothstep(0., .7, curv);\r\n        col *= vec3(curv, curv*.95, curv*.85);\r\n \r\n        \r\n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\r\n        col += getSky(sp, reflect(rd, sn), ld)*fre*fre2*.5;\r\n        \r\n        \r\n        // Combining all the terms from above. Some diffuse, some specular - both of which are\r\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\r\n        // good enough for the purposes of this demonstation.        \r\n        col = (col*(dif + .1) + fre2*spe)*shd*ao + amb*col;\r\n       \r\n        \r\n    }\r\n    \r\n    \r\n    // Combine the terrain with the sky using some distance fog. This one is designed to fade off very\r\n    // quickly a few units out from the horizon. Account for the clouds, change \"FAR - 15.\" to zero, and \r\n    // the fog will be way more prominent. You could also use \"1./(1 + t*scale),\" etc.\r\n    col = mix(col, sky, sqrt(smoothstep(FAR - 15., FAR, t)));\r\n    \r\n\r\n    // Edit: This shader needs gamma correction, so I've hacked this and a line above in\r\n    // to counter the dark shading... I'll do it properly later.\r\n    col = pow(max(col, 0.), vec3(.75));\r\n\r\n    \r\n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \r\n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\r\n    // term to give it more subtlety.\r\n    u = fragCoord/iResolution.xy;\r\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\r\n\r\n    // Done.\r\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":null,"published":0}],"Info":{"Name":"Desert Canyon","id":null,"date":null,"viewed":0,"name":"Desert Canyon","description":"Traversing a desert canyon.","likes":0,"published":null,"tags":["raymarching"," tunnel"," terrain"," sky"]},"ver":null,"info":{"Name":"Desert Canyon","id":null,"date":null,"viewed":0,"name":"Desert Canyon","description":"Traversing a desert canyon.","likes":0,"published":null,"tags":["raymarching"," tunnel"," terrain"," sky"]},"renderpass":[{"Code":"/*\r\n\tDesert Canyon\r\n\t-------------\r\n\r\n\tJust a simple canyon fly through. Since the laws of physics aren't adhered to (damn stray floating \r\n\trocks), you can safely assume the setting is a dry, rocky desert on a different planet... in an \r\n\talternate reality. :)\r\n\r\n\tI thought I'd do a daytime scene for a change. I like the way they look, but I find they require\r\n\tmore effort to light up correctly. In this particular example, I had to find the balance between\r\n\tindoor and outdoor lighting, but keep it simple enough to allow reasonable frame rates for swift \r\n\tcamera movement. For that reason, I was really thankful to have some of Dave Hoskins's and IQ's \r\n\texamples to refer to.\r\n\r\n\tThe inspiration for this particular scene came from Dr2's flyby examples. This is obviously less\r\n\tcomplicated, since his involve flybys with actual planes. Really cool, if you've never seen them.\r\n\r\n\tAnyway, I'll put up a more interesting one at a later date.\r\n\t\r\n\r\n\tOutdoor terrain shaders:\r\n\r\n\tElevated - iq\r\n\thttps://www.shadertoy.com/view/MdX3Rr\r\n\tBased on his (RGBA's) famous demo, Elevated.\r\n\thttp://www.pouet.net/prod.php?which=52938\r\n\r\n\t// How a canyon's really done. :)\r\n\tCanyon - iq\r\n\thttps://www.shadertoy.com/view/MdBGzG\r\n\r\n\t// Too many good ones to choose from, but here's one.\r\n\t// Mountains - Dave_Hoskins\r\n\thttps://www.shadertoy.com/view/4slGD4\r\n\r\n\t// Awesome.\r\n    River Flight - Dr2\r\n    https://www.shadertoy.com/view/4sSXDG\r\n\r\n*/\r\n\r\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \r\n// additional scenery starts to slow things down on my slower machine.\r\n#define FAR 65.\r\n\r\n// Frequencies and amplitudes of the \"path\" function, used to shape the tunnel and guide the camera.\r\nconst float freqA = .15/3.75;\r\nconst float freqB = .25/2.75;\r\nconst float ampA = 20.;\r\nconst float ampB = 4.;\r\n\r\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\r\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\r\n\r\n// 1x1 and 3x1 hash functions.\r\nfloat hash(float n){ return fract(cos(n)*45758.5453); }\r\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\r\n\r\n// Grey scale.\r\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\r\n\r\n/*\r\n// IQ's smooth minium function. \r\nfloat sminP(float a, float b , float s){\r\n    \r\n    float h = clamp(.5 + .5*(b - a)/s, 0., 1.);\r\n    return mix(b, a, h) - h*(1.0-h)*s;\r\n}\r\n*/\r\n\r\n// Smooth maximum, based on the function above.\r\nfloat smaxP(float a, float b, float s){\r\n    \r\n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\r\n    return mix(b, a, h) + h*(1. - h)*s;\r\n}\r\n\r\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\r\nvec2 path(in float z){ return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB) + 3.*(sin(z*0.025)  - 1.)); }\r\n\r\n// The canyon, complete with hills, gorges and tunnels. I would have liked to provide a far\r\n// more interesting scene, but had to keep things simple in order to accommodate slower machines.\r\nfloat map(in vec3 p){\r\n    \r\n    // Indexing into the pebbled texture to provide some rocky surface detatiling. I like this\r\n    // texture but I'd much rather produce my own. From what I hear, Shadertoy will be providing\r\n    // fixed offscreen buffer sizes (like 512 by 512, for instance) at a later date. When that\r\n    // happens, I'll really be able to do some damage. :)\r\n    float tx = textureLod(iChannel0, p.xz/16. + p.xy/80., 0.).x;\r\n  \r\n    // A couple of sinusoidal layers to produce the rocky hills.\r\n    vec3 q = p*.25;\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(.111));\r\n    \r\n    \r\n    // The terrain, so to speak. Just a flat XZ plane, at zero height, with some hills added.\r\n    float d = p.y + h*6.;\r\n  \r\n    // Reusing \"h\" to provide an undulating base layer on the tunnel walls.\r\n    q = sin(p*.5 + h);\r\n    h = q.x*q.y*q.z;\r\n  \r\n\t// Producing a single winding tunnel. If you're not familiar with the process, this is it.\r\n    // We're also adding some detailing to the walls via \"h\" and the rocky \"tx\" value.\r\n    p.xy -= path(p.z);\r\n    float tnl = 1.5 - length(p.xy*vec2(.33, .66)) + h + (1. - tx)*.25;\r\n\r\n\t// Smoothly combine the terrain with the tunnel - using a smooth maximum - then add some\r\n    // detailing. I've also added a portion of the tunnel term onto the end, just because\r\n    // I liked the way it looked more. \r\n    return smaxP(d, tnl, 2.) - tx*.5 + tnl*.8; \r\n\r\n}\r\n\r\n\r\n// Log-Bisection Tracing\r\n// https://www.shadertoy.com/view/4sSXzD\r\n//\r\n// Log-Bisection Tracing by nimitz (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Contact: nmz@Stormoid.com\r\n//\r\n// Notes: This is a trimmed down version of Nitmitz's original. If you're interested in the function \r\n// itself, refer to the original function in the link above. There, you'll find a good explanation as to \r\n// how it works too.\r\n//\r\n// For what it's worth, I've tried most of the standard raymarching methods around, and for difficult \r\n// surfaces to hone in on, like the one in this particular example, \"Log Bisection\" is my favorite.\r\n\r\nfloat logBisectTrace(in vec3 ro, in vec3 rd){\r\n\r\n\r\n    float t = 0., told = 0., mid, dn;\r\n    float d = map(rd*t + ro);\r\n    float sgn = sign(d);\r\n\r\n    for (int i=0; i<96; i++){\r\n\r\n        // If the threshold is crossed with no detection, use the bisection method.\r\n        // Also, break for the usual reasons. Note that there's only one \"break\"\r\n        // statement in the loop. I heard GPUs like that... but who knows?\r\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\r\n \r\n        told = t;\r\n        \r\n        // Branchless version of the following:   \r\n        // if(d>1.) t += d; else t += log(abs(d) + 1.1);     \r\n        t += step(d, 1.)*(log(abs(d) + 1.1) - d) + d;\r\n        //t += log(abs(d) + 1.1);\r\n        //t += d;//step(-1., -d)*(d - d*.5) + d*.5;\r\n        \r\n        d = map(rd*t + ro);\r\n    }\r\n    \r\n    // If a threshold was crossed without a solution, use the bisection method.\r\n    if (sign(d) != sgn){\r\n    \r\n        // Based on suggestions from CeeJayDK, with some minor changes.\r\n\r\n        dn = sign(map(rd*told + ro));\r\n        \r\n        vec2 iv = vec2(told, t); // Near, Far\r\n\r\n        // 6 iterations seems to be more than enough, for most cases...\r\n        // but there's an early exit, so I've added a couple more.\r\n        for (int ii=0; ii<8; ii++){ \r\n            //Evaluate midpoint\r\n            mid = dot(iv, vec2(.5));\r\n            float d = map(rd*mid + ro);\r\n            if (abs(d) < 0.001)break;\r\n            // Suggestion from movAX13h - Shadertoy is one of those rare\r\n            // sites with helpful commenters. :)\r\n            // Set mid to near or far, depending on which side we're on.\r\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\r\n        }\r\n\r\n        t = mid; \r\n        \r\n    }\r\n    \r\n\r\n    return min(t, FAR);\r\n}\r\n\r\n\r\n// Tetrahedral normal, courtesy of IQ.\r\nvec3 normal(in vec3 p)\r\n{  \r\n    vec2 e = vec2(-1, 1)*.001;   \r\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \r\n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \r\n}\r\n\r\n\r\n// Tri-Planar blending function. Based on an old Nvidia writeup:\r\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\r\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\r\n   \r\n    n = max(n*n, .001);\r\n    n /= (n.x + n.y + n.z );  \r\n    \r\n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\r\n}\r\n\r\n\r\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\r\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\r\n   \r\n    const float eps = .001;\r\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x - eps, p.y, p.z), nor)),\r\n                      getGrey(tex3D(tex, vec3(p.x, p.y - eps, p.z), nor)),\r\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z - eps), nor)));\r\n    \r\n    grad = (grad - getGrey(tex3D(tex, p, nor)))/eps; \r\n            \r\n    grad -= nor*dot(nor, grad);          \r\n                      \r\n    return normalize(nor + grad*bumpfactor);\r\n\t\r\n}\r\n\r\n// The iterations should be higher for proper accuracy, but in this case, I wanted less accuracy, just to leave\r\n// behind some subtle trails of light in the caves. They're fake, but they look a little like light streaming \r\n// through some cracks... kind of.\r\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\r\n\r\n    float shade = 1.;\r\n    // Increase this and the shadows will be more accurate, but the wispy light trails in the caves will disappear.\r\n    // Plus more iterations slow things down, so it works out, in this case.\r\n    const int maxIterationsShad = 10; \r\n\r\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \r\n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\r\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\r\n    float dist = start;\r\n    float stepDist = end/float(maxIterationsShad);\r\n\r\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \r\n    // number to give a decent shadow is the best one to choose. \r\n    for (int i=0; i<maxIterationsShad; i++){\r\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\r\n        // you may hit a surface not between the surface and the light.\r\n        float h = map(ro + rd*dist);\r\n        //shade = min(shade, k*h/dist);\r\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\r\n        \r\n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \r\n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\r\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\r\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\r\n        \r\n        // In this particular instance the light source is a long way away. However, we're only taking a few small steps\r\n        // toward the light and checking whether anything \"locally\" gets in the way. If a part of the scene a long distance away\r\n        // is between our hit point and the light source, it won't be accounted for. Technically that's not correct, but the local\r\n        // shadows give that illusion... kind of.\r\n        dist += clamp(h, .2, stepDist*2.);\r\n        \r\n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\r\n        if (abs(h)<.001 || dist > end) break; \r\n    }\r\n\r\n    // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \r\n    // look too brutal to me.\r\n    return min(max(shade, 0.) + .1, 1.); \r\n}\r\n\r\n\r\n\r\n\r\n\r\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \r\n// function and have been looking for an excuse to use it. For a better version, and usage, \r\n// refer to XT95's examples below:\r\n//\r\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\r\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\r\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist )\r\n{\r\n\tfloat ao = 0., l;\r\n\tconst float nbIte = 6.;\r\n\t//const float falloff = .9;\r\n    for(float i=1.; i< nbIte+.5; i++){\r\n    \r\n        l = (i + hash(i))*.5/nbIte*maxDist;\r\n        \r\n        ao += (l - map( p + n*l))/(1. + l);// / pow(1.+l, falloff);\r\n    }\r\n\t\r\n    return clamp(1. - ao/nbIte, 0., 1.);\r\n}\r\n\r\n// More concise, self contained version of IQ's original 3D noise function.\r\nfloat noise3D(in vec3 p){\r\n    \r\n    // Just some random figures, analogous to stride. You can change this, if you want.\r\n\tconst vec3 s = vec3(7, 157, 113);\r\n\t\r\n\tvec3 ip = floor(p); // Unique unit cell ID.\r\n    \r\n    // Setting up the stride vector for randomization and interpolation, kind of. \r\n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\r\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\r\n    \r\n\tp -= ip; // Cell's fractional component.\r\n\t\r\n    // A bit of cubic smoothing, to give the noise that rounded look.\r\n    p = p*p*(3. - 2.*p);\r\n    \r\n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\r\n    // then interpolating along X. There are countless ways to randomize, but this is\r\n    // the way most are familar with: fract(sin(x)*largeNumber).\r\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\r\n\t\r\n    // Interpolating along Y.\r\n    h.xy = mix(h.xz, h.yw, p.y);\r\n    \r\n    // Interpolating along Z, and returning the 3D noise value.\r\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\r\n\t\r\n}\r\n\r\n// Simple fBm to produce some clouds.\r\nfloat fbm(in vec3 p){\r\n    \r\n    // Four layers of 3D noise.\r\n    return .5333*noise3D(p) + .2667*noise3D(p*2.02) + .1333*noise3D(p*4.03) + .0667*noise3D(p*8.03);\r\n\r\n}\r\n\r\n\r\n// Pretty standard way to make a sky. \r\nvec3 getSky(in vec3 ro, in vec3 rd, vec3 sunDir){\r\n\r\n\t\r\n\tfloat sun = max(dot(rd, sunDir), 0.); // Sun strength.\r\n\tfloat horiz = pow(1.0-max(rd.y, 0.), 3.)*.35; // Horizon strength.\r\n\t\r\n\t// The blueish sky color. Tinging the sky redish around the sun. \t\t\r\n\tvec3 col = mix(vec3(.25, .35, .5), vec3(.4, .375, .35), sun*.75);//.zyx;\r\n    // Mixing in the sun color near the horizon.\r\n\tcol = mix(col, vec3(1, .9, .7), horiz);\r\n    \r\n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\r\n    // layers, rather than just the one. Much better.\r\n\tcol += .25*vec3(1, .7, .4)*pow(sun, 5.);\r\n\tcol += .25*vec3(1, .8, .6)*pow(sun, 64.);\r\n\tcol += .2*vec3(1, .9, .7)*max(pow(sun, 512.), .3);\r\n    \r\n    // Add a touch of speckle, to match up with the slightly speckly ground.\r\n    col = clamp(col + hash(rd)*.05 - .025, 0., 1.);\r\n\t\r\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\r\n    // since we're in the desert, and all that.\r\n\tvec3 sc = ro + rd*FAR*100.; sc.y *= 3.;\r\n    \r\n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\r\n\treturn mix( col, vec3(1, .95, 1), .5*smoothstep(.5, 1., fbm(.001*sc)) * clamp(rd.y*4., 0., 1.) );\r\n\t\r\n\r\n}\r\n\r\n// Cool curve function, by Shadertoy user, Nimitz.\r\n//\r\n// It gives you a scalar curvature value for an object's signed distance function, which \r\n// is pretty handy for all kinds of things. Here's it's used to darken the crevices.\r\n//\r\n// From an intuitive sense, the function returns a weighted difference between a surface \r\n// value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\r\n// calculations, I'm assuming. Almost common sense... almost. :)\r\n//\r\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\r\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\r\nfloat curve(in vec3 p){\r\n\r\n    const float eps = .05, amp = 4., ampInit = .5;\r\n\r\n    vec2 e = vec2(-1, 1)*eps; // 0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    \r\n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\r\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\r\n    \r\n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\r\n}\r\n\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\r\n\r\n\t\r\n\t// Screen coordinates.\r\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\r\n\t\r\n\t// Camera Setup.\r\n\tvec3 lookAt = vec3(0, 0, iTime*8.);  // \"Look At\" position.\r\n\tvec3 ro = lookAt + vec3(0, 0, -.25); // Camera position, doubling as the ray origin.\r\n \r\n\t// Using the Z-value to perturb the XY-plane.\r\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \r\n\t// synchronized with the distance function.\r\n\tlookAt.xy += path(lookAt.z);\r\n\tro.xy += path(ro.z);\r\n\r\n    // Using the above to produce the unit ray-direction vector.\r\n    float FOV = 3.14159/3.; // FOV - Field of view.\r\n    vec3 forward = normalize(lookAt - ro);\r\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \r\n    vec3 up = cross(forward, right);\r\n\r\n    // rd - Ray direction.\r\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\r\n    \r\n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\r\n    // Naturally, it's synchronized with the path in some kind of way.\r\n\trd.xy = rot2( path(lookAt.z).x/64. )*rd.xy;\r\n    \r\n    \r\n\t\r\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\r\n    // like some of the angular subtleties of point lights, so this is a point light a\r\n    // long distance away. Fake, and probably not advisable, but no one will notice.\r\n    vec3 lp = vec3(FAR*.5, FAR, FAR) + vec3(0, 0, ro.z);\r\n \r\n\r\n\t// Raymarching, using Nimitz's \"Log Bisection\" method. Very handy on stubborn surfaces. :)\r\n\tfloat t = logBisectTrace(ro, rd);\r\n    \r\n    // Standard sky routine. Worth learning. For outdoor scenes, you render the sky, then the\r\n    // terrain, then mix together with a fog falloff. Pretty straight forward.\r\n    vec3 sky = getSky(ro, rd, normalize(lp - ro));\r\n    \r\n    // The terrain color. Can't remember why I set it to sky. I'm sure I had my reasons.\r\n    vec3 col = sky;\r\n    \r\n    // If we've hit the ground, color it up.\r\n    if (t < FAR){\r\n    \r\n        vec3 sp = ro+t*rd; // Surface point.\r\n        vec3 sn = normal(sp); // Surface normal.\r\n\r\n        \r\n        // Light direction vector. From the sun to the surface point. We're not performing\r\n        // light distance attenuation, since it'll probably have minimal effect.\r\n        vec3 ld = lp-sp;\r\n        ld /= max(length(ld), 0.001); // Normalize the light direct vector.\r\n\r\n        \r\n        // Texture scale factor.        \r\n        const float tSize1 = 1./6.;\r\n        \r\n        // Bump mapping with the sandstone texture to provide a bit of gritty detailing.\r\n        // This might seem counter intuitive, but I've turned off mip mapping and set the\r\n        // texture to linear, in order to give some grainyness. I'm dividing the bump\r\n        // factor by the distance to smooth it out a little. Mip mapped textures without\r\n        // anisotropy look too smooth at certain viewing angles.\r\n        sn = doBumpMap(iChannel1, sp*tSize1, sn, .007/(1. + t/FAR));//max(1.-length(fwidth(sn)), .001)*hash(sp)/(1.+t/FAR)\r\n        \r\n        float shd = softShadow(sp, ld, .05, FAR, 8.); // Shadows.\r\n        float curv = curve(sp)*.9 +.1; // Surface curvature.\r\n        float ao = calculateAO(sp, sn, 4.); // Ambient occlusion.\r\n        \r\n        float dif = max( dot( ld, sn ), 0.); // Diffuse term.\r\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 5.); // Specular term.\r\n        float fre = clamp(1.0 + dot(rd, sn), 0., 1.); // Fresnel reflection term.\r\n\r\n       \r\n\r\n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\r\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\r\n        // used to give a hard clay consistency... It \"kind of\" works.\r\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\r\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\r\n       \r\n        // Overal global ambience. Without it, the cave sections would be pretty dark. It's made up,\r\n        // but I figured a little reflectance would be in amongst it... Sounds good, anyway. :)\r\n        float amb = fre*fre2 + .06*ao;\r\n        \r\n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\r\n        col = clamp(mix(vec3(.8, .5, .3), vec3(.5, .25, .125),(sp.y+1.)*.15), vec3(.5, .25, .125), vec3(1));\r\n        \r\n        // Give the soil a bit of a sandstone texture. This line's made up.\r\n        col =  smoothstep(-.5, 1., tex3D(iChannel1, sp*tSize1, sn))*(col + .25);\r\n        // One thing I really miss when using Shadertoy is anisotropic filtering, which makes mapped \r\n        // textures appear far more crisp. It requires just a few lines in the backend code, and doesn't \r\n        // appear to effect frame rate, but I'm assuming the developers have their reasons. Anyway, this\r\n        // line attempts to put a little definition back in, but it's definitely not the same thing. :)     \r\n        col = clamp(col + noise3D(sp*48.)*.3 - .15, 0., 1.);\r\n        \r\n        // Edit: This shader needs gamma correction, so I've hacked this and a postprocessing line\r\n        // in to counter the dark shading... I'll do it properly later.\r\n        col = pow(col, vec3(1.5));\r\n        \r\n        // Tweaking the curvature value a bit, then using it to color in the crevices with a \r\n        // brownish color... in a lame attempt to make the surface look dirt-like.\r\n        curv = smoothstep(0., .7, curv);\r\n        col *= vec3(curv, curv*.95, curv*.85);\r\n \r\n        \r\n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\r\n        col += getSky(sp, reflect(rd, sn), ld)*fre*fre2*.5;\r\n        \r\n        \r\n        // Combining all the terms from above. Some diffuse, some specular - both of which are\r\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\r\n        // good enough for the purposes of this demonstation.        \r\n        col = (col*(dif + .1) + fre2*spe)*shd*ao + amb*col;\r\n       \r\n        \r\n    }\r\n    \r\n    \r\n    // Combine the terrain with the sky using some distance fog. This one is designed to fade off very\r\n    // quickly a few units out from the horizon. Account for the clouds, change \"FAR - 15.\" to zero, and \r\n    // the fog will be way more prominent. You could also use \"1./(1 + t*scale),\" etc.\r\n    col = mix(col, sky, sqrt(smoothstep(FAR - 15., FAR, t)));\r\n    \r\n\r\n    // Edit: This shader needs gamma correction, so I've hacked this and a line above in\r\n    // to counter the dark shading... I'll do it properly later.\r\n    col = pow(max(col, 0.), vec3(.75));\r\n\r\n    \r\n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \r\n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\r\n    // term to give it more subtlety.\r\n    u = fragCoord/iResolution.xy;\r\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\r\n\r\n    // Done.\r\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":null,"published":0}],"outputs":[],"code":"/*\r\n\tDesert Canyon\r\n\t-------------\r\n\r\n\tJust a simple canyon fly through. Since the laws of physics aren't adhered to (damn stray floating \r\n\trocks), you can safely assume the setting is a dry, rocky desert on a different planet... in an \r\n\talternate reality. :)\r\n\r\n\tI thought I'd do a daytime scene for a change. I like the way they look, but I find they require\r\n\tmore effort to light up correctly. In this particular example, I had to find the balance between\r\n\tindoor and outdoor lighting, but keep it simple enough to allow reasonable frame rates for swift \r\n\tcamera movement. For that reason, I was really thankful to have some of Dave Hoskins's and IQ's \r\n\texamples to refer to.\r\n\r\n\tThe inspiration for this particular scene came from Dr2's flyby examples. This is obviously less\r\n\tcomplicated, since his involve flybys with actual planes. Really cool, if you've never seen them.\r\n\r\n\tAnyway, I'll put up a more interesting one at a later date.\r\n\t\r\n\r\n\tOutdoor terrain shaders:\r\n\r\n\tElevated - iq\r\n\thttps://www.shadertoy.com/view/MdX3Rr\r\n\tBased on his (RGBA's) famous demo, Elevated.\r\n\thttp://www.pouet.net/prod.php?which=52938\r\n\r\n\t// How a canyon's really done. :)\r\n\tCanyon - iq\r\n\thttps://www.shadertoy.com/view/MdBGzG\r\n\r\n\t// Too many good ones to choose from, but here's one.\r\n\t// Mountains - Dave_Hoskins\r\n\thttps://www.shadertoy.com/view/4slGD4\r\n\r\n\t// Awesome.\r\n    River Flight - Dr2\r\n    https://www.shadertoy.com/view/4sSXDG\r\n\r\n*/\r\n\r\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \r\n// additional scenery starts to slow things down on my slower machine.\r\n#define FAR 65.\r\n\r\n// Frequencies and amplitudes of the \"path\" function, used to shape the tunnel and guide the camera.\r\nconst float freqA = .15/3.75;\r\nconst float freqB = .25/2.75;\r\nconst float ampA = 20.;\r\nconst float ampB = 4.;\r\n\r\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\r\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\r\n\r\n// 1x1 and 3x1 hash functions.\r\nfloat hash(float n){ return fract(cos(n)*45758.5453); }\r\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\r\n\r\n// Grey scale.\r\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\r\n\r\n/*\r\n// IQ's smooth minium function. \r\nfloat sminP(float a, float b , float s){\r\n    \r\n    float h = clamp(.5 + .5*(b - a)/s, 0., 1.);\r\n    return mix(b, a, h) - h*(1.0-h)*s;\r\n}\r\n*/\r\n\r\n// Smooth maximum, based on the function above.\r\nfloat smaxP(float a, float b, float s){\r\n    \r\n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\r\n    return mix(b, a, h) + h*(1. - h)*s;\r\n}\r\n\r\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\r\nvec2 path(in float z){ return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB) + 3.*(sin(z*0.025)  - 1.)); }\r\n\r\n// The canyon, complete with hills, gorges and tunnels. I would have liked to provide a far\r\n// more interesting scene, but had to keep things simple in order to accommodate slower machines.\r\nfloat map(in vec3 p){\r\n    \r\n    // Indexing into the pebbled texture to provide some rocky surface detatiling. I like this\r\n    // texture but I'd much rather produce my own. From what I hear, Shadertoy will be providing\r\n    // fixed offscreen buffer sizes (like 512 by 512, for instance) at a later date. When that\r\n    // happens, I'll really be able to do some damage. :)\r\n    float tx = textureLod(iChannel0, p.xz/16. + p.xy/80., 0.).x;\r\n  \r\n    // A couple of sinusoidal layers to produce the rocky hills.\r\n    vec3 q = p*.25;\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(.111));\r\n    \r\n    \r\n    // The terrain, so to speak. Just a flat XZ plane, at zero height, with some hills added.\r\n    float d = p.y + h*6.;\r\n  \r\n    // Reusing \"h\" to provide an undulating base layer on the tunnel walls.\r\n    q = sin(p*.5 + h);\r\n    h = q.x*q.y*q.z;\r\n  \r\n\t// Producing a single winding tunnel. If you're not familiar with the process, this is it.\r\n    // We're also adding some detailing to the walls via \"h\" and the rocky \"tx\" value.\r\n    p.xy -= path(p.z);\r\n    float tnl = 1.5 - length(p.xy*vec2(.33, .66)) + h + (1. - tx)*.25;\r\n\r\n\t// Smoothly combine the terrain with the tunnel - using a smooth maximum - then add some\r\n    // detailing. I've also added a portion of the tunnel term onto the end, just because\r\n    // I liked the way it looked more. \r\n    return smaxP(d, tnl, 2.) - tx*.5 + tnl*.8; \r\n\r\n}\r\n\r\n\r\n// Log-Bisection Tracing\r\n// https://www.shadertoy.com/view/4sSXzD\r\n//\r\n// Log-Bisection Tracing by nimitz (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Contact: nmz@Stormoid.com\r\n//\r\n// Notes: This is a trimmed down version of Nitmitz's original. If you're interested in the function \r\n// itself, refer to the original function in the link above. There, you'll find a good explanation as to \r\n// how it works too.\r\n//\r\n// For what it's worth, I've tried most of the standard raymarching methods around, and for difficult \r\n// surfaces to hone in on, like the one in this particular example, \"Log Bisection\" is my favorite.\r\n\r\nfloat logBisectTrace(in vec3 ro, in vec3 rd){\r\n\r\n\r\n    float t = 0., told = 0., mid, dn;\r\n    float d = map(rd*t + ro);\r\n    float sgn = sign(d);\r\n\r\n    for (int i=0; i<96; i++){\r\n\r\n        // If the threshold is crossed with no detection, use the bisection method.\r\n        // Also, break for the usual reasons. Note that there's only one \"break\"\r\n        // statement in the loop. I heard GPUs like that... but who knows?\r\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\r\n \r\n        told = t;\r\n        \r\n        // Branchless version of the following:   \r\n        // if(d>1.) t += d; else t += log(abs(d) + 1.1);     \r\n        t += step(d, 1.)*(log(abs(d) + 1.1) - d) + d;\r\n        //t += log(abs(d) + 1.1);\r\n        //t += d;//step(-1., -d)*(d - d*.5) + d*.5;\r\n        \r\n        d = map(rd*t + ro);\r\n    }\r\n    \r\n    // If a threshold was crossed without a solution, use the bisection method.\r\n    if (sign(d) != sgn){\r\n    \r\n        // Based on suggestions from CeeJayDK, with some minor changes.\r\n\r\n        dn = sign(map(rd*told + ro));\r\n        \r\n        vec2 iv = vec2(told, t); // Near, Far\r\n\r\n        // 6 iterations seems to be more than enough, for most cases...\r\n        // but there's an early exit, so I've added a couple more.\r\n        for (int ii=0; ii<8; ii++){ \r\n            //Evaluate midpoint\r\n            mid = dot(iv, vec2(.5));\r\n            float d = map(rd*mid + ro);\r\n            if (abs(d) < 0.001)break;\r\n            // Suggestion from movAX13h - Shadertoy is one of those rare\r\n            // sites with helpful commenters. :)\r\n            // Set mid to near or far, depending on which side we're on.\r\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\r\n        }\r\n\r\n        t = mid; \r\n        \r\n    }\r\n    \r\n\r\n    return min(t, FAR);\r\n}\r\n\r\n\r\n// Tetrahedral normal, courtesy of IQ.\r\nvec3 normal(in vec3 p)\r\n{  \r\n    vec2 e = vec2(-1, 1)*.001;   \r\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \r\n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \r\n}\r\n\r\n\r\n// Tri-Planar blending function. Based on an old Nvidia writeup:\r\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\r\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\r\n   \r\n    n = max(n*n, .001);\r\n    n /= (n.x + n.y + n.z );  \r\n    \r\n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\r\n}\r\n\r\n\r\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\r\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\r\n   \r\n    const float eps = .001;\r\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x - eps, p.y, p.z), nor)),\r\n                      getGrey(tex3D(tex, vec3(p.x, p.y - eps, p.z), nor)),\r\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z - eps), nor)));\r\n    \r\n    grad = (grad - getGrey(tex3D(tex, p, nor)))/eps; \r\n            \r\n    grad -= nor*dot(nor, grad);          \r\n                      \r\n    return normalize(nor + grad*bumpfactor);\r\n\t\r\n}\r\n\r\n// The iterations should be higher for proper accuracy, but in this case, I wanted less accuracy, just to leave\r\n// behind some subtle trails of light in the caves. They're fake, but they look a little like light streaming \r\n// through some cracks... kind of.\r\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\r\n\r\n    float shade = 1.;\r\n    // Increase this and the shadows will be more accurate, but the wispy light trails in the caves will disappear.\r\n    // Plus more iterations slow things down, so it works out, in this case.\r\n    const int maxIterationsShad = 10; \r\n\r\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \r\n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\r\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\r\n    float dist = start;\r\n    float stepDist = end/float(maxIterationsShad);\r\n\r\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \r\n    // number to give a decent shadow is the best one to choose. \r\n    for (int i=0; i<maxIterationsShad; i++){\r\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\r\n        // you may hit a surface not between the surface and the light.\r\n        float h = map(ro + rd*dist);\r\n        //shade = min(shade, k*h/dist);\r\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\r\n        \r\n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \r\n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\r\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\r\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\r\n        \r\n        // In this particular instance the light source is a long way away. However, we're only taking a few small steps\r\n        // toward the light and checking whether anything \"locally\" gets in the way. If a part of the scene a long distance away\r\n        // is between our hit point and the light source, it won't be accounted for. Technically that's not correct, but the local\r\n        // shadows give that illusion... kind of.\r\n        dist += clamp(h, .2, stepDist*2.);\r\n        \r\n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\r\n        if (abs(h)<.001 || dist > end) break; \r\n    }\r\n\r\n    // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \r\n    // look too brutal to me.\r\n    return min(max(shade, 0.) + .1, 1.); \r\n}\r\n\r\n\r\n\r\n\r\n\r\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \r\n// function and have been looking for an excuse to use it. For a better version, and usage, \r\n// refer to XT95's examples below:\r\n//\r\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\r\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\r\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist )\r\n{\r\n\tfloat ao = 0., l;\r\n\tconst float nbIte = 6.;\r\n\t//const float falloff = .9;\r\n    for(float i=1.; i< nbIte+.5; i++){\r\n    \r\n        l = (i + hash(i))*.5/nbIte*maxDist;\r\n        \r\n        ao += (l - map( p + n*l))/(1. + l);// / pow(1.+l, falloff);\r\n    }\r\n\t\r\n    return clamp(1. - ao/nbIte, 0., 1.);\r\n}\r\n\r\n// More concise, self contained version of IQ's original 3D noise function.\r\nfloat noise3D(in vec3 p){\r\n    \r\n    // Just some random figures, analogous to stride. You can change this, if you want.\r\n\tconst vec3 s = vec3(7, 157, 113);\r\n\t\r\n\tvec3 ip = floor(p); // Unique unit cell ID.\r\n    \r\n    // Setting up the stride vector for randomization and interpolation, kind of. \r\n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\r\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\r\n    \r\n\tp -= ip; // Cell's fractional component.\r\n\t\r\n    // A bit of cubic smoothing, to give the noise that rounded look.\r\n    p = p*p*(3. - 2.*p);\r\n    \r\n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\r\n    // then interpolating along X. There are countless ways to randomize, but this is\r\n    // the way most are familar with: fract(sin(x)*largeNumber).\r\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\r\n\t\r\n    // Interpolating along Y.\r\n    h.xy = mix(h.xz, h.yw, p.y);\r\n    \r\n    // Interpolating along Z, and returning the 3D noise value.\r\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\r\n\t\r\n}\r\n\r\n// Simple fBm to produce some clouds.\r\nfloat fbm(in vec3 p){\r\n    \r\n    // Four layers of 3D noise.\r\n    return .5333*noise3D(p) + .2667*noise3D(p*2.02) + .1333*noise3D(p*4.03) + .0667*noise3D(p*8.03);\r\n\r\n}\r\n\r\n\r\n// Pretty standard way to make a sky. \r\nvec3 getSky(in vec3 ro, in vec3 rd, vec3 sunDir){\r\n\r\n\t\r\n\tfloat sun = max(dot(rd, sunDir), 0.); // Sun strength.\r\n\tfloat horiz = pow(1.0-max(rd.y, 0.), 3.)*.35; // Horizon strength.\r\n\t\r\n\t// The blueish sky color. Tinging the sky redish around the sun. \t\t\r\n\tvec3 col = mix(vec3(.25, .35, .5), vec3(.4, .375, .35), sun*.75);//.zyx;\r\n    // Mixing in the sun color near the horizon.\r\n\tcol = mix(col, vec3(1, .9, .7), horiz);\r\n    \r\n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\r\n    // layers, rather than just the one. Much better.\r\n\tcol += .25*vec3(1, .7, .4)*pow(sun, 5.);\r\n\tcol += .25*vec3(1, .8, .6)*pow(sun, 64.);\r\n\tcol += .2*vec3(1, .9, .7)*max(pow(sun, 512.), .3);\r\n    \r\n    // Add a touch of speckle, to match up with the slightly speckly ground.\r\n    col = clamp(col + hash(rd)*.05 - .025, 0., 1.);\r\n\t\r\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\r\n    // since we're in the desert, and all that.\r\n\tvec3 sc = ro + rd*FAR*100.; sc.y *= 3.;\r\n    \r\n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\r\n\treturn mix( col, vec3(1, .95, 1), .5*smoothstep(.5, 1., fbm(.001*sc)) * clamp(rd.y*4., 0., 1.) );\r\n\t\r\n\r\n}\r\n\r\n// Cool curve function, by Shadertoy user, Nimitz.\r\n//\r\n// It gives you a scalar curvature value for an object's signed distance function, which \r\n// is pretty handy for all kinds of things. Here's it's used to darken the crevices.\r\n//\r\n// From an intuitive sense, the function returns a weighted difference between a surface \r\n// value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\r\n// calculations, I'm assuming. Almost common sense... almost. :)\r\n//\r\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\r\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\r\nfloat curve(in vec3 p){\r\n\r\n    const float eps = .05, amp = 4., ampInit = .5;\r\n\r\n    vec2 e = vec2(-1, 1)*eps; // 0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    \r\n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\r\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\r\n    \r\n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\r\n}\r\n\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\r\n\r\n\t\r\n\t// Screen coordinates.\r\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\r\n\t\r\n\t// Camera Setup.\r\n\tvec3 lookAt = vec3(0, 0, iTime*8.);  // \"Look At\" position.\r\n\tvec3 ro = lookAt + vec3(0, 0, -.25); // Camera position, doubling as the ray origin.\r\n \r\n\t// Using the Z-value to perturb the XY-plane.\r\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \r\n\t// synchronized with the distance function.\r\n\tlookAt.xy += path(lookAt.z);\r\n\tro.xy += path(ro.z);\r\n\r\n    // Using the above to produce the unit ray-direction vector.\r\n    float FOV = 3.14159/3.; // FOV - Field of view.\r\n    vec3 forward = normalize(lookAt - ro);\r\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \r\n    vec3 up = cross(forward, right);\r\n\r\n    // rd - Ray direction.\r\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\r\n    \r\n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\r\n    // Naturally, it's synchronized with the path in some kind of way.\r\n\trd.xy = rot2( path(lookAt.z).x/64. )*rd.xy;\r\n    \r\n    \r\n\t\r\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\r\n    // like some of the angular subtleties of point lights, so this is a point light a\r\n    // long distance away. Fake, and probably not advisable, but no one will notice.\r\n    vec3 lp = vec3(FAR*.5, FAR, FAR) + vec3(0, 0, ro.z);\r\n \r\n\r\n\t// Raymarching, using Nimitz's \"Log Bisection\" method. Very handy on stubborn surfaces. :)\r\n\tfloat t = logBisectTrace(ro, rd);\r\n    \r\n    // Standard sky routine. Worth learning. For outdoor scenes, you render the sky, then the\r\n    // terrain, then mix together with a fog falloff. Pretty straight forward.\r\n    vec3 sky = getSky(ro, rd, normalize(lp - ro));\r\n    \r\n    // The terrain color. Can't remember why I set it to sky. I'm sure I had my reasons.\r\n    vec3 col = sky;\r\n    \r\n    // If we've hit the ground, color it up.\r\n    if (t < FAR){\r\n    \r\n        vec3 sp = ro+t*rd; // Surface point.\r\n        vec3 sn = normal(sp); // Surface normal.\r\n\r\n        \r\n        // Light direction vector. From the sun to the surface point. We're not performing\r\n        // light distance attenuation, since it'll probably have minimal effect.\r\n        vec3 ld = lp-sp;\r\n        ld /= max(length(ld), 0.001); // Normalize the light direct vector.\r\n\r\n        \r\n        // Texture scale factor.        \r\n        const float tSize1 = 1./6.;\r\n        \r\n        // Bump mapping with the sandstone texture to provide a bit of gritty detailing.\r\n        // This might seem counter intuitive, but I've turned off mip mapping and set the\r\n        // texture to linear, in order to give some grainyness. I'm dividing the bump\r\n        // factor by the distance to smooth it out a little. Mip mapped textures without\r\n        // anisotropy look too smooth at certain viewing angles.\r\n        sn = doBumpMap(iChannel1, sp*tSize1, sn, .007/(1. + t/FAR));//max(1.-length(fwidth(sn)), .001)*hash(sp)/(1.+t/FAR)\r\n        \r\n        float shd = softShadow(sp, ld, .05, FAR, 8.); // Shadows.\r\n        float curv = curve(sp)*.9 +.1; // Surface curvature.\r\n        float ao = calculateAO(sp, sn, 4.); // Ambient occlusion.\r\n        \r\n        float dif = max( dot( ld, sn ), 0.); // Diffuse term.\r\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 5.); // Specular term.\r\n        float fre = clamp(1.0 + dot(rd, sn), 0., 1.); // Fresnel reflection term.\r\n\r\n       \r\n\r\n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\r\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\r\n        // used to give a hard clay consistency... It \"kind of\" works.\r\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\r\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\r\n       \r\n        // Overal global ambience. Without it, the cave sections would be pretty dark. It's made up,\r\n        // but I figured a little reflectance would be in amongst it... Sounds good, anyway. :)\r\n        float amb = fre*fre2 + .06*ao;\r\n        \r\n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\r\n        col = clamp(mix(vec3(.8, .5, .3), vec3(.5, .25, .125),(sp.y+1.)*.15), vec3(.5, .25, .125), vec3(1));\r\n        \r\n        // Give the soil a bit of a sandstone texture. This line's made up.\r\n        col =  smoothstep(-.5, 1., tex3D(iChannel1, sp*tSize1, sn))*(col + .25);\r\n        // One thing I really miss when using Shadertoy is anisotropic filtering, which makes mapped \r\n        // textures appear far more crisp. It requires just a few lines in the backend code, and doesn't \r\n        // appear to effect frame rate, but I'm assuming the developers have their reasons. Anyway, this\r\n        // line attempts to put a little definition back in, but it's definitely not the same thing. :)     \r\n        col = clamp(col + noise3D(sp*48.)*.3 - .15, 0., 1.);\r\n        \r\n        // Edit: This shader needs gamma correction, so I've hacked this and a postprocessing line\r\n        // in to counter the dark shading... I'll do it properly later.\r\n        col = pow(col, vec3(1.5));\r\n        \r\n        // Tweaking the curvature value a bit, then using it to color in the crevices with a \r\n        // brownish color... in a lame attempt to make the surface look dirt-like.\r\n        curv = smoothstep(0., .7, curv);\r\n        col *= vec3(curv, curv*.95, curv*.85);\r\n \r\n        \r\n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\r\n        col += getSky(sp, reflect(rd, sn), ld)*fre*fre2*.5;\r\n        \r\n        \r\n        // Combining all the terms from above. Some diffuse, some specular - both of which are\r\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\r\n        // good enough for the purposes of this demonstation.        \r\n        col = (col*(dif + .1) + fre2*spe)*shd*ao + amb*col;\r\n       \r\n        \r\n    }\r\n    \r\n    \r\n    // Combine the terrain with the sky using some distance fog. This one is designed to fade off very\r\n    // quickly a few units out from the horizon. Account for the clouds, change \"FAR - 15.\" to zero, and \r\n    // the fog will be way more prominent. You could also use \"1./(1 + t*scale),\" etc.\r\n    col = mix(col, sky, sqrt(smoothstep(FAR - 15., FAR, t)));\r\n    \r\n\r\n    // Edit: This shader needs gamma correction, so I've hacked this and a line above in\r\n    // to counter the dark shading... I'll do it properly later.\r\n    col = pow(max(col, 0.), vec3(.75));\r\n\r\n    \r\n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \r\n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\r\n    // term to give it more subtlety.\r\n    u = fragCoord/iResolution.xy;\r\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\r\n\r\n    // Done.\r\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2014\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\nfloat hash1( float n ) { return fract(sin(n)*43758.5453123); }\r\n\r\nfloat noise1( in float x )\r\n{\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash1(p+0.0), hash1(p+1.0), f );\r\n}\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\nvec2 sd2Segment( vec3 a, vec3 b, vec3 p )\r\n{\r\n\tvec3  pa = p - a;\r\n\tvec3  ba = b - a;\r\n\tfloat t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\tvec3  v = pa - ba*t;\r\n\treturn vec2( dot(v,v), t );\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n  vec3 d = abs(p) - b;\r\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\r\n\treturn mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\nvec3 fishPos;\r\nfloat fishTime;\r\n\r\nvec3 sdFish( vec3 p )\r\n{\r\n    vec3 res = vec3( 1000.0, 0.0, 0.0 );\r\n\r\n\tp -= fishPos;\r\n\t\r\n\tif( dot(p,p)>16.0 ) return vec3(5.0);\r\n\r\n\tp *= vec3(1.2,0.8,1.2);\r\n\tvec3 q = p;\r\n\t\r\n    vec3 a = vec3(0.0,0.0,0.0);\r\n\t\r\n    \r\n    a.x -= 0.25*sin(8.0*0.2*fishTime);\r\n\tvec3 oa = a;\r\n\r\n\tfloat or = 0.0;\r\n\tfloat th = 0.0;\r\n\tfloat hm = 0.0;\r\n\r\n\t#define NUMI 7\r\n\t#define NUMF 7.0\r\n\tvec3 p1 = a; vec3 d1=vec3(0.0);\r\n\tvec3 p2 = a; vec3 d2=vec3(0.0);\r\n\tvec3 mp = a;\r\n\tfor( int i=0; i<NUMI; i++ )\r\n\t{\t\r\n\t\tfloat ih = float(i)/NUMF;\r\n\t\t\r\n\t\tfloat an = or + 1.0*(0.2+0.8*ih)*sin(3.0*ih - 2.0*fishTime);\r\n\t\tfloat ll = 0.26;\r\n\t\tif( i==(NUMI-1) ) ll=0.4;\r\n\t\tvec3 b = a + ll*vec3(sin(an), 0.0, cos(an))*(16.0/NUMF);\r\n\t\t\r\n\t\tvec2 dis = sd2Segment( a, b, p );\r\n\r\n\t\tif( dis.x<res.x ) {res=vec3(dis.x,ih+dis.y/NUMF,0.0); mp=a+(b-a)*dis.y; }\r\n\t\t\r\n\t\tif( i==1 ) { p1=a; d1 = b-a; }\r\n\t\t\r\n\t\ta = b;\r\n\t}\r\n\tfloat h = res.y;\r\n\tfloat ra = 0.04 + h*(1.0-h)*(1.0-h)*2.7;\r\n\r\n\t// tail\r\n\tp.y /= 1.0 + 14.0*(1.0-smoothstep( 0.0, 0.13, 1.0-h));\r\n    p.z += 0.08*(1.0-clamp(abs(p.y)/0.075,0.0,1.0))*(1.0-smoothstep( 0.0,0.1,1.0-h));\r\n\tres.x = 0.75 * (distance(p,mp) - ra);\r\n\t\r\n\t// mouth\r\n\tfloat d3 = 0.75*(length( (p - oa)*vec3(0.5,2.0,1.0) )-0.12);\r\n\tres.x = max( -d3, res.x );\r\n\t\r\n\t// upper central fin\r\n\tfloat fh = smoothstep(0.15,0.2,h) - smoothstep(0.25,0.8,h);\r\n\tfh -= 0.2*pow(0.5+0.5*sin(210.0*h),0.2)*fh;\r\n\td3 = length(p.xz-mp.xz) - 0.01;\r\n    d3 = max( d3, p.y - (mp.y+ra+0.2*fh) );\r\n\td3 = max( d3, -p.y - 0.0 );\r\n\tres.x = min( res.x, d3 );\r\n\t\r\n\t// fins\r\n\td1.xz = normalize(d1.xz);\r\n\r\n\tfloat flap = 0.7 + 0.3*sin(2.0*8.0*0.2*fishTime);\r\n    vec2 dd = normalize(d1.xz + sign((p-p1).x)*flap*d1.zx*vec2(-1.0,1.0));\r\n\tmat2 mm = mat2( dd.y, dd.x, -dd.x, dd.y );\r\n\tvec3 sq = p-p1;\r\n\tsq.xz = mm*sq.xz;\r\n\tsq.y += 0.2;\r\n\tsq.x += -0.15;\r\n\tfloat d = length( (sq-vec3(0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\r\n\td = 0.5*max( d, sdBox( sq, vec3(1.0,1.0,0.01) ) );\r\n    if( d<res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\r\n\tres.x = smin( d, res.x, 0.05 );\r\n\r\n\tsq = p-p1;\r\n\tsq.xz = mm*sq.xz;\r\n\tsq.y += 0.2;\r\n\tsq.x += 0.15;\r\n\td = length( (sq-vec3(-0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\r\n\td = 0.5*max( d, sdBox( sq, vec3(1.0,1.0,0.01) ) );\r\n    if( d<res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\r\n\tres.x = smin( d, res.x, 0.05 );\r\n\r\n\treturn res;\r\n\r\n}\r\n\r\nvec3 sdSeaBed( in vec3 p )\r\n{\r\n\tfloat h = 1.0;\r\n\tvec3 q = p;\r\n\tfloat th = smoothstep( 0.1, 0.4, textureLod( iChannel0, 0.002*q.xz, 0.0 ).x );\r\n    float rr = smoothstep( 0.2, 0.5, textureLod( iChannel1, 2.0*0.02*q.xz, 0.0 ).y );\r\n\th = 0.9 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.1*(1.0-textureLod( iChannel0, 0.1*q.xz, 0.0 ).x);\r\n\th += th*1.25;\r\n    h -= 0.24*rr;\r\n\th *= 0.75;\r\n    return vec3( (p.y+h)*0.3, p.x, 0.0 );\r\n\r\n}\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n    vec4 d1 = vec4( sdSeaBed(p), 0.0 );\r\n\tvec4 d2 = vec4( sdFish(p), 1.0 ); \r\n    return (d2.x<d1.x)?d2:d1;\r\n}\r\n\r\nvec4 intersect( in vec3 ro, in vec3 rd )\r\n{\r\n\tconst float maxd = 20.0;\r\n\tconst float precis = 0.001;\r\n    float h = precis*3.0;\r\n    float t = 0.0;\r\n    float m = 0.0;\r\n\tfloat l = 0.0;\r\n\tfloat r = 0.0;\r\n    for( int i=0; i<80; i++ )\r\n    {\r\n\t    vec4 res = map( ro+rd*t );\r\n        if( h<precis || t>maxd ) break;\r\n        h = res.x;\r\n\t\tl = res.y;\r\n\t\tr = res.z;\r\n        m = res.w;\t\t\t\r\n\t\tt += h;\r\n    }\r\n\r\n    if( t>maxd ) m=-1.0;\r\n    return vec4( t, l, m, r);\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos, in float e )\r\n{\r\n    vec3 eps = vec3(e,0.0,0.0);\r\n\treturn normalize( vec3(\r\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\r\n}\r\n\r\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\r\n{\r\n    float res = 1.0;\r\n    float t = mint;\r\n\tfloat h = 1.0;\r\n    for( int i=0; i<40; i++ )\r\n    {\r\n        h = map(ro + rd*t).x;\r\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h<0.0001 ) break;\r\n    }\r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\nvec3 lig = normalize(vec3(0.9,0.35,-0.2));\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.5);\r\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\r\n\r\n\r\n    //-----------------------------------------------------\r\n    // animate\r\n    //-----------------------------------------------------\r\n\t\r\n\tfishTime = iTime + 3.5*noise1(0.2*iTime);\r\n\r\n\tfishPos = vec3( 0.0, 0.0, -0.7*fishTime );\r\n\t\r\n    //-----------------------------------------------------\r\n    // camera\r\n    //-----------------------------------------------------\r\n\r\n\tfloat an = 1.5 + 0.1*iTime - 12.0*(m.x-0.5);\r\n\r\n\tvec3 ta = fishPos - vec3(0.0,0.0,-2.0);//vec3(0.0,1.0,2.0);\r\n\tvec3 ro = ta + vec3(4.0*sin(an),4.0,4.0*cos(an));\r\n\r\n    // shake\r\n\tro += 0.01*sin(4.0*iTime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0) );\r\n\tta += 0.01*sin(4.0*iTime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0) );\r\n\r\n    // camera matrix\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n\t\r\n\t// create view ray\r\n    p.x += 0.012*sin( 3.0*sin(4.0*p.y+0.5*iTime) + 4.0*p.x + 0.5*iTime );\r\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\r\n\r\n    //-----------------------------------------------------\r\n\t// render\r\n    //-----------------------------------------------------\r\n\r\n\tvec3 col = vec3(0.4,0.6,0.8);\r\n\tvec3 bcol = col;\r\n\t\r\n\tfloat pt = (1.0-ro.y)/rd.y;\r\n\t\r\n\tvec3 oro = ro;\r\n\tif( pt>0.0 ) ro=ro+rd*pt;\r\n\t\r\n\t// raymarch\r\n    vec4 tmat = intersect(ro,rd);\r\n    if( tmat.z>-0.5 )\r\n    {\r\n\t\tfloat eps = 0.01 + 0.03*step(0.5,tmat.z);\r\n        // geometry\r\n        vec3 pos = ro + tmat.x*rd;\r\n        vec3 nor = calcNormal(pos,eps);\r\n\t\tvec3 ref = reflect( rd, nor );\r\n\r\n        // materials\r\n\t\tvec4 mate = vec4(0.5,0.5,0.5,0.0);\r\n\t\t\r\n\t\tif( tmat.z<0.5 )\r\n\t\t{\r\n\t\t\tvec3 te = texture( iChannel0, 0.1*pos.xz ).xyz;\r\n\t\t\tte = 0.05 + te;\r\n\t\t\t\r\n\t\t\tmate.xyz = 0.6*te;\r\n\t\t\tmate.w = 5.0*(0.5+0.5*te.x);\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\tfloat th = smoothstep( 0.1, 0.4, texture( iChannel0, 0.002*pos.xz ).x );\r\n\t\t\tvec3 dcol = mix( vec3(0.1, 0.1, 0.0), 0.4*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\r\n\t\t\tmate.xyz = mix( mate.xyz*0.5, dcol, th*smoothstep( 0.0, 1.0, nor.y ) );\r\n\r\n\t\t\tfloat rr = smoothstep( 0.2, 0.4, texture( iChannel1, 2.0*0.02*pos.xz ).y );\r\n\t\t\tmate.xyz *= mix( vec3(1.0), vec3(0.2,0.2,0.2)*1.5, rr );\r\n\t\t\t\r\n\t\t\tmate.xyz *= 1.5;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmate.w = 8.0;\r\n\t\t\tmate.xyz = 1.0*vec3(0.24,0.17,0.22);\r\n\r\n\t\t\tvec3 te = 0.8+2.2*texture( iChannel0, vec2(2.0*tmat.y,pos.y) ).xyz;\r\n\t\t\tmate.xyz *= te;\r\n\t\t\t\r\n\t\t\t// belly/backfin\r\n\t\t\tfloat iscola = smoothstep( 0.0, 0.2, 1.0-tmat.y );\r\n\t\t\tmate.xyz = mix( mate.xyz, mix(vec3(te.x*0.5 + 1.5),\r\n\t\t\t\t\t\t\t\t\t\t  mix(1.0+0.5*sin(150.0*pos.y - sign(pos.y)*tmat.y*300.0),1.0,smoothstep( 0.0, 0.1, 1.0-tmat.y ))*vec3(2.6,1.5,1.0)*0.9 + 1.0*vec3(2.0,1.0,0.5)*(1.0-smoothstep( 0.0, 0.09, 1.0-tmat.y )),\r\n\t\t\t\t\t\t\t\t\t\t  1.0-iscola)*0.5, smoothstep(-0.4,0.0,-nor.y) );\r\n\t\t\t\r\n\t\t\t// stripes\r\n\t\t\tmate.xyz = mix( mate.xyz, (te.x+0.5)*1.0*vec3(0.5), 0.75*smoothstep( 0.5, 1.0, sin(1.0*te.x+tmat.y*100.0 + 13.0*nor.y) )*smoothstep(0.0,0.5,nor.y) );\r\n\r\n\t\t\t// escamas\r\n\t\t\tfloat ll = clamp( (tmat.y-0.2)/(0.8-0.2), 0.0, 1.0 );\r\n\t\t\tfloat ha = 1.0-4.0*ll*(1.0-ll);\r\n\t\t\tfloat pa = smoothstep( -1.0+2.0*ha, 1.0, sin( 50.0*pos.y ) )* smoothstep( -1.0, 0.0, sin( 560.0*tmat.y ) );\r\n\t\t\tpa *= 1.0-smoothstep( 0.1, 0.2, nor.y );\r\n\t\t\tmate.xyz *= 0.5 + 0.5*vec3(1.0) * (1.0-pa);\r\n\t\t\t\r\n\t\t\t// eye\r\n\t\t\tfloat r = length(vec2(5.0*tmat.y,pos.y)-vec2(0.5,0.13) );\r\n\t\t\tr /= 1.2;\r\n\t\t\tmate.xyz = mix( mate.xyz, vec3(1.5)*clamp(1.0-r*4.0,0.0,1.0), 0.5*(1.0-smoothstep(0.08,0.09,r)) );\r\n\t\t\tmate.xyz *= smoothstep(0.03,0.05,r);\r\n\t\t\tmate.xyz += vec3(4.0)*(1.0-smoothstep(0.0,0.1,r))*pow( texture( iChannel1, 4.0*vec2(0.2*fishPos.z+4.0*tmat.y,pos.y) ).x, 2.0 );\r\n\t\t\tr = length(vec2(5.0*tmat.y,pos.y)-vec2(0.48,0.14) );\r\n\t\t\tmate.xyz = mix( mate.xyz, vec3(2.0), (1.0-smoothstep(0.0,0.02,r)) );\r\n\t\t\t\r\n\t\t\t// mouth\r\n\t\t\tvec3 oa = fishPos;\r\n\t        oa.x -= 0.25*sin(8.0*0.2*fishTime);\r\n\t\t\tmate.xyz *= 0.1 + 0.9*step( 0.0, length( (pos - oa+vec3(0.0,0.0,-0.02))*vec3(1.5,2.0,1.0) ) - 0.14 );\r\n\t\t\t\r\n\t\t\t// top fin\r\n\t        float fh = smoothstep(0.15,0.2,tmat.y) - smoothstep(0.25,0.8,tmat.y);\r\n\t        float ra = 0.04 + tmat.y*(1.0-tmat.y)*(1.0-tmat.y)*2.7;\r\n\t\t\tfloat vv = clamp((pos.y-ra-0.1)/0.2,0.0,1.0);\r\n\t\t\tvec3 fincol = mix(1.0+0.5*sin(520.0*tmat.y),1.0,vv)*mix(vec3(0.8,0.2,0.2),vec3(1.5,1.4,1.5),vv);\r\n            mate.xyz = mix( mate.xyz, fincol, fh*smoothstep(0.0,0.05,pos.y-ra-0.1) );\r\n\t\t\t\r\n\t\t\t// side fins\r\n\t\t\tfloat isFin = tmat.w;\r\n\t\t\tfincol = 0.5*vec3(3.0,2.0,2.0) * mix(1.0+0.2*sin(150.0*pos.y),1.0,0.0);\r\n            mate.xyz = mix( mate.xyz, fincol, isFin );\r\n\t\t\t\r\n\t\t\tmate.xyz *= 0.17;\r\n\t\t}\r\n\t\t\r\n\t\t// lighting\r\n        float sky = clamp(nor.y,0.0,1.0);\r\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\r\n\t\tfloat dif = max(dot(nor,lig),0.0);\r\n        float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);\r\n\t\tfloat sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );\r\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 5.0 );\r\n        float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0), mate.w ) ) * mate.w;\r\n\t\tfloat sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 3.0 );\r\n\t\t\r\n\t\t// lights\r\n\t\tvec3 lin = vec3(0.0);\r\n\t\tfloat cc  = 0.55*texture( iChannel2, 1.8*0.02*pos.xz + 0.007*iTime*vec2( 1.0, 0.0) ).x;\r\n\t\t      cc += 0.25*texture( iChannel2, 1.8*0.04*pos.xz + 0.011*iTime*vec2( 0.0, 1.0) ).x;\r\n\t\t      cc += 0.10*texture( iChannel2, 1.8*0.08*pos.xz + 0.014*iTime*vec2(-1.0,-1.0) ).x;\r\n\t\tcc = 0.6*(1.0-smoothstep( 0.0, 0.025, abs(cc-0.4))) + \r\n\t\t\t 0.4*(1.0-smoothstep( 0.0, 0.150, abs(cc-0.4)));\r\n\t\tdif *= 1.0 + 2.0*cc;\r\n\r\n\t\tlin += 3.5*dif*vec3(1.00,1.00,1.00)*sha;\r\n\t\tlin += 3.0*sky*vec3(0.10,0.20,0.35);\r\n\t\tlin += 1.0*bou*vec3(0.20,0.20,0.20);\r\n\t\tlin += 2.0*bac*vec3(0.50,0.60,0.70);\r\n        lin += 2.0*sss*vec3(0.20,0.20,0.20)*(0.2+0.8*dif*sha)*mate.w;\r\n\t\tlin += 2.0*spe*vec3(1.0)*sha*(0.3+0.7*fre);\r\n\t\t\r\n\t\t// surface-light interacion\r\n\t\tcol = mate.xyz * lin;\r\n\r\n\t\t// fog\r\n\t\ttmat.x = max(0.0,tmat.x-1.3); col *= 0.65;\r\n\t\tfloat hh = 1.0-exp(-0.2*tmat.x); \r\n\t\tcol = col*(1.0-hh)*(1.0-hh) + 1.25*vec3(0.0,0.12,0.2)*hh;\r\n\t}\r\n\t\r\n    // foam\t\r\n\tvec2 uv = (oro + rd*pt).xz;\r\n\tfloat sur = texture( iChannel3, 0.06*uv ).x;\r\n\tsur = smoothstep( 0.5, 1.0, sur )*0.5 + 0.5*sur*sur*smoothstep(0.2,1.0,texture( iChannel2, 1.0*uv ).x);\r\n\tcol = mix( col, vec3(1.0), 0.5*sur );\r\n\r\n\t// sun specular\r\n\tfloat sun = clamp( dot(lig, reflect( rd, vec3(0.0,1.0,0.0) ) ), 0.0, 1.0 );\r\n\tcol += 0.2*vec3(1.0,0.95,0.9)*pow(sun,16.0);\r\n\tcol += 0.5*vec3(1.0,0.95,0.9)*pow(sun,96.0);\r\n\r\n\t//-----------------------------------------------------\r\n\t// postprocessing\r\n    //-----------------------------------------------------\r\n\r\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\r\n\r\n    col = mix( col, vec3(dot(col,vec3(0.333))), -0.5 );\r\n\t\r\n\tcol = 0.5*col + 0.5*col*col*(3.0-2.0*col);\r\n\t\r\n\tcol *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\t\r\n\tcol *= smoothstep( 0.0, 1.0, iTime );\r\n\t\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":null,"published":0}],"outputs":[],"code":"// Created by inigo quilez - iq/2014\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\nfloat hash1( float n ) { return fract(sin(n)*43758.5453123); }\r\n\r\nfloat noise1( in float x )\r\n{\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash1(p+0.0), hash1(p+1.0), f );\r\n}\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\nvec2 sd2Segment( vec3 a, vec3 b, vec3 p )\r\n{\r\n\tvec3  pa = p - a;\r\n\tvec3  ba = b - a;\r\n\tfloat t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\tvec3  v = pa - ba*t;\r\n\treturn vec2( dot(v,v), t );\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n  vec3 d = abs(p) - b;\r\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\r\n\treturn mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\nvec3 fishPos;\r\nfloat fishTime;\r\n\r\nvec3 sdFish( vec3 p )\r\n{\r\n    vec3 res = vec3( 1000.0, 0.0, 0.0 );\r\n\r\n\tp -= fishPos;\r\n\t\r\n\tif( dot(p,p)>16.0 ) return vec3(5.0);\r\n\r\n\tp *= vec3(1.2,0.8,1.2);\r\n\tvec3 q = p;\r\n\t\r\n    vec3 a = vec3(0.0,0.0,0.0);\r\n\t\r\n    \r\n    a.x -= 0.25*sin(8.0*0.2*fishTime);\r\n\tvec3 oa = a;\r\n\r\n\tfloat or = 0.0;\r\n\tfloat th = 0.0;\r\n\tfloat hm = 0.0;\r\n\r\n\t#define NUMI 7\r\n\t#define NUMF 7.0\r\n\tvec3 p1 = a; vec3 d1=vec3(0.0);\r\n\tvec3 p2 = a; vec3 d2=vec3(0.0);\r\n\tvec3 mp = a;\r\n\tfor( int i=0; i<NUMI; i++ )\r\n\t{\t\r\n\t\tfloat ih = float(i)/NUMF;\r\n\t\t\r\n\t\tfloat an = or + 1.0*(0.2+0.8*ih)*sin(3.0*ih - 2.0*fishTime);\r\n\t\tfloat ll = 0.26;\r\n\t\tif( i==(NUMI-1) ) ll=0.4;\r\n\t\tvec3 b = a + ll*vec3(sin(an), 0.0, cos(an))*(16.0/NUMF);\r\n\t\t\r\n\t\tvec2 dis = sd2Segment( a, b, p );\r\n\r\n\t\tif( dis.x<res.x ) {res=vec3(dis.x,ih+dis.y/NUMF,0.0); mp=a+(b-a)*dis.y; }\r\n\t\t\r\n\t\tif( i==1 ) { p1=a; d1 = b-a; }\r\n\t\t\r\n\t\ta = b;\r\n\t}\r\n\tfloat h = res.y;\r\n\tfloat ra = 0.04 + h*(1.0-h)*(1.0-h)*2.7;\r\n\r\n\t// tail\r\n\tp.y /= 1.0 + 14.0*(1.0-smoothstep( 0.0, 0.13, 1.0-h));\r\n    p.z += 0.08*(1.0-clamp(abs(p.y)/0.075,0.0,1.0))*(1.0-smoothstep( 0.0,0.1,1.0-h));\r\n\tres.x = 0.75 * (distance(p,mp) - ra);\r\n\t\r\n\t// mouth\r\n\tfloat d3 = 0.75*(length( (p - oa)*vec3(0.5,2.0,1.0) )-0.12);\r\n\tres.x = max( -d3, res.x );\r\n\t\r\n\t// upper central fin\r\n\tfloat fh = smoothstep(0.15,0.2,h) - smoothstep(0.25,0.8,h);\r\n\tfh -= 0.2*pow(0.5+0.5*sin(210.0*h),0.2)*fh;\r\n\td3 = length(p.xz-mp.xz) - 0.01;\r\n    d3 = max( d3, p.y - (mp.y+ra+0.2*fh) );\r\n\td3 = max( d3, -p.y - 0.0 );\r\n\tres.x = min( res.x, d3 );\r\n\t\r\n\t// fins\r\n\td1.xz = normalize(d1.xz);\r\n\r\n\tfloat flap = 0.7 + 0.3*sin(2.0*8.0*0.2*fishTime);\r\n    vec2 dd = normalize(d1.xz + sign((p-p1).x)*flap*d1.zx*vec2(-1.0,1.0));\r\n\tmat2 mm = mat2( dd.y, dd.x, -dd.x, dd.y );\r\n\tvec3 sq = p-p1;\r\n\tsq.xz = mm*sq.xz;\r\n\tsq.y += 0.2;\r\n\tsq.x += -0.15;\r\n\tfloat d = length( (sq-vec3(0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\r\n\td = 0.5*max( d, sdBox( sq, vec3(1.0,1.0,0.01) ) );\r\n    if( d<res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\r\n\tres.x = smin( d, res.x, 0.05 );\r\n\r\n\tsq = p-p1;\r\n\tsq.xz = mm*sq.xz;\r\n\tsq.y += 0.2;\r\n\tsq.x += 0.15;\r\n\td = length( (sq-vec3(-0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\r\n\td = 0.5*max( d, sdBox( sq, vec3(1.0,1.0,0.01) ) );\r\n    if( d<res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\r\n\tres.x = smin( d, res.x, 0.05 );\r\n\r\n\treturn res;\r\n\r\n}\r\n\r\nvec3 sdSeaBed( in vec3 p )\r\n{\r\n\tfloat h = 1.0;\r\n\tvec3 q = p;\r\n\tfloat th = smoothstep( 0.1, 0.4, textureLod( iChannel0, 0.002*q.xz, 0.0 ).x );\r\n    float rr = smoothstep( 0.2, 0.5, textureLod( iChannel1, 2.0*0.02*q.xz, 0.0 ).y );\r\n\th = 0.9 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.1*(1.0-textureLod( iChannel0, 0.1*q.xz, 0.0 ).x);\r\n\th += th*1.25;\r\n    h -= 0.24*rr;\r\n\th *= 0.75;\r\n    return vec3( (p.y+h)*0.3, p.x, 0.0 );\r\n\r\n}\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n    vec4 d1 = vec4( sdSeaBed(p), 0.0 );\r\n\tvec4 d2 = vec4( sdFish(p), 1.0 ); \r\n    return (d2.x<d1.x)?d2:d1;\r\n}\r\n\r\nvec4 intersect( in vec3 ro, in vec3 rd )\r\n{\r\n\tconst float maxd = 20.0;\r\n\tconst float precis = 0.001;\r\n    float h = precis*3.0;\r\n    float t = 0.0;\r\n    float m = 0.0;\r\n\tfloat l = 0.0;\r\n\tfloat r = 0.0;\r\n    for( int i=0; i<80; i++ )\r\n    {\r\n\t    vec4 res = map( ro+rd*t );\r\n        if( h<precis || t>maxd ) break;\r\n        h = res.x;\r\n\t\tl = res.y;\r\n\t\tr = res.z;\r\n        m = res.w;\t\t\t\r\n\t\tt += h;\r\n    }\r\n\r\n    if( t>maxd ) m=-1.0;\r\n    return vec4( t, l, m, r);\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos, in float e )\r\n{\r\n    vec3 eps = vec3(e,0.0,0.0);\r\n\treturn normalize( vec3(\r\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\r\n}\r\n\r\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\r\n{\r\n    float res = 1.0;\r\n    float t = mint;\r\n\tfloat h = 1.0;\r\n    for( int i=0; i<40; i++ )\r\n    {\r\n        h = map(ro + rd*t).x;\r\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h<0.0001 ) break;\r\n    }\r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\nvec3 lig = normalize(vec3(0.9,0.35,-0.2));\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.5);\r\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\r\n\r\n\r\n    //-----------------------------------------------------\r\n    // animate\r\n    //-----------------------------------------------------\r\n\t\r\n\tfishTime = iTime + 3.5*noise1(0.2*iTime);\r\n\r\n\tfishPos = vec3( 0.0, 0.0, -0.7*fishTime );\r\n\t\r\n    //-----------------------------------------------------\r\n    // camera\r\n    //-----------------------------------------------------\r\n\r\n\tfloat an = 1.5 + 0.1*iTime - 12.0*(m.x-0.5);\r\n\r\n\tvec3 ta = fishPos - vec3(0.0,0.0,-2.0);//vec3(0.0,1.0,2.0);\r\n\tvec3 ro = ta + vec3(4.0*sin(an),4.0,4.0*cos(an));\r\n\r\n    // shake\r\n\tro += 0.01*sin(4.0*iTime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0) );\r\n\tta += 0.01*sin(4.0*iTime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0) );\r\n\r\n    // camera matrix\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n\t\r\n\t// create view ray\r\n    p.x += 0.012*sin( 3.0*sin(4.0*p.y+0.5*iTime) + 4.0*p.x + 0.5*iTime );\r\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\r\n\r\n    //-----------------------------------------------------\r\n\t// render\r\n    //-----------------------------------------------------\r\n\r\n\tvec3 col = vec3(0.4,0.6,0.8);\r\n\tvec3 bcol = col;\r\n\t\r\n\tfloat pt = (1.0-ro.y)/rd.y;\r\n\t\r\n\tvec3 oro = ro;\r\n\tif( pt>0.0 ) ro=ro+rd*pt;\r\n\t\r\n\t// raymarch\r\n    vec4 tmat = intersect(ro,rd);\r\n    if( tmat.z>-0.5 )\r\n    {\r\n\t\tfloat eps = 0.01 + 0.03*step(0.5,tmat.z);\r\n        // geometry\r\n        vec3 pos = ro + tmat.x*rd;\r\n        vec3 nor = calcNormal(pos,eps);\r\n\t\tvec3 ref = reflect( rd, nor );\r\n\r\n        // materials\r\n\t\tvec4 mate = vec4(0.5,0.5,0.5,0.0);\r\n\t\t\r\n\t\tif( tmat.z<0.5 )\r\n\t\t{\r\n\t\t\tvec3 te = texture( iChannel0, 0.1*pos.xz ).xyz;\r\n\t\t\tte = 0.05 + te;\r\n\t\t\t\r\n\t\t\tmate.xyz = 0.6*te;\r\n\t\t\tmate.w = 5.0*(0.5+0.5*te.x);\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\tfloat th = smoothstep( 0.1, 0.4, texture( iChannel0, 0.002*pos.xz ).x );\r\n\t\t\tvec3 dcol = mix( vec3(0.1, 0.1, 0.0), 0.4*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\r\n\t\t\tmate.xyz = mix( mate.xyz*0.5, dcol, th*smoothstep( 0.0, 1.0, nor.y ) );\r\n\r\n\t\t\tfloat rr = smoothstep( 0.2, 0.4, texture( iChannel1, 2.0*0.02*pos.xz ).y );\r\n\t\t\tmate.xyz *= mix( vec3(1.0), vec3(0.2,0.2,0.2)*1.5, rr );\r\n\t\t\t\r\n\t\t\tmate.xyz *= 1.5;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmate.w = 8.0;\r\n\t\t\tmate.xyz = 1.0*vec3(0.24,0.17,0.22);\r\n\r\n\t\t\tvec3 te = 0.8+2.2*texture( iChannel0, vec2(2.0*tmat.y,pos.y) ).xyz;\r\n\t\t\tmate.xyz *= te;\r\n\t\t\t\r\n\t\t\t// belly/backfin\r\n\t\t\tfloat iscola = smoothstep( 0.0, 0.2, 1.0-tmat.y );\r\n\t\t\tmate.xyz = mix( mate.xyz, mix(vec3(te.x*0.5 + 1.5),\r\n\t\t\t\t\t\t\t\t\t\t  mix(1.0+0.5*sin(150.0*pos.y - sign(pos.y)*tmat.y*300.0),1.0,smoothstep( 0.0, 0.1, 1.0-tmat.y ))*vec3(2.6,1.5,1.0)*0.9 + 1.0*vec3(2.0,1.0,0.5)*(1.0-smoothstep( 0.0, 0.09, 1.0-tmat.y )),\r\n\t\t\t\t\t\t\t\t\t\t  1.0-iscola)*0.5, smoothstep(-0.4,0.0,-nor.y) );\r\n\t\t\t\r\n\t\t\t// stripes\r\n\t\t\tmate.xyz = mix( mate.xyz, (te.x+0.5)*1.0*vec3(0.5), 0.75*smoothstep( 0.5, 1.0, sin(1.0*te.x+tmat.y*100.0 + 13.0*nor.y) )*smoothstep(0.0,0.5,nor.y) );\r\n\r\n\t\t\t// escamas\r\n\t\t\tfloat ll = clamp( (tmat.y-0.2)/(0.8-0.2), 0.0, 1.0 );\r\n\t\t\tfloat ha = 1.0-4.0*ll*(1.0-ll);\r\n\t\t\tfloat pa = smoothstep( -1.0+2.0*ha, 1.0, sin( 50.0*pos.y ) )* smoothstep( -1.0, 0.0, sin( 560.0*tmat.y ) );\r\n\t\t\tpa *= 1.0-smoothstep( 0.1, 0.2, nor.y );\r\n\t\t\tmate.xyz *= 0.5 + 0.5*vec3(1.0) * (1.0-pa);\r\n\t\t\t\r\n\t\t\t// eye\r\n\t\t\tfloat r = length(vec2(5.0*tmat.y,pos.y)-vec2(0.5,0.13) );\r\n\t\t\tr /= 1.2;\r\n\t\t\tmate.xyz = mix( mate.xyz, vec3(1.5)*clamp(1.0-r*4.0,0.0,1.0), 0.5*(1.0-smoothstep(0.08,0.09,r)) );\r\n\t\t\tmate.xyz *= smoothstep(0.03,0.05,r);\r\n\t\t\tmate.xyz += vec3(4.0)*(1.0-smoothstep(0.0,0.1,r))*pow( texture( iChannel1, 4.0*vec2(0.2*fishPos.z+4.0*tmat.y,pos.y) ).x, 2.0 );\r\n\t\t\tr = length(vec2(5.0*tmat.y,pos.y)-vec2(0.48,0.14) );\r\n\t\t\tmate.xyz = mix( mate.xyz, vec3(2.0), (1.0-smoothstep(0.0,0.02,r)) );\r\n\t\t\t\r\n\t\t\t// mouth\r\n\t\t\tvec3 oa = fishPos;\r\n\t        oa.x -= 0.25*sin(8.0*0.2*fishTime);\r\n\t\t\tmate.xyz *= 0.1 + 0.9*step( 0.0, length( (pos - oa+vec3(0.0,0.0,-0.02))*vec3(1.5,2.0,1.0) ) - 0.14 );\r\n\t\t\t\r\n\t\t\t// top fin\r\n\t        float fh = smoothstep(0.15,0.2,tmat.y) - smoothstep(0.25,0.8,tmat.y);\r\n\t        float ra = 0.04 + tmat.y*(1.0-tmat.y)*(1.0-tmat.y)*2.7;\r\n\t\t\tfloat vv = clamp((pos.y-ra-0.1)/0.2,0.0,1.0);\r\n\t\t\tvec3 fincol = mix(1.0+0.5*sin(520.0*tmat.y),1.0,vv)*mix(vec3(0.8,0.2,0.2),vec3(1.5,1.4,1.5),vv);\r\n            mate.xyz = mix( mate.xyz, fincol, fh*smoothstep(0.0,0.05,pos.y-ra-0.1) );\r\n\t\t\t\r\n\t\t\t// side fins\r\n\t\t\tfloat isFin = tmat.w;\r\n\t\t\tfincol = 0.5*vec3(3.0,2.0,2.0) * mix(1.0+0.2*sin(150.0*pos.y),1.0,0.0);\r\n            mate.xyz = mix( mate.xyz, fincol, isFin );\r\n\t\t\t\r\n\t\t\tmate.xyz *= 0.17;\r\n\t\t}\r\n\t\t\r\n\t\t// lighting\r\n        float sky = clamp(nor.y,0.0,1.0);\r\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\r\n\t\tfloat dif = max(dot(nor,lig),0.0);\r\n        float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);\r\n\t\tfloat sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );\r\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 5.0 );\r\n        float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0), mate.w ) ) * mate.w;\r\n\t\tfloat sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 3.0 );\r\n\t\t\r\n\t\t// lights\r\n\t\tvec3 lin = vec3(0.0);\r\n\t\tfloat cc  = 0.55*texture( iChannel2, 1.8*0.02*pos.xz + 0.007*iTime*vec2( 1.0, 0.0) ).x;\r\n\t\t      cc += 0.25*texture( iChannel2, 1.8*0.04*pos.xz + 0.011*iTime*vec2( 0.0, 1.0) ).x;\r\n\t\t      cc += 0.10*texture( iChannel2, 1.8*0.08*pos.xz + 0.014*iTime*vec2(-1.0,-1.0) ).x;\r\n\t\tcc = 0.6*(1.0-smoothstep( 0.0, 0.025, abs(cc-0.4))) + \r\n\t\t\t 0.4*(1.0-smoothstep( 0.0, 0.150, abs(cc-0.4)));\r\n\t\tdif *= 1.0 + 2.0*cc;\r\n\r\n\t\tlin += 3.5*dif*vec3(1.00,1.00,1.00)*sha;\r\n\t\tlin += 3.0*sky*vec3(0.10,0.20,0.35);\r\n\t\tlin += 1.0*bou*vec3(0.20,0.20,0.20);\r\n\t\tlin += 2.0*bac*vec3(0.50,0.60,0.70);\r\n        lin += 2.0*sss*vec3(0.20,0.20,0.20)*(0.2+0.8*dif*sha)*mate.w;\r\n\t\tlin += 2.0*spe*vec3(1.0)*sha*(0.3+0.7*fre);\r\n\t\t\r\n\t\t// surface-light interacion\r\n\t\tcol = mate.xyz * lin;\r\n\r\n\t\t// fog\r\n\t\ttmat.x = max(0.0,tmat.x-1.3); col *= 0.65;\r\n\t\tfloat hh = 1.0-exp(-0.2*tmat.x); \r\n\t\tcol = col*(1.0-hh)*(1.0-hh) + 1.25*vec3(0.0,0.12,0.2)*hh;\r\n\t}\r\n\t\r\n    // foam\t\r\n\tvec2 uv = (oro + rd*pt).xz;\r\n\tfloat sur = texture( iChannel3, 0.06*uv ).x;\r\n\tsur = smoothstep( 0.5, 1.0, sur )*0.5 + 0.5*sur*sur*smoothstep(0.2,1.0,texture( iChannel2, 1.0*uv ).x);\r\n\tcol = mix( col, vec3(1.0), 0.5*sur );\r\n\r\n\t// sun specular\r\n\tfloat sun = clamp( dot(lig, reflect( rd, vec3(0.0,1.0,0.0) ) ), 0.0, 1.0 );\r\n\tcol += 0.2*vec3(1.0,0.95,0.9)*pow(sun,16.0);\r\n\tcol += 0.5*vec3(1.0,0.95,0.9)*pow(sun,96.0);\r\n\r\n\t//-----------------------------------------------------\r\n\t// postprocessing\r\n    //-----------------------------------------------------\r\n\r\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\r\n\r\n    col = mix( col, vec3(dot(col,vec3(0.333))), -0.5 );\r\n\t\r\n\tcol = 0.5*col + 0.5*col*col*(3.0-2.0*col);\r\n\t\r\n\tcol *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\t\r\n\tcol *= smoothstep( 0.0, 1.0, iTime );\r\n\t\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":null,"published":0}],"Info":{"Name":"Fish swimming","id":null,"date":null,"viewed":0,"name":"Fish swimming","description":"Swimming fish","likes":0,"published":null,"tags":["procedural"," 3d"," raymarching"," distancefield"," fish"]},"ver":null,"info":{"Name":"Fish swimming","id":null,"date":null,"viewed":0,"name":"Fish swimming","description":"Swimming fish","likes":0,"published":null,"tags":["procedural"," 3d"," raymarching"," distancefield"," fish"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2014\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\nfloat hash1( float n ) { return fract(sin(n)*43758.5453123); }\r\n\r\nfloat noise1( in float x )\r\n{\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash1(p+0.0), hash1(p+1.0), f );\r\n}\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\nvec2 sd2Segment( vec3 a, vec3 b, vec3 p )\r\n{\r\n\tvec3  pa = p - a;\r\n\tvec3  ba = b - a;\r\n\tfloat t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\tvec3  v = pa - ba*t;\r\n\treturn vec2( dot(v,v), t );\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n  vec3 d = abs(p) - b;\r\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\r\n\treturn mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\nvec3 fishPos;\r\nfloat fishTime;\r\n\r\nvec3 sdFish( vec3 p )\r\n{\r\n    vec3 res = vec3( 1000.0, 0.0, 0.0 );\r\n\r\n\tp -= fishPos;\r\n\t\r\n\tif( dot(p,p)>16.0 ) return vec3(5.0);\r\n\r\n\tp *= vec3(1.2,0.8,1.2);\r\n\tvec3 q = p;\r\n\t\r\n    vec3 a = vec3(0.0,0.0,0.0);\r\n\t\r\n    \r\n    a.x -= 0.25*sin(8.0*0.2*fishTime);\r\n\tvec3 oa = a;\r\n\r\n\tfloat or = 0.0;\r\n\tfloat th = 0.0;\r\n\tfloat hm = 0.0;\r\n\r\n\t#define NUMI 7\r\n\t#define NUMF 7.0\r\n\tvec3 p1 = a; vec3 d1=vec3(0.0);\r\n\tvec3 p2 = a; vec3 d2=vec3(0.0);\r\n\tvec3 mp = a;\r\n\tfor( int i=0; i<NUMI; i++ )\r\n\t{\t\r\n\t\tfloat ih = float(i)/NUMF;\r\n\t\t\r\n\t\tfloat an = or + 1.0*(0.2+0.8*ih)*sin(3.0*ih - 2.0*fishTime);\r\n\t\tfloat ll = 0.26;\r\n\t\tif( i==(NUMI-1) ) ll=0.4;\r\n\t\tvec3 b = a + ll*vec3(sin(an), 0.0, cos(an))*(16.0/NUMF);\r\n\t\t\r\n\t\tvec2 dis = sd2Segment( a, b, p );\r\n\r\n\t\tif( dis.x<res.x ) {res=vec3(dis.x,ih+dis.y/NUMF,0.0); mp=a+(b-a)*dis.y; }\r\n\t\t\r\n\t\tif( i==1 ) { p1=a; d1 = b-a; }\r\n\t\t\r\n\t\ta = b;\r\n\t}\r\n\tfloat h = res.y;\r\n\tfloat ra = 0.04 + h*(1.0-h)*(1.0-h)*2.7;\r\n\r\n\t// tail\r\n\tp.y /= 1.0 + 14.0*(1.0-smoothstep( 0.0, 0.13, 1.0-h));\r\n    p.z += 0.08*(1.0-clamp(abs(p.y)/0.075,0.0,1.0))*(1.0-smoothstep( 0.0,0.1,1.0-h));\r\n\tres.x = 0.75 * (distance(p,mp) - ra);\r\n\t\r\n\t// mouth\r\n\tfloat d3 = 0.75*(length( (p - oa)*vec3(0.5,2.0,1.0) )-0.12);\r\n\tres.x = max( -d3, res.x );\r\n\t\r\n\t// upper central fin\r\n\tfloat fh = smoothstep(0.15,0.2,h) - smoothstep(0.25,0.8,h);\r\n\tfh -= 0.2*pow(0.5+0.5*sin(210.0*h),0.2)*fh;\r\n\td3 = length(p.xz-mp.xz) - 0.01;\r\n    d3 = max( d3, p.y - (mp.y+ra+0.2*fh) );\r\n\td3 = max( d3, -p.y - 0.0 );\r\n\tres.x = min( res.x, d3 );\r\n\t\r\n\t// fins\r\n\td1.xz = normalize(d1.xz);\r\n\r\n\tfloat flap = 0.7 + 0.3*sin(2.0*8.0*0.2*fishTime);\r\n    vec2 dd = normalize(d1.xz + sign((p-p1).x)*flap*d1.zx*vec2(-1.0,1.0));\r\n\tmat2 mm = mat2( dd.y, dd.x, -dd.x, dd.y );\r\n\tvec3 sq = p-p1;\r\n\tsq.xz = mm*sq.xz;\r\n\tsq.y += 0.2;\r\n\tsq.x += -0.15;\r\n\tfloat d = length( (sq-vec3(0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\r\n\td = 0.5*max( d, sdBox( sq, vec3(1.0,1.0,0.01) ) );\r\n    if( d<res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\r\n\tres.x = smin( d, res.x, 0.05 );\r\n\r\n\tsq = p-p1;\r\n\tsq.xz = mm*sq.xz;\r\n\tsq.y += 0.2;\r\n\tsq.x += 0.15;\r\n\td = length( (sq-vec3(-0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\r\n\td = 0.5*max( d, sdBox( sq, vec3(1.0,1.0,0.01) ) );\r\n    if( d<res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\r\n\tres.x = smin( d, res.x, 0.05 );\r\n\r\n\treturn res;\r\n\r\n}\r\n\r\nvec3 sdSeaBed( in vec3 p )\r\n{\r\n\tfloat h = 1.0;\r\n\tvec3 q = p;\r\n\tfloat th = smoothstep( 0.1, 0.4, textureLod( iChannel0, 0.002*q.xz, 0.0 ).x );\r\n    float rr = smoothstep( 0.2, 0.5, textureLod( iChannel1, 2.0*0.02*q.xz, 0.0 ).y );\r\n\th = 0.9 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.1*(1.0-textureLod( iChannel0, 0.1*q.xz, 0.0 ).x);\r\n\th += th*1.25;\r\n    h -= 0.24*rr;\r\n\th *= 0.75;\r\n    return vec3( (p.y+h)*0.3, p.x, 0.0 );\r\n\r\n}\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n    vec4 d1 = vec4( sdSeaBed(p), 0.0 );\r\n\tvec4 d2 = vec4( sdFish(p), 1.0 ); \r\n    return (d2.x<d1.x)?d2:d1;\r\n}\r\n\r\nvec4 intersect( in vec3 ro, in vec3 rd )\r\n{\r\n\tconst float maxd = 20.0;\r\n\tconst float precis = 0.001;\r\n    float h = precis*3.0;\r\n    float t = 0.0;\r\n    float m = 0.0;\r\n\tfloat l = 0.0;\r\n\tfloat r = 0.0;\r\n    for( int i=0; i<80; i++ )\r\n    {\r\n\t    vec4 res = map( ro+rd*t );\r\n        if( h<precis || t>maxd ) break;\r\n        h = res.x;\r\n\t\tl = res.y;\r\n\t\tr = res.z;\r\n        m = res.w;\t\t\t\r\n\t\tt += h;\r\n    }\r\n\r\n    if( t>maxd ) m=-1.0;\r\n    return vec4( t, l, m, r);\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos, in float e )\r\n{\r\n    vec3 eps = vec3(e,0.0,0.0);\r\n\treturn normalize( vec3(\r\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\r\n}\r\n\r\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\r\n{\r\n    float res = 1.0;\r\n    float t = mint;\r\n\tfloat h = 1.0;\r\n    for( int i=0; i<40; i++ )\r\n    {\r\n        h = map(ro + rd*t).x;\r\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h<0.0001 ) break;\r\n    }\r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\nvec3 lig = normalize(vec3(0.9,0.35,-0.2));\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.5);\r\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\r\n\r\n\r\n    //-----------------------------------------------------\r\n    // animate\r\n    //-----------------------------------------------------\r\n\t\r\n\tfishTime = iTime + 3.5*noise1(0.2*iTime);\r\n\r\n\tfishPos = vec3( 0.0, 0.0, -0.7*fishTime );\r\n\t\r\n    //-----------------------------------------------------\r\n    // camera\r\n    //-----------------------------------------------------\r\n\r\n\tfloat an = 1.5 + 0.1*iTime - 12.0*(m.x-0.5);\r\n\r\n\tvec3 ta = fishPos - vec3(0.0,0.0,-2.0);//vec3(0.0,1.0,2.0);\r\n\tvec3 ro = ta + vec3(4.0*sin(an),4.0,4.0*cos(an));\r\n\r\n    // shake\r\n\tro += 0.01*sin(4.0*iTime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0) );\r\n\tta += 0.01*sin(4.0*iTime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0) );\r\n\r\n    // camera matrix\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n\t\r\n\t// create view ray\r\n    p.x += 0.012*sin( 3.0*sin(4.0*p.y+0.5*iTime) + 4.0*p.x + 0.5*iTime );\r\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\r\n\r\n    //-----------------------------------------------------\r\n\t// render\r\n    //-----------------------------------------------------\r\n\r\n\tvec3 col = vec3(0.4,0.6,0.8);\r\n\tvec3 bcol = col;\r\n\t\r\n\tfloat pt = (1.0-ro.y)/rd.y;\r\n\t\r\n\tvec3 oro = ro;\r\n\tif( pt>0.0 ) ro=ro+rd*pt;\r\n\t\r\n\t// raymarch\r\n    vec4 tmat = intersect(ro,rd);\r\n    if( tmat.z>-0.5 )\r\n    {\r\n\t\tfloat eps = 0.01 + 0.03*step(0.5,tmat.z);\r\n        // geometry\r\n        vec3 pos = ro + tmat.x*rd;\r\n        vec3 nor = calcNormal(pos,eps);\r\n\t\tvec3 ref = reflect( rd, nor );\r\n\r\n        // materials\r\n\t\tvec4 mate = vec4(0.5,0.5,0.5,0.0);\r\n\t\t\r\n\t\tif( tmat.z<0.5 )\r\n\t\t{\r\n\t\t\tvec3 te = texture( iChannel0, 0.1*pos.xz ).xyz;\r\n\t\t\tte = 0.05 + te;\r\n\t\t\t\r\n\t\t\tmate.xyz = 0.6*te;\r\n\t\t\tmate.w = 5.0*(0.5+0.5*te.x);\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\tfloat th = smoothstep( 0.1, 0.4, texture( iChannel0, 0.002*pos.xz ).x );\r\n\t\t\tvec3 dcol = mix( vec3(0.1, 0.1, 0.0), 0.4*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\r\n\t\t\tmate.xyz = mix( mate.xyz*0.5, dcol, th*smoothstep( 0.0, 1.0, nor.y ) );\r\n\r\n\t\t\tfloat rr = smoothstep( 0.2, 0.4, texture( iChannel1, 2.0*0.02*pos.xz ).y );\r\n\t\t\tmate.xyz *= mix( vec3(1.0), vec3(0.2,0.2,0.2)*1.5, rr );\r\n\t\t\t\r\n\t\t\tmate.xyz *= 1.5;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmate.w = 8.0;\r\n\t\t\tmate.xyz = 1.0*vec3(0.24,0.17,0.22);\r\n\r\n\t\t\tvec3 te = 0.8+2.2*texture( iChannel0, vec2(2.0*tmat.y,pos.y) ).xyz;\r\n\t\t\tmate.xyz *= te;\r\n\t\t\t\r\n\t\t\t// belly/backfin\r\n\t\t\tfloat iscola = smoothstep( 0.0, 0.2, 1.0-tmat.y );\r\n\t\t\tmate.xyz = mix( mate.xyz, mix(vec3(te.x*0.5 + 1.5),\r\n\t\t\t\t\t\t\t\t\t\t  mix(1.0+0.5*sin(150.0*pos.y - sign(pos.y)*tmat.y*300.0),1.0,smoothstep( 0.0, 0.1, 1.0-tmat.y ))*vec3(2.6,1.5,1.0)*0.9 + 1.0*vec3(2.0,1.0,0.5)*(1.0-smoothstep( 0.0, 0.09, 1.0-tmat.y )),\r\n\t\t\t\t\t\t\t\t\t\t  1.0-iscola)*0.5, smoothstep(-0.4,0.0,-nor.y) );\r\n\t\t\t\r\n\t\t\t// stripes\r\n\t\t\tmate.xyz = mix( mate.xyz, (te.x+0.5)*1.0*vec3(0.5), 0.75*smoothstep( 0.5, 1.0, sin(1.0*te.x+tmat.y*100.0 + 13.0*nor.y) )*smoothstep(0.0,0.5,nor.y) );\r\n\r\n\t\t\t// escamas\r\n\t\t\tfloat ll = clamp( (tmat.y-0.2)/(0.8-0.2), 0.0, 1.0 );\r\n\t\t\tfloat ha = 1.0-4.0*ll*(1.0-ll);\r\n\t\t\tfloat pa = smoothstep( -1.0+2.0*ha, 1.0, sin( 50.0*pos.y ) )* smoothstep( -1.0, 0.0, sin( 560.0*tmat.y ) );\r\n\t\t\tpa *= 1.0-smoothstep( 0.1, 0.2, nor.y );\r\n\t\t\tmate.xyz *= 0.5 + 0.5*vec3(1.0) * (1.0-pa);\r\n\t\t\t\r\n\t\t\t// eye\r\n\t\t\tfloat r = length(vec2(5.0*tmat.y,pos.y)-vec2(0.5,0.13) );\r\n\t\t\tr /= 1.2;\r\n\t\t\tmate.xyz = mix( mate.xyz, vec3(1.5)*clamp(1.0-r*4.0,0.0,1.0), 0.5*(1.0-smoothstep(0.08,0.09,r)) );\r\n\t\t\tmate.xyz *= smoothstep(0.03,0.05,r);\r\n\t\t\tmate.xyz += vec3(4.0)*(1.0-smoothstep(0.0,0.1,r))*pow( texture( iChannel1, 4.0*vec2(0.2*fishPos.z+4.0*tmat.y,pos.y) ).x, 2.0 );\r\n\t\t\tr = length(vec2(5.0*tmat.y,pos.y)-vec2(0.48,0.14) );\r\n\t\t\tmate.xyz = mix( mate.xyz, vec3(2.0), (1.0-smoothstep(0.0,0.02,r)) );\r\n\t\t\t\r\n\t\t\t// mouth\r\n\t\t\tvec3 oa = fishPos;\r\n\t        oa.x -= 0.25*sin(8.0*0.2*fishTime);\r\n\t\t\tmate.xyz *= 0.1 + 0.9*step( 0.0, length( (pos - oa+vec3(0.0,0.0,-0.02))*vec3(1.5,2.0,1.0) ) - 0.14 );\r\n\t\t\t\r\n\t\t\t// top fin\r\n\t        float fh = smoothstep(0.15,0.2,tmat.y) - smoothstep(0.25,0.8,tmat.y);\r\n\t        float ra = 0.04 + tmat.y*(1.0-tmat.y)*(1.0-tmat.y)*2.7;\r\n\t\t\tfloat vv = clamp((pos.y-ra-0.1)/0.2,0.0,1.0);\r\n\t\t\tvec3 fincol = mix(1.0+0.5*sin(520.0*tmat.y),1.0,vv)*mix(vec3(0.8,0.2,0.2),vec3(1.5,1.4,1.5),vv);\r\n            mate.xyz = mix( mate.xyz, fincol, fh*smoothstep(0.0,0.05,pos.y-ra-0.1) );\r\n\t\t\t\r\n\t\t\t// side fins\r\n\t\t\tfloat isFin = tmat.w;\r\n\t\t\tfincol = 0.5*vec3(3.0,2.0,2.0) * mix(1.0+0.2*sin(150.0*pos.y),1.0,0.0);\r\n            mate.xyz = mix( mate.xyz, fincol, isFin );\r\n\t\t\t\r\n\t\t\tmate.xyz *= 0.17;\r\n\t\t}\r\n\t\t\r\n\t\t// lighting\r\n        float sky = clamp(nor.y,0.0,1.0);\r\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\r\n\t\tfloat dif = max(dot(nor,lig),0.0);\r\n        float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);\r\n\t\tfloat sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );\r\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 5.0 );\r\n        float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0), mate.w ) ) * mate.w;\r\n\t\tfloat sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 3.0 );\r\n\t\t\r\n\t\t// lights\r\n\t\tvec3 lin = vec3(0.0);\r\n\t\tfloat cc  = 0.55*texture( iChannel2, 1.8*0.02*pos.xz + 0.007*iTime*vec2( 1.0, 0.0) ).x;\r\n\t\t      cc += 0.25*texture( iChannel2, 1.8*0.04*pos.xz + 0.011*iTime*vec2( 0.0, 1.0) ).x;\r\n\t\t      cc += 0.10*texture( iChannel2, 1.8*0.08*pos.xz + 0.014*iTime*vec2(-1.0,-1.0) ).x;\r\n\t\tcc = 0.6*(1.0-smoothstep( 0.0, 0.025, abs(cc-0.4))) + \r\n\t\t\t 0.4*(1.0-smoothstep( 0.0, 0.150, abs(cc-0.4)));\r\n\t\tdif *= 1.0 + 2.0*cc;\r\n\r\n\t\tlin += 3.5*dif*vec3(1.00,1.00,1.00)*sha;\r\n\t\tlin += 3.0*sky*vec3(0.10,0.20,0.35);\r\n\t\tlin += 1.0*bou*vec3(0.20,0.20,0.20);\r\n\t\tlin += 2.0*bac*vec3(0.50,0.60,0.70);\r\n        lin += 2.0*sss*vec3(0.20,0.20,0.20)*(0.2+0.8*dif*sha)*mate.w;\r\n\t\tlin += 2.0*spe*vec3(1.0)*sha*(0.3+0.7*fre);\r\n\t\t\r\n\t\t// surface-light interacion\r\n\t\tcol = mate.xyz * lin;\r\n\r\n\t\t// fog\r\n\t\ttmat.x = max(0.0,tmat.x-1.3); col *= 0.65;\r\n\t\tfloat hh = 1.0-exp(-0.2*tmat.x); \r\n\t\tcol = col*(1.0-hh)*(1.0-hh) + 1.25*vec3(0.0,0.12,0.2)*hh;\r\n\t}\r\n\t\r\n    // foam\t\r\n\tvec2 uv = (oro + rd*pt).xz;\r\n\tfloat sur = texture( iChannel3, 0.06*uv ).x;\r\n\tsur = smoothstep( 0.5, 1.0, sur )*0.5 + 0.5*sur*sur*smoothstep(0.2,1.0,texture( iChannel2, 1.0*uv ).x);\r\n\tcol = mix( col, vec3(1.0), 0.5*sur );\r\n\r\n\t// sun specular\r\n\tfloat sun = clamp( dot(lig, reflect( rd, vec3(0.0,1.0,0.0) ) ), 0.0, 1.0 );\r\n\tcol += 0.2*vec3(1.0,0.95,0.9)*pow(sun,16.0);\r\n\tcol += 0.5*vec3(1.0,0.95,0.9)*pow(sun,96.0);\r\n\r\n\t//-----------------------------------------------------\r\n\t// postprocessing\r\n    //-----------------------------------------------------\r\n\r\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\r\n\r\n    col = mix( col, vec3(dot(col,vec3(0.333))), -0.5 );\r\n\t\r\n\tcol = 0.5*col + 0.5*col*col*(3.0-2.0*col);\r\n\t\r\n\tcol *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\t\r\n\tcol *= smoothstep( 0.0, 1.0, iTime );\r\n\t\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":null,"published":0}],"outputs":[],"code":"// Created by inigo quilez - iq/2014\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\nfloat hash1( float n ) { return fract(sin(n)*43758.5453123); }\r\n\r\nfloat noise1( in float x )\r\n{\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash1(p+0.0), hash1(p+1.0), f );\r\n}\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\nvec2 sd2Segment( vec3 a, vec3 b, vec3 p )\r\n{\r\n\tvec3  pa = p - a;\r\n\tvec3  ba = b - a;\r\n\tfloat t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\tvec3  v = pa - ba*t;\r\n\treturn vec2( dot(v,v), t );\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n  vec3 d = abs(p) - b;\r\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\r\n\treturn mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\nvec3 fishPos;\r\nfloat fishTime;\r\n\r\nvec3 sdFish( vec3 p )\r\n{\r\n    vec3 res = vec3( 1000.0, 0.0, 0.0 );\r\n\r\n\tp -= fishPos;\r\n\t\r\n\tif( dot(p,p)>16.0 ) return vec3(5.0);\r\n\r\n\tp *= vec3(1.2,0.8,1.2);\r\n\tvec3 q = p;\r\n\t\r\n    vec3 a = vec3(0.0,0.0,0.0);\r\n\t\r\n    \r\n    a.x -= 0.25*sin(8.0*0.2*fishTime);\r\n\tvec3 oa = a;\r\n\r\n\tfloat or = 0.0;\r\n\tfloat th = 0.0;\r\n\tfloat hm = 0.0;\r\n\r\n\t#define NUMI 7\r\n\t#define NUMF 7.0\r\n\tvec3 p1 = a; vec3 d1=vec3(0.0);\r\n\tvec3 p2 = a; vec3 d2=vec3(0.0);\r\n\tvec3 mp = a;\r\n\tfor( int i=0; i<NUMI; i++ )\r\n\t{\t\r\n\t\tfloat ih = float(i)/NUMF;\r\n\t\t\r\n\t\tfloat an = or + 1.0*(0.2+0.8*ih)*sin(3.0*ih - 2.0*fishTime);\r\n\t\tfloat ll = 0.26;\r\n\t\tif( i==(NUMI-1) ) ll=0.4;\r\n\t\tvec3 b = a + ll*vec3(sin(an), 0.0, cos(an))*(16.0/NUMF);\r\n\t\t\r\n\t\tvec2 dis = sd2Segment( a, b, p );\r\n\r\n\t\tif( dis.x<res.x ) {res=vec3(dis.x,ih+dis.y/NUMF,0.0); mp=a+(b-a)*dis.y; }\r\n\t\t\r\n\t\tif( i==1 ) { p1=a; d1 = b-a; }\r\n\t\t\r\n\t\ta = b;\r\n\t}\r\n\tfloat h = res.y;\r\n\tfloat ra = 0.04 + h*(1.0-h)*(1.0-h)*2.7;\r\n\r\n\t// tail\r\n\tp.y /= 1.0 + 14.0*(1.0-smoothstep( 0.0, 0.13, 1.0-h));\r\n    p.z += 0.08*(1.0-clamp(abs(p.y)/0.075,0.0,1.0))*(1.0-smoothstep( 0.0,0.1,1.0-h));\r\n\tres.x = 0.75 * (distance(p,mp) - ra);\r\n\t\r\n\t// mouth\r\n\tfloat d3 = 0.75*(length( (p - oa)*vec3(0.5,2.0,1.0) )-0.12);\r\n\tres.x = max( -d3, res.x );\r\n\t\r\n\t// upper central fin\r\n\tfloat fh = smoothstep(0.15,0.2,h) - smoothstep(0.25,0.8,h);\r\n\tfh -= 0.2*pow(0.5+0.5*sin(210.0*h),0.2)*fh;\r\n\td3 = length(p.xz-mp.xz) - 0.01;\r\n    d3 = max( d3, p.y - (mp.y+ra+0.2*fh) );\r\n\td3 = max( d3, -p.y - 0.0 );\r\n\tres.x = min( res.x, d3 );\r\n\t\r\n\t// fins\r\n\td1.xz = normalize(d1.xz);\r\n\r\n\tfloat flap = 0.7 + 0.3*sin(2.0*8.0*0.2*fishTime);\r\n    vec2 dd = normalize(d1.xz + sign((p-p1).x)*flap*d1.zx*vec2(-1.0,1.0));\r\n\tmat2 mm = mat2( dd.y, dd.x, -dd.x, dd.y );\r\n\tvec3 sq = p-p1;\r\n\tsq.xz = mm*sq.xz;\r\n\tsq.y += 0.2;\r\n\tsq.x += -0.15;\r\n\tfloat d = length( (sq-vec3(0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\r\n\td = 0.5*max( d, sdBox( sq, vec3(1.0,1.0,0.01) ) );\r\n    if( d<res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\r\n\tres.x = smin( d, res.x, 0.05 );\r\n\r\n\tsq = p-p1;\r\n\tsq.xz = mm*sq.xz;\r\n\tsq.y += 0.2;\r\n\tsq.x += 0.15;\r\n\td = length( (sq-vec3(-0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\r\n\td = 0.5*max( d, sdBox( sq, vec3(1.0,1.0,0.01) ) );\r\n    if( d<res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\r\n\tres.x = smin( d, res.x, 0.05 );\r\n\r\n\treturn res;\r\n\r\n}\r\n\r\nvec3 sdSeaBed( in vec3 p )\r\n{\r\n\tfloat h = 1.0;\r\n\tvec3 q = p;\r\n\tfloat th = smoothstep( 0.1, 0.4, textureLod( iChannel0, 0.002*q.xz, 0.0 ).x );\r\n    float rr = smoothstep( 0.2, 0.5, textureLod( iChannel1, 2.0*0.02*q.xz, 0.0 ).y );\r\n\th = 0.9 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.1*(1.0-textureLod( iChannel0, 0.1*q.xz, 0.0 ).x);\r\n\th += th*1.25;\r\n    h -= 0.24*rr;\r\n\th *= 0.75;\r\n    return vec3( (p.y+h)*0.3, p.x, 0.0 );\r\n\r\n}\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n    vec4 d1 = vec4( sdSeaBed(p), 0.0 );\r\n\tvec4 d2 = vec4( sdFish(p), 1.0 ); \r\n    return (d2.x<d1.x)?d2:d1;\r\n}\r\n\r\nvec4 intersect( in vec3 ro, in vec3 rd )\r\n{\r\n\tconst float maxd = 20.0;\r\n\tconst float precis = 0.001;\r\n    float h = precis*3.0;\r\n    float t = 0.0;\r\n    float m = 0.0;\r\n\tfloat l = 0.0;\r\n\tfloat r = 0.0;\r\n    for( int i=0; i<80; i++ )\r\n    {\r\n\t    vec4 res = map( ro+rd*t );\r\n        if( h<precis || t>maxd ) break;\r\n        h = res.x;\r\n\t\tl = res.y;\r\n\t\tr = res.z;\r\n        m = res.w;\t\t\t\r\n\t\tt += h;\r\n    }\r\n\r\n    if( t>maxd ) m=-1.0;\r\n    return vec4( t, l, m, r);\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos, in float e )\r\n{\r\n    vec3 eps = vec3(e,0.0,0.0);\r\n\treturn normalize( vec3(\r\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\r\n}\r\n\r\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\r\n{\r\n    float res = 1.0;\r\n    float t = mint;\r\n\tfloat h = 1.0;\r\n    for( int i=0; i<40; i++ )\r\n    {\r\n        h = map(ro + rd*t).x;\r\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h<0.0001 ) break;\r\n    }\r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\nvec3 lig = normalize(vec3(0.9,0.35,-0.2));\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.5);\r\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\r\n\r\n\r\n    //-----------------------------------------------------\r\n    // animate\r\n    //-----------------------------------------------------\r\n\t\r\n\tfishTime = iTime + 3.5*noise1(0.2*iTime);\r\n\r\n\tfishPos = vec3( 0.0, 0.0, -0.7*fishTime );\r\n\t\r\n    //-----------------------------------------------------\r\n    // camera\r\n    //-----------------------------------------------------\r\n\r\n\tfloat an = 1.5 + 0.1*iTime - 12.0*(m.x-0.5);\r\n\r\n\tvec3 ta = fishPos - vec3(0.0,0.0,-2.0);//vec3(0.0,1.0,2.0);\r\n\tvec3 ro = ta + vec3(4.0*sin(an),4.0,4.0*cos(an));\r\n\r\n    // shake\r\n\tro += 0.01*sin(4.0*iTime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0) );\r\n\tta += 0.01*sin(4.0*iTime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0) );\r\n\r\n    // camera matrix\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n\t\r\n\t// create view ray\r\n    p.x += 0.012*sin( 3.0*sin(4.0*p.y+0.5*iTime) + 4.0*p.x + 0.5*iTime );\r\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\r\n\r\n    //-----------------------------------------------------\r\n\t// render\r\n    //-----------------------------------------------------\r\n\r\n\tvec3 col = vec3(0.4,0.6,0.8);\r\n\tvec3 bcol = col;\r\n\t\r\n\tfloat pt = (1.0-ro.y)/rd.y;\r\n\t\r\n\tvec3 oro = ro;\r\n\tif( pt>0.0 ) ro=ro+rd*pt;\r\n\t\r\n\t// raymarch\r\n    vec4 tmat = intersect(ro,rd);\r\n    if( tmat.z>-0.5 )\r\n    {\r\n\t\tfloat eps = 0.01 + 0.03*step(0.5,tmat.z);\r\n        // geometry\r\n        vec3 pos = ro + tmat.x*rd;\r\n        vec3 nor = calcNormal(pos,eps);\r\n\t\tvec3 ref = reflect( rd, nor );\r\n\r\n        // materials\r\n\t\tvec4 mate = vec4(0.5,0.5,0.5,0.0);\r\n\t\t\r\n\t\tif( tmat.z<0.5 )\r\n\t\t{\r\n\t\t\tvec3 te = texture( iChannel0, 0.1*pos.xz ).xyz;\r\n\t\t\tte = 0.05 + te;\r\n\t\t\t\r\n\t\t\tmate.xyz = 0.6*te;\r\n\t\t\tmate.w = 5.0*(0.5+0.5*te.x);\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\tfloat th = smoothstep( 0.1, 0.4, texture( iChannel0, 0.002*pos.xz ).x );\r\n\t\t\tvec3 dcol = mix( vec3(0.1, 0.1, 0.0), 0.4*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\r\n\t\t\tmate.xyz = mix( mate.xyz*0.5, dcol, th*smoothstep( 0.0, 1.0, nor.y ) );\r\n\r\n\t\t\tfloat rr = smoothstep( 0.2, 0.4, texture( iChannel1, 2.0*0.02*pos.xz ).y );\r\n\t\t\tmate.xyz *= mix( vec3(1.0), vec3(0.2,0.2,0.2)*1.5, rr );\r\n\t\t\t\r\n\t\t\tmate.xyz *= 1.5;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmate.w = 8.0;\r\n\t\t\tmate.xyz = 1.0*vec3(0.24,0.17,0.22);\r\n\r\n\t\t\tvec3 te = 0.8+2.2*texture( iChannel0, vec2(2.0*tmat.y,pos.y) ).xyz;\r\n\t\t\tmate.xyz *= te;\r\n\t\t\t\r\n\t\t\t// belly/backfin\r\n\t\t\tfloat iscola = smoothstep( 0.0, 0.2, 1.0-tmat.y );\r\n\t\t\tmate.xyz = mix( mate.xyz, mix(vec3(te.x*0.5 + 1.5),\r\n\t\t\t\t\t\t\t\t\t\t  mix(1.0+0.5*sin(150.0*pos.y - sign(pos.y)*tmat.y*300.0),1.0,smoothstep( 0.0, 0.1, 1.0-tmat.y ))*vec3(2.6,1.5,1.0)*0.9 + 1.0*vec3(2.0,1.0,0.5)*(1.0-smoothstep( 0.0, 0.09, 1.0-tmat.y )),\r\n\t\t\t\t\t\t\t\t\t\t  1.0-iscola)*0.5, smoothstep(-0.4,0.0,-nor.y) );\r\n\t\t\t\r\n\t\t\t// stripes\r\n\t\t\tmate.xyz = mix( mate.xyz, (te.x+0.5)*1.0*vec3(0.5), 0.75*smoothstep( 0.5, 1.0, sin(1.0*te.x+tmat.y*100.0 + 13.0*nor.y) )*smoothstep(0.0,0.5,nor.y) );\r\n\r\n\t\t\t// escamas\r\n\t\t\tfloat ll = clamp( (tmat.y-0.2)/(0.8-0.2), 0.0, 1.0 );\r\n\t\t\tfloat ha = 1.0-4.0*ll*(1.0-ll);\r\n\t\t\tfloat pa = smoothstep( -1.0+2.0*ha, 1.0, sin( 50.0*pos.y ) )* smoothstep( -1.0, 0.0, sin( 560.0*tmat.y ) );\r\n\t\t\tpa *= 1.0-smoothstep( 0.1, 0.2, nor.y );\r\n\t\t\tmate.xyz *= 0.5 + 0.5*vec3(1.0) * (1.0-pa);\r\n\t\t\t\r\n\t\t\t// eye\r\n\t\t\tfloat r = length(vec2(5.0*tmat.y,pos.y)-vec2(0.5,0.13) );\r\n\t\t\tr /= 1.2;\r\n\t\t\tmate.xyz = mix( mate.xyz, vec3(1.5)*clamp(1.0-r*4.0,0.0,1.0), 0.5*(1.0-smoothstep(0.08,0.09,r)) );\r\n\t\t\tmate.xyz *= smoothstep(0.03,0.05,r);\r\n\t\t\tmate.xyz += vec3(4.0)*(1.0-smoothstep(0.0,0.1,r))*pow( texture( iChannel1, 4.0*vec2(0.2*fishPos.z+4.0*tmat.y,pos.y) ).x, 2.0 );\r\n\t\t\tr = length(vec2(5.0*tmat.y,pos.y)-vec2(0.48,0.14) );\r\n\t\t\tmate.xyz = mix( mate.xyz, vec3(2.0), (1.0-smoothstep(0.0,0.02,r)) );\r\n\t\t\t\r\n\t\t\t// mouth\r\n\t\t\tvec3 oa = fishPos;\r\n\t        oa.x -= 0.25*sin(8.0*0.2*fishTime);\r\n\t\t\tmate.xyz *= 0.1 + 0.9*step( 0.0, length( (pos - oa+vec3(0.0,0.0,-0.02))*vec3(1.5,2.0,1.0) ) - 0.14 );\r\n\t\t\t\r\n\t\t\t// top fin\r\n\t        float fh = smoothstep(0.15,0.2,tmat.y) - smoothstep(0.25,0.8,tmat.y);\r\n\t        float ra = 0.04 + tmat.y*(1.0-tmat.y)*(1.0-tmat.y)*2.7;\r\n\t\t\tfloat vv = clamp((pos.y-ra-0.1)/0.2,0.0,1.0);\r\n\t\t\tvec3 fincol = mix(1.0+0.5*sin(520.0*tmat.y),1.0,vv)*mix(vec3(0.8,0.2,0.2),vec3(1.5,1.4,1.5),vv);\r\n            mate.xyz = mix( mate.xyz, fincol, fh*smoothstep(0.0,0.05,pos.y-ra-0.1) );\r\n\t\t\t\r\n\t\t\t// side fins\r\n\t\t\tfloat isFin = tmat.w;\r\n\t\t\tfincol = 0.5*vec3(3.0,2.0,2.0) * mix(1.0+0.2*sin(150.0*pos.y),1.0,0.0);\r\n            mate.xyz = mix( mate.xyz, fincol, isFin );\r\n\t\t\t\r\n\t\t\tmate.xyz *= 0.17;\r\n\t\t}\r\n\t\t\r\n\t\t// lighting\r\n        float sky = clamp(nor.y,0.0,1.0);\r\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\r\n\t\tfloat dif = max(dot(nor,lig),0.0);\r\n        float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);\r\n\t\tfloat sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );\r\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 5.0 );\r\n        float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0), mate.w ) ) * mate.w;\r\n\t\tfloat sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 3.0 );\r\n\t\t\r\n\t\t// lights\r\n\t\tvec3 lin = vec3(0.0);\r\n\t\tfloat cc  = 0.55*texture( iChannel2, 1.8*0.02*pos.xz + 0.007*iTime*vec2( 1.0, 0.0) ).x;\r\n\t\t      cc += 0.25*texture( iChannel2, 1.8*0.04*pos.xz + 0.011*iTime*vec2( 0.0, 1.0) ).x;\r\n\t\t      cc += 0.10*texture( iChannel2, 1.8*0.08*pos.xz + 0.014*iTime*vec2(-1.0,-1.0) ).x;\r\n\t\tcc = 0.6*(1.0-smoothstep( 0.0, 0.025, abs(cc-0.4))) + \r\n\t\t\t 0.4*(1.0-smoothstep( 0.0, 0.150, abs(cc-0.4)));\r\n\t\tdif *= 1.0 + 2.0*cc;\r\n\r\n\t\tlin += 3.5*dif*vec3(1.00,1.00,1.00)*sha;\r\n\t\tlin += 3.0*sky*vec3(0.10,0.20,0.35);\r\n\t\tlin += 1.0*bou*vec3(0.20,0.20,0.20);\r\n\t\tlin += 2.0*bac*vec3(0.50,0.60,0.70);\r\n        lin += 2.0*sss*vec3(0.20,0.20,0.20)*(0.2+0.8*dif*sha)*mate.w;\r\n\t\tlin += 2.0*spe*vec3(1.0)*sha*(0.3+0.7*fre);\r\n\t\t\r\n\t\t// surface-light interacion\r\n\t\tcol = mate.xyz * lin;\r\n\r\n\t\t// fog\r\n\t\ttmat.x = max(0.0,tmat.x-1.3); col *= 0.65;\r\n\t\tfloat hh = 1.0-exp(-0.2*tmat.x); \r\n\t\tcol = col*(1.0-hh)*(1.0-hh) + 1.25*vec3(0.0,0.12,0.2)*hh;\r\n\t}\r\n\t\r\n    // foam\t\r\n\tvec2 uv = (oro + rd*pt).xz;\r\n\tfloat sur = texture( iChannel3, 0.06*uv ).x;\r\n\tsur = smoothstep( 0.5, 1.0, sur )*0.5 + 0.5*sur*sur*smoothstep(0.2,1.0,texture( iChannel2, 1.0*uv ).x);\r\n\tcol = mix( col, vec3(1.0), 0.5*sur );\r\n\r\n\t// sun specular\r\n\tfloat sun = clamp( dot(lig, reflect( rd, vec3(0.0,1.0,0.0) ) ), 0.0, 1.0 );\r\n\tcol += 0.2*vec3(1.0,0.95,0.9)*pow(sun,16.0);\r\n\tcol += 0.5*vec3(1.0,0.95,0.9)*pow(sun,96.0);\r\n\r\n\t//-----------------------------------------------------\r\n\t// postprocessing\r\n    //-----------------------------------------------------\r\n\r\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\r\n\r\n    col = mix( col, vec3(dot(col,vec3(0.333))), -0.5 );\r\n\t\r\n\tcol = 0.5*col + 0.5*col*col*(3.0-2.0*col);\r\n\t\r\n\tcol *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\t\r\n\tcol *= smoothstep( 0.0, 1.0, iTime );\r\n\t\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//Magnetismic by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/XlB3zV\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n//Getting 60fps here at high quality\r\n#define HIGH_QUALITY\r\n\r\n#ifdef HIGH_QUALITY\r\n#define STEPS 130\r\n#define ALPHA_WEIGHT 0.015\r\n#define BASE_STEP 0.025\r\n#else\r\n#define STEPS 50\r\n#define ALPHA_WEIGHT 0.05\r\n#define BASE_STEP 0.1\r\n#endif\r\n\r\n#define time iTime\r\nvec2 mo;\r\nvec2 rot(in vec2 p, in float a){float c = cos(a), s = sin(a);return p*mat2(c,s,-s,c);}\r\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\r\nfloat noise(in vec3 p)\r\n{\r\n\tvec3 ip = floor(p), fp = fract(p);\r\n    fp = fp*fp*(3.0-2.0*fp);\r\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\r\n\tvec2 cl = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix(cl.x, cl.y, fp.z);\r\n}\r\n\r\nfloat fbm(in vec3 p, in float sr)\r\n{\r\n    p *= 3.5;\r\n    float rz = 0., z = 1.;\r\n    for(int i=0;i<4;i++)\r\n    {\r\n        float n = noise(p-time*.6);\r\n        rz += (sin(n*4.4)-.45)*z;\r\n        z *= .47;\r\n        p *= 3.5;\r\n    }\r\n    return rz;\r\n}\r\n\r\nvec4 map(in vec3 p)\r\n{\r\n    float dtp = dot(p,p);\r\n\tp = .5*p/(dtp + .2);\r\n    p.xz = rot(p.xz, p.y*2.5);\r\n    p.xy = rot(p.xz, p.y*2.);\r\n    \r\n    float dtp2 = dot(p, p);\r\n    p = (mo.y + .6)*3.*p/(dtp2 - 5.);\r\n    float r = clamp(fbm(p, dtp*0.1)*1.5-dtp*(.35-sin(time*0.3)*0.15), 0. ,1.);\r\n    vec4 col = vec4(.5,1.7,.5,.96)*r;\r\n    \r\n    float grd = clamp((dtp+.7)*0.4,0.,1.);\r\n    col.b += grd*.6;\r\n    col.r -= grd*.5;    \r\n    vec3 lv = mix(p,vec3(0.3),2.);\r\n    grd = clamp((col.w - fbm(p+lv*.05,1.))*2., 0.01, 1.5 );\r\n    col.rgb *= vec3(.5, 0.4, .6)*grd + vec3(4.,0.,.4);\r\n    col.a *= clamp(dtp*2.-1.,0.,1.)*0.07+0.87;\r\n    \r\n    return col;\r\n}\r\n\r\nvec4 vmarch(in vec3 ro, in vec3 rd)\r\n{\r\n\tvec4 rz = vec4(0);\r\n\tfloat t = 2.5;\r\n    t += 0.03*hash21(gl_FragCoord.xy);\r\n\tfor(int i=0; i<STEPS; i++)\r\n\t{\r\n\t\tif(rz.a > 0.99 || t > 6.)break;\r\n\t\tvec3 pos = ro + t*rd;\r\n        vec4 col = map(pos);\r\n        float den = col.a;\r\n        col.a *= ALPHA_WEIGHT;\r\n\t\tcol.rgb *= col.a*1.7;\r\n\t\trz += col*(1. - rz.a);\r\n        t += BASE_STEP - den*(BASE_STEP-BASE_STEP*0.015);\r\n\t}\r\n    return rz;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\tvec2 p = fragCoord.xy/iResolution.xy*2. - 1.;\r\n\tp.x *= iResolution.x/iResolution.y*.85;\r\n    p *= 1.1;\r\n\tmo = 2.0*iMouse.xy/iResolution.xy;\r\n    mo = (mo==vec2(.0))?mo=vec2(0.5,1.):mo;\r\n\t\r\n\tvec3 ro = 4.*normalize(vec3(cos(2.75-2.0*(mo.x+time*0.05)), sin(time*0.22)*0.2, sin(2.75-2.0*(mo.x+time*0.05))));\r\n\tvec3 eye = normalize(vec3(0) - ro);\r\n\tvec3 rgt = normalize(cross(vec3(0,1,0), eye));\r\n\tvec3 up = cross(eye,rgt);\r\n\tvec3 rd = normalize(p.x*rgt + p.y*up + (3.3-sin(time*0.3)*.7)*eye);\r\n\t\r\n\tvec4 col = clamp(vmarch(ro, rd),0.,1.);\r\n    col.rgb = pow(col.rgb, vec3(.9));\r\n    /*col.rb = rot(col.rg, 0.35);\r\n    col.gb = rot(col.gb, -0.1);*/\r\n    \r\n    fragColor = vec4(col.rgb, 1.0);\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"//Magnetismic by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/XlB3zV\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n//Getting 60fps here at high quality\r\n#define HIGH_QUALITY\r\n\r\n#ifdef HIGH_QUALITY\r\n#define STEPS 130\r\n#define ALPHA_WEIGHT 0.015\r\n#define BASE_STEP 0.025\r\n#else\r\n#define STEPS 50\r\n#define ALPHA_WEIGHT 0.05\r\n#define BASE_STEP 0.1\r\n#endif\r\n\r\n#define time iTime\r\nvec2 mo;\r\nvec2 rot(in vec2 p, in float a){float c = cos(a), s = sin(a);return p*mat2(c,s,-s,c);}\r\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\r\nfloat noise(in vec3 p)\r\n{\r\n\tvec3 ip = floor(p), fp = fract(p);\r\n    fp = fp*fp*(3.0-2.0*fp);\r\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\r\n\tvec2 cl = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix(cl.x, cl.y, fp.z);\r\n}\r\n\r\nfloat fbm(in vec3 p, in float sr)\r\n{\r\n    p *= 3.5;\r\n    float rz = 0., z = 1.;\r\n    for(int i=0;i<4;i++)\r\n    {\r\n        float n = noise(p-time*.6);\r\n        rz += (sin(n*4.4)-.45)*z;\r\n        z *= .47;\r\n        p *= 3.5;\r\n    }\r\n    return rz;\r\n}\r\n\r\nvec4 map(in vec3 p)\r\n{\r\n    float dtp = dot(p,p);\r\n\tp = .5*p/(dtp + .2);\r\n    p.xz = rot(p.xz, p.y*2.5);\r\n    p.xy = rot(p.xz, p.y*2.);\r\n    \r\n    float dtp2 = dot(p, p);\r\n    p = (mo.y + .6)*3.*p/(dtp2 - 5.);\r\n    float r = clamp(fbm(p, dtp*0.1)*1.5-dtp*(.35-sin(time*0.3)*0.15), 0. ,1.);\r\n    vec4 col = vec4(.5,1.7,.5,.96)*r;\r\n    \r\n    float grd = clamp((dtp+.7)*0.4,0.,1.);\r\n    col.b += grd*.6;\r\n    col.r -= grd*.5;    \r\n    vec3 lv = mix(p,vec3(0.3),2.);\r\n    grd = clamp((col.w - fbm(p+lv*.05,1.))*2., 0.01, 1.5 );\r\n    col.rgb *= vec3(.5, 0.4, .6)*grd + vec3(4.,0.,.4);\r\n    col.a *= clamp(dtp*2.-1.,0.,1.)*0.07+0.87;\r\n    \r\n    return col;\r\n}\r\n\r\nvec4 vmarch(in vec3 ro, in vec3 rd)\r\n{\r\n\tvec4 rz = vec4(0);\r\n\tfloat t = 2.5;\r\n    t += 0.03*hash21(gl_FragCoord.xy);\r\n\tfor(int i=0; i<STEPS; i++)\r\n\t{\r\n\t\tif(rz.a > 0.99 || t > 6.)break;\r\n\t\tvec3 pos = ro + t*rd;\r\n        vec4 col = map(pos);\r\n        float den = col.a;\r\n        col.a *= ALPHA_WEIGHT;\r\n\t\tcol.rgb *= col.a*1.7;\r\n\t\trz += col*(1. - rz.a);\r\n        t += BASE_STEP - den*(BASE_STEP-BASE_STEP*0.015);\r\n\t}\r\n    return rz;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\tvec2 p = fragCoord.xy/iResolution.xy*2. - 1.;\r\n\tp.x *= iResolution.x/iResolution.y*.85;\r\n    p *= 1.1;\r\n\tmo = 2.0*iMouse.xy/iResolution.xy;\r\n    mo = (mo==vec2(.0))?mo=vec2(0.5,1.):mo;\r\n\t\r\n\tvec3 ro = 4.*normalize(vec3(cos(2.75-2.0*(mo.x+time*0.05)), sin(time*0.22)*0.2, sin(2.75-2.0*(mo.x+time*0.05))));\r\n\tvec3 eye = normalize(vec3(0) - ro);\r\n\tvec3 rgt = normalize(cross(vec3(0,1,0), eye));\r\n\tvec3 up = cross(eye,rgt);\r\n\tvec3 rd = normalize(p.x*rgt + p.y*up + (3.3-sin(time*0.3)*.7)*eye);\r\n\t\r\n\tvec4 col = clamp(vmarch(ro, rd),0.,1.);\r\n    col.rgb = pow(col.rgb, vec3(.9));\r\n    /*col.rb = rot(col.rg, 0.35);\r\n    col.gb = rot(col.gb, -0.1);*/\r\n    \r\n    fragColor = vec4(col.rgb, 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":null,"published":0}],"Info":{"Name":"Magnetismic ","id":null,"date":null,"viewed":0,"name":"Magnetismic ","description":"Volumetric rendering of a deformed field.\r\n\r\nWipe Up/Down = frequency","likes":0,"published":null,"tags":["3d"," noise"," volumetric"," animated"]},"ver":null,"info":{"Name":"Magnetismic ","id":null,"date":null,"viewed":0,"name":"Magnetismic ","description":"Volumetric rendering of a deformed field.\r\n\r\nWipe Up/Down = frequency","likes":0,"published":null,"tags":["3d"," noise"," volumetric"," animated"]},"renderpass":[{"Code":"//Magnetismic by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/XlB3zV\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n//Getting 60fps here at high quality\r\n#define HIGH_QUALITY\r\n\r\n#ifdef HIGH_QUALITY\r\n#define STEPS 130\r\n#define ALPHA_WEIGHT 0.015\r\n#define BASE_STEP 0.025\r\n#else\r\n#define STEPS 50\r\n#define ALPHA_WEIGHT 0.05\r\n#define BASE_STEP 0.1\r\n#endif\r\n\r\n#define time iTime\r\nvec2 mo;\r\nvec2 rot(in vec2 p, in float a){float c = cos(a), s = sin(a);return p*mat2(c,s,-s,c);}\r\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\r\nfloat noise(in vec3 p)\r\n{\r\n\tvec3 ip = floor(p), fp = fract(p);\r\n    fp = fp*fp*(3.0-2.0*fp);\r\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\r\n\tvec2 cl = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix(cl.x, cl.y, fp.z);\r\n}\r\n\r\nfloat fbm(in vec3 p, in float sr)\r\n{\r\n    p *= 3.5;\r\n    float rz = 0., z = 1.;\r\n    for(int i=0;i<4;i++)\r\n    {\r\n        float n = noise(p-time*.6);\r\n        rz += (sin(n*4.4)-.45)*z;\r\n        z *= .47;\r\n        p *= 3.5;\r\n    }\r\n    return rz;\r\n}\r\n\r\nvec4 map(in vec3 p)\r\n{\r\n    float dtp = dot(p,p);\r\n\tp = .5*p/(dtp + .2);\r\n    p.xz = rot(p.xz, p.y*2.5);\r\n    p.xy = rot(p.xz, p.y*2.);\r\n    \r\n    float dtp2 = dot(p, p);\r\n    p = (mo.y + .6)*3.*p/(dtp2 - 5.);\r\n    float r = clamp(fbm(p, dtp*0.1)*1.5-dtp*(.35-sin(time*0.3)*0.15), 0. ,1.);\r\n    vec4 col = vec4(.5,1.7,.5,.96)*r;\r\n    \r\n    float grd = clamp((dtp+.7)*0.4,0.,1.);\r\n    col.b += grd*.6;\r\n    col.r -= grd*.5;    \r\n    vec3 lv = mix(p,vec3(0.3),2.);\r\n    grd = clamp((col.w - fbm(p+lv*.05,1.))*2., 0.01, 1.5 );\r\n    col.rgb *= vec3(.5, 0.4, .6)*grd + vec3(4.,0.,.4);\r\n    col.a *= clamp(dtp*2.-1.,0.,1.)*0.07+0.87;\r\n    \r\n    return col;\r\n}\r\n\r\nvec4 vmarch(in vec3 ro, in vec3 rd)\r\n{\r\n\tvec4 rz = vec4(0);\r\n\tfloat t = 2.5;\r\n    t += 0.03*hash21(gl_FragCoord.xy);\r\n\tfor(int i=0; i<STEPS; i++)\r\n\t{\r\n\t\tif(rz.a > 0.99 || t > 6.)break;\r\n\t\tvec3 pos = ro + t*rd;\r\n        vec4 col = map(pos);\r\n        float den = col.a;\r\n        col.a *= ALPHA_WEIGHT;\r\n\t\tcol.rgb *= col.a*1.7;\r\n\t\trz += col*(1. - rz.a);\r\n        t += BASE_STEP - den*(BASE_STEP-BASE_STEP*0.015);\r\n\t}\r\n    return rz;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\tvec2 p = fragCoord.xy/iResolution.xy*2. - 1.;\r\n\tp.x *= iResolution.x/iResolution.y*.85;\r\n    p *= 1.1;\r\n\tmo = 2.0*iMouse.xy/iResolution.xy;\r\n    mo = (mo==vec2(.0))?mo=vec2(0.5,1.):mo;\r\n\t\r\n\tvec3 ro = 4.*normalize(vec3(cos(2.75-2.0*(mo.x+time*0.05)), sin(time*0.22)*0.2, sin(2.75-2.0*(mo.x+time*0.05))));\r\n\tvec3 eye = normalize(vec3(0) - ro);\r\n\tvec3 rgt = normalize(cross(vec3(0,1,0), eye));\r\n\tvec3 up = cross(eye,rgt);\r\n\tvec3 rd = normalize(p.x*rgt + p.y*up + (3.3-sin(time*0.3)*.7)*eye);\r\n\t\r\n\tvec4 col = clamp(vmarch(ro, rd),0.,1.);\r\n    col.rgb = pow(col.rgb, vec3(.9));\r\n    /*col.rb = rot(col.rg, 0.35);\r\n    col.gb = rot(col.gb, -0.1);*/\r\n    \r\n    fragColor = vec4(col.rgb, 1.0);\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"//Magnetismic by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/XlB3zV\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n//Getting 60fps here at high quality\r\n#define HIGH_QUALITY\r\n\r\n#ifdef HIGH_QUALITY\r\n#define STEPS 130\r\n#define ALPHA_WEIGHT 0.015\r\n#define BASE_STEP 0.025\r\n#else\r\n#define STEPS 50\r\n#define ALPHA_WEIGHT 0.05\r\n#define BASE_STEP 0.1\r\n#endif\r\n\r\n#define time iTime\r\nvec2 mo;\r\nvec2 rot(in vec2 p, in float a){float c = cos(a), s = sin(a);return p*mat2(c,s,-s,c);}\r\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\r\nfloat noise(in vec3 p)\r\n{\r\n\tvec3 ip = floor(p), fp = fract(p);\r\n    fp = fp*fp*(3.0-2.0*fp);\r\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\r\n\tvec2 cl = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix(cl.x, cl.y, fp.z);\r\n}\r\n\r\nfloat fbm(in vec3 p, in float sr)\r\n{\r\n    p *= 3.5;\r\n    float rz = 0., z = 1.;\r\n    for(int i=0;i<4;i++)\r\n    {\r\n        float n = noise(p-time*.6);\r\n        rz += (sin(n*4.4)-.45)*z;\r\n        z *= .47;\r\n        p *= 3.5;\r\n    }\r\n    return rz;\r\n}\r\n\r\nvec4 map(in vec3 p)\r\n{\r\n    float dtp = dot(p,p);\r\n\tp = .5*p/(dtp + .2);\r\n    p.xz = rot(p.xz, p.y*2.5);\r\n    p.xy = rot(p.xz, p.y*2.);\r\n    \r\n    float dtp2 = dot(p, p);\r\n    p = (mo.y + .6)*3.*p/(dtp2 - 5.);\r\n    float r = clamp(fbm(p, dtp*0.1)*1.5-dtp*(.35-sin(time*0.3)*0.15), 0. ,1.);\r\n    vec4 col = vec4(.5,1.7,.5,.96)*r;\r\n    \r\n    float grd = clamp((dtp+.7)*0.4,0.,1.);\r\n    col.b += grd*.6;\r\n    col.r -= grd*.5;    \r\n    vec3 lv = mix(p,vec3(0.3),2.);\r\n    grd = clamp((col.w - fbm(p+lv*.05,1.))*2., 0.01, 1.5 );\r\n    col.rgb *= vec3(.5, 0.4, .6)*grd + vec3(4.,0.,.4);\r\n    col.a *= clamp(dtp*2.-1.,0.,1.)*0.07+0.87;\r\n    \r\n    return col;\r\n}\r\n\r\nvec4 vmarch(in vec3 ro, in vec3 rd)\r\n{\r\n\tvec4 rz = vec4(0);\r\n\tfloat t = 2.5;\r\n    t += 0.03*hash21(gl_FragCoord.xy);\r\n\tfor(int i=0; i<STEPS; i++)\r\n\t{\r\n\t\tif(rz.a > 0.99 || t > 6.)break;\r\n\t\tvec3 pos = ro + t*rd;\r\n        vec4 col = map(pos);\r\n        float den = col.a;\r\n        col.a *= ALPHA_WEIGHT;\r\n\t\tcol.rgb *= col.a*1.7;\r\n\t\trz += col*(1. - rz.a);\r\n        t += BASE_STEP - den*(BASE_STEP-BASE_STEP*0.015);\r\n\t}\r\n    return rz;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\tvec2 p = fragCoord.xy/iResolution.xy*2. - 1.;\r\n\tp.x *= iResolution.x/iResolution.y*.85;\r\n    p *= 1.1;\r\n\tmo = 2.0*iMouse.xy/iResolution.xy;\r\n    mo = (mo==vec2(.0))?mo=vec2(0.5,1.):mo;\r\n\t\r\n\tvec3 ro = 4.*normalize(vec3(cos(2.75-2.0*(mo.x+time*0.05)), sin(time*0.22)*0.2, sin(2.75-2.0*(mo.x+time*0.05))));\r\n\tvec3 eye = normalize(vec3(0) - ro);\r\n\tvec3 rgt = normalize(cross(vec3(0,1,0), eye));\r\n\tvec3 up = cross(eye,rgt);\r\n\tvec3 rd = normalize(p.x*rgt + p.y*up + (3.3-sin(time*0.3)*.7)*eye);\r\n\t\r\n\tvec4 col = clamp(vmarch(ro, rd),0.,1.);\r\n    col.rgb = pow(col.rgb, vec3(.9));\r\n    /*col.rb = rot(col.rg, 0.35);\r\n    col.gb = rot(col.gb, -0.1);*/\r\n    \r\n    fragColor = vec4(col.rgb, 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Mountains. By David Hoskins - 2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// https://www.shadertoy.com/view/4slGD4\r\n// A ray-marched version of my terrain renderer which uses\r\n// streaming texture normals for speed:-\r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// It uses binary subdivision to accurately find the height map.\r\n// Lots of thanks to Inigo and his noise functions!\r\n\r\n// Video of my OpenGL version that \r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// Stereo version code thanks to Croqueteer :)\r\n//#define STEREO \r\n\r\nfloat treeLine = 0.0;\r\nfloat treeCol = 0.0;\r\n\r\n\r\nvec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.48 ) );\r\nvec3 sunColour = vec3(1.0, .9, .83);\r\nfloat specular = 0.0;\r\nvec3 cameraPos;\r\nfloat ambient;\r\nvec2 add = vec2(1.0, 0.0);\r\n#define HASHSCALE1 .1031\r\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\r\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\r\n\r\n// This peturbs the fractal positions for each iteration down...\r\n// Helps make nice twisted landscapes...\r\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\r\n\r\n// Alternative rotation:-\r\n// const mat2 rotate2D = mat2(1.2323, 1.999231, -1.999231, 1.22);\r\n\r\n\r\n//  1 out, 2 in...\r\nfloat Hash12(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n\r\n}\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    \r\n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\r\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Noise2( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y * 57.0;\r\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\r\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Trees(vec2 p)\r\n{\r\n\t\r\n \t//return (texture(iChannel1,0.04*p).x * treeLine);\r\n    return Noise(p*13.0)*treeLine;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Low def version for ray-marching through the height field...\r\n// Thanks to IQ for all the noise stuff...\r\n\r\nfloat Terrain( in vec2 p)\r\n{\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw = -w * 0.4;\t//...Flip negative and positive for variation\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\t\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Map to lower resolution for height field mapping for Scene function...\r\nfloat Map(in vec3 p)\r\n{\r\n\tfloat h = Terrain(p.xz);\r\n\t\t\r\n\r\n\tfloat ff = Noise(p.xz*.3) + Noise(p.xz*3.3)*.5;\r\n\ttreeLine = smoothstep(ff, .0+ff*2.0, h) * smoothstep(1.0+ff*3.0, .4+ff, h) ;\r\n\ttreeCol = Trees(p.xz);\r\n\th += treeCol;\r\n\t\r\n    return p.y - h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// High def version only used for grabbing normal information.\r\nfloat Terrain2( in vec2 p)\r\n{\r\n\t// There's some real magic numbers in here! \r\n\t// The Noise calls add large mountain ranges for more variation over distances...\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\t//...Flip negative and positive for varition\t   \r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\t\r\n\r\n\ttreeCol = Trees(p);\r\n\tf += treeCol;\r\n\tif (treeCol > 0.0) return f;\r\n\r\n\t\r\n\t// That's the last of the low resolution, now go down further for the Normal data...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\t\r\n\t\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw *= 0.5;\r\n\t\txy *= 2.7;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Simply Perlin clouds that fade to the horizon...\r\n// 200 units above the ground...\r\nvec3 GetClouds(in vec3 sky, in vec3 rd)\r\n{\r\n\tif (rd.y < 0.01) return sky;\r\n\tfloat v = (200.0-cameraPos.y)/rd.y;\r\n\trd.xz *= v;\r\n\trd.xz += cameraPos.xz;\r\n\trd.xz *= .010;\r\n\tfloat f = (FractalNoise(rd.xz) -.55) * 5.0;\r\n\t// Uses the ray's y component for horizon fade of fixed colour clouds...\r\n\tsky = mix(sky, vec3(.55, .55, .52), clamp(f*rd.y-.1, 0.0, 1.0));\r\n\r\n\treturn sky;\r\n}\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),5.)*.5;\r\n\tvec3  sky = vec3(v*sunColour.x*0.4+0.18, v*sunColour.y*0.4+0.22, v*sunColour.z*0.4+.4);\r\n\t// Wide glare effect...\r\n\tsky = sky + sunColour * pow(sunAmount, 6.5)*.32;\r\n\t// Actual sun...\r\n\tsky = sky+ sunColour * min(pow(sunAmount, 1150.0), .3)*.65;\r\n\treturn sky;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge mountains into the sky background for correct disappearance...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = exp(-dis* 0.00005);\r\n\treturn mix(GetSky(dir), rgb, fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(sunLight,normal);\r\n\tfloat c = max(h, 0.0)+ambient;\r\n\tmat = mat * sunColour * c ;\r\n\t// Specular...\r\n\tif (h > 0.0)\r\n\t{\r\n\t\tvec3 R = reflect(sunLight, normal);\r\n\t\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\r\n\t\tmat = mix(mat, sunColour, specAmount);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Hack the height, position, and normal data to create the coloured landscape\r\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\r\n{\r\n\tvec3 mat;\r\n\tspecular = .0;\r\n\tambient = .1;\r\n\tvec3 dir = normalize(pos-cameraPos);\r\n\t\r\n\tvec3 matPos = pos * 2.0;// ... I had change scale halfway though, this lazy multiply allow me to keep the graphic scales I had\r\n\r\n\tfloat disSqrd = dis * dis;// Squaring it gives better distance scales.\r\n\r\n\tfloat f = clamp(Noise(matPos.xz*.05), 0.0,1.0);//*10.8;\r\n\tf += Noise(matPos.xz*.1+normal.yz*1.08)*.85;\r\n\tf *= .55;\r\n\tvec3 m = mix(vec3(.63*f+.2, .7*f+.1, .7*f+.1), vec3(f*.43+.1, f*.3+.2, f*.35+.1), f*.65);\r\n\tmat = m*vec3(f*m.x+.36, f*m.y+.30, f*m.z+.28);\r\n\t// Should have used smoothstep to add colours, but left it using 'if' for sanity...\r\n\tif (normal.y < .5)\r\n\t{\r\n\t\tfloat v = normal.y;\r\n\t\tfloat c = (.5-normal.y) * 4.0;\r\n\t\tc = clamp(c*c, 0.1, 1.0);\r\n\t\tf = Noise(vec2(matPos.x*.09, matPos.z*.095+matPos.yy*0.15));\r\n\t\tf += Noise(vec2(matPos.x*2.233, matPos.z*2.23))*0.5;\r\n\t\tmat = mix(mat, vec3(.4*f), c);\r\n\t\tspecular+=.1;\r\n\t}\r\n\r\n\t// Grass. Use the normal to decide when to plonk grass down...\r\n\tif (matPos.y < 45.35 && normal.y > .65)\r\n\t{\r\n\r\n\t\tm = vec3(Noise(matPos.xz*.023)*.5+.15, Noise(matPos.xz*.03)*.6+.25, 0.0);\r\n\t\tm *= (normal.y- 0.65)*.6;\r\n\t\tmat = mix(mat, m, clamp((normal.y-.65)*1.3 * (45.35-matPos.y)*0.1, 0.0, 1.0));\r\n\t}\r\n\r\n\tif (treeCol > 0.0)\r\n\t{\r\n\t\tmat = vec3(.02+Noise(matPos.xz*5.0)*.03, .05, .0);\r\n\t\tnormal = normalize(normal+vec3(Noise(matPos.xz*33.0)*1.0-.5, .0, Noise(matPos.xz*33.0)*1.0-.5));\r\n\t\tspecular = .0;\r\n\t}\r\n\t\r\n\t// Snow topped mountains...\r\n\tif (matPos.y > 80.0 && normal.y > .42)\r\n\t{\r\n\t\tfloat snow = clamp((matPos.y - 80.0 - Noise(matPos.xz * .1)*28.0) * 0.035, 0.0, 1.0);\r\n\t\tmat = mix(mat, vec3(.7,.7,.8), snow);\r\n\t\tspecular += snow;\r\n\t\tambient+=snow *.3;\r\n\t}\r\n\t// Beach effect...\r\n\tif (matPos.y < 1.45)\r\n\t{\r\n\t\tif (normal.y > .4)\r\n\t\t{\r\n\t\t\tf = Noise(matPos.xz * .084)*1.5;\r\n\t\t\tf = clamp((1.45-f-matPos.y) * 1.34, 0.0, .67);\r\n\t\t\tfloat t = (normal.y-.4);\r\n\t\t\tt = (t*t);\r\n\t\t\tmat = mix(mat, vec3(.09+t, .07+t, .03+t), f);\r\n\t\t}\r\n\t\t// Cheap under water darkening...it's wet after all...\r\n\t\tif (matPos.y < 0.0)\r\n\t\t{\r\n\t\t\tmat *= .2;\r\n\t\t}\r\n\t}\r\n\r\n\tDoLighting(mat, pos, normal,dir, disSqrd);\r\n\t\r\n\t// Do the water...\r\n\tif (matPos.y < 0.0)\r\n\t{\r\n\t\t// Pull back along the ray direction to get water surface point at y = 0.0 ...\r\n\t\tfloat time = (iTime)*.03;\r\n\t\tvec3 watPos = matPos;\r\n\t\twatPos += -dir * (watPos.y/dir.y);\r\n\t\t// Make some dodgy waves...\r\n\t\tfloat tx = cos(watPos.x*.052) *4.5;\r\n\t\tfloat tz = sin(watPos.z*.072) *4.5;\r\n\t\tvec2 co = Noise2(vec2(watPos.x*4.7+1.3+tz, watPos.z*4.69+time*35.0-tx));\r\n\t\tco += Noise2(vec2(watPos.z*8.6+time*13.0-tx, watPos.x*8.712+tz))*.4;\r\n\t\tvec3 nor = normalize(vec3(co.x, 20.0, co.y));\r\n\t\tnor = normalize(reflect(dir, nor));//normalize((-2.0*(dot(dir, nor))*nor)+dir);\r\n\t\t// Mix it in at depth transparancy to give beach cues..\r\n        tx = watPos.y-matPos.y;\r\n\t\tmat = mix(mat, GetClouds(GetSky(nor)*vec3(.3,.3,.5), nor)*.1+vec3(.0,.02,.03), clamp((tx)*.4, .6, 1.));\r\n\t\t// Add some extra water glint...\r\n        mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*texture(iChannel1, watPos.xz*.1, -2.).x, 0.,1.0);\r\n\t\tfloat sunAmount = max( dot(nor, sunLight), 0.0 );\r\n\t\tmat = mat + sunColour * pow(sunAmount, 228.5)*.6;\r\n        vec3 temp = (watPos-cameraPos*2.)*.5;\r\n        disSqrd = dot(temp, temp);\r\n\t}\r\n\tmat = ApplyFog(mat, disSqrd, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\r\n{\r\n\t// Home in on the surface by dividing by two and split...\r\n    float halfwayT;\r\n  \r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n\r\n        halfwayT = dot(t, vec2(.5));\r\n        float d = Map(rO + halfwayT*rD); \r\n         t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.5, d));\r\n\r\n    }\r\n\treturn halfwayT;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT, in vec2 fragCoord )\r\n{\r\n    float t = 1. + Hash12(fragCoord.xy)*5.;\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.0;\r\n\tbool fin = false;\r\n\tbool res = false;\r\n\tvec2 distances;\r\n\tfor( int j=0; j< 150; j++ )\r\n\t{\r\n\t\tif (fin || t > 240.0) break;\r\n\t\tvec3 p = rO + t*rD;\r\n\t\t//if (t > 240.0 || p.y > 195.0) break;\r\n\t\tfloat h = Map(p); // ...Get this positions height mapping.\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h < 0.5)\r\n\t\t{\r\n\t\t\tfin = true;\r\n\t\t\tdistances = vec2(oldT, t);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t// Delta ray advance - a fudge between the height returned\r\n\t\t// and the distance already travelled.\r\n\t\t// It's a really fiddly compromise between speed and accuracy\r\n\t\t// Too large a step and the tops of ridges get missed.\r\n\t\tdelta = max(0.01, 0.3*h) + (t*0.0065);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n\tif (fin) resT = BinarySubdivision(rO, rD, distances);\r\n\r\n\treturn fin;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\tfloat m = 1.0+(iMouse.x/iResolution.x)*300.0;\r\n\tt = (iTime*1.5+m+657.0)*.006 + t;\r\n    vec2 p = 476.0*vec2( sin(3.5*t), cos(1.5*t) );\r\n\treturn vec3(35.0-p.x, 0.6, 4108.0+p.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Some would say, most of the magic is done in post! :D\r\nvec3 PostEffects(vec3 rgb, vec2 uv)\r\n{\r\n\t//#define CONTRAST 1.1\r\n\t//#define SATURATION 1.12\r\n\t//#define BRIGHTNESS 1.3\r\n\t//rgb = pow(abs(rgb), vec3(0.45));\r\n\t//rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\trgb = (1.0 - exp(-rgb * 6.0)) * 1.0024;\r\n\t//rgb = clamp(rgb+hash12(fragCoord.xy*rgb.r)*0.1, 0.0, 1.0);\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = xy * vec2(iResolution.x/iResolution.y,1.0);\r\n\tvec3 camTar;\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\t// Use several forward heights, of decreasing influence with distance from the camera.\r\n\tfloat h = 0.0;\r\n\tfloat f = 1.0;\r\n\tfor (int i = 0; i < 7; i++)\r\n\t{\r\n\t\th += Terrain(CameraPath((.6-f)*.008).xz) * f;\r\n\t\tf -= .1;\r\n\t}\r\n\tcameraPos.xz = CameraPath(0.0).xz;\r\n\tcamTar.xyz\t = CameraPath(.005).xyz;\r\n\tcamTar.y = cameraPos.y = max((h*.25)+3.5, 1.5+sin(iTime*5.)*.5);\r\n\t\r\n\tfloat roll = 0.15*sin(iTime*.2);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\r\n\r\n\t#ifdef STEREO\r\n\tcameraPos += .45*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tif( !Scene(cameraPos,rd, distance, fragCoord) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky value...\r\n\t\tcol = GetSky(rd);\r\n\t\tcol = GetClouds(col, rd);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * rd;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tfloat p = min(.3, .0005+.00005 * distance*distance);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain2(pos.xz), 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain2(pos.xz+vec2(p,0.0)), 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain2(pos.xz+vec2(0.0,-p)), -p);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, nor, distance);\r\n\t}\r\n\r\n\tcol = PostEffects(col, uv);\r\n\t\r\n\t#ifdef STEREO\t\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n\t#endif\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\none.png","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"// Mountains. By David Hoskins - 2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// https://www.shadertoy.com/view/4slGD4\r\n// A ray-marched version of my terrain renderer which uses\r\n// streaming texture normals for speed:-\r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// It uses binary subdivision to accurately find the height map.\r\n// Lots of thanks to Inigo and his noise functions!\r\n\r\n// Video of my OpenGL version that \r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// Stereo version code thanks to Croqueteer :)\r\n//#define STEREO \r\n\r\nfloat treeLine = 0.0;\r\nfloat treeCol = 0.0;\r\n\r\n\r\nvec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.48 ) );\r\nvec3 sunColour = vec3(1.0, .9, .83);\r\nfloat specular = 0.0;\r\nvec3 cameraPos;\r\nfloat ambient;\r\nvec2 add = vec2(1.0, 0.0);\r\n#define HASHSCALE1 .1031\r\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\r\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\r\n\r\n// This peturbs the fractal positions for each iteration down...\r\n// Helps make nice twisted landscapes...\r\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\r\n\r\n// Alternative rotation:-\r\n// const mat2 rotate2D = mat2(1.2323, 1.999231, -1.999231, 1.22);\r\n\r\n\r\n//  1 out, 2 in...\r\nfloat Hash12(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n\r\n}\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    \r\n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\r\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Noise2( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y * 57.0;\r\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\r\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Trees(vec2 p)\r\n{\r\n\t\r\n \t//return (texture(iChannel1,0.04*p).x * treeLine);\r\n    return Noise(p*13.0)*treeLine;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Low def version for ray-marching through the height field...\r\n// Thanks to IQ for all the noise stuff...\r\n\r\nfloat Terrain( in vec2 p)\r\n{\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw = -w * 0.4;\t//...Flip negative and positive for variation\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\t\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Map to lower resolution for height field mapping for Scene function...\r\nfloat Map(in vec3 p)\r\n{\r\n\tfloat h = Terrain(p.xz);\r\n\t\t\r\n\r\n\tfloat ff = Noise(p.xz*.3) + Noise(p.xz*3.3)*.5;\r\n\ttreeLine = smoothstep(ff, .0+ff*2.0, h) * smoothstep(1.0+ff*3.0, .4+ff, h) ;\r\n\ttreeCol = Trees(p.xz);\r\n\th += treeCol;\r\n\t\r\n    return p.y - h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// High def version only used for grabbing normal information.\r\nfloat Terrain2( in vec2 p)\r\n{\r\n\t// There's some real magic numbers in here! \r\n\t// The Noise calls add large mountain ranges for more variation over distances...\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\t//...Flip negative and positive for varition\t   \r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\t\r\n\r\n\ttreeCol = Trees(p);\r\n\tf += treeCol;\r\n\tif (treeCol > 0.0) return f;\r\n\r\n\t\r\n\t// That's the last of the low resolution, now go down further for the Normal data...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\t\r\n\t\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw *= 0.5;\r\n\t\txy *= 2.7;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Simply Perlin clouds that fade to the horizon...\r\n// 200 units above the ground...\r\nvec3 GetClouds(in vec3 sky, in vec3 rd)\r\n{\r\n\tif (rd.y < 0.01) return sky;\r\n\tfloat v = (200.0-cameraPos.y)/rd.y;\r\n\trd.xz *= v;\r\n\trd.xz += cameraPos.xz;\r\n\trd.xz *= .010;\r\n\tfloat f = (FractalNoise(rd.xz) -.55) * 5.0;\r\n\t// Uses the ray's y component for horizon fade of fixed colour clouds...\r\n\tsky = mix(sky, vec3(.55, .55, .52), clamp(f*rd.y-.1, 0.0, 1.0));\r\n\r\n\treturn sky;\r\n}\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),5.)*.5;\r\n\tvec3  sky = vec3(v*sunColour.x*0.4+0.18, v*sunColour.y*0.4+0.22, v*sunColour.z*0.4+.4);\r\n\t// Wide glare effect...\r\n\tsky = sky + sunColour * pow(sunAmount, 6.5)*.32;\r\n\t// Actual sun...\r\n\tsky = sky+ sunColour * min(pow(sunAmount, 1150.0), .3)*.65;\r\n\treturn sky;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge mountains into the sky background for correct disappearance...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = exp(-dis* 0.00005);\r\n\treturn mix(GetSky(dir), rgb, fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(sunLight,normal);\r\n\tfloat c = max(h, 0.0)+ambient;\r\n\tmat = mat * sunColour * c ;\r\n\t// Specular...\r\n\tif (h > 0.0)\r\n\t{\r\n\t\tvec3 R = reflect(sunLight, normal);\r\n\t\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\r\n\t\tmat = mix(mat, sunColour, specAmount);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Hack the height, position, and normal data to create the coloured landscape\r\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\r\n{\r\n\tvec3 mat;\r\n\tspecular = .0;\r\n\tambient = .1;\r\n\tvec3 dir = normalize(pos-cameraPos);\r\n\t\r\n\tvec3 matPos = pos * 2.0;// ... I had change scale halfway though, this lazy multiply allow me to keep the graphic scales I had\r\n\r\n\tfloat disSqrd = dis * dis;// Squaring it gives better distance scales.\r\n\r\n\tfloat f = clamp(Noise(matPos.xz*.05), 0.0,1.0);//*10.8;\r\n\tf += Noise(matPos.xz*.1+normal.yz*1.08)*.85;\r\n\tf *= .55;\r\n\tvec3 m = mix(vec3(.63*f+.2, .7*f+.1, .7*f+.1), vec3(f*.43+.1, f*.3+.2, f*.35+.1), f*.65);\r\n\tmat = m*vec3(f*m.x+.36, f*m.y+.30, f*m.z+.28);\r\n\t// Should have used smoothstep to add colours, but left it using 'if' for sanity...\r\n\tif (normal.y < .5)\r\n\t{\r\n\t\tfloat v = normal.y;\r\n\t\tfloat c = (.5-normal.y) * 4.0;\r\n\t\tc = clamp(c*c, 0.1, 1.0);\r\n\t\tf = Noise(vec2(matPos.x*.09, matPos.z*.095+matPos.yy*0.15));\r\n\t\tf += Noise(vec2(matPos.x*2.233, matPos.z*2.23))*0.5;\r\n\t\tmat = mix(mat, vec3(.4*f), c);\r\n\t\tspecular+=.1;\r\n\t}\r\n\r\n\t// Grass. Use the normal to decide when to plonk grass down...\r\n\tif (matPos.y < 45.35 && normal.y > .65)\r\n\t{\r\n\r\n\t\tm = vec3(Noise(matPos.xz*.023)*.5+.15, Noise(matPos.xz*.03)*.6+.25, 0.0);\r\n\t\tm *= (normal.y- 0.65)*.6;\r\n\t\tmat = mix(mat, m, clamp((normal.y-.65)*1.3 * (45.35-matPos.y)*0.1, 0.0, 1.0));\r\n\t}\r\n\r\n\tif (treeCol > 0.0)\r\n\t{\r\n\t\tmat = vec3(.02+Noise(matPos.xz*5.0)*.03, .05, .0);\r\n\t\tnormal = normalize(normal+vec3(Noise(matPos.xz*33.0)*1.0-.5, .0, Noise(matPos.xz*33.0)*1.0-.5));\r\n\t\tspecular = .0;\r\n\t}\r\n\t\r\n\t// Snow topped mountains...\r\n\tif (matPos.y > 80.0 && normal.y > .42)\r\n\t{\r\n\t\tfloat snow = clamp((matPos.y - 80.0 - Noise(matPos.xz * .1)*28.0) * 0.035, 0.0, 1.0);\r\n\t\tmat = mix(mat, vec3(.7,.7,.8), snow);\r\n\t\tspecular += snow;\r\n\t\tambient+=snow *.3;\r\n\t}\r\n\t// Beach effect...\r\n\tif (matPos.y < 1.45)\r\n\t{\r\n\t\tif (normal.y > .4)\r\n\t\t{\r\n\t\t\tf = Noise(matPos.xz * .084)*1.5;\r\n\t\t\tf = clamp((1.45-f-matPos.y) * 1.34, 0.0, .67);\r\n\t\t\tfloat t = (normal.y-.4);\r\n\t\t\tt = (t*t);\r\n\t\t\tmat = mix(mat, vec3(.09+t, .07+t, .03+t), f);\r\n\t\t}\r\n\t\t// Cheap under water darkening...it's wet after all...\r\n\t\tif (matPos.y < 0.0)\r\n\t\t{\r\n\t\t\tmat *= .2;\r\n\t\t}\r\n\t}\r\n\r\n\tDoLighting(mat, pos, normal,dir, disSqrd);\r\n\t\r\n\t// Do the water...\r\n\tif (matPos.y < 0.0)\r\n\t{\r\n\t\t// Pull back along the ray direction to get water surface point at y = 0.0 ...\r\n\t\tfloat time = (iTime)*.03;\r\n\t\tvec3 watPos = matPos;\r\n\t\twatPos += -dir * (watPos.y/dir.y);\r\n\t\t// Make some dodgy waves...\r\n\t\tfloat tx = cos(watPos.x*.052) *4.5;\r\n\t\tfloat tz = sin(watPos.z*.072) *4.5;\r\n\t\tvec2 co = Noise2(vec2(watPos.x*4.7+1.3+tz, watPos.z*4.69+time*35.0-tx));\r\n\t\tco += Noise2(vec2(watPos.z*8.6+time*13.0-tx, watPos.x*8.712+tz))*.4;\r\n\t\tvec3 nor = normalize(vec3(co.x, 20.0, co.y));\r\n\t\tnor = normalize(reflect(dir, nor));//normalize((-2.0*(dot(dir, nor))*nor)+dir);\r\n\t\t// Mix it in at depth transparancy to give beach cues..\r\n        tx = watPos.y-matPos.y;\r\n\t\tmat = mix(mat, GetClouds(GetSky(nor)*vec3(.3,.3,.5), nor)*.1+vec3(.0,.02,.03), clamp((tx)*.4, .6, 1.));\r\n\t\t// Add some extra water glint...\r\n        mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*texture(iChannel1, watPos.xz*.1, -2.).x, 0.,1.0);\r\n\t\tfloat sunAmount = max( dot(nor, sunLight), 0.0 );\r\n\t\tmat = mat + sunColour * pow(sunAmount, 228.5)*.6;\r\n        vec3 temp = (watPos-cameraPos*2.)*.5;\r\n        disSqrd = dot(temp, temp);\r\n\t}\r\n\tmat = ApplyFog(mat, disSqrd, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\r\n{\r\n\t// Home in on the surface by dividing by two and split...\r\n    float halfwayT;\r\n  \r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n\r\n        halfwayT = dot(t, vec2(.5));\r\n        float d = Map(rO + halfwayT*rD); \r\n         t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.5, d));\r\n\r\n    }\r\n\treturn halfwayT;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT, in vec2 fragCoord )\r\n{\r\n    float t = 1. + Hash12(fragCoord.xy)*5.;\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.0;\r\n\tbool fin = false;\r\n\tbool res = false;\r\n\tvec2 distances;\r\n\tfor( int j=0; j< 150; j++ )\r\n\t{\r\n\t\tif (fin || t > 240.0) break;\r\n\t\tvec3 p = rO + t*rD;\r\n\t\t//if (t > 240.0 || p.y > 195.0) break;\r\n\t\tfloat h = Map(p); // ...Get this positions height mapping.\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h < 0.5)\r\n\t\t{\r\n\t\t\tfin = true;\r\n\t\t\tdistances = vec2(oldT, t);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t// Delta ray advance - a fudge between the height returned\r\n\t\t// and the distance already travelled.\r\n\t\t// It's a really fiddly compromise between speed and accuracy\r\n\t\t// Too large a step and the tops of ridges get missed.\r\n\t\tdelta = max(0.01, 0.3*h) + (t*0.0065);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n\tif (fin) resT = BinarySubdivision(rO, rD, distances);\r\n\r\n\treturn fin;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\tfloat m = 1.0+(iMouse.x/iResolution.x)*300.0;\r\n\tt = (iTime*1.5+m+657.0)*.006 + t;\r\n    vec2 p = 476.0*vec2( sin(3.5*t), cos(1.5*t) );\r\n\treturn vec3(35.0-p.x, 0.6, 4108.0+p.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Some would say, most of the magic is done in post! :D\r\nvec3 PostEffects(vec3 rgb, vec2 uv)\r\n{\r\n\t//#define CONTRAST 1.1\r\n\t//#define SATURATION 1.12\r\n\t//#define BRIGHTNESS 1.3\r\n\t//rgb = pow(abs(rgb), vec3(0.45));\r\n\t//rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\trgb = (1.0 - exp(-rgb * 6.0)) * 1.0024;\r\n\t//rgb = clamp(rgb+hash12(fragCoord.xy*rgb.r)*0.1, 0.0, 1.0);\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = xy * vec2(iResolution.x/iResolution.y,1.0);\r\n\tvec3 camTar;\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\t// Use several forward heights, of decreasing influence with distance from the camera.\r\n\tfloat h = 0.0;\r\n\tfloat f = 1.0;\r\n\tfor (int i = 0; i < 7; i++)\r\n\t{\r\n\t\th += Terrain(CameraPath((.6-f)*.008).xz) * f;\r\n\t\tf -= .1;\r\n\t}\r\n\tcameraPos.xz = CameraPath(0.0).xz;\r\n\tcamTar.xyz\t = CameraPath(.005).xyz;\r\n\tcamTar.y = cameraPos.y = max((h*.25)+3.5, 1.5+sin(iTime*5.)*.5);\r\n\t\r\n\tfloat roll = 0.15*sin(iTime*.2);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\r\n\r\n\t#ifdef STEREO\r\n\tcameraPos += .45*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tif( !Scene(cameraPos,rd, distance, fragCoord) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky value...\r\n\t\tcol = GetSky(rd);\r\n\t\tcol = GetClouds(col, rd);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * rd;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tfloat p = min(.3, .0005+.00005 * distance*distance);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain2(pos.xz), 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain2(pos.xz+vec2(p,0.0)), 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain2(pos.xz+vec2(0.0,-p)), -p);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, nor, distance);\r\n\t}\r\n\r\n\tcol = PostEffects(col, uv);\r\n\t\r\n\t#ifdef STEREO\t\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n\t#endif\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\none.png","type":"texture","channel":0,"sampler":null,"published":0}],"Info":{"Name":"Mountains","id":null,"date":null,"viewed":0,"name":"Mountains","description":"A Shader version of my terrain renderer:-\r\nhttp://www.youtube.com/watch?v=qzkBnCBpQAM\r\nUSE MOUSE > TO SHIFT TIME\r\n\r\n\r\nVideo of my OpenGL version that uses streaming texture normals for speed...\r\nhttp://www.youtube.com/watch?v=qzkBnCBpQAM","likes":0,"published":null,"tags":["raymarching"," terrain"," landscape"," mountains"," vr"," soundcloud"]},"ver":null,"info":{"Name":"Mountains","id":null,"date":null,"viewed":0,"name":"Mountains","description":"A Shader version of my terrain renderer:-\r\nhttp://www.youtube.com/watch?v=qzkBnCBpQAM\r\nUSE MOUSE > TO SHIFT TIME\r\n\r\n\r\nVideo of my OpenGL version that uses streaming texture normals for speed...\r\nhttp://www.youtube.com/watch?v=qzkBnCBpQAM","likes":0,"published":null,"tags":["raymarching"," terrain"," landscape"," mountains"," vr"," soundcloud"]},"renderpass":[{"Code":"// Mountains. By David Hoskins - 2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// https://www.shadertoy.com/view/4slGD4\r\n// A ray-marched version of my terrain renderer which uses\r\n// streaming texture normals for speed:-\r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// It uses binary subdivision to accurately find the height map.\r\n// Lots of thanks to Inigo and his noise functions!\r\n\r\n// Video of my OpenGL version that \r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// Stereo version code thanks to Croqueteer :)\r\n//#define STEREO \r\n\r\nfloat treeLine = 0.0;\r\nfloat treeCol = 0.0;\r\n\r\n\r\nvec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.48 ) );\r\nvec3 sunColour = vec3(1.0, .9, .83);\r\nfloat specular = 0.0;\r\nvec3 cameraPos;\r\nfloat ambient;\r\nvec2 add = vec2(1.0, 0.0);\r\n#define HASHSCALE1 .1031\r\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\r\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\r\n\r\n// This peturbs the fractal positions for each iteration down...\r\n// Helps make nice twisted landscapes...\r\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\r\n\r\n// Alternative rotation:-\r\n// const mat2 rotate2D = mat2(1.2323, 1.999231, -1.999231, 1.22);\r\n\r\n\r\n//  1 out, 2 in...\r\nfloat Hash12(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n\r\n}\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    \r\n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\r\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Noise2( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y * 57.0;\r\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\r\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Trees(vec2 p)\r\n{\r\n\t\r\n \t//return (texture(iChannel1,0.04*p).x * treeLine);\r\n    return Noise(p*13.0)*treeLine;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Low def version for ray-marching through the height field...\r\n// Thanks to IQ for all the noise stuff...\r\n\r\nfloat Terrain( in vec2 p)\r\n{\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw = -w * 0.4;\t//...Flip negative and positive for variation\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\t\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Map to lower resolution for height field mapping for Scene function...\r\nfloat Map(in vec3 p)\r\n{\r\n\tfloat h = Terrain(p.xz);\r\n\t\t\r\n\r\n\tfloat ff = Noise(p.xz*.3) + Noise(p.xz*3.3)*.5;\r\n\ttreeLine = smoothstep(ff, .0+ff*2.0, h) * smoothstep(1.0+ff*3.0, .4+ff, h) ;\r\n\ttreeCol = Trees(p.xz);\r\n\th += treeCol;\r\n\t\r\n    return p.y - h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// High def version only used for grabbing normal information.\r\nfloat Terrain2( in vec2 p)\r\n{\r\n\t// There's some real magic numbers in here! \r\n\t// The Noise calls add large mountain ranges for more variation over distances...\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\t//...Flip negative and positive for varition\t   \r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\t\r\n\r\n\ttreeCol = Trees(p);\r\n\tf += treeCol;\r\n\tif (treeCol > 0.0) return f;\r\n\r\n\t\r\n\t// That's the last of the low resolution, now go down further for the Normal data...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\t\r\n\t\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw *= 0.5;\r\n\t\txy *= 2.7;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Simply Perlin clouds that fade to the horizon...\r\n// 200 units above the ground...\r\nvec3 GetClouds(in vec3 sky, in vec3 rd)\r\n{\r\n\tif (rd.y < 0.01) return sky;\r\n\tfloat v = (200.0-cameraPos.y)/rd.y;\r\n\trd.xz *= v;\r\n\trd.xz += cameraPos.xz;\r\n\trd.xz *= .010;\r\n\tfloat f = (FractalNoise(rd.xz) -.55) * 5.0;\r\n\t// Uses the ray's y component for horizon fade of fixed colour clouds...\r\n\tsky = mix(sky, vec3(.55, .55, .52), clamp(f*rd.y-.1, 0.0, 1.0));\r\n\r\n\treturn sky;\r\n}\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),5.)*.5;\r\n\tvec3  sky = vec3(v*sunColour.x*0.4+0.18, v*sunColour.y*0.4+0.22, v*sunColour.z*0.4+.4);\r\n\t// Wide glare effect...\r\n\tsky = sky + sunColour * pow(sunAmount, 6.5)*.32;\r\n\t// Actual sun...\r\n\tsky = sky+ sunColour * min(pow(sunAmount, 1150.0), .3)*.65;\r\n\treturn sky;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge mountains into the sky background for correct disappearance...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = exp(-dis* 0.00005);\r\n\treturn mix(GetSky(dir), rgb, fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(sunLight,normal);\r\n\tfloat c = max(h, 0.0)+ambient;\r\n\tmat = mat * sunColour * c ;\r\n\t// Specular...\r\n\tif (h > 0.0)\r\n\t{\r\n\t\tvec3 R = reflect(sunLight, normal);\r\n\t\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\r\n\t\tmat = mix(mat, sunColour, specAmount);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Hack the height, position, and normal data to create the coloured landscape\r\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\r\n{\r\n\tvec3 mat;\r\n\tspecular = .0;\r\n\tambient = .1;\r\n\tvec3 dir = normalize(pos-cameraPos);\r\n\t\r\n\tvec3 matPos = pos * 2.0;// ... I had change scale halfway though, this lazy multiply allow me to keep the graphic scales I had\r\n\r\n\tfloat disSqrd = dis * dis;// Squaring it gives better distance scales.\r\n\r\n\tfloat f = clamp(Noise(matPos.xz*.05), 0.0,1.0);//*10.8;\r\n\tf += Noise(matPos.xz*.1+normal.yz*1.08)*.85;\r\n\tf *= .55;\r\n\tvec3 m = mix(vec3(.63*f+.2, .7*f+.1, .7*f+.1), vec3(f*.43+.1, f*.3+.2, f*.35+.1), f*.65);\r\n\tmat = m*vec3(f*m.x+.36, f*m.y+.30, f*m.z+.28);\r\n\t// Should have used smoothstep to add colours, but left it using 'if' for sanity...\r\n\tif (normal.y < .5)\r\n\t{\r\n\t\tfloat v = normal.y;\r\n\t\tfloat c = (.5-normal.y) * 4.0;\r\n\t\tc = clamp(c*c, 0.1, 1.0);\r\n\t\tf = Noise(vec2(matPos.x*.09, matPos.z*.095+matPos.yy*0.15));\r\n\t\tf += Noise(vec2(matPos.x*2.233, matPos.z*2.23))*0.5;\r\n\t\tmat = mix(mat, vec3(.4*f), c);\r\n\t\tspecular+=.1;\r\n\t}\r\n\r\n\t// Grass. Use the normal to decide when to plonk grass down...\r\n\tif (matPos.y < 45.35 && normal.y > .65)\r\n\t{\r\n\r\n\t\tm = vec3(Noise(matPos.xz*.023)*.5+.15, Noise(matPos.xz*.03)*.6+.25, 0.0);\r\n\t\tm *= (normal.y- 0.65)*.6;\r\n\t\tmat = mix(mat, m, clamp((normal.y-.65)*1.3 * (45.35-matPos.y)*0.1, 0.0, 1.0));\r\n\t}\r\n\r\n\tif (treeCol > 0.0)\r\n\t{\r\n\t\tmat = vec3(.02+Noise(matPos.xz*5.0)*.03, .05, .0);\r\n\t\tnormal = normalize(normal+vec3(Noise(matPos.xz*33.0)*1.0-.5, .0, Noise(matPos.xz*33.0)*1.0-.5));\r\n\t\tspecular = .0;\r\n\t}\r\n\t\r\n\t// Snow topped mountains...\r\n\tif (matPos.y > 80.0 && normal.y > .42)\r\n\t{\r\n\t\tfloat snow = clamp((matPos.y - 80.0 - Noise(matPos.xz * .1)*28.0) * 0.035, 0.0, 1.0);\r\n\t\tmat = mix(mat, vec3(.7,.7,.8), snow);\r\n\t\tspecular += snow;\r\n\t\tambient+=snow *.3;\r\n\t}\r\n\t// Beach effect...\r\n\tif (matPos.y < 1.45)\r\n\t{\r\n\t\tif (normal.y > .4)\r\n\t\t{\r\n\t\t\tf = Noise(matPos.xz * .084)*1.5;\r\n\t\t\tf = clamp((1.45-f-matPos.y) * 1.34, 0.0, .67);\r\n\t\t\tfloat t = (normal.y-.4);\r\n\t\t\tt = (t*t);\r\n\t\t\tmat = mix(mat, vec3(.09+t, .07+t, .03+t), f);\r\n\t\t}\r\n\t\t// Cheap under water darkening...it's wet after all...\r\n\t\tif (matPos.y < 0.0)\r\n\t\t{\r\n\t\t\tmat *= .2;\r\n\t\t}\r\n\t}\r\n\r\n\tDoLighting(mat, pos, normal,dir, disSqrd);\r\n\t\r\n\t// Do the water...\r\n\tif (matPos.y < 0.0)\r\n\t{\r\n\t\t// Pull back along the ray direction to get water surface point at y = 0.0 ...\r\n\t\tfloat time = (iTime)*.03;\r\n\t\tvec3 watPos = matPos;\r\n\t\twatPos += -dir * (watPos.y/dir.y);\r\n\t\t// Make some dodgy waves...\r\n\t\tfloat tx = cos(watPos.x*.052) *4.5;\r\n\t\tfloat tz = sin(watPos.z*.072) *4.5;\r\n\t\tvec2 co = Noise2(vec2(watPos.x*4.7+1.3+tz, watPos.z*4.69+time*35.0-tx));\r\n\t\tco += Noise2(vec2(watPos.z*8.6+time*13.0-tx, watPos.x*8.712+tz))*.4;\r\n\t\tvec3 nor = normalize(vec3(co.x, 20.0, co.y));\r\n\t\tnor = normalize(reflect(dir, nor));//normalize((-2.0*(dot(dir, nor))*nor)+dir);\r\n\t\t// Mix it in at depth transparancy to give beach cues..\r\n        tx = watPos.y-matPos.y;\r\n\t\tmat = mix(mat, GetClouds(GetSky(nor)*vec3(.3,.3,.5), nor)*.1+vec3(.0,.02,.03), clamp((tx)*.4, .6, 1.));\r\n\t\t// Add some extra water glint...\r\n        mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*texture(iChannel1, watPos.xz*.1, -2.).x, 0.,1.0);\r\n\t\tfloat sunAmount = max( dot(nor, sunLight), 0.0 );\r\n\t\tmat = mat + sunColour * pow(sunAmount, 228.5)*.6;\r\n        vec3 temp = (watPos-cameraPos*2.)*.5;\r\n        disSqrd = dot(temp, temp);\r\n\t}\r\n\tmat = ApplyFog(mat, disSqrd, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\r\n{\r\n\t// Home in on the surface by dividing by two and split...\r\n    float halfwayT;\r\n  \r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n\r\n        halfwayT = dot(t, vec2(.5));\r\n        float d = Map(rO + halfwayT*rD); \r\n         t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.5, d));\r\n\r\n    }\r\n\treturn halfwayT;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT, in vec2 fragCoord )\r\n{\r\n    float t = 1. + Hash12(fragCoord.xy)*5.;\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.0;\r\n\tbool fin = false;\r\n\tbool res = false;\r\n\tvec2 distances;\r\n\tfor( int j=0; j< 150; j++ )\r\n\t{\r\n\t\tif (fin || t > 240.0) break;\r\n\t\tvec3 p = rO + t*rD;\r\n\t\t//if (t > 240.0 || p.y > 195.0) break;\r\n\t\tfloat h = Map(p); // ...Get this positions height mapping.\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h < 0.5)\r\n\t\t{\r\n\t\t\tfin = true;\r\n\t\t\tdistances = vec2(oldT, t);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t// Delta ray advance - a fudge between the height returned\r\n\t\t// and the distance already travelled.\r\n\t\t// It's a really fiddly compromise between speed and accuracy\r\n\t\t// Too large a step and the tops of ridges get missed.\r\n\t\tdelta = max(0.01, 0.3*h) + (t*0.0065);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n\tif (fin) resT = BinarySubdivision(rO, rD, distances);\r\n\r\n\treturn fin;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\tfloat m = 1.0+(iMouse.x/iResolution.x)*300.0;\r\n\tt = (iTime*1.5+m+657.0)*.006 + t;\r\n    vec2 p = 476.0*vec2( sin(3.5*t), cos(1.5*t) );\r\n\treturn vec3(35.0-p.x, 0.6, 4108.0+p.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Some would say, most of the magic is done in post! :D\r\nvec3 PostEffects(vec3 rgb, vec2 uv)\r\n{\r\n\t//#define CONTRAST 1.1\r\n\t//#define SATURATION 1.12\r\n\t//#define BRIGHTNESS 1.3\r\n\t//rgb = pow(abs(rgb), vec3(0.45));\r\n\t//rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\trgb = (1.0 - exp(-rgb * 6.0)) * 1.0024;\r\n\t//rgb = clamp(rgb+hash12(fragCoord.xy*rgb.r)*0.1, 0.0, 1.0);\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = xy * vec2(iResolution.x/iResolution.y,1.0);\r\n\tvec3 camTar;\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\t// Use several forward heights, of decreasing influence with distance from the camera.\r\n\tfloat h = 0.0;\r\n\tfloat f = 1.0;\r\n\tfor (int i = 0; i < 7; i++)\r\n\t{\r\n\t\th += Terrain(CameraPath((.6-f)*.008).xz) * f;\r\n\t\tf -= .1;\r\n\t}\r\n\tcameraPos.xz = CameraPath(0.0).xz;\r\n\tcamTar.xyz\t = CameraPath(.005).xyz;\r\n\tcamTar.y = cameraPos.y = max((h*.25)+3.5, 1.5+sin(iTime*5.)*.5);\r\n\t\r\n\tfloat roll = 0.15*sin(iTime*.2);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\r\n\r\n\t#ifdef STEREO\r\n\tcameraPos += .45*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tif( !Scene(cameraPos,rd, distance, fragCoord) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky value...\r\n\t\tcol = GetSky(rd);\r\n\t\tcol = GetClouds(col, rd);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * rd;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tfloat p = min(.3, .0005+.00005 * distance*distance);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain2(pos.xz), 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain2(pos.xz+vec2(p,0.0)), 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain2(pos.xz+vec2(0.0,-p)), -p);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, nor, distance);\r\n\t}\r\n\r\n\tcol = PostEffects(col, uv);\r\n\t\r\n\t#ifdef STEREO\t\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n\t#endif\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\none.png","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"// Mountains. By David Hoskins - 2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// https://www.shadertoy.com/view/4slGD4\r\n// A ray-marched version of my terrain renderer which uses\r\n// streaming texture normals for speed:-\r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// It uses binary subdivision to accurately find the height map.\r\n// Lots of thanks to Inigo and his noise functions!\r\n\r\n// Video of my OpenGL version that \r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// Stereo version code thanks to Croqueteer :)\r\n//#define STEREO \r\n\r\nfloat treeLine = 0.0;\r\nfloat treeCol = 0.0;\r\n\r\n\r\nvec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.48 ) );\r\nvec3 sunColour = vec3(1.0, .9, .83);\r\nfloat specular = 0.0;\r\nvec3 cameraPos;\r\nfloat ambient;\r\nvec2 add = vec2(1.0, 0.0);\r\n#define HASHSCALE1 .1031\r\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\r\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\r\n\r\n// This peturbs the fractal positions for each iteration down...\r\n// Helps make nice twisted landscapes...\r\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\r\n\r\n// Alternative rotation:-\r\n// const mat2 rotate2D = mat2(1.2323, 1.999231, -1.999231, 1.22);\r\n\r\n\r\n//  1 out, 2 in...\r\nfloat Hash12(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n\r\n}\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    \r\n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\r\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Noise2( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y * 57.0;\r\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\r\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Trees(vec2 p)\r\n{\r\n\t\r\n \t//return (texture(iChannel1,0.04*p).x * treeLine);\r\n    return Noise(p*13.0)*treeLine;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Low def version for ray-marching through the height field...\r\n// Thanks to IQ for all the noise stuff...\r\n\r\nfloat Terrain( in vec2 p)\r\n{\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw = -w * 0.4;\t//...Flip negative and positive for variation\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\t\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Map to lower resolution for height field mapping for Scene function...\r\nfloat Map(in vec3 p)\r\n{\r\n\tfloat h = Terrain(p.xz);\r\n\t\t\r\n\r\n\tfloat ff = Noise(p.xz*.3) + Noise(p.xz*3.3)*.5;\r\n\ttreeLine = smoothstep(ff, .0+ff*2.0, h) * smoothstep(1.0+ff*3.0, .4+ff, h) ;\r\n\ttreeCol = Trees(p.xz);\r\n\th += treeCol;\r\n\t\r\n    return p.y - h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// High def version only used for grabbing normal information.\r\nfloat Terrain2( in vec2 p)\r\n{\r\n\t// There's some real magic numbers in here! \r\n\t// The Noise calls add large mountain ranges for more variation over distances...\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\t//...Flip negative and positive for varition\t   \r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\t\r\n\r\n\ttreeCol = Trees(p);\r\n\tf += treeCol;\r\n\tif (treeCol > 0.0) return f;\r\n\r\n\t\r\n\t// That's the last of the low resolution, now go down further for the Normal data...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\t\r\n\t\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw *= 0.5;\r\n\t\txy *= 2.7;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Simply Perlin clouds that fade to the horizon...\r\n// 200 units above the ground...\r\nvec3 GetClouds(in vec3 sky, in vec3 rd)\r\n{\r\n\tif (rd.y < 0.01) return sky;\r\n\tfloat v = (200.0-cameraPos.y)/rd.y;\r\n\trd.xz *= v;\r\n\trd.xz += cameraPos.xz;\r\n\trd.xz *= .010;\r\n\tfloat f = (FractalNoise(rd.xz) -.55) * 5.0;\r\n\t// Uses the ray's y component for horizon fade of fixed colour clouds...\r\n\tsky = mix(sky, vec3(.55, .55, .52), clamp(f*rd.y-.1, 0.0, 1.0));\r\n\r\n\treturn sky;\r\n}\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),5.)*.5;\r\n\tvec3  sky = vec3(v*sunColour.x*0.4+0.18, v*sunColour.y*0.4+0.22, v*sunColour.z*0.4+.4);\r\n\t// Wide glare effect...\r\n\tsky = sky + sunColour * pow(sunAmount, 6.5)*.32;\r\n\t// Actual sun...\r\n\tsky = sky+ sunColour * min(pow(sunAmount, 1150.0), .3)*.65;\r\n\treturn sky;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge mountains into the sky background for correct disappearance...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = exp(-dis* 0.00005);\r\n\treturn mix(GetSky(dir), rgb, fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(sunLight,normal);\r\n\tfloat c = max(h, 0.0)+ambient;\r\n\tmat = mat * sunColour * c ;\r\n\t// Specular...\r\n\tif (h > 0.0)\r\n\t{\r\n\t\tvec3 R = reflect(sunLight, normal);\r\n\t\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\r\n\t\tmat = mix(mat, sunColour, specAmount);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Hack the height, position, and normal data to create the coloured landscape\r\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\r\n{\r\n\tvec3 mat;\r\n\tspecular = .0;\r\n\tambient = .1;\r\n\tvec3 dir = normalize(pos-cameraPos);\r\n\t\r\n\tvec3 matPos = pos * 2.0;// ... I had change scale halfway though, this lazy multiply allow me to keep the graphic scales I had\r\n\r\n\tfloat disSqrd = dis * dis;// Squaring it gives better distance scales.\r\n\r\n\tfloat f = clamp(Noise(matPos.xz*.05), 0.0,1.0);//*10.8;\r\n\tf += Noise(matPos.xz*.1+normal.yz*1.08)*.85;\r\n\tf *= .55;\r\n\tvec3 m = mix(vec3(.63*f+.2, .7*f+.1, .7*f+.1), vec3(f*.43+.1, f*.3+.2, f*.35+.1), f*.65);\r\n\tmat = m*vec3(f*m.x+.36, f*m.y+.30, f*m.z+.28);\r\n\t// Should have used smoothstep to add colours, but left it using 'if' for sanity...\r\n\tif (normal.y < .5)\r\n\t{\r\n\t\tfloat v = normal.y;\r\n\t\tfloat c = (.5-normal.y) * 4.0;\r\n\t\tc = clamp(c*c, 0.1, 1.0);\r\n\t\tf = Noise(vec2(matPos.x*.09, matPos.z*.095+matPos.yy*0.15));\r\n\t\tf += Noise(vec2(matPos.x*2.233, matPos.z*2.23))*0.5;\r\n\t\tmat = mix(mat, vec3(.4*f), c);\r\n\t\tspecular+=.1;\r\n\t}\r\n\r\n\t// Grass. Use the normal to decide when to plonk grass down...\r\n\tif (matPos.y < 45.35 && normal.y > .65)\r\n\t{\r\n\r\n\t\tm = vec3(Noise(matPos.xz*.023)*.5+.15, Noise(matPos.xz*.03)*.6+.25, 0.0);\r\n\t\tm *= (normal.y- 0.65)*.6;\r\n\t\tmat = mix(mat, m, clamp((normal.y-.65)*1.3 * (45.35-matPos.y)*0.1, 0.0, 1.0));\r\n\t}\r\n\r\n\tif (treeCol > 0.0)\r\n\t{\r\n\t\tmat = vec3(.02+Noise(matPos.xz*5.0)*.03, .05, .0);\r\n\t\tnormal = normalize(normal+vec3(Noise(matPos.xz*33.0)*1.0-.5, .0, Noise(matPos.xz*33.0)*1.0-.5));\r\n\t\tspecular = .0;\r\n\t}\r\n\t\r\n\t// Snow topped mountains...\r\n\tif (matPos.y > 80.0 && normal.y > .42)\r\n\t{\r\n\t\tfloat snow = clamp((matPos.y - 80.0 - Noise(matPos.xz * .1)*28.0) * 0.035, 0.0, 1.0);\r\n\t\tmat = mix(mat, vec3(.7,.7,.8), snow);\r\n\t\tspecular += snow;\r\n\t\tambient+=snow *.3;\r\n\t}\r\n\t// Beach effect...\r\n\tif (matPos.y < 1.45)\r\n\t{\r\n\t\tif (normal.y > .4)\r\n\t\t{\r\n\t\t\tf = Noise(matPos.xz * .084)*1.5;\r\n\t\t\tf = clamp((1.45-f-matPos.y) * 1.34, 0.0, .67);\r\n\t\t\tfloat t = (normal.y-.4);\r\n\t\t\tt = (t*t);\r\n\t\t\tmat = mix(mat, vec3(.09+t, .07+t, .03+t), f);\r\n\t\t}\r\n\t\t// Cheap under water darkening...it's wet after all...\r\n\t\tif (matPos.y < 0.0)\r\n\t\t{\r\n\t\t\tmat *= .2;\r\n\t\t}\r\n\t}\r\n\r\n\tDoLighting(mat, pos, normal,dir, disSqrd);\r\n\t\r\n\t// Do the water...\r\n\tif (matPos.y < 0.0)\r\n\t{\r\n\t\t// Pull back along the ray direction to get water surface point at y = 0.0 ...\r\n\t\tfloat time = (iTime)*.03;\r\n\t\tvec3 watPos = matPos;\r\n\t\twatPos += -dir * (watPos.y/dir.y);\r\n\t\t// Make some dodgy waves...\r\n\t\tfloat tx = cos(watPos.x*.052) *4.5;\r\n\t\tfloat tz = sin(watPos.z*.072) *4.5;\r\n\t\tvec2 co = Noise2(vec2(watPos.x*4.7+1.3+tz, watPos.z*4.69+time*35.0-tx));\r\n\t\tco += Noise2(vec2(watPos.z*8.6+time*13.0-tx, watPos.x*8.712+tz))*.4;\r\n\t\tvec3 nor = normalize(vec3(co.x, 20.0, co.y));\r\n\t\tnor = normalize(reflect(dir, nor));//normalize((-2.0*(dot(dir, nor))*nor)+dir);\r\n\t\t// Mix it in at depth transparancy to give beach cues..\r\n        tx = watPos.y-matPos.y;\r\n\t\tmat = mix(mat, GetClouds(GetSky(nor)*vec3(.3,.3,.5), nor)*.1+vec3(.0,.02,.03), clamp((tx)*.4, .6, 1.));\r\n\t\t// Add some extra water glint...\r\n        mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*texture(iChannel1, watPos.xz*.1, -2.).x, 0.,1.0);\r\n\t\tfloat sunAmount = max( dot(nor, sunLight), 0.0 );\r\n\t\tmat = mat + sunColour * pow(sunAmount, 228.5)*.6;\r\n        vec3 temp = (watPos-cameraPos*2.)*.5;\r\n        disSqrd = dot(temp, temp);\r\n\t}\r\n\tmat = ApplyFog(mat, disSqrd, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\r\n{\r\n\t// Home in on the surface by dividing by two and split...\r\n    float halfwayT;\r\n  \r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n\r\n        halfwayT = dot(t, vec2(.5));\r\n        float d = Map(rO + halfwayT*rD); \r\n         t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.5, d));\r\n\r\n    }\r\n\treturn halfwayT;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT, in vec2 fragCoord )\r\n{\r\n    float t = 1. + Hash12(fragCoord.xy)*5.;\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.0;\r\n\tbool fin = false;\r\n\tbool res = false;\r\n\tvec2 distances;\r\n\tfor( int j=0; j< 150; j++ )\r\n\t{\r\n\t\tif (fin || t > 240.0) break;\r\n\t\tvec3 p = rO + t*rD;\r\n\t\t//if (t > 240.0 || p.y > 195.0) break;\r\n\t\tfloat h = Map(p); // ...Get this positions height mapping.\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h < 0.5)\r\n\t\t{\r\n\t\t\tfin = true;\r\n\t\t\tdistances = vec2(oldT, t);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t// Delta ray advance - a fudge between the height returned\r\n\t\t// and the distance already travelled.\r\n\t\t// It's a really fiddly compromise between speed and accuracy\r\n\t\t// Too large a step and the tops of ridges get missed.\r\n\t\tdelta = max(0.01, 0.3*h) + (t*0.0065);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n\tif (fin) resT = BinarySubdivision(rO, rD, distances);\r\n\r\n\treturn fin;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\tfloat m = 1.0+(iMouse.x/iResolution.x)*300.0;\r\n\tt = (iTime*1.5+m+657.0)*.006 + t;\r\n    vec2 p = 476.0*vec2( sin(3.5*t), cos(1.5*t) );\r\n\treturn vec3(35.0-p.x, 0.6, 4108.0+p.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Some would say, most of the magic is done in post! :D\r\nvec3 PostEffects(vec3 rgb, vec2 uv)\r\n{\r\n\t//#define CONTRAST 1.1\r\n\t//#define SATURATION 1.12\r\n\t//#define BRIGHTNESS 1.3\r\n\t//rgb = pow(abs(rgb), vec3(0.45));\r\n\t//rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\trgb = (1.0 - exp(-rgb * 6.0)) * 1.0024;\r\n\t//rgb = clamp(rgb+hash12(fragCoord.xy*rgb.r)*0.1, 0.0, 1.0);\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = xy * vec2(iResolution.x/iResolution.y,1.0);\r\n\tvec3 camTar;\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\t// Use several forward heights, of decreasing influence with distance from the camera.\r\n\tfloat h = 0.0;\r\n\tfloat f = 1.0;\r\n\tfor (int i = 0; i < 7; i++)\r\n\t{\r\n\t\th += Terrain(CameraPath((.6-f)*.008).xz) * f;\r\n\t\tf -= .1;\r\n\t}\r\n\tcameraPos.xz = CameraPath(0.0).xz;\r\n\tcamTar.xyz\t = CameraPath(.005).xyz;\r\n\tcamTar.y = cameraPos.y = max((h*.25)+3.5, 1.5+sin(iTime*5.)*.5);\r\n\t\r\n\tfloat roll = 0.15*sin(iTime*.2);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\r\n\r\n\t#ifdef STEREO\r\n\tcameraPos += .45*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tif( !Scene(cameraPos,rd, distance, fragCoord) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky value...\r\n\t\tcol = GetSky(rd);\r\n\t\tcol = GetClouds(col, rd);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * rd;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tfloat p = min(.3, .0005+.00005 * distance*distance);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain2(pos.xz), 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain2(pos.xz+vec2(p,0.0)), 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain2(pos.xz+vec2(0.0,-p)), -p);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, nor, distance);\r\n\t}\r\n\r\n\tcol = PostEffects(col, uv);\r\n\t\r\n\t#ifdef STEREO\t\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n\t#endif\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2014\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\n#define LOWDETAIL\r\n//#define HIGH_QUALITY_NOISE\r\n\r\nfloat noise1( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#ifndef HIGH_QUALITY_NOISE\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel2, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n#else\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( iChannel2, (uv+ vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( iChannel2, (uv+ vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( iChannel2, (uv+ vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( iChannel2, (uv+ vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\t\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\n//-----------------------------------------------------------------------------------\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n                    -0.80,  0.36, -0.48,\r\n                    -0.60, -0.48,  0.64 );\r\n\r\nfloat displacement( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise1( p ); p = m*p*2.02;\r\n    f += 0.2500*noise1( p ); p = m*p*2.03;\r\n    f += 0.1250*noise1( p ); p = m*p*2.01;\r\n\t#ifndef LOWDETAIL\r\n    f += 0.0625*noise1( p ); \r\n\t#endif\r\n    return f;\r\n}\r\n\r\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\r\n{\r\n\tvec4 x = texture( sam, p.yz );\r\n\tvec4 y = texture( sam, p.zx );\r\n\tvec4 z = texture( sam, p.xy );\r\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\r\n}\r\n\r\n\r\nvec4 textureGood( sampler2D sam, vec2 uv, float lo )\r\n{\r\n    uv = uv*1024.0 - 0.5;\r\n    vec2 iuv = floor(uv);\r\n    vec2 f = fract(uv);\r\n\tvec4 rg1 = textureLod( sam, (iuv+ vec2(0.5,0.5))/1024.0, lo );\r\n\tvec4 rg2 = textureLod( sam, (iuv+ vec2(1.5,0.5))/1024.0, lo );\r\n\tvec4 rg3 = textureLod( sam, (iuv+ vec2(0.5,1.5))/1024.0, lo );\r\n\tvec4 rg4 = textureLod( sam, (iuv+ vec2(1.5,1.5))/1024.0, lo );\r\n\treturn mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n}\r\n//-----------------------------------------------------------------------------------\r\n\r\nfloat terrain( in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( iChannel0, 0.001*q, 0.0 ).x );\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( iChannel1, 2.0*0.03*q, 0.0 ).y );\r\n\tfloat h = 1.9;\r\n\t#ifndef LOWDETAIL\r\n\th += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( iChannel0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t#endif\r\n\th += th*7.0;\r\n    h += 0.3*rr;\r\n    return -h;\r\n}\r\n\r\nfloat terrain2( in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureGood( iChannel0, 0.001*q, 0.0 ).x );\r\n    float rr = smoothstep( 0.1, 0.5, textureGood( iChannel1, 2.0*0.03*q, 0.0 ).y );\r\n\tfloat h = 1.9;\r\n\th += th*7.0;\r\n    return -h;\r\n}\r\n\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n\tfloat h = terrain( p.xz );\r\n\tfloat dis = displacement( 0.25*p*vec3(1.0,4.0,1.0) );\r\n\tdis *= 3.0;\r\n\treturn vec4( (dis + p.y-h)*0.25, p.x, h, 0.0 );\r\n}\r\n\r\nvec4 intersect( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float t = 0.1;\r\n    vec3 res = vec3(0.0);\r\n    for( int i=0; i<256; i++ )\r\n    {\r\n\t    vec4 tmp = map( ro+rd*t );\r\n        res = tmp.ywz;\r\n        t += tmp.x;\r\n        if( tmp.x<(0.001*t) || t>tmax ) break;\r\n    }\r\n\r\n    return vec4( t, res );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\r\n}\r\n\r\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\r\n{\r\n    float res = 1.0;\r\n    float t = mint;\r\n    for( int i=0; i<50; i++ )\r\n    {\r\n        float h = map(ro + rd*t).x;\r\n        res = min( res, k*h/t );\r\n\t\tt += clamp( h, 0.5, 1.0 );\r\n\t\tif( h<0.001 ) break;\r\n    }\r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\n// Oren-Nayar\r\nfloat Diffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n{\r\n\t\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv,n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\nvec3 cpath( float t )\r\n{\r\n\tvec3 pos = vec3( 0.0, 0.0, 95.0 + t );\r\n\t\r\n\tfloat a = smoothstep(5.0,20.0,t);\r\n\tpos.xz += a*150.0 * cos( vec2(5.0,6.0) + 1.0*0.01*t );\r\n\tpos.xz -= a*150.0 * cos( vec2(5.0,6.0) );\r\n\tpos.xz += a* 50.0 * cos( vec2(0.0,3.5) + 6.0*0.01*t );\r\n\tpos.xz -= a* 50.0 * cos( vec2(0.0,3.5) );\r\n\r\n\treturn pos;\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.0);\r\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\r\n\r\n\t\r\n    //-----------------------------------------------------\r\n    // camera\r\n    //-----------------------------------------------------\r\n\r\n\tfloat an = 0.5*(iTime-5.0);// + 12.0*(m.x-0.5);\r\n\tvec3 ro = cpath( an + 0.0 );\r\n\tvec3 ta = cpath( an + 10.0 *1.0);\r\n\tta = mix( ro + vec3(0.0,0.0,1.0), ta, smoothstep(5.0,25.0,an) );\r\n    ro.y = terrain2( ro.xz ) - 0.5;\r\n\tta.y = ro.y - 0.1;\r\n\tta.xy += step(0.01,m.x)*(m.xy-0.5)*4.0*vec2(-1.0,1.0);\r\n\tfloat rl = -0.1*cos(0.05*6.2831*an);\r\n    // camera to world transform    \r\n    mat3 cam = setCamera( ro, ta, rl );\r\n    \r\n    // ray\r\n\tvec3 rd = normalize( cam * vec3(p.xy, 2.0) );\r\n\r\n    //-----------------------------------------------------\r\n\t// render\r\n    //-----------------------------------------------------\r\n\r\n\tvec3 klig = normalize(vec3(-1.0,0.19,0.4));\r\n\t\r\n\tfloat sun = clamp(dot(klig,rd),0.0,1.0 );\r\n\r\n\tvec3 hor = mix( 1.2*vec3(0.70,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sun );\r\n\t\r\n    vec3 col = mix( vec3(0.2,0.6,.9), hor, exp(-(4.0+2.0*(1.0-sun))*max(0.0,rd.y-0.1)) );\r\n    col *= 0.5;\r\n\tcol += 0.8*vec3(1.0,0.8,0.7)*pow(sun,512.0);\r\n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow(sun,32.0);\r\n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow(sun,4.0);\r\n\t\r\n\tvec3 bcol = col;\r\n\t\r\n\t// clouds\r\n\tfloat pt = (1000.0-ro.y)/rd.y; \r\n\tif( pt>0.0 )\r\n\t{\r\n        vec3 spos = ro + pt*rd;\r\n        float clo = texture( iChannel0, 0.00006*spos.xz ).x;\t\r\n        vec3 cloCol = mix( vec3(0.4,0.5,0.6), vec3(1.3,0.6,0.4), pow(sun,2.0))*(0.5+0.5*clo);\r\n        col = mix( col, cloCol, 0.5*smoothstep( 0.4, 1.0, clo ) );\r\n\t}\r\n\t\r\n\t\r\n\t// raymarch\r\n    float tmax = 120.0;\r\n    \r\n    // bounding plane    \r\n    float bt = (0.0-ro.y)/rd.y; \r\n\tif( bt>0.0 ) tmax = min( tmax, bt );\r\n        \r\n    vec4 tmat = intersect( ro, rd, tmax);\r\n    if( tmat.x<tmax )\r\n    {\r\n        // geometry\r\n        vec3 pos = ro + tmat.x*rd;\r\n        vec3 nor = calcNormal( pos, tmat.x );\r\n\t\tvec3 ref = reflect( rd, nor );\r\n\r\n\t\tfloat occ = smoothstep( 0.0, 1.5, pos.y + 11.5 ) * (1.0 - displacement( 0.25*pos*vec3(1.0,4.0,1.0) ));\r\n\r\n\t\t// materials\r\n\t\tvec4 mate = vec4(0.5,0.5,0.5,0.0);\r\n\t\t\r\n\t\t//if( tmat.z<0.5 )\r\n\t\t{\r\n\t\t\tvec3 uvw = 1.0*pos;\r\n\r\n\t\t\tvec3 bnor;\r\n\t\t\tfloat be = 1.0/1024.0;\r\n\t\t\tfloat bf = 0.4;\r\n\t\t\tbnor.x = texcube( iChannel0, bf*uvw+vec3(be,0.0,0.0), nor ).x - texcube( iChannel0, bf*uvw-vec3(be,0.0,0.0), nor ).x;\r\n\t\t\tbnor.y = texcube( iChannel0, bf*uvw+vec3(0.0,be,0.0), nor ).x - texcube( iChannel0, bf*uvw-vec3(0.0,be,0.0), nor ).x;\r\n\t\t\tbnor.z = texcube( iChannel0, bf*uvw+vec3(0.0,0.0,be), nor ).x - texcube( iChannel0, bf*uvw-vec3(0.0,0.0,be), nor ).x;\r\n\t\t\tbnor = normalize(bnor);\r\n\t\t\tfloat amo = 0.2  + 0.25*(1.0-smoothstep(0.6,0.7,nor.y) );\r\n\t\t\tnor = normalize( nor + amo*(bnor-nor*dot(bnor,nor)) );\r\n\r\n\t\t\tvec3 te = texcube( iChannel0, 0.15*uvw, nor ).xyz;\r\n\t\t\tte = 0.05 + te;\r\n\t\t\tmate.xyz = 0.6*te;\r\n\t\t\tmate.w = 1.5*(0.5+0.5*te.x);\r\n\t\t\tfloat th = smoothstep( 0.1, 0.4, texcube( iChannel0, 0.002*uvw, nor ).x );\r\n\t\t\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.4*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\t\t\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep( 0.0, 1.0, nor.y ) );\r\n\t\t\tmate.xyz *= 0.5;\r\n\t\t\tfloat rr = smoothstep( 0.2, 0.4, texcube( iChannel1, 2.0*0.02*uvw, nor ).y );\r\n\t\t\tmate.xyz *= mix( vec3(1.0), 1.5*vec3(0.25,0.24,0.22)*1.5, rr );\r\n\t\t\tmate.xyz *= 1.5*pow(texcube( iChannel3, 8.0*uvw, nor ).xyz,vec3(0.5));\r\n            mate = mix( mate, vec4(0.7,0.7,0.7,.0), smoothstep(0.8,0.9,nor.y + nor.x*0.6*te.x*te.x ));\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tmate.xyz *= 1.5;\r\n\t\t}\r\n\t\t\r\n\t\tvec3 blig = normalize(vec3(-klig.x,0.0,-klig.z));\r\n\t\tvec3 slig = vec3( 0.0, 1.0, 0.0 );\r\n\t\t\t\r\n\t\t// lighting\r\n        float sky = 0.0;\r\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0, 0.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3( 3.0, 1.0, 0.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3(-3.0, 1.0, 0.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0, 3.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0,-3.0 )), nor, -rd, 1.0 );\r\n\t\tfloat dif = Diffuse( klig, nor, -rd, 1.0 );\r\n\t\tfloat bac = Diffuse( blig, nor, -rd, 1.0 );\r\n\r\n\r\n\t\tfloat sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.01*nor, klig, 0.005, 64.0 );\r\n        float spe = mate.w*pow( clamp(dot(reflect(rd,nor),klig),0.0,1.0),2.0)*clamp(dot(nor,klig),0.0,1.0);\r\n\t\t\r\n\t\t// lights\r\n\t\tvec3 lin = vec3(0.0);\r\n\t\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha );\r\n\t\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\t\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\t    lin += 0.5*vec3(spe)*sha*occ;\r\n\t\t\r\n\t\t// surface-light interacion\r\n\t\tcol = mate.xyz * lin;\r\n\r\n\t\t// fog\r\n        bcol = 0.7*mix( vec3(0.2,0.5,1.0)*0.82, bcol, 0.15+0.8*sun ); col = mix( col, bcol, 1.0-exp(-0.02*tmat.x) );\t\t\r\n\t}\r\n\t\r\n\r\n\tcol += 0.15*vec3(1.0,0.9,0.6)*pow( sun, 6.0 );\r\n\t\r\n\t//-----------------------------------------------------\r\n\t// postprocessing\r\n    //-----------------------------------------------------\r\n    col *= 1.0 - 0.25*pow(1.0-clamp(dot(cam[2],klig),0.0,1.0),3.0);\r\n\t\r\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\r\n\r\n\tcol *= vec3(1.1,1.0,1.0);\r\n\tcol = col*col*(3.0-2.0*col);\r\n\tcol = pow( col, vec3(0.9,1.0,1.0) );\r\n\r\n\tcol = mix( col, vec3(dot(col,vec3(0.333))), 0.4 );\r\n\tcol = col*0.5+0.5*col*col*(3.0-2.0*col);\r\n\t\r\n\tcol *= 0.3 + 0.7*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\r\n    col *= smoothstep(0.0,2.5,iTime);\r\n\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":null,"published":0}],"outputs":[],"code":"// Created by inigo quilez - iq/2014\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\n#define LOWDETAIL\r\n//#define HIGH_QUALITY_NOISE\r\n\r\nfloat noise1( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#ifndef HIGH_QUALITY_NOISE\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel2, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n#else\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( iChannel2, (uv+ vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( iChannel2, (uv+ vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( iChannel2, (uv+ vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( iChannel2, (uv+ vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\t\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\n//-----------------------------------------------------------------------------------\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n                    -0.80,  0.36, -0.48,\r\n                    -0.60, -0.48,  0.64 );\r\n\r\nfloat displacement( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise1( p ); p = m*p*2.02;\r\n    f += 0.2500*noise1( p ); p = m*p*2.03;\r\n    f += 0.1250*noise1( p ); p = m*p*2.01;\r\n\t#ifndef LOWDETAIL\r\n    f += 0.0625*noise1( p ); \r\n\t#endif\r\n    return f;\r\n}\r\n\r\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\r\n{\r\n\tvec4 x = texture( sam, p.yz );\r\n\tvec4 y = texture( sam, p.zx );\r\n\tvec4 z = texture( sam, p.xy );\r\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\r\n}\r\n\r\n\r\nvec4 textureGood( sampler2D sam, vec2 uv, float lo )\r\n{\r\n    uv = uv*1024.0 - 0.5;\r\n    vec2 iuv = floor(uv);\r\n    vec2 f = fract(uv);\r\n\tvec4 rg1 = textureLod( sam, (iuv+ vec2(0.5,0.5))/1024.0, lo );\r\n\tvec4 rg2 = textureLod( sam, (iuv+ vec2(1.5,0.5))/1024.0, lo );\r\n\tvec4 rg3 = textureLod( sam, (iuv+ vec2(0.5,1.5))/1024.0, lo );\r\n\tvec4 rg4 = textureLod( sam, (iuv+ vec2(1.5,1.5))/1024.0, lo );\r\n\treturn mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n}\r\n//-----------------------------------------------------------------------------------\r\n\r\nfloat terrain( in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( iChannel0, 0.001*q, 0.0 ).x );\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( iChannel1, 2.0*0.03*q, 0.0 ).y );\r\n\tfloat h = 1.9;\r\n\t#ifndef LOWDETAIL\r\n\th += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( iChannel0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t#endif\r\n\th += th*7.0;\r\n    h += 0.3*rr;\r\n    return -h;\r\n}\r\n\r\nfloat terrain2( in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureGood( iChannel0, 0.001*q, 0.0 ).x );\r\n    float rr = smoothstep( 0.1, 0.5, textureGood( iChannel1, 2.0*0.03*q, 0.0 ).y );\r\n\tfloat h = 1.9;\r\n\th += th*7.0;\r\n    return -h;\r\n}\r\n\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n\tfloat h = terrain( p.xz );\r\n\tfloat dis = displacement( 0.25*p*vec3(1.0,4.0,1.0) );\r\n\tdis *= 3.0;\r\n\treturn vec4( (dis + p.y-h)*0.25, p.x, h, 0.0 );\r\n}\r\n\r\nvec4 intersect( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float t = 0.1;\r\n    vec3 res = vec3(0.0);\r\n    for( int i=0; i<256; i++ )\r\n    {\r\n\t    vec4 tmp = map( ro+rd*t );\r\n        res = tmp.ywz;\r\n        t += tmp.x;\r\n        if( tmp.x<(0.001*t) || t>tmax ) break;\r\n    }\r\n\r\n    return vec4( t, res );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\r\n}\r\n\r\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\r\n{\r\n    float res = 1.0;\r\n    float t = mint;\r\n    for( int i=0; i<50; i++ )\r\n    {\r\n        float h = map(ro + rd*t).x;\r\n        res = min( res, k*h/t );\r\n\t\tt += clamp( h, 0.5, 1.0 );\r\n\t\tif( h<0.001 ) break;\r\n    }\r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\n// Oren-Nayar\r\nfloat Diffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n{\r\n\t\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv,n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\nvec3 cpath( float t )\r\n{\r\n\tvec3 pos = vec3( 0.0, 0.0, 95.0 + t );\r\n\t\r\n\tfloat a = smoothstep(5.0,20.0,t);\r\n\tpos.xz += a*150.0 * cos( vec2(5.0,6.0) + 1.0*0.01*t );\r\n\tpos.xz -= a*150.0 * cos( vec2(5.0,6.0) );\r\n\tpos.xz += a* 50.0 * cos( vec2(0.0,3.5) + 6.0*0.01*t );\r\n\tpos.xz -= a* 50.0 * cos( vec2(0.0,3.5) );\r\n\r\n\treturn pos;\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.0);\r\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\r\n\r\n\t\r\n    //-----------------------------------------------------\r\n    // camera\r\n    //-----------------------------------------------------\r\n\r\n\tfloat an = 0.5*(iTime-5.0);// + 12.0*(m.x-0.5);\r\n\tvec3 ro = cpath( an + 0.0 );\r\n\tvec3 ta = cpath( an + 10.0 *1.0);\r\n\tta = mix( ro + vec3(0.0,0.0,1.0), ta, smoothstep(5.0,25.0,an) );\r\n    ro.y = terrain2( ro.xz ) - 0.5;\r\n\tta.y = ro.y - 0.1;\r\n\tta.xy += step(0.01,m.x)*(m.xy-0.5)*4.0*vec2(-1.0,1.0);\r\n\tfloat rl = -0.1*cos(0.05*6.2831*an);\r\n    // camera to world transform    \r\n    mat3 cam = setCamera( ro, ta, rl );\r\n    \r\n    // ray\r\n\tvec3 rd = normalize( cam * vec3(p.xy, 2.0) );\r\n\r\n    //-----------------------------------------------------\r\n\t// render\r\n    //-----------------------------------------------------\r\n\r\n\tvec3 klig = normalize(vec3(-1.0,0.19,0.4));\r\n\t\r\n\tfloat sun = clamp(dot(klig,rd),0.0,1.0 );\r\n\r\n\tvec3 hor = mix( 1.2*vec3(0.70,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sun );\r\n\t\r\n    vec3 col = mix( vec3(0.2,0.6,.9), hor, exp(-(4.0+2.0*(1.0-sun))*max(0.0,rd.y-0.1)) );\r\n    col *= 0.5;\r\n\tcol += 0.8*vec3(1.0,0.8,0.7)*pow(sun,512.0);\r\n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow(sun,32.0);\r\n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow(sun,4.0);\r\n\t\r\n\tvec3 bcol = col;\r\n\t\r\n\t// clouds\r\n\tfloat pt = (1000.0-ro.y)/rd.y; \r\n\tif( pt>0.0 )\r\n\t{\r\n        vec3 spos = ro + pt*rd;\r\n        float clo = texture( iChannel0, 0.00006*spos.xz ).x;\t\r\n        vec3 cloCol = mix( vec3(0.4,0.5,0.6), vec3(1.3,0.6,0.4), pow(sun,2.0))*(0.5+0.5*clo);\r\n        col = mix( col, cloCol, 0.5*smoothstep( 0.4, 1.0, clo ) );\r\n\t}\r\n\t\r\n\t\r\n\t// raymarch\r\n    float tmax = 120.0;\r\n    \r\n    // bounding plane    \r\n    float bt = (0.0-ro.y)/rd.y; \r\n\tif( bt>0.0 ) tmax = min( tmax, bt );\r\n        \r\n    vec4 tmat = intersect( ro, rd, tmax);\r\n    if( tmat.x<tmax )\r\n    {\r\n        // geometry\r\n        vec3 pos = ro + tmat.x*rd;\r\n        vec3 nor = calcNormal( pos, tmat.x );\r\n\t\tvec3 ref = reflect( rd, nor );\r\n\r\n\t\tfloat occ = smoothstep( 0.0, 1.5, pos.y + 11.5 ) * (1.0 - displacement( 0.25*pos*vec3(1.0,4.0,1.0) ));\r\n\r\n\t\t// materials\r\n\t\tvec4 mate = vec4(0.5,0.5,0.5,0.0);\r\n\t\t\r\n\t\t//if( tmat.z<0.5 )\r\n\t\t{\r\n\t\t\tvec3 uvw = 1.0*pos;\r\n\r\n\t\t\tvec3 bnor;\r\n\t\t\tfloat be = 1.0/1024.0;\r\n\t\t\tfloat bf = 0.4;\r\n\t\t\tbnor.x = texcube( iChannel0, bf*uvw+vec3(be,0.0,0.0), nor ).x - texcube( iChannel0, bf*uvw-vec3(be,0.0,0.0), nor ).x;\r\n\t\t\tbnor.y = texcube( iChannel0, bf*uvw+vec3(0.0,be,0.0), nor ).x - texcube( iChannel0, bf*uvw-vec3(0.0,be,0.0), nor ).x;\r\n\t\t\tbnor.z = texcube( iChannel0, bf*uvw+vec3(0.0,0.0,be), nor ).x - texcube( iChannel0, bf*uvw-vec3(0.0,0.0,be), nor ).x;\r\n\t\t\tbnor = normalize(bnor);\r\n\t\t\tfloat amo = 0.2  + 0.25*(1.0-smoothstep(0.6,0.7,nor.y) );\r\n\t\t\tnor = normalize( nor + amo*(bnor-nor*dot(bnor,nor)) );\r\n\r\n\t\t\tvec3 te = texcube( iChannel0, 0.15*uvw, nor ).xyz;\r\n\t\t\tte = 0.05 + te;\r\n\t\t\tmate.xyz = 0.6*te;\r\n\t\t\tmate.w = 1.5*(0.5+0.5*te.x);\r\n\t\t\tfloat th = smoothstep( 0.1, 0.4, texcube( iChannel0, 0.002*uvw, nor ).x );\r\n\t\t\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.4*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\t\t\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep( 0.0, 1.0, nor.y ) );\r\n\t\t\tmate.xyz *= 0.5;\r\n\t\t\tfloat rr = smoothstep( 0.2, 0.4, texcube( iChannel1, 2.0*0.02*uvw, nor ).y );\r\n\t\t\tmate.xyz *= mix( vec3(1.0), 1.5*vec3(0.25,0.24,0.22)*1.5, rr );\r\n\t\t\tmate.xyz *= 1.5*pow(texcube( iChannel3, 8.0*uvw, nor ).xyz,vec3(0.5));\r\n            mate = mix( mate, vec4(0.7,0.7,0.7,.0), smoothstep(0.8,0.9,nor.y + nor.x*0.6*te.x*te.x ));\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tmate.xyz *= 1.5;\r\n\t\t}\r\n\t\t\r\n\t\tvec3 blig = normalize(vec3(-klig.x,0.0,-klig.z));\r\n\t\tvec3 slig = vec3( 0.0, 1.0, 0.0 );\r\n\t\t\t\r\n\t\t// lighting\r\n        float sky = 0.0;\r\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0, 0.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3( 3.0, 1.0, 0.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3(-3.0, 1.0, 0.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0, 3.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0,-3.0 )), nor, -rd, 1.0 );\r\n\t\tfloat dif = Diffuse( klig, nor, -rd, 1.0 );\r\n\t\tfloat bac = Diffuse( blig, nor, -rd, 1.0 );\r\n\r\n\r\n\t\tfloat sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.01*nor, klig, 0.005, 64.0 );\r\n        float spe = mate.w*pow( clamp(dot(reflect(rd,nor),klig),0.0,1.0),2.0)*clamp(dot(nor,klig),0.0,1.0);\r\n\t\t\r\n\t\t// lights\r\n\t\tvec3 lin = vec3(0.0);\r\n\t\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha );\r\n\t\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\t\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\t    lin += 0.5*vec3(spe)*sha*occ;\r\n\t\t\r\n\t\t// surface-light interacion\r\n\t\tcol = mate.xyz * lin;\r\n\r\n\t\t// fog\r\n        bcol = 0.7*mix( vec3(0.2,0.5,1.0)*0.82, bcol, 0.15+0.8*sun ); col = mix( col, bcol, 1.0-exp(-0.02*tmat.x) );\t\t\r\n\t}\r\n\t\r\n\r\n\tcol += 0.15*vec3(1.0,0.9,0.6)*pow( sun, 6.0 );\r\n\t\r\n\t//-----------------------------------------------------\r\n\t// postprocessing\r\n    //-----------------------------------------------------\r\n    col *= 1.0 - 0.25*pow(1.0-clamp(dot(cam[2],klig),0.0,1.0),3.0);\r\n\t\r\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\r\n\r\n\tcol *= vec3(1.1,1.0,1.0);\r\n\tcol = col*col*(3.0-2.0*col);\r\n\tcol = pow( col, vec3(0.9,1.0,1.0) );\r\n\r\n\tcol = mix( col, vec3(dot(col,vec3(0.333))), 0.4 );\r\n\tcol = col*0.5+0.5*col*col*(3.0-2.0*col);\r\n\t\r\n\tcol *= 0.3 + 0.7*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\r\n    col *= smoothstep(0.0,2.5,iTime);\r\n\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":null,"published":0}],"Info":{"Name":"Canyon","id":null,"date":null,"viewed":0,"name":"Canyon","description":"Another terrain, a quick one. Same concept as Elevated, just a different terrain shape.","likes":0,"published":null,"tags":["procedural"," 3d"," raymarching"," distancefield"," terrain"," elevated"]},"ver":null,"info":{"Name":"Canyon","id":null,"date":null,"viewed":0,"name":"Canyon","description":"Another terrain, a quick one. Same concept as Elevated, just a different terrain shape.","likes":0,"published":null,"tags":["procedural"," 3d"," raymarching"," distancefield"," terrain"," elevated"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2014\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\n#define LOWDETAIL\r\n//#define HIGH_QUALITY_NOISE\r\n\r\nfloat noise1( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#ifndef HIGH_QUALITY_NOISE\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel2, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n#else\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( iChannel2, (uv+ vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( iChannel2, (uv+ vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( iChannel2, (uv+ vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( iChannel2, (uv+ vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\t\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\n//-----------------------------------------------------------------------------------\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n                    -0.80,  0.36, -0.48,\r\n                    -0.60, -0.48,  0.64 );\r\n\r\nfloat displacement( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise1( p ); p = m*p*2.02;\r\n    f += 0.2500*noise1( p ); p = m*p*2.03;\r\n    f += 0.1250*noise1( p ); p = m*p*2.01;\r\n\t#ifndef LOWDETAIL\r\n    f += 0.0625*noise1( p ); \r\n\t#endif\r\n    return f;\r\n}\r\n\r\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\r\n{\r\n\tvec4 x = texture( sam, p.yz );\r\n\tvec4 y = texture( sam, p.zx );\r\n\tvec4 z = texture( sam, p.xy );\r\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\r\n}\r\n\r\n\r\nvec4 textureGood( sampler2D sam, vec2 uv, float lo )\r\n{\r\n    uv = uv*1024.0 - 0.5;\r\n    vec2 iuv = floor(uv);\r\n    vec2 f = fract(uv);\r\n\tvec4 rg1 = textureLod( sam, (iuv+ vec2(0.5,0.5))/1024.0, lo );\r\n\tvec4 rg2 = textureLod( sam, (iuv+ vec2(1.5,0.5))/1024.0, lo );\r\n\tvec4 rg3 = textureLod( sam, (iuv+ vec2(0.5,1.5))/1024.0, lo );\r\n\tvec4 rg4 = textureLod( sam, (iuv+ vec2(1.5,1.5))/1024.0, lo );\r\n\treturn mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n}\r\n//-----------------------------------------------------------------------------------\r\n\r\nfloat terrain( in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( iChannel0, 0.001*q, 0.0 ).x );\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( iChannel1, 2.0*0.03*q, 0.0 ).y );\r\n\tfloat h = 1.9;\r\n\t#ifndef LOWDETAIL\r\n\th += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( iChannel0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t#endif\r\n\th += th*7.0;\r\n    h += 0.3*rr;\r\n    return -h;\r\n}\r\n\r\nfloat terrain2( in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureGood( iChannel0, 0.001*q, 0.0 ).x );\r\n    float rr = smoothstep( 0.1, 0.5, textureGood( iChannel1, 2.0*0.03*q, 0.0 ).y );\r\n\tfloat h = 1.9;\r\n\th += th*7.0;\r\n    return -h;\r\n}\r\n\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n\tfloat h = terrain( p.xz );\r\n\tfloat dis = displacement( 0.25*p*vec3(1.0,4.0,1.0) );\r\n\tdis *= 3.0;\r\n\treturn vec4( (dis + p.y-h)*0.25, p.x, h, 0.0 );\r\n}\r\n\r\nvec4 intersect( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float t = 0.1;\r\n    vec3 res = vec3(0.0);\r\n    for( int i=0; i<256; i++ )\r\n    {\r\n\t    vec4 tmp = map( ro+rd*t );\r\n        res = tmp.ywz;\r\n        t += tmp.x;\r\n        if( tmp.x<(0.001*t) || t>tmax ) break;\r\n    }\r\n\r\n    return vec4( t, res );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\r\n}\r\n\r\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\r\n{\r\n    float res = 1.0;\r\n    float t = mint;\r\n    for( int i=0; i<50; i++ )\r\n    {\r\n        float h = map(ro + rd*t).x;\r\n        res = min( res, k*h/t );\r\n\t\tt += clamp( h, 0.5, 1.0 );\r\n\t\tif( h<0.001 ) break;\r\n    }\r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\n// Oren-Nayar\r\nfloat Diffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n{\r\n\t\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv,n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\nvec3 cpath( float t )\r\n{\r\n\tvec3 pos = vec3( 0.0, 0.0, 95.0 + t );\r\n\t\r\n\tfloat a = smoothstep(5.0,20.0,t);\r\n\tpos.xz += a*150.0 * cos( vec2(5.0,6.0) + 1.0*0.01*t );\r\n\tpos.xz -= a*150.0 * cos( vec2(5.0,6.0) );\r\n\tpos.xz += a* 50.0 * cos( vec2(0.0,3.5) + 6.0*0.01*t );\r\n\tpos.xz -= a* 50.0 * cos( vec2(0.0,3.5) );\r\n\r\n\treturn pos;\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.0);\r\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\r\n\r\n\t\r\n    //-----------------------------------------------------\r\n    // camera\r\n    //-----------------------------------------------------\r\n\r\n\tfloat an = 0.5*(iTime-5.0);// + 12.0*(m.x-0.5);\r\n\tvec3 ro = cpath( an + 0.0 );\r\n\tvec3 ta = cpath( an + 10.0 *1.0);\r\n\tta = mix( ro + vec3(0.0,0.0,1.0), ta, smoothstep(5.0,25.0,an) );\r\n    ro.y = terrain2( ro.xz ) - 0.5;\r\n\tta.y = ro.y - 0.1;\r\n\tta.xy += step(0.01,m.x)*(m.xy-0.5)*4.0*vec2(-1.0,1.0);\r\n\tfloat rl = -0.1*cos(0.05*6.2831*an);\r\n    // camera to world transform    \r\n    mat3 cam = setCamera( ro, ta, rl );\r\n    \r\n    // ray\r\n\tvec3 rd = normalize( cam * vec3(p.xy, 2.0) );\r\n\r\n    //-----------------------------------------------------\r\n\t// render\r\n    //-----------------------------------------------------\r\n\r\n\tvec3 klig = normalize(vec3(-1.0,0.19,0.4));\r\n\t\r\n\tfloat sun = clamp(dot(klig,rd),0.0,1.0 );\r\n\r\n\tvec3 hor = mix( 1.2*vec3(0.70,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sun );\r\n\t\r\n    vec3 col = mix( vec3(0.2,0.6,.9), hor, exp(-(4.0+2.0*(1.0-sun))*max(0.0,rd.y-0.1)) );\r\n    col *= 0.5;\r\n\tcol += 0.8*vec3(1.0,0.8,0.7)*pow(sun,512.0);\r\n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow(sun,32.0);\r\n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow(sun,4.0);\r\n\t\r\n\tvec3 bcol = col;\r\n\t\r\n\t// clouds\r\n\tfloat pt = (1000.0-ro.y)/rd.y; \r\n\tif( pt>0.0 )\r\n\t{\r\n        vec3 spos = ro + pt*rd;\r\n        float clo = texture( iChannel0, 0.00006*spos.xz ).x;\t\r\n        vec3 cloCol = mix( vec3(0.4,0.5,0.6), vec3(1.3,0.6,0.4), pow(sun,2.0))*(0.5+0.5*clo);\r\n        col = mix( col, cloCol, 0.5*smoothstep( 0.4, 1.0, clo ) );\r\n\t}\r\n\t\r\n\t\r\n\t// raymarch\r\n    float tmax = 120.0;\r\n    \r\n    // bounding plane    \r\n    float bt = (0.0-ro.y)/rd.y; \r\n\tif( bt>0.0 ) tmax = min( tmax, bt );\r\n        \r\n    vec4 tmat = intersect( ro, rd, tmax);\r\n    if( tmat.x<tmax )\r\n    {\r\n        // geometry\r\n        vec3 pos = ro + tmat.x*rd;\r\n        vec3 nor = calcNormal( pos, tmat.x );\r\n\t\tvec3 ref = reflect( rd, nor );\r\n\r\n\t\tfloat occ = smoothstep( 0.0, 1.5, pos.y + 11.5 ) * (1.0 - displacement( 0.25*pos*vec3(1.0,4.0,1.0) ));\r\n\r\n\t\t// materials\r\n\t\tvec4 mate = vec4(0.5,0.5,0.5,0.0);\r\n\t\t\r\n\t\t//if( tmat.z<0.5 )\r\n\t\t{\r\n\t\t\tvec3 uvw = 1.0*pos;\r\n\r\n\t\t\tvec3 bnor;\r\n\t\t\tfloat be = 1.0/1024.0;\r\n\t\t\tfloat bf = 0.4;\r\n\t\t\tbnor.x = texcube( iChannel0, bf*uvw+vec3(be,0.0,0.0), nor ).x - texcube( iChannel0, bf*uvw-vec3(be,0.0,0.0), nor ).x;\r\n\t\t\tbnor.y = texcube( iChannel0, bf*uvw+vec3(0.0,be,0.0), nor ).x - texcube( iChannel0, bf*uvw-vec3(0.0,be,0.0), nor ).x;\r\n\t\t\tbnor.z = texcube( iChannel0, bf*uvw+vec3(0.0,0.0,be), nor ).x - texcube( iChannel0, bf*uvw-vec3(0.0,0.0,be), nor ).x;\r\n\t\t\tbnor = normalize(bnor);\r\n\t\t\tfloat amo = 0.2  + 0.25*(1.0-smoothstep(0.6,0.7,nor.y) );\r\n\t\t\tnor = normalize( nor + amo*(bnor-nor*dot(bnor,nor)) );\r\n\r\n\t\t\tvec3 te = texcube( iChannel0, 0.15*uvw, nor ).xyz;\r\n\t\t\tte = 0.05 + te;\r\n\t\t\tmate.xyz = 0.6*te;\r\n\t\t\tmate.w = 1.5*(0.5+0.5*te.x);\r\n\t\t\tfloat th = smoothstep( 0.1, 0.4, texcube( iChannel0, 0.002*uvw, nor ).x );\r\n\t\t\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.4*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\t\t\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep( 0.0, 1.0, nor.y ) );\r\n\t\t\tmate.xyz *= 0.5;\r\n\t\t\tfloat rr = smoothstep( 0.2, 0.4, texcube( iChannel1, 2.0*0.02*uvw, nor ).y );\r\n\t\t\tmate.xyz *= mix( vec3(1.0), 1.5*vec3(0.25,0.24,0.22)*1.5, rr );\r\n\t\t\tmate.xyz *= 1.5*pow(texcube( iChannel3, 8.0*uvw, nor ).xyz,vec3(0.5));\r\n            mate = mix( mate, vec4(0.7,0.7,0.7,.0), smoothstep(0.8,0.9,nor.y + nor.x*0.6*te.x*te.x ));\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tmate.xyz *= 1.5;\r\n\t\t}\r\n\t\t\r\n\t\tvec3 blig = normalize(vec3(-klig.x,0.0,-klig.z));\r\n\t\tvec3 slig = vec3( 0.0, 1.0, 0.0 );\r\n\t\t\t\r\n\t\t// lighting\r\n        float sky = 0.0;\r\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0, 0.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3( 3.0, 1.0, 0.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3(-3.0, 1.0, 0.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0, 3.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0,-3.0 )), nor, -rd, 1.0 );\r\n\t\tfloat dif = Diffuse( klig, nor, -rd, 1.0 );\r\n\t\tfloat bac = Diffuse( blig, nor, -rd, 1.0 );\r\n\r\n\r\n\t\tfloat sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.01*nor, klig, 0.005, 64.0 );\r\n        float spe = mate.w*pow( clamp(dot(reflect(rd,nor),klig),0.0,1.0),2.0)*clamp(dot(nor,klig),0.0,1.0);\r\n\t\t\r\n\t\t// lights\r\n\t\tvec3 lin = vec3(0.0);\r\n\t\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha );\r\n\t\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\t\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\t    lin += 0.5*vec3(spe)*sha*occ;\r\n\t\t\r\n\t\t// surface-light interacion\r\n\t\tcol = mate.xyz * lin;\r\n\r\n\t\t// fog\r\n        bcol = 0.7*mix( vec3(0.2,0.5,1.0)*0.82, bcol, 0.15+0.8*sun ); col = mix( col, bcol, 1.0-exp(-0.02*tmat.x) );\t\t\r\n\t}\r\n\t\r\n\r\n\tcol += 0.15*vec3(1.0,0.9,0.6)*pow( sun, 6.0 );\r\n\t\r\n\t//-----------------------------------------------------\r\n\t// postprocessing\r\n    //-----------------------------------------------------\r\n    col *= 1.0 - 0.25*pow(1.0-clamp(dot(cam[2],klig),0.0,1.0),3.0);\r\n\t\r\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\r\n\r\n\tcol *= vec3(1.1,1.0,1.0);\r\n\tcol = col*col*(3.0-2.0*col);\r\n\tcol = pow( col, vec3(0.9,1.0,1.0) );\r\n\r\n\tcol = mix( col, vec3(dot(col,vec3(0.333))), 0.4 );\r\n\tcol = col*0.5+0.5*col*col*(3.0-2.0*col);\r\n\t\r\n\tcol *= 0.3 + 0.7*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\r\n    col *= smoothstep(0.0,2.5,iTime);\r\n\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":null,"published":0}],"outputs":[],"code":"// Created by inigo quilez - iq/2014\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n//-----------------------------------------------------------------------------------\r\n\r\n#define LOWDETAIL\r\n//#define HIGH_QUALITY_NOISE\r\n\r\nfloat noise1( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#ifndef HIGH_QUALITY_NOISE\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel2, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n#else\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( iChannel2, (uv+ vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( iChannel2, (uv+ vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( iChannel2, (uv+ vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( iChannel2, (uv+ vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\t\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\n//-----------------------------------------------------------------------------------\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n                    -0.80,  0.36, -0.48,\r\n                    -0.60, -0.48,  0.64 );\r\n\r\nfloat displacement( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise1( p ); p = m*p*2.02;\r\n    f += 0.2500*noise1( p ); p = m*p*2.03;\r\n    f += 0.1250*noise1( p ); p = m*p*2.01;\r\n\t#ifndef LOWDETAIL\r\n    f += 0.0625*noise1( p ); \r\n\t#endif\r\n    return f;\r\n}\r\n\r\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\r\n{\r\n\tvec4 x = texture( sam, p.yz );\r\n\tvec4 y = texture( sam, p.zx );\r\n\tvec4 z = texture( sam, p.xy );\r\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\r\n}\r\n\r\n\r\nvec4 textureGood( sampler2D sam, vec2 uv, float lo )\r\n{\r\n    uv = uv*1024.0 - 0.5;\r\n    vec2 iuv = floor(uv);\r\n    vec2 f = fract(uv);\r\n\tvec4 rg1 = textureLod( sam, (iuv+ vec2(0.5,0.5))/1024.0, lo );\r\n\tvec4 rg2 = textureLod( sam, (iuv+ vec2(1.5,0.5))/1024.0, lo );\r\n\tvec4 rg3 = textureLod( sam, (iuv+ vec2(0.5,1.5))/1024.0, lo );\r\n\tvec4 rg4 = textureLod( sam, (iuv+ vec2(1.5,1.5))/1024.0, lo );\r\n\treturn mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n}\r\n//-----------------------------------------------------------------------------------\r\n\r\nfloat terrain( in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( iChannel0, 0.001*q, 0.0 ).x );\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( iChannel1, 2.0*0.03*q, 0.0 ).y );\r\n\tfloat h = 1.9;\r\n\t#ifndef LOWDETAIL\r\n\th += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( iChannel0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t#endif\r\n\th += th*7.0;\r\n    h += 0.3*rr;\r\n    return -h;\r\n}\r\n\r\nfloat terrain2( in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureGood( iChannel0, 0.001*q, 0.0 ).x );\r\n    float rr = smoothstep( 0.1, 0.5, textureGood( iChannel1, 2.0*0.03*q, 0.0 ).y );\r\n\tfloat h = 1.9;\r\n\th += th*7.0;\r\n    return -h;\r\n}\r\n\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n\tfloat h = terrain( p.xz );\r\n\tfloat dis = displacement( 0.25*p*vec3(1.0,4.0,1.0) );\r\n\tdis *= 3.0;\r\n\treturn vec4( (dis + p.y-h)*0.25, p.x, h, 0.0 );\r\n}\r\n\r\nvec4 intersect( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float t = 0.1;\r\n    vec3 res = vec3(0.0);\r\n    for( int i=0; i<256; i++ )\r\n    {\r\n\t    vec4 tmp = map( ro+rd*t );\r\n        res = tmp.ywz;\r\n        t += tmp.x;\r\n        if( tmp.x<(0.001*t) || t>tmax ) break;\r\n    }\r\n\r\n    return vec4( t, res );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\r\n}\r\n\r\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\r\n{\r\n    float res = 1.0;\r\n    float t = mint;\r\n    for( int i=0; i<50; i++ )\r\n    {\r\n        float h = map(ro + rd*t).x;\r\n        res = min( res, k*h/t );\r\n\t\tt += clamp( h, 0.5, 1.0 );\r\n\t\tif( h<0.001 ) break;\r\n    }\r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\n// Oren-Nayar\r\nfloat Diffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n{\r\n\t\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv,n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\nvec3 cpath( float t )\r\n{\r\n\tvec3 pos = vec3( 0.0, 0.0, 95.0 + t );\r\n\t\r\n\tfloat a = smoothstep(5.0,20.0,t);\r\n\tpos.xz += a*150.0 * cos( vec2(5.0,6.0) + 1.0*0.01*t );\r\n\tpos.xz -= a*150.0 * cos( vec2(5.0,6.0) );\r\n\tpos.xz += a* 50.0 * cos( vec2(0.0,3.5) + 6.0*0.01*t );\r\n\tpos.xz -= a* 50.0 * cos( vec2(0.0,3.5) );\r\n\r\n\treturn pos;\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.0);\r\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\r\n\r\n\t\r\n    //-----------------------------------------------------\r\n    // camera\r\n    //-----------------------------------------------------\r\n\r\n\tfloat an = 0.5*(iTime-5.0);// + 12.0*(m.x-0.5);\r\n\tvec3 ro = cpath( an + 0.0 );\r\n\tvec3 ta = cpath( an + 10.0 *1.0);\r\n\tta = mix( ro + vec3(0.0,0.0,1.0), ta, smoothstep(5.0,25.0,an) );\r\n    ro.y = terrain2( ro.xz ) - 0.5;\r\n\tta.y = ro.y - 0.1;\r\n\tta.xy += step(0.01,m.x)*(m.xy-0.5)*4.0*vec2(-1.0,1.0);\r\n\tfloat rl = -0.1*cos(0.05*6.2831*an);\r\n    // camera to world transform    \r\n    mat3 cam = setCamera( ro, ta, rl );\r\n    \r\n    // ray\r\n\tvec3 rd = normalize( cam * vec3(p.xy, 2.0) );\r\n\r\n    //-----------------------------------------------------\r\n\t// render\r\n    //-----------------------------------------------------\r\n\r\n\tvec3 klig = normalize(vec3(-1.0,0.19,0.4));\r\n\t\r\n\tfloat sun = clamp(dot(klig,rd),0.0,1.0 );\r\n\r\n\tvec3 hor = mix( 1.2*vec3(0.70,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sun );\r\n\t\r\n    vec3 col = mix( vec3(0.2,0.6,.9), hor, exp(-(4.0+2.0*(1.0-sun))*max(0.0,rd.y-0.1)) );\r\n    col *= 0.5;\r\n\tcol += 0.8*vec3(1.0,0.8,0.7)*pow(sun,512.0);\r\n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow(sun,32.0);\r\n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow(sun,4.0);\r\n\t\r\n\tvec3 bcol = col;\r\n\t\r\n\t// clouds\r\n\tfloat pt = (1000.0-ro.y)/rd.y; \r\n\tif( pt>0.0 )\r\n\t{\r\n        vec3 spos = ro + pt*rd;\r\n        float clo = texture( iChannel0, 0.00006*spos.xz ).x;\t\r\n        vec3 cloCol = mix( vec3(0.4,0.5,0.6), vec3(1.3,0.6,0.4), pow(sun,2.0))*(0.5+0.5*clo);\r\n        col = mix( col, cloCol, 0.5*smoothstep( 0.4, 1.0, clo ) );\r\n\t}\r\n\t\r\n\t\r\n\t// raymarch\r\n    float tmax = 120.0;\r\n    \r\n    // bounding plane    \r\n    float bt = (0.0-ro.y)/rd.y; \r\n\tif( bt>0.0 ) tmax = min( tmax, bt );\r\n        \r\n    vec4 tmat = intersect( ro, rd, tmax);\r\n    if( tmat.x<tmax )\r\n    {\r\n        // geometry\r\n        vec3 pos = ro + tmat.x*rd;\r\n        vec3 nor = calcNormal( pos, tmat.x );\r\n\t\tvec3 ref = reflect( rd, nor );\r\n\r\n\t\tfloat occ = smoothstep( 0.0, 1.5, pos.y + 11.5 ) * (1.0 - displacement( 0.25*pos*vec3(1.0,4.0,1.0) ));\r\n\r\n\t\t// materials\r\n\t\tvec4 mate = vec4(0.5,0.5,0.5,0.0);\r\n\t\t\r\n\t\t//if( tmat.z<0.5 )\r\n\t\t{\r\n\t\t\tvec3 uvw = 1.0*pos;\r\n\r\n\t\t\tvec3 bnor;\r\n\t\t\tfloat be = 1.0/1024.0;\r\n\t\t\tfloat bf = 0.4;\r\n\t\t\tbnor.x = texcube( iChannel0, bf*uvw+vec3(be,0.0,0.0), nor ).x - texcube( iChannel0, bf*uvw-vec3(be,0.0,0.0), nor ).x;\r\n\t\t\tbnor.y = texcube( iChannel0, bf*uvw+vec3(0.0,be,0.0), nor ).x - texcube( iChannel0, bf*uvw-vec3(0.0,be,0.0), nor ).x;\r\n\t\t\tbnor.z = texcube( iChannel0, bf*uvw+vec3(0.0,0.0,be), nor ).x - texcube( iChannel0, bf*uvw-vec3(0.0,0.0,be), nor ).x;\r\n\t\t\tbnor = normalize(bnor);\r\n\t\t\tfloat amo = 0.2  + 0.25*(1.0-smoothstep(0.6,0.7,nor.y) );\r\n\t\t\tnor = normalize( nor + amo*(bnor-nor*dot(bnor,nor)) );\r\n\r\n\t\t\tvec3 te = texcube( iChannel0, 0.15*uvw, nor ).xyz;\r\n\t\t\tte = 0.05 + te;\r\n\t\t\tmate.xyz = 0.6*te;\r\n\t\t\tmate.w = 1.5*(0.5+0.5*te.x);\r\n\t\t\tfloat th = smoothstep( 0.1, 0.4, texcube( iChannel0, 0.002*uvw, nor ).x );\r\n\t\t\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.4*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\t\t\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep( 0.0, 1.0, nor.y ) );\r\n\t\t\tmate.xyz *= 0.5;\r\n\t\t\tfloat rr = smoothstep( 0.2, 0.4, texcube( iChannel1, 2.0*0.02*uvw, nor ).y );\r\n\t\t\tmate.xyz *= mix( vec3(1.0), 1.5*vec3(0.25,0.24,0.22)*1.5, rr );\r\n\t\t\tmate.xyz *= 1.5*pow(texcube( iChannel3, 8.0*uvw, nor ).xyz,vec3(0.5));\r\n            mate = mix( mate, vec4(0.7,0.7,0.7,.0), smoothstep(0.8,0.9,nor.y + nor.x*0.6*te.x*te.x ));\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tmate.xyz *= 1.5;\r\n\t\t}\r\n\t\t\r\n\t\tvec3 blig = normalize(vec3(-klig.x,0.0,-klig.z));\r\n\t\tvec3 slig = vec3( 0.0, 1.0, 0.0 );\r\n\t\t\t\r\n\t\t// lighting\r\n        float sky = 0.0;\r\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0, 0.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3( 3.0, 1.0, 0.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3(-3.0, 1.0, 0.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0, 3.0 )), nor, -rd, 1.0 );\r\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0,-3.0 )), nor, -rd, 1.0 );\r\n\t\tfloat dif = Diffuse( klig, nor, -rd, 1.0 );\r\n\t\tfloat bac = Diffuse( blig, nor, -rd, 1.0 );\r\n\r\n\r\n\t\tfloat sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.01*nor, klig, 0.005, 64.0 );\r\n        float spe = mate.w*pow( clamp(dot(reflect(rd,nor),klig),0.0,1.0),2.0)*clamp(dot(nor,klig),0.0,1.0);\r\n\t\t\r\n\t\t// lights\r\n\t\tvec3 lin = vec3(0.0);\r\n\t\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha );\r\n\t\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\t\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\t    lin += 0.5*vec3(spe)*sha*occ;\r\n\t\t\r\n\t\t// surface-light interacion\r\n\t\tcol = mate.xyz * lin;\r\n\r\n\t\t// fog\r\n        bcol = 0.7*mix( vec3(0.2,0.5,1.0)*0.82, bcol, 0.15+0.8*sun ); col = mix( col, bcol, 1.0-exp(-0.02*tmat.x) );\t\t\r\n\t}\r\n\t\r\n\r\n\tcol += 0.15*vec3(1.0,0.9,0.6)*pow( sun, 6.0 );\r\n\t\r\n\t//-----------------------------------------------------\r\n\t// postprocessing\r\n    //-----------------------------------------------------\r\n    col *= 1.0 - 0.25*pow(1.0-clamp(dot(cam[2],klig),0.0,1.0),3.0);\r\n\t\r\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\r\n\r\n\tcol *= vec3(1.1,1.0,1.0);\r\n\tcol = col*col*(3.0-2.0*col);\r\n\tcol = pow( col, vec3(0.9,1.0,1.0) );\r\n\r\n\tcol = mix( col, vec3(dot(col,vec3(0.333))), 0.4 );\r\n\tcol = col*0.5+0.5*col*col*(3.0-2.0*col);\r\n\t\r\n\tcol *= 0.3 + 0.7*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\r\n    col *= smoothstep(0.0,2.5,iTime);\r\n\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"const float MATH_PI = float(3.14159);\r\n\r\nconst float MENU_SURFACE = 0.;\r\nconst float MENU_METAL = 1.;\r\nconst float MENU_DIELECTRIC = 2.;\r\nconst float MENU_ROUGHNESS = 3.;\r\nconst float MENU_BASE_COLOR = 4.;\r\nconst float MENU_LIGHTING = 5.;\r\nconst float MENU_DIFFUSE = 6.;\r\nconst float MENU_SPECULAR = 7.;\r\nconst float MENU_DISTR = 8.;\r\nconst float MENU_FRESNEL = 9.;\r\nconst float MENU_GEOMETRY = 10.;\r\n\r\nconst vec3 BASE_COLORS[6] = vec3[6]\r\n(\r\n\tvec3(0.74),\r\n\tvec3(0.51, 0.72, 0.81),\r\n\tvec3(0.66, .85, .42),\r\n\tvec3(0.87, 0.53, 0.66),\r\n\tvec3(0.51, 0.46, 0.74),\r\n\tvec3(0.78, 0.71, 0.45)\r\n\t);\r\n\r\nstruct AppState\r\n{\r\n\tfloat\tmenuId;\r\n\tfloat\tmetal;\r\n\tfloat   roughness;\r\n\tfloat   baseColor;\r\n\tfloat   focus;\r\n\tfloat   focusObjRot;\r\n\tfloat   objRot;\r\n};\r\n\r\nvec4 LoadValue(int x, int y)\r\n{\r\n\treturn texelFetch(iChannel0, ivec2(x, y), 0);\r\n}\r\n\r\nvoid LoadState(out AppState s)\r\n{\r\n\tvec4 data;\r\n\r\n\tdata = LoadValue(0, 0);\r\n\ts.menuId = data.x;\r\n\ts.metal = data.y;\r\n\ts.roughness = data.z;\r\n\ts.baseColor = data.w;\r\n\r\n\tdata = LoadValue(1, 0);\r\n\ts.focus = data.x;\r\n\ts.focusObjRot = data.y;\r\n\ts.objRot = data.z;\r\n}\r\n\r\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\r\n{\r\n\tfragCoord = floor(fragCoord);\r\n\tfragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\r\n}\r\n\r\nfloat saturate(float x)\r\n{\r\n\treturn clamp(x, 0., 1.);\r\n}\r\n\r\nvec3 saturate(vec3 x)\r\n{\r\n\treturn clamp(x, vec3(0.), vec3(1.));\r\n}\r\n\r\nfloat Smooth(float x)\r\n{\r\n\treturn smoothstep(0., 1., saturate(x));\r\n}\r\n\r\nvoid Repeat(inout float p, float w)\r\n{\r\n\tp = mod(p, w) - 0.5f * w;\r\n}\r\n\r\nfloat Circle(vec2 p, float r)\r\n{\r\n\treturn (length(p / r) - 1.) * r;\r\n}\r\n\r\nfloat Rectangle(vec2 p, vec2 b)\r\n{\r\n\tvec2 d = abs(p) - b;\r\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\r\n}\r\n\r\nvoid Rotate(inout vec2 p, float a)\r\n{\r\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\r\n}\r\n\r\nfloat Capsule(vec2 p, float r, float c)\r\n{\r\n\treturn mix(length(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\r\n}\r\n\r\nfloat Arrow(vec2 p, float a, float l, float w)\r\n{\r\n\tRotate(p, a);\r\n\tp.y += l;\r\n\r\n\tfloat body = Capsule(p, w, l);\r\n\tp.y -= w;\r\n\r\n\tfloat tip = p.y + l;\r\n\r\n\tp.y += l + w;\r\n\tRotate(p, +2.);\r\n\ttip = max(tip, p.y - 2. * w);\r\n\tRotate(p, -4.);\r\n\ttip = max(tip, p.y - 2. * w);\r\n\r\n\treturn min(body, tip);\r\n}\r\n\r\nfloat TextSDF(vec2 p, float glyph)\r\n{\r\n\tp = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\r\n\treturn 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\r\n}\r\n\r\nvoid Diagram(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tvec3 surfColor = vec3(0.9, 0.84, 0.8);\r\n\tvec3 lightColor = vec3(0.88, 0.65, 0.2);\r\n\tvec3 baseColor = BASE_COLORS[int(s.baseColor)];\r\n\tvec3 diffuseColor = s.metal == 1. ? vec3(0.) : baseColor;\r\n\tvec3 specularColor = s.metal == 1. ? baseColor : vec3(0.7);\r\n\r\n\tp -= vec2(84., 44.);\r\n\r\n\tvec2 t = p - vec2(18., 4.);\r\n\tfloat r = Rectangle(t, vec2(52., 12.));\r\n\tcolor = mix(color, surfColor, Smooth(-r * 2.));\r\n\r\n\tt.y += s.roughness * sin(t.x);\r\n\tr = Rectangle(t - vec2(0., 11.), vec2(52., 1.2));\r\n\tcolor = mix(color, surfColor * 0.6, Smooth(-r * 2.));\r\n\r\n\r\n\t// refraction\r\n\tr = 1e4;\r\n\tt = p - vec2(18., 15.);\r\n\tfor (int i = 0; i < 3; ++i)\r\n\t{\r\n\t\tr = min(r, Arrow(t - vec2(-15. + float(i) * 15., 0.), -0.4, 7., .7));\r\n\t}\r\n\tr = min(r, Arrow(t - vec2(9., -15.), 2., 4., .7));\r\n\tr = min(r, Arrow(t - vec2(17., -10.), 3.8, 18., .7));\r\n\tr = min(r, Arrow(t - vec2(-6., -14.), 0.9, 3., .7));\r\n\tr = min(r, Arrow(t - vec2(1., -19.), 2.9, 18., .7));\r\n\tr = min(r, Arrow(t - vec2(-22., -15.), 4.5, 2., .7));\r\n\tr = min(r, Arrow(t - vec2(-28., -14.), 2.6, 14., .7));\r\n\tif (s.metal != 1. && s.menuId < MENU_SPECULAR)\r\n\t{\r\n\t\tcolor = mix(color, diffuseColor, Smooth(-r * 2.));\r\n\t}\r\n\r\n\t// reflection\r\n\tr = 1e4;\r\n\tt = p - vec2(18., 15.);\r\n\tfor (int i = 0; i < 3; ++i)\r\n\t{\r\n\t\tfloat off = s.roughness * (1.5 - float(i)) * .45;\r\n\t\tr = min(r, Arrow(t - vec2(-15. + float(i) * 15., 2.), -0.5 * MATH_PI - 0.9 + off, 12., 1.));\r\n\t}\r\n\tif (s.menuId != MENU_DIFFUSE)\r\n\t{\r\n\t\tcolor = mix(color, specularColor, Smooth(-r * 2.));\r\n\t}\r\n\r\n\t// light in\r\n\tr = 1e4;\r\n\tt = p - vec2(18., 15.);\r\n\tfor (int i = 0; i < 3; ++i)\r\n\t{\r\n\t\tr = min(r, Arrow(t - vec2(12. + float(i) * 15., 22.), -0.9, 15., 1.));\r\n\t}\r\n\tcolor = mix(color, lightColor, Smooth(-r * 2.));\r\n}\r\n\r\nfloat RaySphere(vec3 rayOrigin, vec3 rayDir, vec3 spherePos, float sphereRadius)\r\n{\r\n\tvec3 oc = rayOrigin - spherePos;\r\n\r\n\tfloat b = dot(oc, rayDir);\r\n\tfloat c = dot(oc, oc) - sphereRadius * sphereRadius;\r\n\tfloat h = b * b - c;\r\n\r\n\tfloat t;\r\n\tif (h < 0.0)\r\n\t{\r\n\t\tt = -1.0;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tt = (-b - sqrt(h));\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nfloat VisibilityTerm(float roughness, float ndotv, float ndotl)\r\n{\r\n\tfloat r2 = roughness * roughness;\r\n\tfloat gv = ndotl * sqrt(ndotv * (ndotv - ndotv * r2) + r2);\r\n\tfloat gl = ndotv * sqrt(ndotl * (ndotl - ndotl * r2) + r2);\r\n\treturn 0.5 / max(gv + gl, 0.00001);\r\n}\r\n\r\nfloat DistributionTerm(float roughness, float ndoth)\r\n{\r\n\tfloat r2 = roughness * roughness;\r\n\tfloat d = (ndoth * r2 - ndoth) * ndoth + 1.0;\r\n\treturn r2 / (d * d * MATH_PI);\r\n}\r\n\r\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\r\n{\r\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\r\n\treturn fresnel;\r\n}\r\n\r\nfloat Cylinder(vec3 p, float r, float height)\r\n{\r\n\tfloat d = length(p.xz) - r;\r\n\td = max(d, abs(p.y) - height);\r\n\treturn d;\r\n}\r\n\r\nfloat Substract(float a, float b)\r\n{\r\n\treturn max(a, -b);\r\n}\r\n\r\nfloat SubstractRound(float a, float b, float r)\r\n{\r\n\tvec2 u = max(vec2(r + a, r - b), vec2(0.0, 0.0));\r\n\treturn min(-r, max(a, -b)) + length(u);\r\n}\r\n\r\nfloat Union(float a, float b)\r\n{\r\n\treturn min(a, b);\r\n}\r\n\r\nfloat Box(vec3 p, vec3 b)\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nfloat Sphere(vec3 p, float s)\r\n{\r\n\treturn length(p) - s;\r\n}\r\n\r\nfloat Torus(vec3 p, float sr, float lr)\r\n{\r\n\treturn length(vec2(length(p.xz) - lr, p.y)) - sr;\r\n}\r\n\r\nfloat Disc(vec3 p, float r, float t)\r\n{\r\n\tfloat l = length(p.xz) - r;\r\n\treturn l < 0. ? abs(p.y) - t : length(vec2(p.y, l)) - t;\r\n}\r\n\r\nfloat UnionRound(float a, float b, float k)\r\n{\r\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k * h * (1.0 - h);\r\n}\r\n\r\nfloat Scene(vec3 p, mat3 localToWorld)\r\n{\r\n\tp = p * localToWorld;\r\n\r\n\t// ring\r\n\tvec3 t = p;\r\n\tt.y -= -.7;\r\n\tfloat r = Substract(Disc(t, 0.9, .1), Cylinder(t, .7, 2.));\r\n\tvec3 t2 = t - vec3(0., 0., 1.0);\r\n\tRotate(t2.xz, 0.25 * MATH_PI);\r\n\tr = Substract(r, Box(t2, vec3(.5)));\r\n\tr = Union(r, Disc(t + vec3(0., 0.05, 0.), 0.85, .05));\r\n\r\n\tt = p;\r\n\tRotate(t.yz, -.3);\r\n\r\n\t// body\r\n\tfloat b = Sphere(t, .8);\r\n\tb = Substract(b, Sphere(t - vec3(0., 0., .5), .5));\r\n\tb = Substract(b, Sphere(t - vec3(0., 0., -.7), .3));\r\n\tb = Substract(b, Box(t, vec3(2., .03, 2.)));\r\n\tb = Union(b, Sphere(t, .7));\r\n\r\n\tfloat ret = Union(r, b);\r\n\treturn ret;\r\n}\r\n\r\nfloat CastRay(in vec3 ro, in vec3 rd, mat3 localToWorld)\r\n{\r\n\tconst float maxd = 5.0;\r\n\r\n\tfloat h = 0.5;\r\n\tfloat t = 0.0;\r\n\r\n\tfor (int i = 0; i < 50; ++i)\r\n\t{\r\n\t\tif (h < 0.001 || t > maxd)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\th = Scene(ro + rd * t, localToWorld);\r\n\t\tt += h;\r\n\t}\r\n\r\n\tif (t > maxd)\r\n\t{\r\n\t\tt = -1.0;\r\n\t}\r\n\r\n\treturn t;\r\n}\r\n\r\nvec3 SceneNormal(in vec3 pos, mat3 localToWorld)\r\n{\r\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\r\n\tvec3 nor = vec3(\r\n\t\tScene(pos + eps.xyy, localToWorld) - Scene(pos - eps.xyy, localToWorld),\r\n\t\tScene(pos + eps.yxy, localToWorld) - Scene(pos - eps.yxy, localToWorld),\r\n\t\tScene(pos + eps.yyx, localToWorld) - Scene(pos - eps.yyx, localToWorld));\r\n\treturn normalize(nor);\r\n}\r\n\r\nfloat SceneAO(vec3 p, vec3 n, mat3 localToWorld)\r\n{\r\n\tfloat ao = 0.0;\r\n\tfloat s = 1.0;\r\n\tfor (int i = 0; i < 6; ++i)\r\n\t{\r\n\t\tfloat off = 0.001 + 0.2 * float(i) / 5.;\r\n\t\tfloat t = Scene(n * off + p, localToWorld);\r\n\t\tao += (off - t) * s;\r\n\t\ts *= 0.4;\r\n\t}\r\n\r\n\treturn Smooth(1.0 - 12.0 * ao);\r\n}\r\n\r\n// St. Peter's Basilica SH\r\n// https://www.shadertoy.com/view/lt2GRD\r\nstruct SHCoefficients\r\n{\r\n\tvec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\r\n};\r\n\r\nconst SHCoefficients SH_STPETER = SHCoefficients(\r\n\tvec3(0.3623915, 0.2624130, 0.2326261),\r\n\tvec3(0.1759131, 0.1436266, 0.1260569),\r\n\tvec3(-0.0247311, -0.0101254, -0.0010745),\r\n\tvec3(0.0346500, 0.0223184, 0.0101350),\r\n\tvec3(0.0198140, 0.0144073, 0.0043987),\r\n\tvec3(-0.0469596, -0.0254485, -0.0117786),\r\n\tvec3(-0.0898667, -0.0760911, -0.0740964),\r\n\tvec3(0.0050194, 0.0038841, 0.0001374),\r\n\tvec3(-0.0818750, -0.0321501, 0.0033399)\r\n);\r\n\r\nvec3 SHIrradiance(vec3 nrm)\r\n{\r\n\tconst SHCoefficients c = SH_STPETER;\r\n\tconst float c1 = 0.429043;\r\n\tconst float c2 = 0.511664;\r\n\tconst float c3 = 0.743125;\r\n\tconst float c4 = 0.886227;\r\n\tconst float c5 = 0.247708;\r\n\treturn (\r\n\t\tc1 * c.l22 * (nrm.x * nrm.x - nrm.y * nrm.y) +\r\n\t\tc3 * c.l20 * nrm.z * nrm.z +\r\n\t\tc4 * c.l00 -\r\n\t\tc5 * c.l20 +\r\n\t\t2.0 * c1 * c.l2m2 * nrm.x * nrm.y +\r\n\t\t2.0 * c1 * c.l21  * nrm.x * nrm.z +\r\n\t\t2.0 * c1 * c.l2m1 * nrm.y * nrm.z +\r\n\t\t2.0 * c2 * c.l11  * nrm.x +\r\n\t\t2.0 * c2 * c.l1m1 * nrm.y +\r\n\t\t2.0 * c2 * c.l10  * nrm.z\r\n\t\t);\r\n}\r\n\r\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\r\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv)\r\n{\r\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\r\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\r\n\tvec4 r = roughness * c0 + c1;\r\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\r\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\r\n\treturn specularColor * AB.x + AB.y;\r\n}\r\n\r\nvec3 EnvRemap(vec3 c)\r\n{\r\n\treturn pow(2. * c, vec3(2.2));\r\n}\r\n\r\nvoid DrawScene(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tvec3 lightColor = vec3(2.);\r\n\tvec3 lightDir = normalize(vec3(.7, .9, -.2));\r\n\r\n\tvec3 baseColor = pow(BASE_COLORS[int(s.baseColor)], vec3(2.2));\r\n\tvec3 diffuseColor = s.metal == 1. ? vec3(0.) : baseColor;\r\n\tvec3 specularColor = s.metal == 1. ? baseColor : vec3(0.02);\r\n\tfloat roughnessE = s.roughness * s.roughness;\r\n\tfloat roughnessL = max(.01, roughnessE);\r\n\r\n\tfloat a = -iTime * .5;\r\n\tmat3 rot = mat3(\r\n\t\tvec3(cos(a), 0., -sin(a)),\r\n\t\tvec3(0., 1., 0.),\r\n\t\tvec3(sin(a), 0., cos(a))\r\n\t);\r\n\r\n\tp -= vec2(-20., 10.);\r\n\tp *= .011;\r\n\r\n\tfloat yaw = 2.7 - s.objRot;\r\n\tmat3 rotZ = mat3(\r\n\t\tvec3(cos(yaw), 0.0, -sin(yaw)),\r\n\t\tvec3(0.0, 1.0, 0.0),\r\n\t\tvec3(sin(yaw), 0.0, cos(yaw))\r\n\t);\r\n\r\n\tfloat phi = -0.1;\r\n\tmat3 rotY = mat3(\r\n\t\tvec3(1.0, 0.0, 0.0),\r\n\t\tvec3(0.0, cos(phi), sin(phi)),\r\n\t\tvec3(0.0, -sin(phi), cos(phi))\r\n\t);\r\n\r\n\tmat3 localToWorld = rotY * rotZ;\r\n\r\n\tvec3 rayOrigin = vec3(0.0, .5, -3.5);\r\n\tvec3 rayDir = normalize(vec3(p.x, p.y, 2.0));\r\n\tfloat t = CastRay(rayOrigin, rayDir, localToWorld);\r\n\tif (t > 0.0)\r\n\t{\r\n\t\tvec3 pos = rayOrigin + t * rayDir;\r\n\t\tvec3 normal = SceneNormal(pos, localToWorld);\r\n\t\tvec3 viewDir = -rayDir;\r\n\t\tvec3 refl = reflect(rayDir, normal);\r\n\r\n\t\tvec3 diffuse = vec3(0.);\r\n\t\tvec3 specular = vec3(0.);\r\n\r\n\t\tvec3 halfVec = normalize(viewDir + lightDir);\r\n\t\tfloat vdoth = saturate(dot(viewDir, halfVec));\r\n\t\tfloat ndoth = saturate(dot(normal, halfVec));\r\n\t\tfloat ndotv = saturate(dot(normal, viewDir));\r\n\t\tfloat ndotl = saturate(dot(normal, lightDir));\r\n\t\tvec3 envSpecularColor = EnvBRDFApprox(specularColor, roughnessE, ndotv);\r\n\r\n\t\tvec3 env1 = EnvRemap(texture(iChannel2, refl.xy).xyz);\r\n\t\tvec3 env2 = EnvRemap(texture(iChannel1, refl.xy).xyz);\r\n\t\tvec3 env3 = EnvRemap(SHIrradiance(refl));\r\n\t\tvec3 env = mix(env1, env2, saturate(roughnessE * 4.));\r\n\t\tenv = mix(env, env3, saturate((roughnessE - 0.25) / 0.75));\r\n\r\n\t\tdiffuse += diffuseColor * EnvRemap(SHIrradiance(normal));\r\n\t\tspecular += envSpecularColor * env;\r\n\r\n\t\tdiffuse += diffuseColor * lightColor * saturate(dot(normal, lightDir));\r\n\r\n\t\tvec3 lightF = FresnelTerm(specularColor, vdoth);\r\n\t\tfloat lightD = DistributionTerm(roughnessL, ndoth);\r\n\t\tfloat lightV = VisibilityTerm(roughnessL, ndotv, ndotl);\r\n\t\tspecular += lightColor * lightF * (lightD * lightV * MATH_PI * ndotl);\r\n\r\n\t\tfloat ao = SceneAO(pos, normal, localToWorld);\r\n\t\tdiffuse *= ao;\r\n\t\tspecular *= saturate(pow(ndotv + ao, roughnessE) - 1. + ao);\r\n\r\n\t\tcolor = diffuse + specular;\r\n\t\tif (s.menuId == MENU_DIFFUSE)\r\n\t\t{\r\n\t\t\tcolor = diffuse;\r\n\t\t}\r\n\t\tif (s.menuId == MENU_SPECULAR)\r\n\t\t{\r\n\t\t\tcolor = specular;\r\n\t\t}\r\n\t\tif (s.menuId == MENU_DISTR)\r\n\t\t{\r\n\t\t\tcolor = vec3(lightD);\r\n\t\t}\r\n\t\tif (s.menuId == MENU_FRESNEL)\r\n\t\t{\r\n\t\t\tcolor = envSpecularColor;\r\n\t\t}\r\n\t\tif (s.menuId == MENU_GEOMETRY)\r\n\t\t{\r\n\t\t\tcolor = vec3(lightV) * (4.0f * ndotv * ndotl);\r\n\t\t}\r\n\t\tcolor = pow(color * .4, vec3(1. / 2.2));\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// shadow\r\n\t\tfloat planeT = -(rayOrigin.y + 1.2) / rayDir.y;\r\n\t\tif (planeT > 0.0)\r\n\t\t{\r\n\t\t\tvec3 p = rayOrigin + planeT * rayDir;\r\n\r\n\t\t\tfloat radius = .7;\r\n\t\t\tcolor *= 0.7 + 0.3 * smoothstep(0.0, 1.0, saturate(length(p + vec3(0.0, 1.0, -0.5)) - radius));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid InfoText(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tp -= vec2(52, 12);\r\n\tvec2 q = p;\r\n\tif (s.menuId == MENU_METAL || s.menuId == MENU_BASE_COLOR || s.menuId == MENU_DISTR)\r\n\t{\r\n\t\tp.y -= 6.;\r\n\t}\r\n\tif (s.menuId == MENU_DIELECTRIC || s.menuId == MENU_FRESNEL)\r\n\t{\r\n\t\tp.y += 6.;\r\n\t}\r\n\tif (s.menuId == MENU_SPECULAR)\r\n\t{\r\n\t\tp.y += 6. * 6.;\r\n\r\n\t\tif (p.x < 21. && p.y >= 27. && p.y < 30.)\r\n\t\t{\r\n\t\t\tp.y = 0.;\r\n\t\t}\r\n\t\telse if (s.menuId == MENU_SPECULAR && p.y > 20. && p.y < 28. && p.x < 21.)\r\n\t\t{\r\n\t\t\tp.y += 3.;\r\n\t\t}\r\n\t}\r\n\r\n\tvec2 scale = vec2(3., 6.);\r\n\tvec2 t = floor(p / scale);\r\n\r\n\tuint v = 0u;\r\n\tif (s.menuId == MENU_SURFACE)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1702127169u : (t.x < 8. ? 1768431730u : (t.x < 12. ? 1852404852u : (t.x < 16. ? 1752440935u : (t.x < 20. ? 1970479205u : (t.x < 24. ? 1667327602u : (t.x < 28. ? 1768693861u : 7628903u))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1937334642u : (t.x < 8. ? 1717924384u : (t.x < 12. ? 1952671084u : (t.x < 16. ? 1684955424u : (t.x < 20. ? 1717924384u : (t.x < 24. ? 1952670066u : (t.x < 28. ? 32u : 0u))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1868784481u : (t.x < 8. ? 1852400754u : (t.x < 12. ? 1869881447u : (t.x < 16. ? 1701729056u : (t.x < 20. ? 1931963500u : (t.x < 24. ? 2002873376u : 0u)))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_METAL)\r\n\t{\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1635018061u : (t.x < 8. ? 1852776556u : (t.x < 12. ? 1914730860u : (t.x < 16. ? 1701602917u : (t.x < 20. ? 544437347u : (t.x < 24. ? 1751607660u : (t.x < 28. ? 1914729332u : (t.x < 32. ? 544438625u : 45u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 544432488u : (t.x < 8. ? 2037149295u : (t.x < 12. ? 1701868320u : (t.x < 16. ? 1634497891u : (t.x < 20. ? 114u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_DIELECTRIC)\r\n\t{\r\n\t\tv = t.y == 3. ? (t.x < 4. ? 1818585412u : (t.x < 8. ? 1920230245u : (t.x < 12. ? 1914725225u : (t.x < 16. ? 1701602917u : (t.x < 20. ? 544437347u : (t.x < 24. ? 1701868328u : (t.x < 28. ? 1634497891u : (t.x < 32. ? 2107762u : 0u)))))))) : v;\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 543452769u : (t.x < 8. ? 1935832435u : (t.x < 12. ? 1634103925u : (t.x < 16. ? 1931502947u : (t.x < 20. ? 1953784163u : (t.x < 24. ? 544436837u : (t.x < 28. ? 1718182952u : (t.x < 32. ? 1702065510u : 41u)))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1751607660u : (t.x < 8. ? 1634869364u : (t.x < 12. ? 539915129u : (t.x < 16. ? 1667592275u : (t.x < 20. ? 1918987381u : (t.x < 24. ? 544434464u : (t.x < 28. ? 1936617315u : (t.x < 32. ? 1953390964u : 0u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 808333438u : (t.x < 8. ? 774909234u : (t.x < 12. ? 13360u : 0u))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_ROUGHNESS)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 544367976u : (t.x < 12. ? 1718777203u : (t.x < 16. ? 1936024417u : (t.x < 20. ? 1830825248u : (t.x < 24. ? 543519343u : (t.x < 28. ? 1952539507u : (t.x < 32. ? 1701995892u : 100u)))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 544499815u : (t.x < 20. ? 1937334642u : (t.x < 24. ? 1851858988u : (t.x < 28. ? 1752440932u : (t.x < 32. ? 2126709u : 0u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1920298082u : (t.x < 8. ? 1919248754u : (t.x < 12. ? 1717924384u : (t.x < 16. ? 1952671084u : (t.x < 20. ? 1936617321u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_BASE_COLOR)\r\n\t{\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 544370502u : (t.x < 8. ? 1635018093u : (t.x < 12. ? 1679848300u : (t.x < 16. ? 1852401253u : (t.x < 20. ? 1931506533u : (t.x < 24. ? 1969448304u : (t.x < 28. ? 544366956u : (t.x < 32. ? 1869377379u : 114u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 544370502u : (t.x < 8. ? 1818585444u : (t.x < 12. ? 1920230245u : (t.x < 16. ? 544433001u : (t.x < 20. ? 1768169517u : (t.x < 24. ? 1937073766u : (t.x < 28. ? 1868767333u : (t.x < 32. ? 7499628u : 0u)))))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_LIGHTING)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1751607628u : (t.x < 8. ? 1735289204u : (t.x < 12. ? 544434464u : (t.x < 16. ? 1869770849u : (t.x < 20. ? 1634560376u : (t.x < 24. ? 543450484u : 2128226u)))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1634755955u : (t.x < 8. ? 1769234802u : (t.x < 12. ? 1679845230u : (t.x < 16. ? 1969645161u : (t.x < 20. ? 1629513075u : (t.x < 24. ? 2122862u : 0u)))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1667592307u : (t.x < 8. ? 1918987381u : (t.x < 12. ? 1836016416u : (t.x < 16. ? 1701736304u : (t.x < 20. ? 544437358u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_DIFFUSE)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1818324307u : (t.x < 8. ? 1668489324u : (t.x < 12. ? 543517793u : (t.x < 16. ? 1935832435u : (t.x < 20. ? 1634103925u : (t.x < 24. ? 1931502947u : (t.x < 28. ? 1953784163u : (t.x < 32. ? 1852404325u : 8295u)))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1635087189u : (t.x < 8. ? 981036140u : (t.x < 12. ? 1835093024u : (t.x < 16. ? 1953654114u : (t.x < 20. ? 1146241568u : (t.x < 24. ? 1713388102u : (t.x < 28. ? 824196384u : (t.x < 32. ? 543780911u : 0u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1702257960u : (t.x < 8. ? 1914730866u : (t.x < 12. ? 1696627041u : (t.x < 16. ? 1937009016u : (t.x < 20. ? 544106784u : (t.x < 24. ? 1634869345u : (t.x < 28. ? 1679844462u : (t.x < 32. ? 2716265u : 0u)))))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_SPECULAR)\r\n\t{\r\n\t\tv = t.y == 8. ? (t.x < 4. ? 1818649938u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 779380839u : (t.x < 20. ? 1970492704u : (t.x < 24. ? 2037148769u : 8250u)))))) : v;\r\n\t\tv = t.y == 7. ? (t.x < 4. ? 1802465091u : (t.x < 8. ? 1919898669u : (t.x < 12. ? 1668178290u : (t.x < 16. ? 1998597221u : (t.x < 20. ? 1751345512u : (t.x < 24. ? 1685024032u : 7564389u)))))) : v;\r\n\t\tv = t.y == 6. ? (t.x < 4. ? 1919117677u : (t.x < 8. ? 1667327599u : (t.x < 12. ? 544437349u : (t.x < 16. ? 1919250472u : (t.x < 20. ? 1952671078u : (t.x < 24. ? 1919511840u : 544370546u)))))) : v;\r\n\t\tv = t.y == 5. ? (t.x < 4. ? 1734960488u : (t.x < 8. ? 1634563176u : (t.x < 12. ? 3811696u : 0u))) : v;\r\n\t\tv = t.y == 4. ? (t.x < 4. ? 745285734u : (t.x < 8. ? 1178413430u : (t.x < 12. ? 1747744296u : (t.x < 16. ? 1814578985u : (t.x < 20. ? 1747744300u : (t.x < 24. ? 1747469353u : 41u)))))) : v;\r\n\t\tv = t.y == 3. ? (t.x < 4. ? 538976288u : (t.x < 8. ? 538976288u : (t.x < 12. ? 1848128544u : (t.x < 16. ? 673803447u : (t.x < 20. ? 695646062u : 0u))))) : v;\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 539828294u : (t.x < 8. ? 1936028230u : (t.x < 12. ? 7103854u : 0u))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 539828295u : (t.x < 8. ? 1836016967u : (t.x < 12. ? 2037544037u : 0u))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 539828292u : (t.x < 8. ? 1953720644u : (t.x < 12. ? 1969383794u : (t.x < 16. ? 1852795252u : 0u)))) : v;\r\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_DISTR)\r\n\t{\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1702109252u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 622883685u : (t.x < 20. ? 543584032u : (t.x < 24. ? 1919117677u : (t.x < 28. ? 1667327599u : 544437349u))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1769235301u : (t.x < 12. ? 1814062958u : (t.x < 16. ? 1952999273u : (t.x < 20. ? 1919903264u : (t.x < 24. ? 1730175264u : (t.x < 28. ? 1852143209u : 1919509536u))))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_FRESNEL)\r\n\t{\r\n\t\tv = t.y == 3. ? (t.x < 4. ? 1702109254u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 1629516645u : (t.x < 20. ? 1853189997u : (t.x < 24. ? 1718558836u : 32u)))))) : v;\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 544499815u : (t.x < 20. ? 544370534u : (t.x < 24. ? 1768366177u : 544105846u)))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1935832435u : (t.x < 8. ? 1851880052u : (t.x < 12. ? 539911523u : (t.x < 16. ? 1629516873u : (t.x < 20. ? 1869770864u : (t.x < 24. ? 1701340001u : 3219571u)))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 544370534u : (t.x < 8. ? 2053206631u : (t.x < 12. ? 543649385u : (t.x < 16. ? 1818717793u : (t.x < 20. ? 29541u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_GEOMETRY)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1702109255u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 1931506533u : (t.x < 20. ? 1868849512u : (t.x < 24. ? 1735289207u : (t.x < 28. ? 543584032u : 0u))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1919117677u : (t.x < 8. ? 1667327599u : (t.x < 12. ? 544437349u : (t.x < 16. ? 1701864804u : (t.x < 20. ? 1852400750u : (t.x < 24. ? 1852776551u : (t.x < 28. ? 1701344288u : 2126441u))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1634890337u : (t.x < 8. ? 1835362158u : (t.x < 12. ? 7630437u : 0u))) : v;\r\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\r\n\t}\r\n\r\n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\r\n\r\n\tvec3 textColor = vec3(.3);\r\n\r\n\tp = (p - t * scale) / scale;\r\n\tp.x = (p.x - .5) * .45 + .5;\r\n\tfloat sdf = TextSDF(p, c);\r\n\tif (c != 0.)\r\n\t{\r\n\t\tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\r\n\t}\r\n\r\n\tif (s.menuId == MENU_SPECULAR)\r\n\t{\r\n\t\tcolor = mix(color, textColor, smoothstep(.05, -.05, Capsule(q.yx - vec2(-12.3, 48.), .3, 26.)));\r\n\t}\r\n}\r\n\r\nvoid MenuText(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tp -= vec2(-160, -1);\r\n\r\n\tvec2 scale = vec2(4., 8.);\r\n\tvec2 t = floor(p / scale);\r\n\r\n\tfloat tab = 1.;\r\n\tif (t.y >= 6. && t.y < 10.)\r\n\t{\r\n\t\tp.x -= tab * scale.x;\r\n\t\tt.x -= tab;\r\n\t}\r\n\tif (t.y >= 0. && t.y < 5.)\r\n\t{\r\n\t\tp.x -= tab * scale.x;\r\n\t\tt.x -= tab;\r\n\t}\r\n\tif (t.y >= 0. && t.y < 3.)\r\n\t{\r\n\t\tp.x -= tab * scale.x;\r\n\t\tt.x -= tab;\r\n\t}\r\n\r\n\tuint v = 0u;\r\n\tv = t.y == 10. ? (t.x < 4. ? 1718777171u : (t.x < 8. ? 6644577u : 0u)) : v;\r\n\tv = t.y == 9. ? (t.x < 4. ? 1635018061u : (t.x < 8. ? 108u : 0u)) : v;\r\n\tv = t.y == 8. ? (t.x < 4. ? 1818585412u : (t.x < 8. ? 1920230245u : 25449u)) : v;\r\n\tv = t.y == 7. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 1936027240u : 115u)) : v;\r\n\tv = t.y == 6. ? (t.x < 4. ? 1702060354u : (t.x < 8. ? 1819231008u : 29295u)) : v;\r\n\tv = t.y == 5. ? (t.x < 4. ? 1751607628u : (t.x < 8. ? 1735289204u : 0u)) : v;\r\n\tv = t.y == 4. ? (t.x < 4. ? 1717987652u : (t.x < 8. ? 6648693u : 0u)) : v;\r\n\tv = t.y == 3. ? (t.x < 4. ? 1667592275u : (t.x < 8. ? 1918987381u : 0u)) : v;\r\n\tv = t.y == 2. ? (t.x < 4. ? 1953720644u : (t.x < 8. ? 1969383794u : 1852795252u)) : v;\r\n\tv = t.y == 1. ? (t.x < 4. ? 1936028230u : (t.x < 8. ? 7103854u : 0u)) : v;\r\n\tv = t.y == 0. ? (t.x < 4. ? 1836016967u : (t.x < 8. ? 2037544037u : 0u)) : v;\r\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\r\n\r\n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\r\n\r\n\tvec3 textColor = vec3(.3);\r\n\tif (t.y == 10. - s.menuId)\r\n\t{\r\n\t\ttextColor = vec3(0.74, 0.5, 0.12);\r\n\t}\r\n\r\n\tp = (p - t * scale) / scale;\r\n\tp.x = (p.x - .5) * .45 + .5;\r\n\tfloat sdf = TextSDF(p, c);\r\n\tif (c != 0.)\r\n\t{\r\n\t\tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\r\n\t}\r\n}\r\n\r\nvoid DrawMenuControls(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tp -= vec2(-110, 74);\r\n\r\n\t// radial\r\n\tfloat c2 = Capsule(p - vec2(0., -3.5), 3., 4.);\r\n\tfloat c1 = Circle(p + vec2(0., 7. - 7. * s.metal), 2.5);\r\n\r\n\t// roughness slider\r\n\tp.y += 15.;\r\n\tc1 = min(c1, Capsule(p.yx - vec2(0., 20.), 1., 20.));\r\n\tc1 = min(c1, Circle(p - vec2(40. * s.roughness, 0.), 2.5));\r\n\r\n\tp.y += 8.;\r\n\tc1 = min(c1, Rectangle(p - vec2(19.5, 0.), vec2(21.4, 4.)));\r\n\tcolor = mix(color, vec3(0.9), Smooth(-c2 * 2.));\r\n\tcolor = mix(color, vec3(0.3), Smooth(-c1 * 2.));\r\n\r\n\tfor (int i = 0; i < 6; ++i)\r\n\t{\r\n\t\tvec2 o = vec2(i == int(s.baseColor) ? 2.5 : 3.5);\r\n\t\tcolor = mix(color, BASE_COLORS[i], Smooth(-2. * Rectangle(p - vec2(2. + float(i) * 7., 0.), o)));\r\n\t}\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n\tvec2 p = -1. + 2. * q;\r\n\tp.x *= iResolution.x / iResolution.y;\r\n\tp *= 100.;\r\n\r\n\tAppState s;\r\n\tLoadState(s);\r\n\r\n\tvec3 color = vec3(1., .98, .94) * mix(1.0, 0.4, Smooth(abs(.5 - uv.y)));\r\n\tfloat vignette = q.x * q.y * (1.0 - q.x) * (1.0 - q.y);\r\n\tvignette = saturate(pow(32.0 * vignette, 0.05));\r\n\tcolor *= vignette;\r\n\r\n\tDrawScene(color, p, s);\r\n\tDiagram(color, p, s);\r\n\tInfoText(color, p, s);\r\n\tMenuText(color, p, s);\r\n\tDrawMenuControls(color, p, s);\r\n\r\n\tfragColor = vec4(color, 1.);\r\n}","inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"const float MATH_PI = float(3.14159);\r\n\r\nconst float MENU_SURFACE = 0.;\r\nconst float MENU_METAL = 1.;\r\nconst float MENU_DIELECTRIC = 2.;\r\nconst float MENU_ROUGHNESS = 3.;\r\nconst float MENU_BASE_COLOR = 4.;\r\nconst float MENU_LIGHTING = 5.;\r\nconst float MENU_DIFFUSE = 6.;\r\nconst float MENU_SPECULAR = 7.;\r\nconst float MENU_DISTR = 8.;\r\nconst float MENU_FRESNEL = 9.;\r\nconst float MENU_GEOMETRY = 10.;\r\n\r\nconst vec3 BASE_COLORS[6] = vec3[6]\r\n(\r\n\tvec3(0.74),\r\n\tvec3(0.51, 0.72, 0.81),\r\n\tvec3(0.66, .85, .42),\r\n\tvec3(0.87, 0.53, 0.66),\r\n\tvec3(0.51, 0.46, 0.74),\r\n\tvec3(0.78, 0.71, 0.45)\r\n\t);\r\n\r\nstruct AppState\r\n{\r\n\tfloat\tmenuId;\r\n\tfloat\tmetal;\r\n\tfloat   roughness;\r\n\tfloat   baseColor;\r\n\tfloat   focus;\r\n\tfloat   focusObjRot;\r\n\tfloat   objRot;\r\n};\r\n\r\nvec4 LoadValue(int x, int y)\r\n{\r\n\treturn texelFetch(iChannel0, ivec2(x, y), 0);\r\n}\r\n\r\nvoid LoadState(out AppState s)\r\n{\r\n\tvec4 data;\r\n\r\n\tdata = LoadValue(0, 0);\r\n\ts.menuId = data.x;\r\n\ts.metal = data.y;\r\n\ts.roughness = data.z;\r\n\ts.baseColor = data.w;\r\n\r\n\tdata = LoadValue(1, 0);\r\n\ts.focus = data.x;\r\n\ts.focusObjRot = data.y;\r\n\ts.objRot = data.z;\r\n}\r\n\r\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\r\n{\r\n\tfragCoord = floor(fragCoord);\r\n\tfragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\r\n}\r\n\r\nfloat saturate(float x)\r\n{\r\n\treturn clamp(x, 0., 1.);\r\n}\r\n\r\nvec3 saturate(vec3 x)\r\n{\r\n\treturn clamp(x, vec3(0.), vec3(1.));\r\n}\r\n\r\nfloat Smooth(float x)\r\n{\r\n\treturn smoothstep(0., 1., saturate(x));\r\n}\r\n\r\nvoid Repeat(inout float p, float w)\r\n{\r\n\tp = mod(p, w) - 0.5f * w;\r\n}\r\n\r\nfloat Circle(vec2 p, float r)\r\n{\r\n\treturn (length(p / r) - 1.) * r;\r\n}\r\n\r\nfloat Rectangle(vec2 p, vec2 b)\r\n{\r\n\tvec2 d = abs(p) - b;\r\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\r\n}\r\n\r\nvoid Rotate(inout vec2 p, float a)\r\n{\r\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\r\n}\r\n\r\nfloat Capsule(vec2 p, float r, float c)\r\n{\r\n\treturn mix(length(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\r\n}\r\n\r\nfloat Arrow(vec2 p, float a, float l, float w)\r\n{\r\n\tRotate(p, a);\r\n\tp.y += l;\r\n\r\n\tfloat body = Capsule(p, w, l);\r\n\tp.y -= w;\r\n\r\n\tfloat tip = p.y + l;\r\n\r\n\tp.y += l + w;\r\n\tRotate(p, +2.);\r\n\ttip = max(tip, p.y - 2. * w);\r\n\tRotate(p, -4.);\r\n\ttip = max(tip, p.y - 2. * w);\r\n\r\n\treturn min(body, tip);\r\n}\r\n\r\nfloat TextSDF(vec2 p, float glyph)\r\n{\r\n\tp = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\r\n\treturn 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\r\n}\r\n\r\nvoid Diagram(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tvec3 surfColor = vec3(0.9, 0.84, 0.8);\r\n\tvec3 lightColor = vec3(0.88, 0.65, 0.2);\r\n\tvec3 baseColor = BASE_COLORS[int(s.baseColor)];\r\n\tvec3 diffuseColor = s.metal == 1. ? vec3(0.) : baseColor;\r\n\tvec3 specularColor = s.metal == 1. ? baseColor : vec3(0.7);\r\n\r\n\tp -= vec2(84., 44.);\r\n\r\n\tvec2 t = p - vec2(18., 4.);\r\n\tfloat r = Rectangle(t, vec2(52., 12.));\r\n\tcolor = mix(color, surfColor, Smooth(-r * 2.));\r\n\r\n\tt.y += s.roughness * sin(t.x);\r\n\tr = Rectangle(t - vec2(0., 11.), vec2(52., 1.2));\r\n\tcolor = mix(color, surfColor * 0.6, Smooth(-r * 2.));\r\n\r\n\r\n\t// refraction\r\n\tr = 1e4;\r\n\tt = p - vec2(18., 15.);\r\n\tfor (int i = 0; i < 3; ++i)\r\n\t{\r\n\t\tr = min(r, Arrow(t - vec2(-15. + float(i) * 15., 0.), -0.4, 7., .7));\r\n\t}\r\n\tr = min(r, Arrow(t - vec2(9., -15.), 2., 4., .7));\r\n\tr = min(r, Arrow(t - vec2(17., -10.), 3.8, 18., .7));\r\n\tr = min(r, Arrow(t - vec2(-6., -14.), 0.9, 3., .7));\r\n\tr = min(r, Arrow(t - vec2(1., -19.), 2.9, 18., .7));\r\n\tr = min(r, Arrow(t - vec2(-22., -15.), 4.5, 2., .7));\r\n\tr = min(r, Arrow(t - vec2(-28., -14.), 2.6, 14., .7));\r\n\tif (s.metal != 1. && s.menuId < MENU_SPECULAR)\r\n\t{\r\n\t\tcolor = mix(color, diffuseColor, Smooth(-r * 2.));\r\n\t}\r\n\r\n\t// reflection\r\n\tr = 1e4;\r\n\tt = p - vec2(18., 15.);\r\n\tfor (int i = 0; i < 3; ++i)\r\n\t{\r\n\t\tfloat off = s.roughness * (1.5 - float(i)) * .45;\r\n\t\tr = min(r, Arrow(t - vec2(-15. + float(i) * 15., 2.), -0.5 * MATH_PI - 0.9 + off, 12., 1.));\r\n\t}\r\n\tif (s.menuId != MENU_DIFFUSE)\r\n\t{\r\n\t\tcolor = mix(color, specularColor, Smooth(-r * 2.));\r\n\t}\r\n\r\n\t// light in\r\n\tr = 1e4;\r\n\tt = p - vec2(18., 15.);\r\n\tfor (int i = 0; i < 3; ++i)\r\n\t{\r\n\t\tr = min(r, Arrow(t - vec2(12. + float(i) * 15., 22.), -0.9, 15., 1.));\r\n\t}\r\n\tcolor = mix(color, lightColor, Smooth(-r * 2.));\r\n}\r\n\r\nfloat RaySphere(vec3 rayOrigin, vec3 rayDir, vec3 spherePos, float sphereRadius)\r\n{\r\n\tvec3 oc = rayOrigin - spherePos;\r\n\r\n\tfloat b = dot(oc, rayDir);\r\n\tfloat c = dot(oc, oc) - sphereRadius * sphereRadius;\r\n\tfloat h = b * b - c;\r\n\r\n\tfloat t;\r\n\tif (h < 0.0)\r\n\t{\r\n\t\tt = -1.0;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tt = (-b - sqrt(h));\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nfloat VisibilityTerm(float roughness, float ndotv, float ndotl)\r\n{\r\n\tfloat r2 = roughness * roughness;\r\n\tfloat gv = ndotl * sqrt(ndotv * (ndotv - ndotv * r2) + r2);\r\n\tfloat gl = ndotv * sqrt(ndotl * (ndotl - ndotl * r2) + r2);\r\n\treturn 0.5 / max(gv + gl, 0.00001);\r\n}\r\n\r\nfloat DistributionTerm(float roughness, float ndoth)\r\n{\r\n\tfloat r2 = roughness * roughness;\r\n\tfloat d = (ndoth * r2 - ndoth) * ndoth + 1.0;\r\n\treturn r2 / (d * d * MATH_PI);\r\n}\r\n\r\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\r\n{\r\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\r\n\treturn fresnel;\r\n}\r\n\r\nfloat Cylinder(vec3 p, float r, float height)\r\n{\r\n\tfloat d = length(p.xz) - r;\r\n\td = max(d, abs(p.y) - height);\r\n\treturn d;\r\n}\r\n\r\nfloat Substract(float a, float b)\r\n{\r\n\treturn max(a, -b);\r\n}\r\n\r\nfloat SubstractRound(float a, float b, float r)\r\n{\r\n\tvec2 u = max(vec2(r + a, r - b), vec2(0.0, 0.0));\r\n\treturn min(-r, max(a, -b)) + length(u);\r\n}\r\n\r\nfloat Union(float a, float b)\r\n{\r\n\treturn min(a, b);\r\n}\r\n\r\nfloat Box(vec3 p, vec3 b)\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nfloat Sphere(vec3 p, float s)\r\n{\r\n\treturn length(p) - s;\r\n}\r\n\r\nfloat Torus(vec3 p, float sr, float lr)\r\n{\r\n\treturn length(vec2(length(p.xz) - lr, p.y)) - sr;\r\n}\r\n\r\nfloat Disc(vec3 p, float r, float t)\r\n{\r\n\tfloat l = length(p.xz) - r;\r\n\treturn l < 0. ? abs(p.y) - t : length(vec2(p.y, l)) - t;\r\n}\r\n\r\nfloat UnionRound(float a, float b, float k)\r\n{\r\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k * h * (1.0 - h);\r\n}\r\n\r\nfloat Scene(vec3 p, mat3 localToWorld)\r\n{\r\n\tp = p * localToWorld;\r\n\r\n\t// ring\r\n\tvec3 t = p;\r\n\tt.y -= -.7;\r\n\tfloat r = Substract(Disc(t, 0.9, .1), Cylinder(t, .7, 2.));\r\n\tvec3 t2 = t - vec3(0., 0., 1.0);\r\n\tRotate(t2.xz, 0.25 * MATH_PI);\r\n\tr = Substract(r, Box(t2, vec3(.5)));\r\n\tr = Union(r, Disc(t + vec3(0., 0.05, 0.), 0.85, .05));\r\n\r\n\tt = p;\r\n\tRotate(t.yz, -.3);\r\n\r\n\t// body\r\n\tfloat b = Sphere(t, .8);\r\n\tb = Substract(b, Sphere(t - vec3(0., 0., .5), .5));\r\n\tb = Substract(b, Sphere(t - vec3(0., 0., -.7), .3));\r\n\tb = Substract(b, Box(t, vec3(2., .03, 2.)));\r\n\tb = Union(b, Sphere(t, .7));\r\n\r\n\tfloat ret = Union(r, b);\r\n\treturn ret;\r\n}\r\n\r\nfloat CastRay(in vec3 ro, in vec3 rd, mat3 localToWorld)\r\n{\r\n\tconst float maxd = 5.0;\r\n\r\n\tfloat h = 0.5;\r\n\tfloat t = 0.0;\r\n\r\n\tfor (int i = 0; i < 50; ++i)\r\n\t{\r\n\t\tif (h < 0.001 || t > maxd)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\th = Scene(ro + rd * t, localToWorld);\r\n\t\tt += h;\r\n\t}\r\n\r\n\tif (t > maxd)\r\n\t{\r\n\t\tt = -1.0;\r\n\t}\r\n\r\n\treturn t;\r\n}\r\n\r\nvec3 SceneNormal(in vec3 pos, mat3 localToWorld)\r\n{\r\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\r\n\tvec3 nor = vec3(\r\n\t\tScene(pos + eps.xyy, localToWorld) - Scene(pos - eps.xyy, localToWorld),\r\n\t\tScene(pos + eps.yxy, localToWorld) - Scene(pos - eps.yxy, localToWorld),\r\n\t\tScene(pos + eps.yyx, localToWorld) - Scene(pos - eps.yyx, localToWorld));\r\n\treturn normalize(nor);\r\n}\r\n\r\nfloat SceneAO(vec3 p, vec3 n, mat3 localToWorld)\r\n{\r\n\tfloat ao = 0.0;\r\n\tfloat s = 1.0;\r\n\tfor (int i = 0; i < 6; ++i)\r\n\t{\r\n\t\tfloat off = 0.001 + 0.2 * float(i) / 5.;\r\n\t\tfloat t = Scene(n * off + p, localToWorld);\r\n\t\tao += (off - t) * s;\r\n\t\ts *= 0.4;\r\n\t}\r\n\r\n\treturn Smooth(1.0 - 12.0 * ao);\r\n}\r\n\r\n// St. Peter's Basilica SH\r\n// https://www.shadertoy.com/view/lt2GRD\r\nstruct SHCoefficients\r\n{\r\n\tvec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\r\n};\r\n\r\nconst SHCoefficients SH_STPETER = SHCoefficients(\r\n\tvec3(0.3623915, 0.2624130, 0.2326261),\r\n\tvec3(0.1759131, 0.1436266, 0.1260569),\r\n\tvec3(-0.0247311, -0.0101254, -0.0010745),\r\n\tvec3(0.0346500, 0.0223184, 0.0101350),\r\n\tvec3(0.0198140, 0.0144073, 0.0043987),\r\n\tvec3(-0.0469596, -0.0254485, -0.0117786),\r\n\tvec3(-0.0898667, -0.0760911, -0.0740964),\r\n\tvec3(0.0050194, 0.0038841, 0.0001374),\r\n\tvec3(-0.0818750, -0.0321501, 0.0033399)\r\n);\r\n\r\nvec3 SHIrradiance(vec3 nrm)\r\n{\r\n\tconst SHCoefficients c = SH_STPETER;\r\n\tconst float c1 = 0.429043;\r\n\tconst float c2 = 0.511664;\r\n\tconst float c3 = 0.743125;\r\n\tconst float c4 = 0.886227;\r\n\tconst float c5 = 0.247708;\r\n\treturn (\r\n\t\tc1 * c.l22 * (nrm.x * nrm.x - nrm.y * nrm.y) +\r\n\t\tc3 * c.l20 * nrm.z * nrm.z +\r\n\t\tc4 * c.l00 -\r\n\t\tc5 * c.l20 +\r\n\t\t2.0 * c1 * c.l2m2 * nrm.x * nrm.y +\r\n\t\t2.0 * c1 * c.l21  * nrm.x * nrm.z +\r\n\t\t2.0 * c1 * c.l2m1 * nrm.y * nrm.z +\r\n\t\t2.0 * c2 * c.l11  * nrm.x +\r\n\t\t2.0 * c2 * c.l1m1 * nrm.y +\r\n\t\t2.0 * c2 * c.l10  * nrm.z\r\n\t\t);\r\n}\r\n\r\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\r\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv)\r\n{\r\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\r\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\r\n\tvec4 r = roughness * c0 + c1;\r\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\r\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\r\n\treturn specularColor * AB.x + AB.y;\r\n}\r\n\r\nvec3 EnvRemap(vec3 c)\r\n{\r\n\treturn pow(2. * c, vec3(2.2));\r\n}\r\n\r\nvoid DrawScene(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tvec3 lightColor = vec3(2.);\r\n\tvec3 lightDir = normalize(vec3(.7, .9, -.2));\r\n\r\n\tvec3 baseColor = pow(BASE_COLORS[int(s.baseColor)], vec3(2.2));\r\n\tvec3 diffuseColor = s.metal == 1. ? vec3(0.) : baseColor;\r\n\tvec3 specularColor = s.metal == 1. ? baseColor : vec3(0.02);\r\n\tfloat roughnessE = s.roughness * s.roughness;\r\n\tfloat roughnessL = max(.01, roughnessE);\r\n\r\n\tfloat a = -iTime * .5;\r\n\tmat3 rot = mat3(\r\n\t\tvec3(cos(a), 0., -sin(a)),\r\n\t\tvec3(0., 1., 0.),\r\n\t\tvec3(sin(a), 0., cos(a))\r\n\t);\r\n\r\n\tp -= vec2(-20., 10.);\r\n\tp *= .011;\r\n\r\n\tfloat yaw = 2.7 - s.objRot;\r\n\tmat3 rotZ = mat3(\r\n\t\tvec3(cos(yaw), 0.0, -sin(yaw)),\r\n\t\tvec3(0.0, 1.0, 0.0),\r\n\t\tvec3(sin(yaw), 0.0, cos(yaw))\r\n\t);\r\n\r\n\tfloat phi = -0.1;\r\n\tmat3 rotY = mat3(\r\n\t\tvec3(1.0, 0.0, 0.0),\r\n\t\tvec3(0.0, cos(phi), sin(phi)),\r\n\t\tvec3(0.0, -sin(phi), cos(phi))\r\n\t);\r\n\r\n\tmat3 localToWorld = rotY * rotZ;\r\n\r\n\tvec3 rayOrigin = vec3(0.0, .5, -3.5);\r\n\tvec3 rayDir = normalize(vec3(p.x, p.y, 2.0));\r\n\tfloat t = CastRay(rayOrigin, rayDir, localToWorld);\r\n\tif (t > 0.0)\r\n\t{\r\n\t\tvec3 pos = rayOrigin + t * rayDir;\r\n\t\tvec3 normal = SceneNormal(pos, localToWorld);\r\n\t\tvec3 viewDir = -rayDir;\r\n\t\tvec3 refl = reflect(rayDir, normal);\r\n\r\n\t\tvec3 diffuse = vec3(0.);\r\n\t\tvec3 specular = vec3(0.);\r\n\r\n\t\tvec3 halfVec = normalize(viewDir + lightDir);\r\n\t\tfloat vdoth = saturate(dot(viewDir, halfVec));\r\n\t\tfloat ndoth = saturate(dot(normal, halfVec));\r\n\t\tfloat ndotv = saturate(dot(normal, viewDir));\r\n\t\tfloat ndotl = saturate(dot(normal, lightDir));\r\n\t\tvec3 envSpecularColor = EnvBRDFApprox(specularColor, roughnessE, ndotv);\r\n\r\n\t\tvec3 env1 = EnvRemap(texture(iChannel2, refl.xy).xyz);\r\n\t\tvec3 env2 = EnvRemap(texture(iChannel1, refl.xy).xyz);\r\n\t\tvec3 env3 = EnvRemap(SHIrradiance(refl));\r\n\t\tvec3 env = mix(env1, env2, saturate(roughnessE * 4.));\r\n\t\tenv = mix(env, env3, saturate((roughnessE - 0.25) / 0.75));\r\n\r\n\t\tdiffuse += diffuseColor * EnvRemap(SHIrradiance(normal));\r\n\t\tspecular += envSpecularColor * env;\r\n\r\n\t\tdiffuse += diffuseColor * lightColor * saturate(dot(normal, lightDir));\r\n\r\n\t\tvec3 lightF = FresnelTerm(specularColor, vdoth);\r\n\t\tfloat lightD = DistributionTerm(roughnessL, ndoth);\r\n\t\tfloat lightV = VisibilityTerm(roughnessL, ndotv, ndotl);\r\n\t\tspecular += lightColor * lightF * (lightD * lightV * MATH_PI * ndotl);\r\n\r\n\t\tfloat ao = SceneAO(pos, normal, localToWorld);\r\n\t\tdiffuse *= ao;\r\n\t\tspecular *= saturate(pow(ndotv + ao, roughnessE) - 1. + ao);\r\n\r\n\t\tcolor = diffuse + specular;\r\n\t\tif (s.menuId == MENU_DIFFUSE)\r\n\t\t{\r\n\t\t\tcolor = diffuse;\r\n\t\t}\r\n\t\tif (s.menuId == MENU_SPECULAR)\r\n\t\t{\r\n\t\t\tcolor = specular;\r\n\t\t}\r\n\t\tif (s.menuId == MENU_DISTR)\r\n\t\t{\r\n\t\t\tcolor = vec3(lightD);\r\n\t\t}\r\n\t\tif (s.menuId == MENU_FRESNEL)\r\n\t\t{\r\n\t\t\tcolor = envSpecularColor;\r\n\t\t}\r\n\t\tif (s.menuId == MENU_GEOMETRY)\r\n\t\t{\r\n\t\t\tcolor = vec3(lightV) * (4.0f * ndotv * ndotl);\r\n\t\t}\r\n\t\tcolor = pow(color * .4, vec3(1. / 2.2));\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// shadow\r\n\t\tfloat planeT = -(rayOrigin.y + 1.2) / rayDir.y;\r\n\t\tif (planeT > 0.0)\r\n\t\t{\r\n\t\t\tvec3 p = rayOrigin + planeT * rayDir;\r\n\r\n\t\t\tfloat radius = .7;\r\n\t\t\tcolor *= 0.7 + 0.3 * smoothstep(0.0, 1.0, saturate(length(p + vec3(0.0, 1.0, -0.5)) - radius));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid InfoText(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tp -= vec2(52, 12);\r\n\tvec2 q = p;\r\n\tif (s.menuId == MENU_METAL || s.menuId == MENU_BASE_COLOR || s.menuId == MENU_DISTR)\r\n\t{\r\n\t\tp.y -= 6.;\r\n\t}\r\n\tif (s.menuId == MENU_DIELECTRIC || s.menuId == MENU_FRESNEL)\r\n\t{\r\n\t\tp.y += 6.;\r\n\t}\r\n\tif (s.menuId == MENU_SPECULAR)\r\n\t{\r\n\t\tp.y += 6. * 6.;\r\n\r\n\t\tif (p.x < 21. && p.y >= 27. && p.y < 30.)\r\n\t\t{\r\n\t\t\tp.y = 0.;\r\n\t\t}\r\n\t\telse if (s.menuId == MENU_SPECULAR && p.y > 20. && p.y < 28. && p.x < 21.)\r\n\t\t{\r\n\t\t\tp.y += 3.;\r\n\t\t}\r\n\t}\r\n\r\n\tvec2 scale = vec2(3., 6.);\r\n\tvec2 t = floor(p / scale);\r\n\r\n\tuint v = 0u;\r\n\tif (s.menuId == MENU_SURFACE)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1702127169u : (t.x < 8. ? 1768431730u : (t.x < 12. ? 1852404852u : (t.x < 16. ? 1752440935u : (t.x < 20. ? 1970479205u : (t.x < 24. ? 1667327602u : (t.x < 28. ? 1768693861u : 7628903u))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1937334642u : (t.x < 8. ? 1717924384u : (t.x < 12. ? 1952671084u : (t.x < 16. ? 1684955424u : (t.x < 20. ? 1717924384u : (t.x < 24. ? 1952670066u : (t.x < 28. ? 32u : 0u))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1868784481u : (t.x < 8. ? 1852400754u : (t.x < 12. ? 1869881447u : (t.x < 16. ? 1701729056u : (t.x < 20. ? 1931963500u : (t.x < 24. ? 2002873376u : 0u)))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_METAL)\r\n\t{\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1635018061u : (t.x < 8. ? 1852776556u : (t.x < 12. ? 1914730860u : (t.x < 16. ? 1701602917u : (t.x < 20. ? 544437347u : (t.x < 24. ? 1751607660u : (t.x < 28. ? 1914729332u : (t.x < 32. ? 544438625u : 45u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 544432488u : (t.x < 8. ? 2037149295u : (t.x < 12. ? 1701868320u : (t.x < 16. ? 1634497891u : (t.x < 20. ? 114u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_DIELECTRIC)\r\n\t{\r\n\t\tv = t.y == 3. ? (t.x < 4. ? 1818585412u : (t.x < 8. ? 1920230245u : (t.x < 12. ? 1914725225u : (t.x < 16. ? 1701602917u : (t.x < 20. ? 544437347u : (t.x < 24. ? 1701868328u : (t.x < 28. ? 1634497891u : (t.x < 32. ? 2107762u : 0u)))))))) : v;\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 543452769u : (t.x < 8. ? 1935832435u : (t.x < 12. ? 1634103925u : (t.x < 16. ? 1931502947u : (t.x < 20. ? 1953784163u : (t.x < 24. ? 544436837u : (t.x < 28. ? 1718182952u : (t.x < 32. ? 1702065510u : 41u)))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1751607660u : (t.x < 8. ? 1634869364u : (t.x < 12. ? 539915129u : (t.x < 16. ? 1667592275u : (t.x < 20. ? 1918987381u : (t.x < 24. ? 544434464u : (t.x < 28. ? 1936617315u : (t.x < 32. ? 1953390964u : 0u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 808333438u : (t.x < 8. ? 774909234u : (t.x < 12. ? 13360u : 0u))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_ROUGHNESS)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 544367976u : (t.x < 12. ? 1718777203u : (t.x < 16. ? 1936024417u : (t.x < 20. ? 1830825248u : (t.x < 24. ? 543519343u : (t.x < 28. ? 1952539507u : (t.x < 32. ? 1701995892u : 100u)))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 544499815u : (t.x < 20. ? 1937334642u : (t.x < 24. ? 1851858988u : (t.x < 28. ? 1752440932u : (t.x < 32. ? 2126709u : 0u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1920298082u : (t.x < 8. ? 1919248754u : (t.x < 12. ? 1717924384u : (t.x < 16. ? 1952671084u : (t.x < 20. ? 1936617321u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_BASE_COLOR)\r\n\t{\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 544370502u : (t.x < 8. ? 1635018093u : (t.x < 12. ? 1679848300u : (t.x < 16. ? 1852401253u : (t.x < 20. ? 1931506533u : (t.x < 24. ? 1969448304u : (t.x < 28. ? 544366956u : (t.x < 32. ? 1869377379u : 114u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 544370502u : (t.x < 8. ? 1818585444u : (t.x < 12. ? 1920230245u : (t.x < 16. ? 544433001u : (t.x < 20. ? 1768169517u : (t.x < 24. ? 1937073766u : (t.x < 28. ? 1868767333u : (t.x < 32. ? 7499628u : 0u)))))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_LIGHTING)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1751607628u : (t.x < 8. ? 1735289204u : (t.x < 12. ? 544434464u : (t.x < 16. ? 1869770849u : (t.x < 20. ? 1634560376u : (t.x < 24. ? 543450484u : 2128226u)))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1634755955u : (t.x < 8. ? 1769234802u : (t.x < 12. ? 1679845230u : (t.x < 16. ? 1969645161u : (t.x < 20. ? 1629513075u : (t.x < 24. ? 2122862u : 0u)))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1667592307u : (t.x < 8. ? 1918987381u : (t.x < 12. ? 1836016416u : (t.x < 16. ? 1701736304u : (t.x < 20. ? 544437358u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_DIFFUSE)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1818324307u : (t.x < 8. ? 1668489324u : (t.x < 12. ? 543517793u : (t.x < 16. ? 1935832435u : (t.x < 20. ? 1634103925u : (t.x < 24. ? 1931502947u : (t.x < 28. ? 1953784163u : (t.x < 32. ? 1852404325u : 8295u)))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1635087189u : (t.x < 8. ? 981036140u : (t.x < 12. ? 1835093024u : (t.x < 16. ? 1953654114u : (t.x < 20. ? 1146241568u : (t.x < 24. ? 1713388102u : (t.x < 28. ? 824196384u : (t.x < 32. ? 543780911u : 0u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1702257960u : (t.x < 8. ? 1914730866u : (t.x < 12. ? 1696627041u : (t.x < 16. ? 1937009016u : (t.x < 20. ? 544106784u : (t.x < 24. ? 1634869345u : (t.x < 28. ? 1679844462u : (t.x < 32. ? 2716265u : 0u)))))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_SPECULAR)\r\n\t{\r\n\t\tv = t.y == 8. ? (t.x < 4. ? 1818649938u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 779380839u : (t.x < 20. ? 1970492704u : (t.x < 24. ? 2037148769u : 8250u)))))) : v;\r\n\t\tv = t.y == 7. ? (t.x < 4. ? 1802465091u : (t.x < 8. ? 1919898669u : (t.x < 12. ? 1668178290u : (t.x < 16. ? 1998597221u : (t.x < 20. ? 1751345512u : (t.x < 24. ? 1685024032u : 7564389u)))))) : v;\r\n\t\tv = t.y == 6. ? (t.x < 4. ? 1919117677u : (t.x < 8. ? 1667327599u : (t.x < 12. ? 544437349u : (t.x < 16. ? 1919250472u : (t.x < 20. ? 1952671078u : (t.x < 24. ? 1919511840u : 544370546u)))))) : v;\r\n\t\tv = t.y == 5. ? (t.x < 4. ? 1734960488u : (t.x < 8. ? 1634563176u : (t.x < 12. ? 3811696u : 0u))) : v;\r\n\t\tv = t.y == 4. ? (t.x < 4. ? 745285734u : (t.x < 8. ? 1178413430u : (t.x < 12. ? 1747744296u : (t.x < 16. ? 1814578985u : (t.x < 20. ? 1747744300u : (t.x < 24. ? 1747469353u : 41u)))))) : v;\r\n\t\tv = t.y == 3. ? (t.x < 4. ? 538976288u : (t.x < 8. ? 538976288u : (t.x < 12. ? 1848128544u : (t.x < 16. ? 673803447u : (t.x < 20. ? 695646062u : 0u))))) : v;\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 539828294u : (t.x < 8. ? 1936028230u : (t.x < 12. ? 7103854u : 0u))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 539828295u : (t.x < 8. ? 1836016967u : (t.x < 12. ? 2037544037u : 0u))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 539828292u : (t.x < 8. ? 1953720644u : (t.x < 12. ? 1969383794u : (t.x < 16. ? 1852795252u : 0u)))) : v;\r\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_DISTR)\r\n\t{\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1702109252u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 622883685u : (t.x < 20. ? 543584032u : (t.x < 24. ? 1919117677u : (t.x < 28. ? 1667327599u : 544437349u))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1769235301u : (t.x < 12. ? 1814062958u : (t.x < 16. ? 1952999273u : (t.x < 20. ? 1919903264u : (t.x < 24. ? 1730175264u : (t.x < 28. ? 1852143209u : 1919509536u))))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_FRESNEL)\r\n\t{\r\n\t\tv = t.y == 3. ? (t.x < 4. ? 1702109254u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 1629516645u : (t.x < 20. ? 1853189997u : (t.x < 24. ? 1718558836u : 32u)))))) : v;\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 544499815u : (t.x < 20. ? 544370534u : (t.x < 24. ? 1768366177u : 544105846u)))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1935832435u : (t.x < 8. ? 1851880052u : (t.x < 12. ? 539911523u : (t.x < 16. ? 1629516873u : (t.x < 20. ? 1869770864u : (t.x < 24. ? 1701340001u : 3219571u)))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 544370534u : (t.x < 8. ? 2053206631u : (t.x < 12. ? 543649385u : (t.x < 16. ? 1818717793u : (t.x < 20. ? 29541u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_GEOMETRY)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1702109255u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 1931506533u : (t.x < 20. ? 1868849512u : (t.x < 24. ? 1735289207u : (t.x < 28. ? 543584032u : 0u))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1919117677u : (t.x < 8. ? 1667327599u : (t.x < 12. ? 544437349u : (t.x < 16. ? 1701864804u : (t.x < 20. ? 1852400750u : (t.x < 24. ? 1852776551u : (t.x < 28. ? 1701344288u : 2126441u))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1634890337u : (t.x < 8. ? 1835362158u : (t.x < 12. ? 7630437u : 0u))) : v;\r\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\r\n\t}\r\n\r\n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\r\n\r\n\tvec3 textColor = vec3(.3);\r\n\r\n\tp = (p - t * scale) / scale;\r\n\tp.x = (p.x - .5) * .45 + .5;\r\n\tfloat sdf = TextSDF(p, c);\r\n\tif (c != 0.)\r\n\t{\r\n\t\tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\r\n\t}\r\n\r\n\tif (s.menuId == MENU_SPECULAR)\r\n\t{\r\n\t\tcolor = mix(color, textColor, smoothstep(.05, -.05, Capsule(q.yx - vec2(-12.3, 48.), .3, 26.)));\r\n\t}\r\n}\r\n\r\nvoid MenuText(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tp -= vec2(-160, -1);\r\n\r\n\tvec2 scale = vec2(4., 8.);\r\n\tvec2 t = floor(p / scale);\r\n\r\n\tfloat tab = 1.;\r\n\tif (t.y >= 6. && t.y < 10.)\r\n\t{\r\n\t\tp.x -= tab * scale.x;\r\n\t\tt.x -= tab;\r\n\t}\r\n\tif (t.y >= 0. && t.y < 5.)\r\n\t{\r\n\t\tp.x -= tab * scale.x;\r\n\t\tt.x -= tab;\r\n\t}\r\n\tif (t.y >= 0. && t.y < 3.)\r\n\t{\r\n\t\tp.x -= tab * scale.x;\r\n\t\tt.x -= tab;\r\n\t}\r\n\r\n\tuint v = 0u;\r\n\tv = t.y == 10. ? (t.x < 4. ? 1718777171u : (t.x < 8. ? 6644577u : 0u)) : v;\r\n\tv = t.y == 9. ? (t.x < 4. ? 1635018061u : (t.x < 8. ? 108u : 0u)) : v;\r\n\tv = t.y == 8. ? (t.x < 4. ? 1818585412u : (t.x < 8. ? 1920230245u : 25449u)) : v;\r\n\tv = t.y == 7. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 1936027240u : 115u)) : v;\r\n\tv = t.y == 6. ? (t.x < 4. ? 1702060354u : (t.x < 8. ? 1819231008u : 29295u)) : v;\r\n\tv = t.y == 5. ? (t.x < 4. ? 1751607628u : (t.x < 8. ? 1735289204u : 0u)) : v;\r\n\tv = t.y == 4. ? (t.x < 4. ? 1717987652u : (t.x < 8. ? 6648693u : 0u)) : v;\r\n\tv = t.y == 3. ? (t.x < 4. ? 1667592275u : (t.x < 8. ? 1918987381u : 0u)) : v;\r\n\tv = t.y == 2. ? (t.x < 4. ? 1953720644u : (t.x < 8. ? 1969383794u : 1852795252u)) : v;\r\n\tv = t.y == 1. ? (t.x < 4. ? 1936028230u : (t.x < 8. ? 7103854u : 0u)) : v;\r\n\tv = t.y == 0. ? (t.x < 4. ? 1836016967u : (t.x < 8. ? 2037544037u : 0u)) : v;\r\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\r\n\r\n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\r\n\r\n\tvec3 textColor = vec3(.3);\r\n\tif (t.y == 10. - s.menuId)\r\n\t{\r\n\t\ttextColor = vec3(0.74, 0.5, 0.12);\r\n\t}\r\n\r\n\tp = (p - t * scale) / scale;\r\n\tp.x = (p.x - .5) * .45 + .5;\r\n\tfloat sdf = TextSDF(p, c);\r\n\tif (c != 0.)\r\n\t{\r\n\t\tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\r\n\t}\r\n}\r\n\r\nvoid DrawMenuControls(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tp -= vec2(-110, 74);\r\n\r\n\t// radial\r\n\tfloat c2 = Capsule(p - vec2(0., -3.5), 3., 4.);\r\n\tfloat c1 = Circle(p + vec2(0., 7. - 7. * s.metal), 2.5);\r\n\r\n\t// roughness slider\r\n\tp.y += 15.;\r\n\tc1 = min(c1, Capsule(p.yx - vec2(0., 20.), 1., 20.));\r\n\tc1 = min(c1, Circle(p - vec2(40. * s.roughness, 0.), 2.5));\r\n\r\n\tp.y += 8.;\r\n\tc1 = min(c1, Rectangle(p - vec2(19.5, 0.), vec2(21.4, 4.)));\r\n\tcolor = mix(color, vec3(0.9), Smooth(-c2 * 2.));\r\n\tcolor = mix(color, vec3(0.3), Smooth(-c1 * 2.));\r\n\r\n\tfor (int i = 0; i < 6; ++i)\r\n\t{\r\n\t\tvec2 o = vec2(i == int(s.baseColor) ? 2.5 : 3.5);\r\n\t\tcolor = mix(color, BASE_COLORS[i], Smooth(-2. * Rectangle(p - vec2(2. + float(i) * 7., 0.), o)));\r\n\t}\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n\tvec2 p = -1. + 2. * q;\r\n\tp.x *= iResolution.x / iResolution.y;\r\n\tp *= 100.;\r\n\r\n\tAppState s;\r\n\tLoadState(s);\r\n\r\n\tvec3 color = vec3(1., .98, .94) * mix(1.0, 0.4, Smooth(abs(.5 - uv.y)));\r\n\tfloat vignette = q.x * q.y * (1.0 - q.x) * (1.0 - q.y);\r\n\tvignette = saturate(pow(32.0 * vignette, 0.05));\r\n\tcolor *= vignette;\r\n\r\n\tDrawScene(color, p, s);\r\n\tDiagram(color, p, s);\r\n\tInfoText(color, p, s);\r\n\tMenuText(color, p, s);\r\n\tDrawMenuControls(color, p, s);\r\n\r\n\tfragColor = vec4(color, 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0}],"Info":{"Name":"[SH17C] Physically Based Shading","id":null,"date":null,"viewed":0,"name":"[SH17C] Physically Based Shading","description":"Click on menu buttons, use controls, rotate object and learn!","likes":0,"published":null,"tags":[" tutorial"," text"," presentation"," pbr"," gui"," sh17c"]},"ver":null,"info":{"Name":"[SH17C] Physically Based Shading","id":null,"date":null,"viewed":0,"name":"[SH17C] Physically Based Shading","description":"Click on menu buttons, use controls, rotate object and learn!","likes":0,"published":null,"tags":[" tutorial"," text"," presentation"," pbr"," gui"," sh17c"]},"renderpass":[{"Code":"const float MATH_PI = float(3.14159);\r\n\r\nconst float MENU_SURFACE = 0.;\r\nconst float MENU_METAL = 1.;\r\nconst float MENU_DIELECTRIC = 2.;\r\nconst float MENU_ROUGHNESS = 3.;\r\nconst float MENU_BASE_COLOR = 4.;\r\nconst float MENU_LIGHTING = 5.;\r\nconst float MENU_DIFFUSE = 6.;\r\nconst float MENU_SPECULAR = 7.;\r\nconst float MENU_DISTR = 8.;\r\nconst float MENU_FRESNEL = 9.;\r\nconst float MENU_GEOMETRY = 10.;\r\n\r\nconst vec3 BASE_COLORS[6] = vec3[6]\r\n(\r\n\tvec3(0.74),\r\n\tvec3(0.51, 0.72, 0.81),\r\n\tvec3(0.66, .85, .42),\r\n\tvec3(0.87, 0.53, 0.66),\r\n\tvec3(0.51, 0.46, 0.74),\r\n\tvec3(0.78, 0.71, 0.45)\r\n\t);\r\n\r\nstruct AppState\r\n{\r\n\tfloat\tmenuId;\r\n\tfloat\tmetal;\r\n\tfloat   roughness;\r\n\tfloat   baseColor;\r\n\tfloat   focus;\r\n\tfloat   focusObjRot;\r\n\tfloat   objRot;\r\n};\r\n\r\nvec4 LoadValue(int x, int y)\r\n{\r\n\treturn texelFetch(iChannel0, ivec2(x, y), 0);\r\n}\r\n\r\nvoid LoadState(out AppState s)\r\n{\r\n\tvec4 data;\r\n\r\n\tdata = LoadValue(0, 0);\r\n\ts.menuId = data.x;\r\n\ts.metal = data.y;\r\n\ts.roughness = data.z;\r\n\ts.baseColor = data.w;\r\n\r\n\tdata = LoadValue(1, 0);\r\n\ts.focus = data.x;\r\n\ts.focusObjRot = data.y;\r\n\ts.objRot = data.z;\r\n}\r\n\r\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\r\n{\r\n\tfragCoord = floor(fragCoord);\r\n\tfragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\r\n}\r\n\r\nfloat saturate(float x)\r\n{\r\n\treturn clamp(x, 0., 1.);\r\n}\r\n\r\nvec3 saturate(vec3 x)\r\n{\r\n\treturn clamp(x, vec3(0.), vec3(1.));\r\n}\r\n\r\nfloat Smooth(float x)\r\n{\r\n\treturn smoothstep(0., 1., saturate(x));\r\n}\r\n\r\nvoid Repeat(inout float p, float w)\r\n{\r\n\tp = mod(p, w) - 0.5f * w;\r\n}\r\n\r\nfloat Circle(vec2 p, float r)\r\n{\r\n\treturn (length(p / r) - 1.) * r;\r\n}\r\n\r\nfloat Rectangle(vec2 p, vec2 b)\r\n{\r\n\tvec2 d = abs(p) - b;\r\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\r\n}\r\n\r\nvoid Rotate(inout vec2 p, float a)\r\n{\r\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\r\n}\r\n\r\nfloat Capsule(vec2 p, float r, float c)\r\n{\r\n\treturn mix(length(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\r\n}\r\n\r\nfloat Arrow(vec2 p, float a, float l, float w)\r\n{\r\n\tRotate(p, a);\r\n\tp.y += l;\r\n\r\n\tfloat body = Capsule(p, w, l);\r\n\tp.y -= w;\r\n\r\n\tfloat tip = p.y + l;\r\n\r\n\tp.y += l + w;\r\n\tRotate(p, +2.);\r\n\ttip = max(tip, p.y - 2. * w);\r\n\tRotate(p, -4.);\r\n\ttip = max(tip, p.y - 2. * w);\r\n\r\n\treturn min(body, tip);\r\n}\r\n\r\nfloat TextSDF(vec2 p, float glyph)\r\n{\r\n\tp = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\r\n\treturn 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\r\n}\r\n\r\nvoid Diagram(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tvec3 surfColor = vec3(0.9, 0.84, 0.8);\r\n\tvec3 lightColor = vec3(0.88, 0.65, 0.2);\r\n\tvec3 baseColor = BASE_COLORS[int(s.baseColor)];\r\n\tvec3 diffuseColor = s.metal == 1. ? vec3(0.) : baseColor;\r\n\tvec3 specularColor = s.metal == 1. ? baseColor : vec3(0.7);\r\n\r\n\tp -= vec2(84., 44.);\r\n\r\n\tvec2 t = p - vec2(18., 4.);\r\n\tfloat r = Rectangle(t, vec2(52., 12.));\r\n\tcolor = mix(color, surfColor, Smooth(-r * 2.));\r\n\r\n\tt.y += s.roughness * sin(t.x);\r\n\tr = Rectangle(t - vec2(0., 11.), vec2(52., 1.2));\r\n\tcolor = mix(color, surfColor * 0.6, Smooth(-r * 2.));\r\n\r\n\r\n\t// refraction\r\n\tr = 1e4;\r\n\tt = p - vec2(18., 15.);\r\n\tfor (int i = 0; i < 3; ++i)\r\n\t{\r\n\t\tr = min(r, Arrow(t - vec2(-15. + float(i) * 15., 0.), -0.4, 7., .7));\r\n\t}\r\n\tr = min(r, Arrow(t - vec2(9., -15.), 2., 4., .7));\r\n\tr = min(r, Arrow(t - vec2(17., -10.), 3.8, 18., .7));\r\n\tr = min(r, Arrow(t - vec2(-6., -14.), 0.9, 3., .7));\r\n\tr = min(r, Arrow(t - vec2(1., -19.), 2.9, 18., .7));\r\n\tr = min(r, Arrow(t - vec2(-22., -15.), 4.5, 2., .7));\r\n\tr = min(r, Arrow(t - vec2(-28., -14.), 2.6, 14., .7));\r\n\tif (s.metal != 1. && s.menuId < MENU_SPECULAR)\r\n\t{\r\n\t\tcolor = mix(color, diffuseColor, Smooth(-r * 2.));\r\n\t}\r\n\r\n\t// reflection\r\n\tr = 1e4;\r\n\tt = p - vec2(18., 15.);\r\n\tfor (int i = 0; i < 3; ++i)\r\n\t{\r\n\t\tfloat off = s.roughness * (1.5 - float(i)) * .45;\r\n\t\tr = min(r, Arrow(t - vec2(-15. + float(i) * 15., 2.), -0.5 * MATH_PI - 0.9 + off, 12., 1.));\r\n\t}\r\n\tif (s.menuId != MENU_DIFFUSE)\r\n\t{\r\n\t\tcolor = mix(color, specularColor, Smooth(-r * 2.));\r\n\t}\r\n\r\n\t// light in\r\n\tr = 1e4;\r\n\tt = p - vec2(18., 15.);\r\n\tfor (int i = 0; i < 3; ++i)\r\n\t{\r\n\t\tr = min(r, Arrow(t - vec2(12. + float(i) * 15., 22.), -0.9, 15., 1.));\r\n\t}\r\n\tcolor = mix(color, lightColor, Smooth(-r * 2.));\r\n}\r\n\r\nfloat RaySphere(vec3 rayOrigin, vec3 rayDir, vec3 spherePos, float sphereRadius)\r\n{\r\n\tvec3 oc = rayOrigin - spherePos;\r\n\r\n\tfloat b = dot(oc, rayDir);\r\n\tfloat c = dot(oc, oc) - sphereRadius * sphereRadius;\r\n\tfloat h = b * b - c;\r\n\r\n\tfloat t;\r\n\tif (h < 0.0)\r\n\t{\r\n\t\tt = -1.0;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tt = (-b - sqrt(h));\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nfloat VisibilityTerm(float roughness, float ndotv, float ndotl)\r\n{\r\n\tfloat r2 = roughness * roughness;\r\n\tfloat gv = ndotl * sqrt(ndotv * (ndotv - ndotv * r2) + r2);\r\n\tfloat gl = ndotv * sqrt(ndotl * (ndotl - ndotl * r2) + r2);\r\n\treturn 0.5 / max(gv + gl, 0.00001);\r\n}\r\n\r\nfloat DistributionTerm(float roughness, float ndoth)\r\n{\r\n\tfloat r2 = roughness * roughness;\r\n\tfloat d = (ndoth * r2 - ndoth) * ndoth + 1.0;\r\n\treturn r2 / (d * d * MATH_PI);\r\n}\r\n\r\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\r\n{\r\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\r\n\treturn fresnel;\r\n}\r\n\r\nfloat Cylinder(vec3 p, float r, float height)\r\n{\r\n\tfloat d = length(p.xz) - r;\r\n\td = max(d, abs(p.y) - height);\r\n\treturn d;\r\n}\r\n\r\nfloat Substract(float a, float b)\r\n{\r\n\treturn max(a, -b);\r\n}\r\n\r\nfloat SubstractRound(float a, float b, float r)\r\n{\r\n\tvec2 u = max(vec2(r + a, r - b), vec2(0.0, 0.0));\r\n\treturn min(-r, max(a, -b)) + length(u);\r\n}\r\n\r\nfloat Union(float a, float b)\r\n{\r\n\treturn min(a, b);\r\n}\r\n\r\nfloat Box(vec3 p, vec3 b)\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nfloat Sphere(vec3 p, float s)\r\n{\r\n\treturn length(p) - s;\r\n}\r\n\r\nfloat Torus(vec3 p, float sr, float lr)\r\n{\r\n\treturn length(vec2(length(p.xz) - lr, p.y)) - sr;\r\n}\r\n\r\nfloat Disc(vec3 p, float r, float t)\r\n{\r\n\tfloat l = length(p.xz) - r;\r\n\treturn l < 0. ? abs(p.y) - t : length(vec2(p.y, l)) - t;\r\n}\r\n\r\nfloat UnionRound(float a, float b, float k)\r\n{\r\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k * h * (1.0 - h);\r\n}\r\n\r\nfloat Scene(vec3 p, mat3 localToWorld)\r\n{\r\n\tp = p * localToWorld;\r\n\r\n\t// ring\r\n\tvec3 t = p;\r\n\tt.y -= -.7;\r\n\tfloat r = Substract(Disc(t, 0.9, .1), Cylinder(t, .7, 2.));\r\n\tvec3 t2 = t - vec3(0., 0., 1.0);\r\n\tRotate(t2.xz, 0.25 * MATH_PI);\r\n\tr = Substract(r, Box(t2, vec3(.5)));\r\n\tr = Union(r, Disc(t + vec3(0., 0.05, 0.), 0.85, .05));\r\n\r\n\tt = p;\r\n\tRotate(t.yz, -.3);\r\n\r\n\t// body\r\n\tfloat b = Sphere(t, .8);\r\n\tb = Substract(b, Sphere(t - vec3(0., 0., .5), .5));\r\n\tb = Substract(b, Sphere(t - vec3(0., 0., -.7), .3));\r\n\tb = Substract(b, Box(t, vec3(2., .03, 2.)));\r\n\tb = Union(b, Sphere(t, .7));\r\n\r\n\tfloat ret = Union(r, b);\r\n\treturn ret;\r\n}\r\n\r\nfloat CastRay(in vec3 ro, in vec3 rd, mat3 localToWorld)\r\n{\r\n\tconst float maxd = 5.0;\r\n\r\n\tfloat h = 0.5;\r\n\tfloat t = 0.0;\r\n\r\n\tfor (int i = 0; i < 50; ++i)\r\n\t{\r\n\t\tif (h < 0.001 || t > maxd)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\th = Scene(ro + rd * t, localToWorld);\r\n\t\tt += h;\r\n\t}\r\n\r\n\tif (t > maxd)\r\n\t{\r\n\t\tt = -1.0;\r\n\t}\r\n\r\n\treturn t;\r\n}\r\n\r\nvec3 SceneNormal(in vec3 pos, mat3 localToWorld)\r\n{\r\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\r\n\tvec3 nor = vec3(\r\n\t\tScene(pos + eps.xyy, localToWorld) - Scene(pos - eps.xyy, localToWorld),\r\n\t\tScene(pos + eps.yxy, localToWorld) - Scene(pos - eps.yxy, localToWorld),\r\n\t\tScene(pos + eps.yyx, localToWorld) - Scene(pos - eps.yyx, localToWorld));\r\n\treturn normalize(nor);\r\n}\r\n\r\nfloat SceneAO(vec3 p, vec3 n, mat3 localToWorld)\r\n{\r\n\tfloat ao = 0.0;\r\n\tfloat s = 1.0;\r\n\tfor (int i = 0; i < 6; ++i)\r\n\t{\r\n\t\tfloat off = 0.001 + 0.2 * float(i) / 5.;\r\n\t\tfloat t = Scene(n * off + p, localToWorld);\r\n\t\tao += (off - t) * s;\r\n\t\ts *= 0.4;\r\n\t}\r\n\r\n\treturn Smooth(1.0 - 12.0 * ao);\r\n}\r\n\r\n// St. Peter's Basilica SH\r\n// https://www.shadertoy.com/view/lt2GRD\r\nstruct SHCoefficients\r\n{\r\n\tvec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\r\n};\r\n\r\nconst SHCoefficients SH_STPETER = SHCoefficients(\r\n\tvec3(0.3623915, 0.2624130, 0.2326261),\r\n\tvec3(0.1759131, 0.1436266, 0.1260569),\r\n\tvec3(-0.0247311, -0.0101254, -0.0010745),\r\n\tvec3(0.0346500, 0.0223184, 0.0101350),\r\n\tvec3(0.0198140, 0.0144073, 0.0043987),\r\n\tvec3(-0.0469596, -0.0254485, -0.0117786),\r\n\tvec3(-0.0898667, -0.0760911, -0.0740964),\r\n\tvec3(0.0050194, 0.0038841, 0.0001374),\r\n\tvec3(-0.0818750, -0.0321501, 0.0033399)\r\n);\r\n\r\nvec3 SHIrradiance(vec3 nrm)\r\n{\r\n\tconst SHCoefficients c = SH_STPETER;\r\n\tconst float c1 = 0.429043;\r\n\tconst float c2 = 0.511664;\r\n\tconst float c3 = 0.743125;\r\n\tconst float c4 = 0.886227;\r\n\tconst float c5 = 0.247708;\r\n\treturn (\r\n\t\tc1 * c.l22 * (nrm.x * nrm.x - nrm.y * nrm.y) +\r\n\t\tc3 * c.l20 * nrm.z * nrm.z +\r\n\t\tc4 * c.l00 -\r\n\t\tc5 * c.l20 +\r\n\t\t2.0 * c1 * c.l2m2 * nrm.x * nrm.y +\r\n\t\t2.0 * c1 * c.l21  * nrm.x * nrm.z +\r\n\t\t2.0 * c1 * c.l2m1 * nrm.y * nrm.z +\r\n\t\t2.0 * c2 * c.l11  * nrm.x +\r\n\t\t2.0 * c2 * c.l1m1 * nrm.y +\r\n\t\t2.0 * c2 * c.l10  * nrm.z\r\n\t\t);\r\n}\r\n\r\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\r\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv)\r\n{\r\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\r\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\r\n\tvec4 r = roughness * c0 + c1;\r\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\r\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\r\n\treturn specularColor * AB.x + AB.y;\r\n}\r\n\r\nvec3 EnvRemap(vec3 c)\r\n{\r\n\treturn pow(2. * c, vec3(2.2));\r\n}\r\n\r\nvoid DrawScene(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tvec3 lightColor = vec3(2.);\r\n\tvec3 lightDir = normalize(vec3(.7, .9, -.2));\r\n\r\n\tvec3 baseColor = pow(BASE_COLORS[int(s.baseColor)], vec3(2.2));\r\n\tvec3 diffuseColor = s.metal == 1. ? vec3(0.) : baseColor;\r\n\tvec3 specularColor = s.metal == 1. ? baseColor : vec3(0.02);\r\n\tfloat roughnessE = s.roughness * s.roughness;\r\n\tfloat roughnessL = max(.01, roughnessE);\r\n\r\n\tfloat a = -iTime * .5;\r\n\tmat3 rot = mat3(\r\n\t\tvec3(cos(a), 0., -sin(a)),\r\n\t\tvec3(0., 1., 0.),\r\n\t\tvec3(sin(a), 0., cos(a))\r\n\t);\r\n\r\n\tp -= vec2(-20., 10.);\r\n\tp *= .011;\r\n\r\n\tfloat yaw = 2.7 - s.objRot;\r\n\tmat3 rotZ = mat3(\r\n\t\tvec3(cos(yaw), 0.0, -sin(yaw)),\r\n\t\tvec3(0.0, 1.0, 0.0),\r\n\t\tvec3(sin(yaw), 0.0, cos(yaw))\r\n\t);\r\n\r\n\tfloat phi = -0.1;\r\n\tmat3 rotY = mat3(\r\n\t\tvec3(1.0, 0.0, 0.0),\r\n\t\tvec3(0.0, cos(phi), sin(phi)),\r\n\t\tvec3(0.0, -sin(phi), cos(phi))\r\n\t);\r\n\r\n\tmat3 localToWorld = rotY * rotZ;\r\n\r\n\tvec3 rayOrigin = vec3(0.0, .5, -3.5);\r\n\tvec3 rayDir = normalize(vec3(p.x, p.y, 2.0));\r\n\tfloat t = CastRay(rayOrigin, rayDir, localToWorld);\r\n\tif (t > 0.0)\r\n\t{\r\n\t\tvec3 pos = rayOrigin + t * rayDir;\r\n\t\tvec3 normal = SceneNormal(pos, localToWorld);\r\n\t\tvec3 viewDir = -rayDir;\r\n\t\tvec3 refl = reflect(rayDir, normal);\r\n\r\n\t\tvec3 diffuse = vec3(0.);\r\n\t\tvec3 specular = vec3(0.);\r\n\r\n\t\tvec3 halfVec = normalize(viewDir + lightDir);\r\n\t\tfloat vdoth = saturate(dot(viewDir, halfVec));\r\n\t\tfloat ndoth = saturate(dot(normal, halfVec));\r\n\t\tfloat ndotv = saturate(dot(normal, viewDir));\r\n\t\tfloat ndotl = saturate(dot(normal, lightDir));\r\n\t\tvec3 envSpecularColor = EnvBRDFApprox(specularColor, roughnessE, ndotv);\r\n\r\n\t\tvec3 env1 = EnvRemap(texture(iChannel2, refl.xy).xyz);\r\n\t\tvec3 env2 = EnvRemap(texture(iChannel1, refl.xy).xyz);\r\n\t\tvec3 env3 = EnvRemap(SHIrradiance(refl));\r\n\t\tvec3 env = mix(env1, env2, saturate(roughnessE * 4.));\r\n\t\tenv = mix(env, env3, saturate((roughnessE - 0.25) / 0.75));\r\n\r\n\t\tdiffuse += diffuseColor * EnvRemap(SHIrradiance(normal));\r\n\t\tspecular += envSpecularColor * env;\r\n\r\n\t\tdiffuse += diffuseColor * lightColor * saturate(dot(normal, lightDir));\r\n\r\n\t\tvec3 lightF = FresnelTerm(specularColor, vdoth);\r\n\t\tfloat lightD = DistributionTerm(roughnessL, ndoth);\r\n\t\tfloat lightV = VisibilityTerm(roughnessL, ndotv, ndotl);\r\n\t\tspecular += lightColor * lightF * (lightD * lightV * MATH_PI * ndotl);\r\n\r\n\t\tfloat ao = SceneAO(pos, normal, localToWorld);\r\n\t\tdiffuse *= ao;\r\n\t\tspecular *= saturate(pow(ndotv + ao, roughnessE) - 1. + ao);\r\n\r\n\t\tcolor = diffuse + specular;\r\n\t\tif (s.menuId == MENU_DIFFUSE)\r\n\t\t{\r\n\t\t\tcolor = diffuse;\r\n\t\t}\r\n\t\tif (s.menuId == MENU_SPECULAR)\r\n\t\t{\r\n\t\t\tcolor = specular;\r\n\t\t}\r\n\t\tif (s.menuId == MENU_DISTR)\r\n\t\t{\r\n\t\t\tcolor = vec3(lightD);\r\n\t\t}\r\n\t\tif (s.menuId == MENU_FRESNEL)\r\n\t\t{\r\n\t\t\tcolor = envSpecularColor;\r\n\t\t}\r\n\t\tif (s.menuId == MENU_GEOMETRY)\r\n\t\t{\r\n\t\t\tcolor = vec3(lightV) * (4.0f * ndotv * ndotl);\r\n\t\t}\r\n\t\tcolor = pow(color * .4, vec3(1. / 2.2));\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// shadow\r\n\t\tfloat planeT = -(rayOrigin.y + 1.2) / rayDir.y;\r\n\t\tif (planeT > 0.0)\r\n\t\t{\r\n\t\t\tvec3 p = rayOrigin + planeT * rayDir;\r\n\r\n\t\t\tfloat radius = .7;\r\n\t\t\tcolor *= 0.7 + 0.3 * smoothstep(0.0, 1.0, saturate(length(p + vec3(0.0, 1.0, -0.5)) - radius));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid InfoText(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tp -= vec2(52, 12);\r\n\tvec2 q = p;\r\n\tif (s.menuId == MENU_METAL || s.menuId == MENU_BASE_COLOR || s.menuId == MENU_DISTR)\r\n\t{\r\n\t\tp.y -= 6.;\r\n\t}\r\n\tif (s.menuId == MENU_DIELECTRIC || s.menuId == MENU_FRESNEL)\r\n\t{\r\n\t\tp.y += 6.;\r\n\t}\r\n\tif (s.menuId == MENU_SPECULAR)\r\n\t{\r\n\t\tp.y += 6. * 6.;\r\n\r\n\t\tif (p.x < 21. && p.y >= 27. && p.y < 30.)\r\n\t\t{\r\n\t\t\tp.y = 0.;\r\n\t\t}\r\n\t\telse if (s.menuId == MENU_SPECULAR && p.y > 20. && p.y < 28. && p.x < 21.)\r\n\t\t{\r\n\t\t\tp.y += 3.;\r\n\t\t}\r\n\t}\r\n\r\n\tvec2 scale = vec2(3., 6.);\r\n\tvec2 t = floor(p / scale);\r\n\r\n\tuint v = 0u;\r\n\tif (s.menuId == MENU_SURFACE)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1702127169u : (t.x < 8. ? 1768431730u : (t.x < 12. ? 1852404852u : (t.x < 16. ? 1752440935u : (t.x < 20. ? 1970479205u : (t.x < 24. ? 1667327602u : (t.x < 28. ? 1768693861u : 7628903u))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1937334642u : (t.x < 8. ? 1717924384u : (t.x < 12. ? 1952671084u : (t.x < 16. ? 1684955424u : (t.x < 20. ? 1717924384u : (t.x < 24. ? 1952670066u : (t.x < 28. ? 32u : 0u))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1868784481u : (t.x < 8. ? 1852400754u : (t.x < 12. ? 1869881447u : (t.x < 16. ? 1701729056u : (t.x < 20. ? 1931963500u : (t.x < 24. ? 2002873376u : 0u)))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_METAL)\r\n\t{\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1635018061u : (t.x < 8. ? 1852776556u : (t.x < 12. ? 1914730860u : (t.x < 16. ? 1701602917u : (t.x < 20. ? 544437347u : (t.x < 24. ? 1751607660u : (t.x < 28. ? 1914729332u : (t.x < 32. ? 544438625u : 45u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 544432488u : (t.x < 8. ? 2037149295u : (t.x < 12. ? 1701868320u : (t.x < 16. ? 1634497891u : (t.x < 20. ? 114u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_DIELECTRIC)\r\n\t{\r\n\t\tv = t.y == 3. ? (t.x < 4. ? 1818585412u : (t.x < 8. ? 1920230245u : (t.x < 12. ? 1914725225u : (t.x < 16. ? 1701602917u : (t.x < 20. ? 544437347u : (t.x < 24. ? 1701868328u : (t.x < 28. ? 1634497891u : (t.x < 32. ? 2107762u : 0u)))))))) : v;\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 543452769u : (t.x < 8. ? 1935832435u : (t.x < 12. ? 1634103925u : (t.x < 16. ? 1931502947u : (t.x < 20. ? 1953784163u : (t.x < 24. ? 544436837u : (t.x < 28. ? 1718182952u : (t.x < 32. ? 1702065510u : 41u)))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1751607660u : (t.x < 8. ? 1634869364u : (t.x < 12. ? 539915129u : (t.x < 16. ? 1667592275u : (t.x < 20. ? 1918987381u : (t.x < 24. ? 544434464u : (t.x < 28. ? 1936617315u : (t.x < 32. ? 1953390964u : 0u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 808333438u : (t.x < 8. ? 774909234u : (t.x < 12. ? 13360u : 0u))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_ROUGHNESS)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 544367976u : (t.x < 12. ? 1718777203u : (t.x < 16. ? 1936024417u : (t.x < 20. ? 1830825248u : (t.x < 24. ? 543519343u : (t.x < 28. ? 1952539507u : (t.x < 32. ? 1701995892u : 100u)))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 544499815u : (t.x < 20. ? 1937334642u : (t.x < 24. ? 1851858988u : (t.x < 28. ? 1752440932u : (t.x < 32. ? 2126709u : 0u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1920298082u : (t.x < 8. ? 1919248754u : (t.x < 12. ? 1717924384u : (t.x < 16. ? 1952671084u : (t.x < 20. ? 1936617321u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_BASE_COLOR)\r\n\t{\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 544370502u : (t.x < 8. ? 1635018093u : (t.x < 12. ? 1679848300u : (t.x < 16. ? 1852401253u : (t.x < 20. ? 1931506533u : (t.x < 24. ? 1969448304u : (t.x < 28. ? 544366956u : (t.x < 32. ? 1869377379u : 114u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 544370502u : (t.x < 8. ? 1818585444u : (t.x < 12. ? 1920230245u : (t.x < 16. ? 544433001u : (t.x < 20. ? 1768169517u : (t.x < 24. ? 1937073766u : (t.x < 28. ? 1868767333u : (t.x < 32. ? 7499628u : 0u)))))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_LIGHTING)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1751607628u : (t.x < 8. ? 1735289204u : (t.x < 12. ? 544434464u : (t.x < 16. ? 1869770849u : (t.x < 20. ? 1634560376u : (t.x < 24. ? 543450484u : 2128226u)))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1634755955u : (t.x < 8. ? 1769234802u : (t.x < 12. ? 1679845230u : (t.x < 16. ? 1969645161u : (t.x < 20. ? 1629513075u : (t.x < 24. ? 2122862u : 0u)))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1667592307u : (t.x < 8. ? 1918987381u : (t.x < 12. ? 1836016416u : (t.x < 16. ? 1701736304u : (t.x < 20. ? 544437358u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_DIFFUSE)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1818324307u : (t.x < 8. ? 1668489324u : (t.x < 12. ? 543517793u : (t.x < 16. ? 1935832435u : (t.x < 20. ? 1634103925u : (t.x < 24. ? 1931502947u : (t.x < 28. ? 1953784163u : (t.x < 32. ? 1852404325u : 8295u)))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1635087189u : (t.x < 8. ? 981036140u : (t.x < 12. ? 1835093024u : (t.x < 16. ? 1953654114u : (t.x < 20. ? 1146241568u : (t.x < 24. ? 1713388102u : (t.x < 28. ? 824196384u : (t.x < 32. ? 543780911u : 0u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1702257960u : (t.x < 8. ? 1914730866u : (t.x < 12. ? 1696627041u : (t.x < 16. ? 1937009016u : (t.x < 20. ? 544106784u : (t.x < 24. ? 1634869345u : (t.x < 28. ? 1679844462u : (t.x < 32. ? 2716265u : 0u)))))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_SPECULAR)\r\n\t{\r\n\t\tv = t.y == 8. ? (t.x < 4. ? 1818649938u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 779380839u : (t.x < 20. ? 1970492704u : (t.x < 24. ? 2037148769u : 8250u)))))) : v;\r\n\t\tv = t.y == 7. ? (t.x < 4. ? 1802465091u : (t.x < 8. ? 1919898669u : (t.x < 12. ? 1668178290u : (t.x < 16. ? 1998597221u : (t.x < 20. ? 1751345512u : (t.x < 24. ? 1685024032u : 7564389u)))))) : v;\r\n\t\tv = t.y == 6. ? (t.x < 4. ? 1919117677u : (t.x < 8. ? 1667327599u : (t.x < 12. ? 544437349u : (t.x < 16. ? 1919250472u : (t.x < 20. ? 1952671078u : (t.x < 24. ? 1919511840u : 544370546u)))))) : v;\r\n\t\tv = t.y == 5. ? (t.x < 4. ? 1734960488u : (t.x < 8. ? 1634563176u : (t.x < 12. ? 3811696u : 0u))) : v;\r\n\t\tv = t.y == 4. ? (t.x < 4. ? 745285734u : (t.x < 8. ? 1178413430u : (t.x < 12. ? 1747744296u : (t.x < 16. ? 1814578985u : (t.x < 20. ? 1747744300u : (t.x < 24. ? 1747469353u : 41u)))))) : v;\r\n\t\tv = t.y == 3. ? (t.x < 4. ? 538976288u : (t.x < 8. ? 538976288u : (t.x < 12. ? 1848128544u : (t.x < 16. ? 673803447u : (t.x < 20. ? 695646062u : 0u))))) : v;\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 539828294u : (t.x < 8. ? 1936028230u : (t.x < 12. ? 7103854u : 0u))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 539828295u : (t.x < 8. ? 1836016967u : (t.x < 12. ? 2037544037u : 0u))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 539828292u : (t.x < 8. ? 1953720644u : (t.x < 12. ? 1969383794u : (t.x < 16. ? 1852795252u : 0u)))) : v;\r\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_DISTR)\r\n\t{\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1702109252u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 622883685u : (t.x < 20. ? 543584032u : (t.x < 24. ? 1919117677u : (t.x < 28. ? 1667327599u : 544437349u))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1769235301u : (t.x < 12. ? 1814062958u : (t.x < 16. ? 1952999273u : (t.x < 20. ? 1919903264u : (t.x < 24. ? 1730175264u : (t.x < 28. ? 1852143209u : 1919509536u))))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_FRESNEL)\r\n\t{\r\n\t\tv = t.y == 3. ? (t.x < 4. ? 1702109254u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 1629516645u : (t.x < 20. ? 1853189997u : (t.x < 24. ? 1718558836u : 32u)))))) : v;\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 544499815u : (t.x < 20. ? 544370534u : (t.x < 24. ? 1768366177u : 544105846u)))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1935832435u : (t.x < 8. ? 1851880052u : (t.x < 12. ? 539911523u : (t.x < 16. ? 1629516873u : (t.x < 20. ? 1869770864u : (t.x < 24. ? 1701340001u : 3219571u)))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 544370534u : (t.x < 8. ? 2053206631u : (t.x < 12. ? 543649385u : (t.x < 16. ? 1818717793u : (t.x < 20. ? 29541u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_GEOMETRY)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1702109255u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 1931506533u : (t.x < 20. ? 1868849512u : (t.x < 24. ? 1735289207u : (t.x < 28. ? 543584032u : 0u))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1919117677u : (t.x < 8. ? 1667327599u : (t.x < 12. ? 544437349u : (t.x < 16. ? 1701864804u : (t.x < 20. ? 1852400750u : (t.x < 24. ? 1852776551u : (t.x < 28. ? 1701344288u : 2126441u))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1634890337u : (t.x < 8. ? 1835362158u : (t.x < 12. ? 7630437u : 0u))) : v;\r\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\r\n\t}\r\n\r\n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\r\n\r\n\tvec3 textColor = vec3(.3);\r\n\r\n\tp = (p - t * scale) / scale;\r\n\tp.x = (p.x - .5) * .45 + .5;\r\n\tfloat sdf = TextSDF(p, c);\r\n\tif (c != 0.)\r\n\t{\r\n\t\tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\r\n\t}\r\n\r\n\tif (s.menuId == MENU_SPECULAR)\r\n\t{\r\n\t\tcolor = mix(color, textColor, smoothstep(.05, -.05, Capsule(q.yx - vec2(-12.3, 48.), .3, 26.)));\r\n\t}\r\n}\r\n\r\nvoid MenuText(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tp -= vec2(-160, -1);\r\n\r\n\tvec2 scale = vec2(4., 8.);\r\n\tvec2 t = floor(p / scale);\r\n\r\n\tfloat tab = 1.;\r\n\tif (t.y >= 6. && t.y < 10.)\r\n\t{\r\n\t\tp.x -= tab * scale.x;\r\n\t\tt.x -= tab;\r\n\t}\r\n\tif (t.y >= 0. && t.y < 5.)\r\n\t{\r\n\t\tp.x -= tab * scale.x;\r\n\t\tt.x -= tab;\r\n\t}\r\n\tif (t.y >= 0. && t.y < 3.)\r\n\t{\r\n\t\tp.x -= tab * scale.x;\r\n\t\tt.x -= tab;\r\n\t}\r\n\r\n\tuint v = 0u;\r\n\tv = t.y == 10. ? (t.x < 4. ? 1718777171u : (t.x < 8. ? 6644577u : 0u)) : v;\r\n\tv = t.y == 9. ? (t.x < 4. ? 1635018061u : (t.x < 8. ? 108u : 0u)) : v;\r\n\tv = t.y == 8. ? (t.x < 4. ? 1818585412u : (t.x < 8. ? 1920230245u : 25449u)) : v;\r\n\tv = t.y == 7. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 1936027240u : 115u)) : v;\r\n\tv = t.y == 6. ? (t.x < 4. ? 1702060354u : (t.x < 8. ? 1819231008u : 29295u)) : v;\r\n\tv = t.y == 5. ? (t.x < 4. ? 1751607628u : (t.x < 8. ? 1735289204u : 0u)) : v;\r\n\tv = t.y == 4. ? (t.x < 4. ? 1717987652u : (t.x < 8. ? 6648693u : 0u)) : v;\r\n\tv = t.y == 3. ? (t.x < 4. ? 1667592275u : (t.x < 8. ? 1918987381u : 0u)) : v;\r\n\tv = t.y == 2. ? (t.x < 4. ? 1953720644u : (t.x < 8. ? 1969383794u : 1852795252u)) : v;\r\n\tv = t.y == 1. ? (t.x < 4. ? 1936028230u : (t.x < 8. ? 7103854u : 0u)) : v;\r\n\tv = t.y == 0. ? (t.x < 4. ? 1836016967u : (t.x < 8. ? 2037544037u : 0u)) : v;\r\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\r\n\r\n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\r\n\r\n\tvec3 textColor = vec3(.3);\r\n\tif (t.y == 10. - s.menuId)\r\n\t{\r\n\t\ttextColor = vec3(0.74, 0.5, 0.12);\r\n\t}\r\n\r\n\tp = (p - t * scale) / scale;\r\n\tp.x = (p.x - .5) * .45 + .5;\r\n\tfloat sdf = TextSDF(p, c);\r\n\tif (c != 0.)\r\n\t{\r\n\t\tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\r\n\t}\r\n}\r\n\r\nvoid DrawMenuControls(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tp -= vec2(-110, 74);\r\n\r\n\t// radial\r\n\tfloat c2 = Capsule(p - vec2(0., -3.5), 3., 4.);\r\n\tfloat c1 = Circle(p + vec2(0., 7. - 7. * s.metal), 2.5);\r\n\r\n\t// roughness slider\r\n\tp.y += 15.;\r\n\tc1 = min(c1, Capsule(p.yx - vec2(0., 20.), 1., 20.));\r\n\tc1 = min(c1, Circle(p - vec2(40. * s.roughness, 0.), 2.5));\r\n\r\n\tp.y += 8.;\r\n\tc1 = min(c1, Rectangle(p - vec2(19.5, 0.), vec2(21.4, 4.)));\r\n\tcolor = mix(color, vec3(0.9), Smooth(-c2 * 2.));\r\n\tcolor = mix(color, vec3(0.3), Smooth(-c1 * 2.));\r\n\r\n\tfor (int i = 0; i < 6; ++i)\r\n\t{\r\n\t\tvec2 o = vec2(i == int(s.baseColor) ? 2.5 : 3.5);\r\n\t\tcolor = mix(color, BASE_COLORS[i], Smooth(-2. * Rectangle(p - vec2(2. + float(i) * 7., 0.), o)));\r\n\t}\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n\tvec2 p = -1. + 2. * q;\r\n\tp.x *= iResolution.x / iResolution.y;\r\n\tp *= 100.;\r\n\r\n\tAppState s;\r\n\tLoadState(s);\r\n\r\n\tvec3 color = vec3(1., .98, .94) * mix(1.0, 0.4, Smooth(abs(.5 - uv.y)));\r\n\tfloat vignette = q.x * q.y * (1.0 - q.x) * (1.0 - q.y);\r\n\tvignette = saturate(pow(32.0 * vignette, 0.05));\r\n\tcolor *= vignette;\r\n\r\n\tDrawScene(color, p, s);\r\n\tDiagram(color, p, s);\r\n\tInfoText(color, p, s);\r\n\tMenuText(color, p, s);\r\n\tDrawMenuControls(color, p, s);\r\n\r\n\tfragColor = vec4(color, 1.);\r\n}","inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"const float MATH_PI = float(3.14159);\r\n\r\nconst float MENU_SURFACE = 0.;\r\nconst float MENU_METAL = 1.;\r\nconst float MENU_DIELECTRIC = 2.;\r\nconst float MENU_ROUGHNESS = 3.;\r\nconst float MENU_BASE_COLOR = 4.;\r\nconst float MENU_LIGHTING = 5.;\r\nconst float MENU_DIFFUSE = 6.;\r\nconst float MENU_SPECULAR = 7.;\r\nconst float MENU_DISTR = 8.;\r\nconst float MENU_FRESNEL = 9.;\r\nconst float MENU_GEOMETRY = 10.;\r\n\r\nconst vec3 BASE_COLORS[6] = vec3[6]\r\n(\r\n\tvec3(0.74),\r\n\tvec3(0.51, 0.72, 0.81),\r\n\tvec3(0.66, .85, .42),\r\n\tvec3(0.87, 0.53, 0.66),\r\n\tvec3(0.51, 0.46, 0.74),\r\n\tvec3(0.78, 0.71, 0.45)\r\n\t);\r\n\r\nstruct AppState\r\n{\r\n\tfloat\tmenuId;\r\n\tfloat\tmetal;\r\n\tfloat   roughness;\r\n\tfloat   baseColor;\r\n\tfloat   focus;\r\n\tfloat   focusObjRot;\r\n\tfloat   objRot;\r\n};\r\n\r\nvec4 LoadValue(int x, int y)\r\n{\r\n\treturn texelFetch(iChannel0, ivec2(x, y), 0);\r\n}\r\n\r\nvoid LoadState(out AppState s)\r\n{\r\n\tvec4 data;\r\n\r\n\tdata = LoadValue(0, 0);\r\n\ts.menuId = data.x;\r\n\ts.metal = data.y;\r\n\ts.roughness = data.z;\r\n\ts.baseColor = data.w;\r\n\r\n\tdata = LoadValue(1, 0);\r\n\ts.focus = data.x;\r\n\ts.focusObjRot = data.y;\r\n\ts.objRot = data.z;\r\n}\r\n\r\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\r\n{\r\n\tfragCoord = floor(fragCoord);\r\n\tfragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\r\n}\r\n\r\nfloat saturate(float x)\r\n{\r\n\treturn clamp(x, 0., 1.);\r\n}\r\n\r\nvec3 saturate(vec3 x)\r\n{\r\n\treturn clamp(x, vec3(0.), vec3(1.));\r\n}\r\n\r\nfloat Smooth(float x)\r\n{\r\n\treturn smoothstep(0., 1., saturate(x));\r\n}\r\n\r\nvoid Repeat(inout float p, float w)\r\n{\r\n\tp = mod(p, w) - 0.5f * w;\r\n}\r\n\r\nfloat Circle(vec2 p, float r)\r\n{\r\n\treturn (length(p / r) - 1.) * r;\r\n}\r\n\r\nfloat Rectangle(vec2 p, vec2 b)\r\n{\r\n\tvec2 d = abs(p) - b;\r\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\r\n}\r\n\r\nvoid Rotate(inout vec2 p, float a)\r\n{\r\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\r\n}\r\n\r\nfloat Capsule(vec2 p, float r, float c)\r\n{\r\n\treturn mix(length(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\r\n}\r\n\r\nfloat Arrow(vec2 p, float a, float l, float w)\r\n{\r\n\tRotate(p, a);\r\n\tp.y += l;\r\n\r\n\tfloat body = Capsule(p, w, l);\r\n\tp.y -= w;\r\n\r\n\tfloat tip = p.y + l;\r\n\r\n\tp.y += l + w;\r\n\tRotate(p, +2.);\r\n\ttip = max(tip, p.y - 2. * w);\r\n\tRotate(p, -4.);\r\n\ttip = max(tip, p.y - 2. * w);\r\n\r\n\treturn min(body, tip);\r\n}\r\n\r\nfloat TextSDF(vec2 p, float glyph)\r\n{\r\n\tp = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\r\n\treturn 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\r\n}\r\n\r\nvoid Diagram(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tvec3 surfColor = vec3(0.9, 0.84, 0.8);\r\n\tvec3 lightColor = vec3(0.88, 0.65, 0.2);\r\n\tvec3 baseColor = BASE_COLORS[int(s.baseColor)];\r\n\tvec3 diffuseColor = s.metal == 1. ? vec3(0.) : baseColor;\r\n\tvec3 specularColor = s.metal == 1. ? baseColor : vec3(0.7);\r\n\r\n\tp -= vec2(84., 44.);\r\n\r\n\tvec2 t = p - vec2(18., 4.);\r\n\tfloat r = Rectangle(t, vec2(52., 12.));\r\n\tcolor = mix(color, surfColor, Smooth(-r * 2.));\r\n\r\n\tt.y += s.roughness * sin(t.x);\r\n\tr = Rectangle(t - vec2(0., 11.), vec2(52., 1.2));\r\n\tcolor = mix(color, surfColor * 0.6, Smooth(-r * 2.));\r\n\r\n\r\n\t// refraction\r\n\tr = 1e4;\r\n\tt = p - vec2(18., 15.);\r\n\tfor (int i = 0; i < 3; ++i)\r\n\t{\r\n\t\tr = min(r, Arrow(t - vec2(-15. + float(i) * 15., 0.), -0.4, 7., .7));\r\n\t}\r\n\tr = min(r, Arrow(t - vec2(9., -15.), 2., 4., .7));\r\n\tr = min(r, Arrow(t - vec2(17., -10.), 3.8, 18., .7));\r\n\tr = min(r, Arrow(t - vec2(-6., -14.), 0.9, 3., .7));\r\n\tr = min(r, Arrow(t - vec2(1., -19.), 2.9, 18., .7));\r\n\tr = min(r, Arrow(t - vec2(-22., -15.), 4.5, 2., .7));\r\n\tr = min(r, Arrow(t - vec2(-28., -14.), 2.6, 14., .7));\r\n\tif (s.metal != 1. && s.menuId < MENU_SPECULAR)\r\n\t{\r\n\t\tcolor = mix(color, diffuseColor, Smooth(-r * 2.));\r\n\t}\r\n\r\n\t// reflection\r\n\tr = 1e4;\r\n\tt = p - vec2(18., 15.);\r\n\tfor (int i = 0; i < 3; ++i)\r\n\t{\r\n\t\tfloat off = s.roughness * (1.5 - float(i)) * .45;\r\n\t\tr = min(r, Arrow(t - vec2(-15. + float(i) * 15., 2.), -0.5 * MATH_PI - 0.9 + off, 12., 1.));\r\n\t}\r\n\tif (s.menuId != MENU_DIFFUSE)\r\n\t{\r\n\t\tcolor = mix(color, specularColor, Smooth(-r * 2.));\r\n\t}\r\n\r\n\t// light in\r\n\tr = 1e4;\r\n\tt = p - vec2(18., 15.);\r\n\tfor (int i = 0; i < 3; ++i)\r\n\t{\r\n\t\tr = min(r, Arrow(t - vec2(12. + float(i) * 15., 22.), -0.9, 15., 1.));\r\n\t}\r\n\tcolor = mix(color, lightColor, Smooth(-r * 2.));\r\n}\r\n\r\nfloat RaySphere(vec3 rayOrigin, vec3 rayDir, vec3 spherePos, float sphereRadius)\r\n{\r\n\tvec3 oc = rayOrigin - spherePos;\r\n\r\n\tfloat b = dot(oc, rayDir);\r\n\tfloat c = dot(oc, oc) - sphereRadius * sphereRadius;\r\n\tfloat h = b * b - c;\r\n\r\n\tfloat t;\r\n\tif (h < 0.0)\r\n\t{\r\n\t\tt = -1.0;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tt = (-b - sqrt(h));\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nfloat VisibilityTerm(float roughness, float ndotv, float ndotl)\r\n{\r\n\tfloat r2 = roughness * roughness;\r\n\tfloat gv = ndotl * sqrt(ndotv * (ndotv - ndotv * r2) + r2);\r\n\tfloat gl = ndotv * sqrt(ndotl * (ndotl - ndotl * r2) + r2);\r\n\treturn 0.5 / max(gv + gl, 0.00001);\r\n}\r\n\r\nfloat DistributionTerm(float roughness, float ndoth)\r\n{\r\n\tfloat r2 = roughness * roughness;\r\n\tfloat d = (ndoth * r2 - ndoth) * ndoth + 1.0;\r\n\treturn r2 / (d * d * MATH_PI);\r\n}\r\n\r\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\r\n{\r\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\r\n\treturn fresnel;\r\n}\r\n\r\nfloat Cylinder(vec3 p, float r, float height)\r\n{\r\n\tfloat d = length(p.xz) - r;\r\n\td = max(d, abs(p.y) - height);\r\n\treturn d;\r\n}\r\n\r\nfloat Substract(float a, float b)\r\n{\r\n\treturn max(a, -b);\r\n}\r\n\r\nfloat SubstractRound(float a, float b, float r)\r\n{\r\n\tvec2 u = max(vec2(r + a, r - b), vec2(0.0, 0.0));\r\n\treturn min(-r, max(a, -b)) + length(u);\r\n}\r\n\r\nfloat Union(float a, float b)\r\n{\r\n\treturn min(a, b);\r\n}\r\n\r\nfloat Box(vec3 p, vec3 b)\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nfloat Sphere(vec3 p, float s)\r\n{\r\n\treturn length(p) - s;\r\n}\r\n\r\nfloat Torus(vec3 p, float sr, float lr)\r\n{\r\n\treturn length(vec2(length(p.xz) - lr, p.y)) - sr;\r\n}\r\n\r\nfloat Disc(vec3 p, float r, float t)\r\n{\r\n\tfloat l = length(p.xz) - r;\r\n\treturn l < 0. ? abs(p.y) - t : length(vec2(p.y, l)) - t;\r\n}\r\n\r\nfloat UnionRound(float a, float b, float k)\r\n{\r\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k * h * (1.0 - h);\r\n}\r\n\r\nfloat Scene(vec3 p, mat3 localToWorld)\r\n{\r\n\tp = p * localToWorld;\r\n\r\n\t// ring\r\n\tvec3 t = p;\r\n\tt.y -= -.7;\r\n\tfloat r = Substract(Disc(t, 0.9, .1), Cylinder(t, .7, 2.));\r\n\tvec3 t2 = t - vec3(0., 0., 1.0);\r\n\tRotate(t2.xz, 0.25 * MATH_PI);\r\n\tr = Substract(r, Box(t2, vec3(.5)));\r\n\tr = Union(r, Disc(t + vec3(0., 0.05, 0.), 0.85, .05));\r\n\r\n\tt = p;\r\n\tRotate(t.yz, -.3);\r\n\r\n\t// body\r\n\tfloat b = Sphere(t, .8);\r\n\tb = Substract(b, Sphere(t - vec3(0., 0., .5), .5));\r\n\tb = Substract(b, Sphere(t - vec3(0., 0., -.7), .3));\r\n\tb = Substract(b, Box(t, vec3(2., .03, 2.)));\r\n\tb = Union(b, Sphere(t, .7));\r\n\r\n\tfloat ret = Union(r, b);\r\n\treturn ret;\r\n}\r\n\r\nfloat CastRay(in vec3 ro, in vec3 rd, mat3 localToWorld)\r\n{\r\n\tconst float maxd = 5.0;\r\n\r\n\tfloat h = 0.5;\r\n\tfloat t = 0.0;\r\n\r\n\tfor (int i = 0; i < 50; ++i)\r\n\t{\r\n\t\tif (h < 0.001 || t > maxd)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\th = Scene(ro + rd * t, localToWorld);\r\n\t\tt += h;\r\n\t}\r\n\r\n\tif (t > maxd)\r\n\t{\r\n\t\tt = -1.0;\r\n\t}\r\n\r\n\treturn t;\r\n}\r\n\r\nvec3 SceneNormal(in vec3 pos, mat3 localToWorld)\r\n{\r\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\r\n\tvec3 nor = vec3(\r\n\t\tScene(pos + eps.xyy, localToWorld) - Scene(pos - eps.xyy, localToWorld),\r\n\t\tScene(pos + eps.yxy, localToWorld) - Scene(pos - eps.yxy, localToWorld),\r\n\t\tScene(pos + eps.yyx, localToWorld) - Scene(pos - eps.yyx, localToWorld));\r\n\treturn normalize(nor);\r\n}\r\n\r\nfloat SceneAO(vec3 p, vec3 n, mat3 localToWorld)\r\n{\r\n\tfloat ao = 0.0;\r\n\tfloat s = 1.0;\r\n\tfor (int i = 0; i < 6; ++i)\r\n\t{\r\n\t\tfloat off = 0.001 + 0.2 * float(i) / 5.;\r\n\t\tfloat t = Scene(n * off + p, localToWorld);\r\n\t\tao += (off - t) * s;\r\n\t\ts *= 0.4;\r\n\t}\r\n\r\n\treturn Smooth(1.0 - 12.0 * ao);\r\n}\r\n\r\n// St. Peter's Basilica SH\r\n// https://www.shadertoy.com/view/lt2GRD\r\nstruct SHCoefficients\r\n{\r\n\tvec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\r\n};\r\n\r\nconst SHCoefficients SH_STPETER = SHCoefficients(\r\n\tvec3(0.3623915, 0.2624130, 0.2326261),\r\n\tvec3(0.1759131, 0.1436266, 0.1260569),\r\n\tvec3(-0.0247311, -0.0101254, -0.0010745),\r\n\tvec3(0.0346500, 0.0223184, 0.0101350),\r\n\tvec3(0.0198140, 0.0144073, 0.0043987),\r\n\tvec3(-0.0469596, -0.0254485, -0.0117786),\r\n\tvec3(-0.0898667, -0.0760911, -0.0740964),\r\n\tvec3(0.0050194, 0.0038841, 0.0001374),\r\n\tvec3(-0.0818750, -0.0321501, 0.0033399)\r\n);\r\n\r\nvec3 SHIrradiance(vec3 nrm)\r\n{\r\n\tconst SHCoefficients c = SH_STPETER;\r\n\tconst float c1 = 0.429043;\r\n\tconst float c2 = 0.511664;\r\n\tconst float c3 = 0.743125;\r\n\tconst float c4 = 0.886227;\r\n\tconst float c5 = 0.247708;\r\n\treturn (\r\n\t\tc1 * c.l22 * (nrm.x * nrm.x - nrm.y * nrm.y) +\r\n\t\tc3 * c.l20 * nrm.z * nrm.z +\r\n\t\tc4 * c.l00 -\r\n\t\tc5 * c.l20 +\r\n\t\t2.0 * c1 * c.l2m2 * nrm.x * nrm.y +\r\n\t\t2.0 * c1 * c.l21  * nrm.x * nrm.z +\r\n\t\t2.0 * c1 * c.l2m1 * nrm.y * nrm.z +\r\n\t\t2.0 * c2 * c.l11  * nrm.x +\r\n\t\t2.0 * c2 * c.l1m1 * nrm.y +\r\n\t\t2.0 * c2 * c.l10  * nrm.z\r\n\t\t);\r\n}\r\n\r\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\r\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv)\r\n{\r\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\r\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\r\n\tvec4 r = roughness * c0 + c1;\r\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\r\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\r\n\treturn specularColor * AB.x + AB.y;\r\n}\r\n\r\nvec3 EnvRemap(vec3 c)\r\n{\r\n\treturn pow(2. * c, vec3(2.2));\r\n}\r\n\r\nvoid DrawScene(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tvec3 lightColor = vec3(2.);\r\n\tvec3 lightDir = normalize(vec3(.7, .9, -.2));\r\n\r\n\tvec3 baseColor = pow(BASE_COLORS[int(s.baseColor)], vec3(2.2));\r\n\tvec3 diffuseColor = s.metal == 1. ? vec3(0.) : baseColor;\r\n\tvec3 specularColor = s.metal == 1. ? baseColor : vec3(0.02);\r\n\tfloat roughnessE = s.roughness * s.roughness;\r\n\tfloat roughnessL = max(.01, roughnessE);\r\n\r\n\tfloat a = -iTime * .5;\r\n\tmat3 rot = mat3(\r\n\t\tvec3(cos(a), 0., -sin(a)),\r\n\t\tvec3(0., 1., 0.),\r\n\t\tvec3(sin(a), 0., cos(a))\r\n\t);\r\n\r\n\tp -= vec2(-20., 10.);\r\n\tp *= .011;\r\n\r\n\tfloat yaw = 2.7 - s.objRot;\r\n\tmat3 rotZ = mat3(\r\n\t\tvec3(cos(yaw), 0.0, -sin(yaw)),\r\n\t\tvec3(0.0, 1.0, 0.0),\r\n\t\tvec3(sin(yaw), 0.0, cos(yaw))\r\n\t);\r\n\r\n\tfloat phi = -0.1;\r\n\tmat3 rotY = mat3(\r\n\t\tvec3(1.0, 0.0, 0.0),\r\n\t\tvec3(0.0, cos(phi), sin(phi)),\r\n\t\tvec3(0.0, -sin(phi), cos(phi))\r\n\t);\r\n\r\n\tmat3 localToWorld = rotY * rotZ;\r\n\r\n\tvec3 rayOrigin = vec3(0.0, .5, -3.5);\r\n\tvec3 rayDir = normalize(vec3(p.x, p.y, 2.0));\r\n\tfloat t = CastRay(rayOrigin, rayDir, localToWorld);\r\n\tif (t > 0.0)\r\n\t{\r\n\t\tvec3 pos = rayOrigin + t * rayDir;\r\n\t\tvec3 normal = SceneNormal(pos, localToWorld);\r\n\t\tvec3 viewDir = -rayDir;\r\n\t\tvec3 refl = reflect(rayDir, normal);\r\n\r\n\t\tvec3 diffuse = vec3(0.);\r\n\t\tvec3 specular = vec3(0.);\r\n\r\n\t\tvec3 halfVec = normalize(viewDir + lightDir);\r\n\t\tfloat vdoth = saturate(dot(viewDir, halfVec));\r\n\t\tfloat ndoth = saturate(dot(normal, halfVec));\r\n\t\tfloat ndotv = saturate(dot(normal, viewDir));\r\n\t\tfloat ndotl = saturate(dot(normal, lightDir));\r\n\t\tvec3 envSpecularColor = EnvBRDFApprox(specularColor, roughnessE, ndotv);\r\n\r\n\t\tvec3 env1 = EnvRemap(texture(iChannel2, refl.xy).xyz);\r\n\t\tvec3 env2 = EnvRemap(texture(iChannel1, refl.xy).xyz);\r\n\t\tvec3 env3 = EnvRemap(SHIrradiance(refl));\r\n\t\tvec3 env = mix(env1, env2, saturate(roughnessE * 4.));\r\n\t\tenv = mix(env, env3, saturate((roughnessE - 0.25) / 0.75));\r\n\r\n\t\tdiffuse += diffuseColor * EnvRemap(SHIrradiance(normal));\r\n\t\tspecular += envSpecularColor * env;\r\n\r\n\t\tdiffuse += diffuseColor * lightColor * saturate(dot(normal, lightDir));\r\n\r\n\t\tvec3 lightF = FresnelTerm(specularColor, vdoth);\r\n\t\tfloat lightD = DistributionTerm(roughnessL, ndoth);\r\n\t\tfloat lightV = VisibilityTerm(roughnessL, ndotv, ndotl);\r\n\t\tspecular += lightColor * lightF * (lightD * lightV * MATH_PI * ndotl);\r\n\r\n\t\tfloat ao = SceneAO(pos, normal, localToWorld);\r\n\t\tdiffuse *= ao;\r\n\t\tspecular *= saturate(pow(ndotv + ao, roughnessE) - 1. + ao);\r\n\r\n\t\tcolor = diffuse + specular;\r\n\t\tif (s.menuId == MENU_DIFFUSE)\r\n\t\t{\r\n\t\t\tcolor = diffuse;\r\n\t\t}\r\n\t\tif (s.menuId == MENU_SPECULAR)\r\n\t\t{\r\n\t\t\tcolor = specular;\r\n\t\t}\r\n\t\tif (s.menuId == MENU_DISTR)\r\n\t\t{\r\n\t\t\tcolor = vec3(lightD);\r\n\t\t}\r\n\t\tif (s.menuId == MENU_FRESNEL)\r\n\t\t{\r\n\t\t\tcolor = envSpecularColor;\r\n\t\t}\r\n\t\tif (s.menuId == MENU_GEOMETRY)\r\n\t\t{\r\n\t\t\tcolor = vec3(lightV) * (4.0f * ndotv * ndotl);\r\n\t\t}\r\n\t\tcolor = pow(color * .4, vec3(1. / 2.2));\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// shadow\r\n\t\tfloat planeT = -(rayOrigin.y + 1.2) / rayDir.y;\r\n\t\tif (planeT > 0.0)\r\n\t\t{\r\n\t\t\tvec3 p = rayOrigin + planeT * rayDir;\r\n\r\n\t\t\tfloat radius = .7;\r\n\t\t\tcolor *= 0.7 + 0.3 * smoothstep(0.0, 1.0, saturate(length(p + vec3(0.0, 1.0, -0.5)) - radius));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid InfoText(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tp -= vec2(52, 12);\r\n\tvec2 q = p;\r\n\tif (s.menuId == MENU_METAL || s.menuId == MENU_BASE_COLOR || s.menuId == MENU_DISTR)\r\n\t{\r\n\t\tp.y -= 6.;\r\n\t}\r\n\tif (s.menuId == MENU_DIELECTRIC || s.menuId == MENU_FRESNEL)\r\n\t{\r\n\t\tp.y += 6.;\r\n\t}\r\n\tif (s.menuId == MENU_SPECULAR)\r\n\t{\r\n\t\tp.y += 6. * 6.;\r\n\r\n\t\tif (p.x < 21. && p.y >= 27. && p.y < 30.)\r\n\t\t{\r\n\t\t\tp.y = 0.;\r\n\t\t}\r\n\t\telse if (s.menuId == MENU_SPECULAR && p.y > 20. && p.y < 28. && p.x < 21.)\r\n\t\t{\r\n\t\t\tp.y += 3.;\r\n\t\t}\r\n\t}\r\n\r\n\tvec2 scale = vec2(3., 6.);\r\n\tvec2 t = floor(p / scale);\r\n\r\n\tuint v = 0u;\r\n\tif (s.menuId == MENU_SURFACE)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1702127169u : (t.x < 8. ? 1768431730u : (t.x < 12. ? 1852404852u : (t.x < 16. ? 1752440935u : (t.x < 20. ? 1970479205u : (t.x < 24. ? 1667327602u : (t.x < 28. ? 1768693861u : 7628903u))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1937334642u : (t.x < 8. ? 1717924384u : (t.x < 12. ? 1952671084u : (t.x < 16. ? 1684955424u : (t.x < 20. ? 1717924384u : (t.x < 24. ? 1952670066u : (t.x < 28. ? 32u : 0u))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1868784481u : (t.x < 8. ? 1852400754u : (t.x < 12. ? 1869881447u : (t.x < 16. ? 1701729056u : (t.x < 20. ? 1931963500u : (t.x < 24. ? 2002873376u : 0u)))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_METAL)\r\n\t{\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1635018061u : (t.x < 8. ? 1852776556u : (t.x < 12. ? 1914730860u : (t.x < 16. ? 1701602917u : (t.x < 20. ? 544437347u : (t.x < 24. ? 1751607660u : (t.x < 28. ? 1914729332u : (t.x < 32. ? 544438625u : 45u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 544432488u : (t.x < 8. ? 2037149295u : (t.x < 12. ? 1701868320u : (t.x < 16. ? 1634497891u : (t.x < 20. ? 114u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_DIELECTRIC)\r\n\t{\r\n\t\tv = t.y == 3. ? (t.x < 4. ? 1818585412u : (t.x < 8. ? 1920230245u : (t.x < 12. ? 1914725225u : (t.x < 16. ? 1701602917u : (t.x < 20. ? 544437347u : (t.x < 24. ? 1701868328u : (t.x < 28. ? 1634497891u : (t.x < 32. ? 2107762u : 0u)))))))) : v;\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 543452769u : (t.x < 8. ? 1935832435u : (t.x < 12. ? 1634103925u : (t.x < 16. ? 1931502947u : (t.x < 20. ? 1953784163u : (t.x < 24. ? 544436837u : (t.x < 28. ? 1718182952u : (t.x < 32. ? 1702065510u : 41u)))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1751607660u : (t.x < 8. ? 1634869364u : (t.x < 12. ? 539915129u : (t.x < 16. ? 1667592275u : (t.x < 20. ? 1918987381u : (t.x < 24. ? 544434464u : (t.x < 28. ? 1936617315u : (t.x < 32. ? 1953390964u : 0u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 808333438u : (t.x < 8. ? 774909234u : (t.x < 12. ? 13360u : 0u))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_ROUGHNESS)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 544367976u : (t.x < 12. ? 1718777203u : (t.x < 16. ? 1936024417u : (t.x < 20. ? 1830825248u : (t.x < 24. ? 543519343u : (t.x < 28. ? 1952539507u : (t.x < 32. ? 1701995892u : 100u)))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 544499815u : (t.x < 20. ? 1937334642u : (t.x < 24. ? 1851858988u : (t.x < 28. ? 1752440932u : (t.x < 32. ? 2126709u : 0u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1920298082u : (t.x < 8. ? 1919248754u : (t.x < 12. ? 1717924384u : (t.x < 16. ? 1952671084u : (t.x < 20. ? 1936617321u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_BASE_COLOR)\r\n\t{\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 544370502u : (t.x < 8. ? 1635018093u : (t.x < 12. ? 1679848300u : (t.x < 16. ? 1852401253u : (t.x < 20. ? 1931506533u : (t.x < 24. ? 1969448304u : (t.x < 28. ? 544366956u : (t.x < 32. ? 1869377379u : 114u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 544370502u : (t.x < 8. ? 1818585444u : (t.x < 12. ? 1920230245u : (t.x < 16. ? 544433001u : (t.x < 20. ? 1768169517u : (t.x < 24. ? 1937073766u : (t.x < 28. ? 1868767333u : (t.x < 32. ? 7499628u : 0u)))))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_LIGHTING)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1751607628u : (t.x < 8. ? 1735289204u : (t.x < 12. ? 544434464u : (t.x < 16. ? 1869770849u : (t.x < 20. ? 1634560376u : (t.x < 24. ? 543450484u : 2128226u)))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1634755955u : (t.x < 8. ? 1769234802u : (t.x < 12. ? 1679845230u : (t.x < 16. ? 1969645161u : (t.x < 20. ? 1629513075u : (t.x < 24. ? 2122862u : 0u)))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1667592307u : (t.x < 8. ? 1918987381u : (t.x < 12. ? 1836016416u : (t.x < 16. ? 1701736304u : (t.x < 20. ? 544437358u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_DIFFUSE)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1818324307u : (t.x < 8. ? 1668489324u : (t.x < 12. ? 543517793u : (t.x < 16. ? 1935832435u : (t.x < 20. ? 1634103925u : (t.x < 24. ? 1931502947u : (t.x < 28. ? 1953784163u : (t.x < 32. ? 1852404325u : 8295u)))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1635087189u : (t.x < 8. ? 981036140u : (t.x < 12. ? 1835093024u : (t.x < 16. ? 1953654114u : (t.x < 20. ? 1146241568u : (t.x < 24. ? 1713388102u : (t.x < 28. ? 824196384u : (t.x < 32. ? 543780911u : 0u)))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1702257960u : (t.x < 8. ? 1914730866u : (t.x < 12. ? 1696627041u : (t.x < 16. ? 1937009016u : (t.x < 20. ? 544106784u : (t.x < 24. ? 1634869345u : (t.x < 28. ? 1679844462u : (t.x < 32. ? 2716265u : 0u)))))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_SPECULAR)\r\n\t{\r\n\t\tv = t.y == 8. ? (t.x < 4. ? 1818649938u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 779380839u : (t.x < 20. ? 1970492704u : (t.x < 24. ? 2037148769u : 8250u)))))) : v;\r\n\t\tv = t.y == 7. ? (t.x < 4. ? 1802465091u : (t.x < 8. ? 1919898669u : (t.x < 12. ? 1668178290u : (t.x < 16. ? 1998597221u : (t.x < 20. ? 1751345512u : (t.x < 24. ? 1685024032u : 7564389u)))))) : v;\r\n\t\tv = t.y == 6. ? (t.x < 4. ? 1919117677u : (t.x < 8. ? 1667327599u : (t.x < 12. ? 544437349u : (t.x < 16. ? 1919250472u : (t.x < 20. ? 1952671078u : (t.x < 24. ? 1919511840u : 544370546u)))))) : v;\r\n\t\tv = t.y == 5. ? (t.x < 4. ? 1734960488u : (t.x < 8. ? 1634563176u : (t.x < 12. ? 3811696u : 0u))) : v;\r\n\t\tv = t.y == 4. ? (t.x < 4. ? 745285734u : (t.x < 8. ? 1178413430u : (t.x < 12. ? 1747744296u : (t.x < 16. ? 1814578985u : (t.x < 20. ? 1747744300u : (t.x < 24. ? 1747469353u : 41u)))))) : v;\r\n\t\tv = t.y == 3. ? (t.x < 4. ? 538976288u : (t.x < 8. ? 538976288u : (t.x < 12. ? 1848128544u : (t.x < 16. ? 673803447u : (t.x < 20. ? 695646062u : 0u))))) : v;\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 539828294u : (t.x < 8. ? 1936028230u : (t.x < 12. ? 7103854u : 0u))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 539828295u : (t.x < 8. ? 1836016967u : (t.x < 12. ? 2037544037u : 0u))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 539828292u : (t.x < 8. ? 1953720644u : (t.x < 12. ? 1969383794u : (t.x < 16. ? 1852795252u : 0u)))) : v;\r\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_DISTR)\r\n\t{\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1702109252u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 622883685u : (t.x < 20. ? 543584032u : (t.x < 24. ? 1919117677u : (t.x < 28. ? 1667327599u : 544437349u))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1769235301u : (t.x < 12. ? 1814062958u : (t.x < 16. ? 1952999273u : (t.x < 20. ? 1919903264u : (t.x < 24. ? 1730175264u : (t.x < 28. ? 1852143209u : 1919509536u))))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_FRESNEL)\r\n\t{\r\n\t\tv = t.y == 3. ? (t.x < 4. ? 1702109254u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 1629516645u : (t.x < 20. ? 1853189997u : (t.x < 24. ? 1718558836u : 32u)))))) : v;\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 544499815u : (t.x < 20. ? 544370534u : (t.x < 24. ? 1768366177u : 544105846u)))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1935832435u : (t.x < 8. ? 1851880052u : (t.x < 12. ? 539911523u : (t.x < 16. ? 1629516873u : (t.x < 20. ? 1869770864u : (t.x < 24. ? 1701340001u : 3219571u)))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 544370534u : (t.x < 8. ? 2053206631u : (t.x < 12. ? 543649385u : (t.x < 16. ? 1818717793u : (t.x < 20. ? 29541u : 0u))))) : v;\r\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\r\n\t}\r\n\tif (s.menuId == MENU_GEOMETRY)\r\n\t{\r\n\t\tv = t.y == 2. ? (t.x < 4. ? 1702109255u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 1931506533u : (t.x < 20. ? 1868849512u : (t.x < 24. ? 1735289207u : (t.x < 28. ? 543584032u : 0u))))))) : v;\r\n\t\tv = t.y == 1. ? (t.x < 4. ? 1919117677u : (t.x < 8. ? 1667327599u : (t.x < 12. ? 544437349u : (t.x < 16. ? 1701864804u : (t.x < 20. ? 1852400750u : (t.x < 24. ? 1852776551u : (t.x < 28. ? 1701344288u : 2126441u))))))) : v;\r\n\t\tv = t.y == 0. ? (t.x < 4. ? 1634890337u : (t.x < 8. ? 1835362158u : (t.x < 12. ? 7630437u : 0u))) : v;\r\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\r\n\t}\r\n\r\n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\r\n\r\n\tvec3 textColor = vec3(.3);\r\n\r\n\tp = (p - t * scale) / scale;\r\n\tp.x = (p.x - .5) * .45 + .5;\r\n\tfloat sdf = TextSDF(p, c);\r\n\tif (c != 0.)\r\n\t{\r\n\t\tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\r\n\t}\r\n\r\n\tif (s.menuId == MENU_SPECULAR)\r\n\t{\r\n\t\tcolor = mix(color, textColor, smoothstep(.05, -.05, Capsule(q.yx - vec2(-12.3, 48.), .3, 26.)));\r\n\t}\r\n}\r\n\r\nvoid MenuText(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tp -= vec2(-160, -1);\r\n\r\n\tvec2 scale = vec2(4., 8.);\r\n\tvec2 t = floor(p / scale);\r\n\r\n\tfloat tab = 1.;\r\n\tif (t.y >= 6. && t.y < 10.)\r\n\t{\r\n\t\tp.x -= tab * scale.x;\r\n\t\tt.x -= tab;\r\n\t}\r\n\tif (t.y >= 0. && t.y < 5.)\r\n\t{\r\n\t\tp.x -= tab * scale.x;\r\n\t\tt.x -= tab;\r\n\t}\r\n\tif (t.y >= 0. && t.y < 3.)\r\n\t{\r\n\t\tp.x -= tab * scale.x;\r\n\t\tt.x -= tab;\r\n\t}\r\n\r\n\tuint v = 0u;\r\n\tv = t.y == 10. ? (t.x < 4. ? 1718777171u : (t.x < 8. ? 6644577u : 0u)) : v;\r\n\tv = t.y == 9. ? (t.x < 4. ? 1635018061u : (t.x < 8. ? 108u : 0u)) : v;\r\n\tv = t.y == 8. ? (t.x < 4. ? 1818585412u : (t.x < 8. ? 1920230245u : 25449u)) : v;\r\n\tv = t.y == 7. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 1936027240u : 115u)) : v;\r\n\tv = t.y == 6. ? (t.x < 4. ? 1702060354u : (t.x < 8. ? 1819231008u : 29295u)) : v;\r\n\tv = t.y == 5. ? (t.x < 4. ? 1751607628u : (t.x < 8. ? 1735289204u : 0u)) : v;\r\n\tv = t.y == 4. ? (t.x < 4. ? 1717987652u : (t.x < 8. ? 6648693u : 0u)) : v;\r\n\tv = t.y == 3. ? (t.x < 4. ? 1667592275u : (t.x < 8. ? 1918987381u : 0u)) : v;\r\n\tv = t.y == 2. ? (t.x < 4. ? 1953720644u : (t.x < 8. ? 1969383794u : 1852795252u)) : v;\r\n\tv = t.y == 1. ? (t.x < 4. ? 1936028230u : (t.x < 8. ? 7103854u : 0u)) : v;\r\n\tv = t.y == 0. ? (t.x < 4. ? 1836016967u : (t.x < 8. ? 2037544037u : 0u)) : v;\r\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\r\n\r\n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\r\n\r\n\tvec3 textColor = vec3(.3);\r\n\tif (t.y == 10. - s.menuId)\r\n\t{\r\n\t\ttextColor = vec3(0.74, 0.5, 0.12);\r\n\t}\r\n\r\n\tp = (p - t * scale) / scale;\r\n\tp.x = (p.x - .5) * .45 + .5;\r\n\tfloat sdf = TextSDF(p, c);\r\n\tif (c != 0.)\r\n\t{\r\n\t\tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\r\n\t}\r\n}\r\n\r\nvoid DrawMenuControls(inout vec3 color, vec2 p, in AppState s)\r\n{\r\n\tp -= vec2(-110, 74);\r\n\r\n\t// radial\r\n\tfloat c2 = Capsule(p - vec2(0., -3.5), 3., 4.);\r\n\tfloat c1 = Circle(p + vec2(0., 7. - 7. * s.metal), 2.5);\r\n\r\n\t// roughness slider\r\n\tp.y += 15.;\r\n\tc1 = min(c1, Capsule(p.yx - vec2(0., 20.), 1., 20.));\r\n\tc1 = min(c1, Circle(p - vec2(40. * s.roughness, 0.), 2.5));\r\n\r\n\tp.y += 8.;\r\n\tc1 = min(c1, Rectangle(p - vec2(19.5, 0.), vec2(21.4, 4.)));\r\n\tcolor = mix(color, vec3(0.9), Smooth(-c2 * 2.));\r\n\tcolor = mix(color, vec3(0.3), Smooth(-c1 * 2.));\r\n\r\n\tfor (int i = 0; i < 6; ++i)\r\n\t{\r\n\t\tvec2 o = vec2(i == int(s.baseColor) ? 2.5 : 3.5);\r\n\t\tcolor = mix(color, BASE_COLORS[i], Smooth(-2. * Rectangle(p - vec2(2. + float(i) * 7., 0.), o)));\r\n\t}\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n\tvec2 p = -1. + 2. * q;\r\n\tp.x *= iResolution.x / iResolution.y;\r\n\tp *= 100.;\r\n\r\n\tAppState s;\r\n\tLoadState(s);\r\n\r\n\tvec3 color = vec3(1., .98, .94) * mix(1.0, 0.4, Smooth(abs(.5 - uv.y)));\r\n\tfloat vignette = q.x * q.y * (1.0 - q.x) * (1.0 - q.y);\r\n\tvignette = saturate(pow(32.0 * vignette, 0.05));\r\n\tcolor *= vignette;\r\n\r\n\tDrawScene(color, p, s);\r\n\tDiagram(color, p, s);\r\n\tInfoText(color, p, s);\r\n\tMenuText(color, p, s);\r\n\tDrawMenuControls(color, p, s);\r\n\r\n\tfragColor = vec4(color, 1.);\r\n}","name":"Image","description":null,"type":"image"},{"Code":"// control loop\r\n\r\nconst float MENU_SURFACE = 0.;\r\nconst float MENU_METAL = 1.;\r\nconst float MENU_DIELECTRIC = 2.;\r\nconst float MENU_ROUGHNESS = 3.;\r\nconst float MENU_BASE_COLOR = 4.;\r\nconst float MENU_LIGHTING = 5.;\r\nconst float MENU_DIFFUSE = 6.;\r\nconst float MENU_SPECULAR = 7.;\r\nconst float MENU_DISTR = 8.;\r\nconst float MENU_FRESNEL = 9.;\r\nconst float MENU_GEOMETRY = 10.;\r\n\r\nconst float FOCUS_SLIDER = 1.;\r\nconst float FOCUS_OBJ = 2.;\r\nconst float FOCUS_COLOR = 3.;\r\n\r\nstruct AppState\r\n{\r\n    float menuId;\r\n    float metal;\r\n    float roughness;\r\n    float baseColor;\r\n    float focus;\r\n    float focusObjRot;\r\n    float objRot;\r\n};\r\n\r\nvec4 LoadValue(int x, int y)\r\n{\r\n    return texelFetch(iChannel0, ivec2(x, y), 0);\r\n}\r\n\r\nvoid LoadState(out AppState s)\r\n{\r\n    vec4 data;\r\n\r\n    data = LoadValue(0, 0);\r\n    s.menuId = data.x;\r\n    s.metal = data.y;\r\n    s.roughness = data.z;\r\n    s.baseColor = data.w;\r\n\r\n    data = LoadValue(1, 0);\r\n    s.focus = data.x;\r\n    s.focusObjRot = data.y;\r\n    s.objRot = data.z;\r\n}\r\n\r\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\r\n{\r\n    fragCoord = floor(fragCoord);\r\n    fragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\r\n}\r\n\r\nvec4 SaveState(in AppState s, in vec2 fragCoord)\r\n{\r\n    vec4 ret = vec4(0.);\r\n    StoreValue(vec2(0., 0.), vec4(s.menuId, s.metal, s.roughness, s.baseColor), ret, fragCoord);\r\n    StoreValue(vec2(1., 0.), vec4(s.focus, s.focusObjRot, s.objRot, 0.), ret, fragCoord);\r\n    //ret = iFrame >= 1 ? ret : vec4(0.);\r\n    //ret = vec4(0.);\r\n    return ret;\r\n}\r\n\r\nfloat saturate(float x)\r\n{\r\n    return clamp(x, 0., 1.);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    if (fragCoord.x >= 8. || fragCoord.y >= 8.)\r\n    {\r\n        discard;\r\n    }\r\n\r\n    AppState s;\r\n    LoadState(s);\r\n\r\n    vec4 q = iMouse / iResolution.xyxy;\r\n    vec4 m = -1. + 2. * q;\r\n    m.xz *= iResolution.x / iResolution.y;\r\n    m *= 100.;\r\n\r\n    vec4 sliderM = m - vec2(-110, 74).xyxy;\r\n    if (sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -20. && sliderM.w < -10.)\r\n    {\r\n        s.focus = FOCUS_SLIDER;\r\n    }\r\n    else if (sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -30. && sliderM.w < -20.)\r\n    {\r\n        s.focus = FOCUS_COLOR;\r\n    }\r\n    else if (sliderM.z >= -4. && sliderM.z < 6. && sliderM.w >= -10. && sliderM.w < -4.)\r\n    {\r\n        s.metal = 0.;\r\n        s.menuId = s.menuId == MENU_METAL ? MENU_DIELECTRIC : s.menuId;\r\n    }\r\n    else if (sliderM.z >= -4. && sliderM.z < 6. && sliderM.w >= -4. && sliderM.w < 6.)\r\n    {\r\n        s.metal = 1.;\r\n        s.menuId = s.menuId == MENU_DIELECTRIC ? MENU_METAL : s.menuId;\r\n    }\r\n    else if (m.w > -100. && m.w < 40. && abs(m.z + 20.) < 70.)\r\n    {\r\n        if (s.focus != FOCUS_OBJ)\r\n        {\r\n            s.focusObjRot = s.objRot;\r\n        }\r\n        s.focus = FOCUS_OBJ;\r\n    }\r\n    else\r\n    {\r\n        s.focus = 0.;\r\n        vec2 mp = (m.xy - vec2(-160, -1));\r\n        float menuId = mp.x < 40. || (mp.x < 60. && (mp.y > 18. && mp.y < 24.)) ? 10. - floor(mp.y / 8.) : -1.;\r\n        if (menuId >= 0. && menuId <= 10.)\r\n        {\r\n            s.menuId = menuId;\r\n        }\r\n        s.metal = menuId == MENU_METAL ? 1. : s.metal;\r\n        s.metal = menuId == MENU_DIELECTRIC ? 0. : s.metal;\r\n    }\r\n\r\n    if (s.focus == FOCUS_SLIDER)\r\n    {\r\n        s.roughness = saturate(sliderM.x / 40.);\r\n    }\r\n    if (s.focus == FOCUS_COLOR)\r\n    {\r\n        s.baseColor = floor(clamp((sliderM.x * 5.) / 32., 0., 5.));\r\n    }\r\n    if (s.focus == FOCUS_OBJ)\r\n    {\r\n        s.objRot = s.focusObjRot + .04 * (m.x - m.z);\r\n    }\r\n\r\n    fragColor = SaveState(s, fragCoord);\r\n}","inputs":[],"outputs":[],"code":"// control loop\r\n\r\nconst float MENU_SURFACE = 0.;\r\nconst float MENU_METAL = 1.;\r\nconst float MENU_DIELECTRIC = 2.;\r\nconst float MENU_ROUGHNESS = 3.;\r\nconst float MENU_BASE_COLOR = 4.;\r\nconst float MENU_LIGHTING = 5.;\r\nconst float MENU_DIFFUSE = 6.;\r\nconst float MENU_SPECULAR = 7.;\r\nconst float MENU_DISTR = 8.;\r\nconst float MENU_FRESNEL = 9.;\r\nconst float MENU_GEOMETRY = 10.;\r\n\r\nconst float FOCUS_SLIDER = 1.;\r\nconst float FOCUS_OBJ = 2.;\r\nconst float FOCUS_COLOR = 3.;\r\n\r\nstruct AppState\r\n{\r\n    float menuId;\r\n    float metal;\r\n    float roughness;\r\n    float baseColor;\r\n    float focus;\r\n    float focusObjRot;\r\n    float objRot;\r\n};\r\n\r\nvec4 LoadValue(int x, int y)\r\n{\r\n    return texelFetch(iChannel0, ivec2(x, y), 0);\r\n}\r\n\r\nvoid LoadState(out AppState s)\r\n{\r\n    vec4 data;\r\n\r\n    data = LoadValue(0, 0);\r\n    s.menuId = data.x;\r\n    s.metal = data.y;\r\n    s.roughness = data.z;\r\n    s.baseColor = data.w;\r\n\r\n    data = LoadValue(1, 0);\r\n    s.focus = data.x;\r\n    s.focusObjRot = data.y;\r\n    s.objRot = data.z;\r\n}\r\n\r\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\r\n{\r\n    fragCoord = floor(fragCoord);\r\n    fragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\r\n}\r\n\r\nvec4 SaveState(in AppState s, in vec2 fragCoord)\r\n{\r\n    vec4 ret = vec4(0.);\r\n    StoreValue(vec2(0., 0.), vec4(s.menuId, s.metal, s.roughness, s.baseColor), ret, fragCoord);\r\n    StoreValue(vec2(1., 0.), vec4(s.focus, s.focusObjRot, s.objRot, 0.), ret, fragCoord);\r\n    //ret = iFrame >= 1 ? ret : vec4(0.);\r\n    //ret = vec4(0.);\r\n    return ret;\r\n}\r\n\r\nfloat saturate(float x)\r\n{\r\n    return clamp(x, 0., 1.);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    if (fragCoord.x >= 8. || fragCoord.y >= 8.)\r\n    {\r\n        discard;\r\n    }\r\n\r\n    AppState s;\r\n    LoadState(s);\r\n\r\n    vec4 q = iMouse / iResolution.xyxy;\r\n    vec4 m = -1. + 2. * q;\r\n    m.xz *= iResolution.x / iResolution.y;\r\n    m *= 100.;\r\n\r\n    vec4 sliderM = m - vec2(-110, 74).xyxy;\r\n    if (sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -20. && sliderM.w < -10.)\r\n    {\r\n        s.focus = FOCUS_SLIDER;\r\n    }\r\n    else if (sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -30. && sliderM.w < -20.)\r\n    {\r\n        s.focus = FOCUS_COLOR;\r\n    }\r\n    else if (sliderM.z >= -4. && sliderM.z < 6. && sliderM.w >= -10. && sliderM.w < -4.)\r\n    {\r\n        s.metal = 0.;\r\n        s.menuId = s.menuId == MENU_METAL ? MENU_DIELECTRIC : s.menuId;\r\n    }\r\n    else if (sliderM.z >= -4. && sliderM.z < 6. && sliderM.w >= -4. && sliderM.w < 6.)\r\n    {\r\n        s.metal = 1.;\r\n        s.menuId = s.menuId == MENU_DIELECTRIC ? MENU_METAL : s.menuId;\r\n    }\r\n    else if (m.w > -100. && m.w < 40. && abs(m.z + 20.) < 70.)\r\n    {\r\n        if (s.focus != FOCUS_OBJ)\r\n        {\r\n            s.focusObjRot = s.objRot;\r\n        }\r\n        s.focus = FOCUS_OBJ;\r\n    }\r\n    else\r\n    {\r\n        s.focus = 0.;\r\n        vec2 mp = (m.xy - vec2(-160, -1));\r\n        float menuId = mp.x < 40. || (mp.x < 60. && (mp.y > 18. && mp.y < 24.)) ? 10. - floor(mp.y / 8.) : -1.;\r\n        if (menuId >= 0. && menuId <= 10.)\r\n        {\r\n            s.menuId = menuId;\r\n        }\r\n        s.metal = menuId == MENU_METAL ? 1. : s.metal;\r\n        s.metal = menuId == MENU_DIELECTRIC ? 0. : s.metal;\r\n    }\r\n\r\n    if (s.focus == FOCUS_SLIDER)\r\n    {\r\n        s.roughness = saturate(sliderM.x / 40.);\r\n    }\r\n    if (s.focus == FOCUS_COLOR)\r\n    {\r\n        s.baseColor = floor(clamp((sliderM.x * 5.) / 32., 0., 5.));\r\n    }\r\n    if (s.focus == FOCUS_OBJ)\r\n    {\r\n        s.objRot = s.focusObjRot + .04 * (m.x - m.z);\r\n    }\r\n\r\n    fragColor = SaveState(s, fragCoord);\r\n}","name":"Buf A","description":null,"type":null}]},{"Ver":null,"ImageRenderpass":{"Code":"// rendering params\r\nconst float sphsize=.7; // planet size\r\nconst float dist=.27; // distance for glow and distortion\r\nconst float perturb=.3; // distortion amount of the flow around the planet\r\nconst float displacement=.015; // hot air effect\r\nconst float windspeed=.4; // speed of wind flow\r\nconst float steps=110.; // number of steps for the volumetric rendering\r\nconst float stepsize=.025; \r\nconst float brightness=.43;\r\nconst vec3 planetcolor=vec3(0.55,0.4,0.3);\r\nconst float fade=.005; //fade by distance\r\nconst float glow=3.5; // glow amount, mainly on hit side\r\n\r\n\r\n// fractal params\r\nconst int iterations=13; \r\nconst float fractparam=.7;\r\nconst vec3 offset=vec3(1.5,2.,-1.5);\r\n\r\n\r\nfloat wind(vec3 p) {\r\n\tfloat d=max(0.,dist-max(0.,length(p)-sphsize)/sphsize)/dist; // for distortion and glow area\r\n\tfloat x=max(0.2,p.x*2.); // to increase glow on left side\r\n\tp.y*=1.+max(0.,-p.x-sphsize*.25)*1.5; // left side distortion (cheesy)\r\n\tp-=d*normalize(p)*perturb; // spheric distortion of flow\r\n\tp+=vec3(iTime*windspeed,0.,0.); // flow movement\r\n\tp=abs(fract((p+offset)*.1)-.5); // tile folding \r\n\tfor (int i=0; i<iterations; i++) {  \r\n\t\tp=abs(p)/dot(p,p)-fractparam; // the magic formula for the hot flow\r\n\t}\r\n\treturn length(p)*(1.+d*glow*x)+d*glow*x; // return the result with glow applied\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// get ray dir\t\r\n\tvec2 uv = fragCoord.xy / iResolution.xy-.5;\r\n\tvec3 dir=vec3(uv,1.);\r\n\tdir.x*=iResolution.x/iResolution.y;\r\n\tvec3 from=vec3(0.,0.,-2.+texture(iChannel0,uv*.5+iTime).x*stepsize); //from+dither\r\n\r\n\t// volumetric rendering\r\n\tfloat v=0., l=-0.0001, t=iTime*windspeed*.2;\r\n\tfor (float r=10.;r<steps;r++) {\r\n\t\tvec3 p=from+r*dir*stepsize;\r\n\t\tfloat tx=texture(iChannel0,uv*.2+vec2(t,0.)).x*displacement; // hot air effect\r\n\t\tif (length(p)-sphsize-tx>0.)\r\n\t\t// outside planet, accumulate values as ray goes, applying distance fading\r\n\t\t\tv+=min(50.,wind(p))*max(0.,1.-r*fade); \r\n\t\telse if (l<0.) \r\n\t\t//inside planet, get planet shading if not already \r\n\t\t//loop continues because of previous problems with breaks and not always optimizes much\r\n\t\t\tl=pow(max(.53,dot(normalize(p),normalize(vec3(-1.,.5,-0.3)))),4.)\r\n\t\t\t*(.5+texture(iChannel1,uv*vec2(2.,1.)*(1.+p.z*.5)+vec2(tx+t*.5,0.)).x*2.);\r\n\t\t}\r\n\tv/=steps; v*=brightness; // average values and apply bright factor\r\n\tvec3 col=vec3(v*1.25,v*v,v*v*v)+l*planetcolor; // set color\r\n\tcol*=1.-length(pow(abs(uv),vec2(5.)))*14.; // vignette (kind of)\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":null,"published":0}],"outputs":[],"code":"// rendering params\r\nconst float sphsize=.7; // planet size\r\nconst float dist=.27; // distance for glow and distortion\r\nconst float perturb=.3; // distortion amount of the flow around the planet\r\nconst float displacement=.015; // hot air effect\r\nconst float windspeed=.4; // speed of wind flow\r\nconst float steps=110.; // number of steps for the volumetric rendering\r\nconst float stepsize=.025; \r\nconst float brightness=.43;\r\nconst vec3 planetcolor=vec3(0.55,0.4,0.3);\r\nconst float fade=.005; //fade by distance\r\nconst float glow=3.5; // glow amount, mainly on hit side\r\n\r\n\r\n// fractal params\r\nconst int iterations=13; \r\nconst float fractparam=.7;\r\nconst vec3 offset=vec3(1.5,2.,-1.5);\r\n\r\n\r\nfloat wind(vec3 p) {\r\n\tfloat d=max(0.,dist-max(0.,length(p)-sphsize)/sphsize)/dist; // for distortion and glow area\r\n\tfloat x=max(0.2,p.x*2.); // to increase glow on left side\r\n\tp.y*=1.+max(0.,-p.x-sphsize*.25)*1.5; // left side distortion (cheesy)\r\n\tp-=d*normalize(p)*perturb; // spheric distortion of flow\r\n\tp+=vec3(iTime*windspeed,0.,0.); // flow movement\r\n\tp=abs(fract((p+offset)*.1)-.5); // tile folding \r\n\tfor (int i=0; i<iterations; i++) {  \r\n\t\tp=abs(p)/dot(p,p)-fractparam; // the magic formula for the hot flow\r\n\t}\r\n\treturn length(p)*(1.+d*glow*x)+d*glow*x; // return the result with glow applied\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// get ray dir\t\r\n\tvec2 uv = fragCoord.xy / iResolution.xy-.5;\r\n\tvec3 dir=vec3(uv,1.);\r\n\tdir.x*=iResolution.x/iResolution.y;\r\n\tvec3 from=vec3(0.,0.,-2.+texture(iChannel0,uv*.5+iTime).x*stepsize); //from+dither\r\n\r\n\t// volumetric rendering\r\n\tfloat v=0., l=-0.0001, t=iTime*windspeed*.2;\r\n\tfor (float r=10.;r<steps;r++) {\r\n\t\tvec3 p=from+r*dir*stepsize;\r\n\t\tfloat tx=texture(iChannel0,uv*.2+vec2(t,0.)).x*displacement; // hot air effect\r\n\t\tif (length(p)-sphsize-tx>0.)\r\n\t\t// outside planet, accumulate values as ray goes, applying distance fading\r\n\t\t\tv+=min(50.,wind(p))*max(0.,1.-r*fade); \r\n\t\telse if (l<0.) \r\n\t\t//inside planet, get planet shading if not already \r\n\t\t//loop continues because of previous problems with breaks and not always optimizes much\r\n\t\t\tl=pow(max(.53,dot(normalize(p),normalize(vec3(-1.,.5,-0.3)))),4.)\r\n\t\t\t*(.5+texture(iChannel1,uv*vec2(2.,1.)*(1.+p.z*.5)+vec2(tx+t*.5,0.)).x*2.);\r\n\t\t}\r\n\tv/=steps; v*=brightness; // average values and apply bright factor\r\n\tvec3 col=vec3(v*1.25,v*v,v*v*v)+l*planetcolor; // set color\r\n\tcol*=1.-length(pow(abs(uv),vec2(5.)))*14.; // vignette (kind of)\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":null,"published":0}],"Info":{"Name":"Hot Shower ","id":null,"date":null,"viewed":0,"name":"Hot Shower ","description":"Using a tile-folded version of the \"p=abs(p)/dot(p,p)-c\" fractal (ashamedly named by me \"kaliset\"),  to render a hot particle-like flow and then applying some distortions to make it look like this kind of \"planet\" object is being hit by it.","likes":0,"published":null,"tags":["planet"]},"ver":null,"info":{"Name":"Hot Shower ","id":null,"date":null,"viewed":0,"name":"Hot Shower ","description":"Using a tile-folded version of the \"p=abs(p)/dot(p,p)-c\" fractal (ashamedly named by me \"kaliset\"),  to render a hot particle-like flow and then applying some distortions to make it look like this kind of \"planet\" object is being hit by it.","likes":0,"published":null,"tags":["planet"]},"renderpass":[{"Code":"// rendering params\r\nconst float sphsize=.7; // planet size\r\nconst float dist=.27; // distance for glow and distortion\r\nconst float perturb=.3; // distortion amount of the flow around the planet\r\nconst float displacement=.015; // hot air effect\r\nconst float windspeed=.4; // speed of wind flow\r\nconst float steps=110.; // number of steps for the volumetric rendering\r\nconst float stepsize=.025; \r\nconst float brightness=.43;\r\nconst vec3 planetcolor=vec3(0.55,0.4,0.3);\r\nconst float fade=.005; //fade by distance\r\nconst float glow=3.5; // glow amount, mainly on hit side\r\n\r\n\r\n// fractal params\r\nconst int iterations=13; \r\nconst float fractparam=.7;\r\nconst vec3 offset=vec3(1.5,2.,-1.5);\r\n\r\n\r\nfloat wind(vec3 p) {\r\n\tfloat d=max(0.,dist-max(0.,length(p)-sphsize)/sphsize)/dist; // for distortion and glow area\r\n\tfloat x=max(0.2,p.x*2.); // to increase glow on left side\r\n\tp.y*=1.+max(0.,-p.x-sphsize*.25)*1.5; // left side distortion (cheesy)\r\n\tp-=d*normalize(p)*perturb; // spheric distortion of flow\r\n\tp+=vec3(iTime*windspeed,0.,0.); // flow movement\r\n\tp=abs(fract((p+offset)*.1)-.5); // tile folding \r\n\tfor (int i=0; i<iterations; i++) {  \r\n\t\tp=abs(p)/dot(p,p)-fractparam; // the magic formula for the hot flow\r\n\t}\r\n\treturn length(p)*(1.+d*glow*x)+d*glow*x; // return the result with glow applied\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// get ray dir\t\r\n\tvec2 uv = fragCoord.xy / iResolution.xy-.5;\r\n\tvec3 dir=vec3(uv,1.);\r\n\tdir.x*=iResolution.x/iResolution.y;\r\n\tvec3 from=vec3(0.,0.,-2.+texture(iChannel0,uv*.5+iTime).x*stepsize); //from+dither\r\n\r\n\t// volumetric rendering\r\n\tfloat v=0., l=-0.0001, t=iTime*windspeed*.2;\r\n\tfor (float r=10.;r<steps;r++) {\r\n\t\tvec3 p=from+r*dir*stepsize;\r\n\t\tfloat tx=texture(iChannel0,uv*.2+vec2(t,0.)).x*displacement; // hot air effect\r\n\t\tif (length(p)-sphsize-tx>0.)\r\n\t\t// outside planet, accumulate values as ray goes, applying distance fading\r\n\t\t\tv+=min(50.,wind(p))*max(0.,1.-r*fade); \r\n\t\telse if (l<0.) \r\n\t\t//inside planet, get planet shading if not already \r\n\t\t//loop continues because of previous problems with breaks and not always optimizes much\r\n\t\t\tl=pow(max(.53,dot(normalize(p),normalize(vec3(-1.,.5,-0.3)))),4.)\r\n\t\t\t*(.5+texture(iChannel1,uv*vec2(2.,1.)*(1.+p.z*.5)+vec2(tx+t*.5,0.)).x*2.);\r\n\t\t}\r\n\tv/=steps; v*=brightness; // average values and apply bright factor\r\n\tvec3 col=vec3(v*1.25,v*v,v*v*v)+l*planetcolor; // set color\r\n\tcol*=1.-length(pow(abs(uv),vec2(5.)))*14.; // vignette (kind of)\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":null,"published":0}],"outputs":[],"code":"// rendering params\r\nconst float sphsize=.7; // planet size\r\nconst float dist=.27; // distance for glow and distortion\r\nconst float perturb=.3; // distortion amount of the flow around the planet\r\nconst float displacement=.015; // hot air effect\r\nconst float windspeed=.4; // speed of wind flow\r\nconst float steps=110.; // number of steps for the volumetric rendering\r\nconst float stepsize=.025; \r\nconst float brightness=.43;\r\nconst vec3 planetcolor=vec3(0.55,0.4,0.3);\r\nconst float fade=.005; //fade by distance\r\nconst float glow=3.5; // glow amount, mainly on hit side\r\n\r\n\r\n// fractal params\r\nconst int iterations=13; \r\nconst float fractparam=.7;\r\nconst vec3 offset=vec3(1.5,2.,-1.5);\r\n\r\n\r\nfloat wind(vec3 p) {\r\n\tfloat d=max(0.,dist-max(0.,length(p)-sphsize)/sphsize)/dist; // for distortion and glow area\r\n\tfloat x=max(0.2,p.x*2.); // to increase glow on left side\r\n\tp.y*=1.+max(0.,-p.x-sphsize*.25)*1.5; // left side distortion (cheesy)\r\n\tp-=d*normalize(p)*perturb; // spheric distortion of flow\r\n\tp+=vec3(iTime*windspeed,0.,0.); // flow movement\r\n\tp=abs(fract((p+offset)*.1)-.5); // tile folding \r\n\tfor (int i=0; i<iterations; i++) {  \r\n\t\tp=abs(p)/dot(p,p)-fractparam; // the magic formula for the hot flow\r\n\t}\r\n\treturn length(p)*(1.+d*glow*x)+d*glow*x; // return the result with glow applied\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// get ray dir\t\r\n\tvec2 uv = fragCoord.xy / iResolution.xy-.5;\r\n\tvec3 dir=vec3(uv,1.);\r\n\tdir.x*=iResolution.x/iResolution.y;\r\n\tvec3 from=vec3(0.,0.,-2.+texture(iChannel0,uv*.5+iTime).x*stepsize); //from+dither\r\n\r\n\t// volumetric rendering\r\n\tfloat v=0., l=-0.0001, t=iTime*windspeed*.2;\r\n\tfor (float r=10.;r<steps;r++) {\r\n\t\tvec3 p=from+r*dir*stepsize;\r\n\t\tfloat tx=texture(iChannel0,uv*.2+vec2(t,0.)).x*displacement; // hot air effect\r\n\t\tif (length(p)-sphsize-tx>0.)\r\n\t\t// outside planet, accumulate values as ray goes, applying distance fading\r\n\t\t\tv+=min(50.,wind(p))*max(0.,1.-r*fade); \r\n\t\telse if (l<0.) \r\n\t\t//inside planet, get planet shading if not already \r\n\t\t//loop continues because of previous problems with breaks and not always optimizes much\r\n\t\t\tl=pow(max(.53,dot(normalize(p),normalize(vec3(-1.,.5,-0.3)))),4.)\r\n\t\t\t*(.5+texture(iChannel1,uv*vec2(2.,1.)*(1.+p.z*.5)+vec2(tx+t*.5,0.)).x*2.);\r\n\t\t}\r\n\tv/=steps; v*=brightness; // average values and apply bright factor\r\n\tvec3 col=vec3(v*1.25,v*v,v*v*v)+l*planetcolor; // set color\r\n\tcol*=1.-length(pow(abs(uv),vec2(5.)))*14.; // vignette (kind of)\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// fur ball\r\n// (c) simon green 2013\r\n// @simesgreen\r\n// v1.1\r\n\r\nconst float uvScale = 1.0;\r\nconst float colorUvScale = 0.1;\r\nconst float furDepth = 0.2;\r\nconst int furLayers = 64;\r\nconst float rayStep = furDepth*2.0 / float(furLayers);\r\nconst float furThreshold = 0.4;\r\nconst float shininess = 50.0;\r\n\r\nbool intersectSphere(vec3 ro, vec3 rd, float r, out float t)\r\n{\r\n\tfloat b = dot(-ro, rd);\r\n\tfloat det = b*b - dot(ro, ro) + r*r;\r\n\tif (det < 0.0) return false;\r\n\tdet = sqrt(det);\r\n\tt = b - det;\r\n\treturn t > 0.0;\r\n}\r\n\r\nvec3 rotateX(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\r\n}\r\n\r\nvec3 rotateY(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\r\n}\r\n\r\nvec2 cartesianToSpherical(vec3 p)\r\n{\t\t\r\n\tfloat r = length(p);\r\n\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\t\r\n\tp = rotateX(p.zyx, -cos(iTime*1.5)*t*t*0.4).zyx;\t// curl\r\n\r\n\tp /= r;\t\r\n\tvec2 uv = vec2(atan(p.y, p.x), acos(p.z));\r\n\r\n\t//uv.x += cos(iTime*1.5)*t*t*0.4;\t// curl\r\n\t//uv.y += sin(iTime*1.7)*t*t*0.2;\r\n\tuv.y -= t*t*0.1;\t// curl down\r\n\treturn uv;\r\n}\r\n\r\n// returns fur density at given position\r\nfloat furDensity(vec3 pos, out vec2 uv)\r\n{\r\n\tuv = cartesianToSpherical(pos.xzy);\t\r\n\tvec4 tex = textureLod(iChannel0, uv*uvScale, 0.0);\r\n\r\n\t// thin out hair\r\n\tfloat density = smoothstep(furThreshold, 1.0, tex.x);\r\n\t\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\t\r\n\t// fade out along length\r\n\tfloat len = tex.y;\r\n\tdensity *= smoothstep(len, len-0.2, t);\r\n\r\n\treturn density;\t\r\n}\r\n\r\n// calculate normal from density\r\nvec3 furNormal(vec3 pos, float density)\r\n{\r\n    float eps = 0.01;\r\n    vec3 n;\r\n\tvec2 uv;\r\n    n.x = furDensity( vec3(pos.x+eps, pos.y, pos.z), uv ) - density;\r\n    n.y = furDensity( vec3(pos.x, pos.y+eps, pos.z), uv ) - density;\r\n    n.z = furDensity( vec3(pos.x, pos.y, pos.z+eps), uv ) - density;\r\n    return normalize(n);\r\n}\r\n\r\nvec3 furShade(vec3 pos, vec2 uv, vec3 ro, float density)\r\n{\r\n\t// lighting\r\n\tconst vec3 L = vec3(0, 1, 0);\r\n\tvec3 V = normalize(ro - pos);\r\n\tvec3 H = normalize(V + L);\r\n\r\n\tvec3 N = -furNormal(pos, density);\r\n\t//float diff = max(0.0, dot(N, L));\r\n\tfloat diff = max(0.0, dot(N, L)*0.5+0.5);\r\n\tfloat spec = pow(max(0.0, dot(N, H)), shininess);\r\n\t\r\n\t// base color\r\n\tvec3 color = textureLod(iChannel1, uv*colorUvScale, 0.0).xyz;\r\n\r\n\t// darken with depth\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\tt = clamp(t, 0.0, 1.0);\r\n\tfloat i = t*0.5+0.5;\r\n\t\t\r\n\treturn color*diff*i + vec3(spec*i);\r\n}\t\t\r\n\r\nvec4 scene(vec3 ro,vec3 rd)\r\n{\r\n\tvec3 p = vec3(0.0);\r\n\tconst float r = 1.0;\r\n\tfloat t;\t\t\t\t  \r\n\tbool hit = intersectSphere(ro - p, rd, r, t);\r\n\t\r\n\tvec4 c = vec4(0.0);\r\n\tif (hit) {\r\n\t\tvec3 pos = ro + rd*t;\r\n\r\n\t\t// ray-march into volume\r\n\t\tfor(int i=0; i<furLayers; i++) {\r\n\t\t\tvec4 sampleCol;\r\n\t\t\tvec2 uv;\r\n\t\t\tsampleCol.a = furDensity(pos, uv);\r\n\t\t\tif (sampleCol.a > 0.0) {\r\n\t\t\t\tsampleCol.rgb = furShade(pos, uv, ro, sampleCol.a);\r\n\r\n\t\t\t\t// pre-multiply alpha\r\n\t\t\t\tsampleCol.rgb *= sampleCol.a;\r\n\t\t\t\tc = c + sampleCol*(1.0 - c.a);\r\n\t\t\t\tif (c.a > 0.95) break;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpos += rd*rayStep;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tuv = uv*2.0-1.0;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n\t\r\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\r\n\tvec3 rd = normalize(vec3(uv, -2.0));\r\n\t\r\n\tvec2 mouse = iMouse.xy / iResolution.xy;\r\n\tfloat roty = 0.0;\r\n\tfloat rotx = 0.0;\r\n\tif (iMouse.z > 0.0) {\r\n\t\trotx = (mouse.y-0.5)*3.0;\r\n\t\troty = -(mouse.x-0.5)*6.0;\r\n\t} else {\r\n\t\troty = sin(iTime*1.5);\r\n\t}\r\n\t\r\n    ro = rotateX(ro, rotx);\t\r\n    ro = rotateY(ro, roty);\t\r\n    rd = rotateX(rd, rotx);\r\n    rd = rotateY(rd, roty);\r\n\t\r\n\tfragColor = scene(ro, rd);\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":null,"published":0}],"outputs":[],"code":"// fur ball\r\n// (c) simon green 2013\r\n// @simesgreen\r\n// v1.1\r\n\r\nconst float uvScale = 1.0;\r\nconst float colorUvScale = 0.1;\r\nconst float furDepth = 0.2;\r\nconst int furLayers = 64;\r\nconst float rayStep = furDepth*2.0 / float(furLayers);\r\nconst float furThreshold = 0.4;\r\nconst float shininess = 50.0;\r\n\r\nbool intersectSphere(vec3 ro, vec3 rd, float r, out float t)\r\n{\r\n\tfloat b = dot(-ro, rd);\r\n\tfloat det = b*b - dot(ro, ro) + r*r;\r\n\tif (det < 0.0) return false;\r\n\tdet = sqrt(det);\r\n\tt = b - det;\r\n\treturn t > 0.0;\r\n}\r\n\r\nvec3 rotateX(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\r\n}\r\n\r\nvec3 rotateY(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\r\n}\r\n\r\nvec2 cartesianToSpherical(vec3 p)\r\n{\t\t\r\n\tfloat r = length(p);\r\n\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\t\r\n\tp = rotateX(p.zyx, -cos(iTime*1.5)*t*t*0.4).zyx;\t// curl\r\n\r\n\tp /= r;\t\r\n\tvec2 uv = vec2(atan(p.y, p.x), acos(p.z));\r\n\r\n\t//uv.x += cos(iTime*1.5)*t*t*0.4;\t// curl\r\n\t//uv.y += sin(iTime*1.7)*t*t*0.2;\r\n\tuv.y -= t*t*0.1;\t// curl down\r\n\treturn uv;\r\n}\r\n\r\n// returns fur density at given position\r\nfloat furDensity(vec3 pos, out vec2 uv)\r\n{\r\n\tuv = cartesianToSpherical(pos.xzy);\t\r\n\tvec4 tex = textureLod(iChannel0, uv*uvScale, 0.0);\r\n\r\n\t// thin out hair\r\n\tfloat density = smoothstep(furThreshold, 1.0, tex.x);\r\n\t\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\t\r\n\t// fade out along length\r\n\tfloat len = tex.y;\r\n\tdensity *= smoothstep(len, len-0.2, t);\r\n\r\n\treturn density;\t\r\n}\r\n\r\n// calculate normal from density\r\nvec3 furNormal(vec3 pos, float density)\r\n{\r\n    float eps = 0.01;\r\n    vec3 n;\r\n\tvec2 uv;\r\n    n.x = furDensity( vec3(pos.x+eps, pos.y, pos.z), uv ) - density;\r\n    n.y = furDensity( vec3(pos.x, pos.y+eps, pos.z), uv ) - density;\r\n    n.z = furDensity( vec3(pos.x, pos.y, pos.z+eps), uv ) - density;\r\n    return normalize(n);\r\n}\r\n\r\nvec3 furShade(vec3 pos, vec2 uv, vec3 ro, float density)\r\n{\r\n\t// lighting\r\n\tconst vec3 L = vec3(0, 1, 0);\r\n\tvec3 V = normalize(ro - pos);\r\n\tvec3 H = normalize(V + L);\r\n\r\n\tvec3 N = -furNormal(pos, density);\r\n\t//float diff = max(0.0, dot(N, L));\r\n\tfloat diff = max(0.0, dot(N, L)*0.5+0.5);\r\n\tfloat spec = pow(max(0.0, dot(N, H)), shininess);\r\n\t\r\n\t// base color\r\n\tvec3 color = textureLod(iChannel1, uv*colorUvScale, 0.0).xyz;\r\n\r\n\t// darken with depth\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\tt = clamp(t, 0.0, 1.0);\r\n\tfloat i = t*0.5+0.5;\r\n\t\t\r\n\treturn color*diff*i + vec3(spec*i);\r\n}\t\t\r\n\r\nvec4 scene(vec3 ro,vec3 rd)\r\n{\r\n\tvec3 p = vec3(0.0);\r\n\tconst float r = 1.0;\r\n\tfloat t;\t\t\t\t  \r\n\tbool hit = intersectSphere(ro - p, rd, r, t);\r\n\t\r\n\tvec4 c = vec4(0.0);\r\n\tif (hit) {\r\n\t\tvec3 pos = ro + rd*t;\r\n\r\n\t\t// ray-march into volume\r\n\t\tfor(int i=0; i<furLayers; i++) {\r\n\t\t\tvec4 sampleCol;\r\n\t\t\tvec2 uv;\r\n\t\t\tsampleCol.a = furDensity(pos, uv);\r\n\t\t\tif (sampleCol.a > 0.0) {\r\n\t\t\t\tsampleCol.rgb = furShade(pos, uv, ro, sampleCol.a);\r\n\r\n\t\t\t\t// pre-multiply alpha\r\n\t\t\t\tsampleCol.rgb *= sampleCol.a;\r\n\t\t\t\tc = c + sampleCol*(1.0 - c.a);\r\n\t\t\t\tif (c.a > 0.95) break;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpos += rd*rayStep;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tuv = uv*2.0-1.0;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n\t\r\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\r\n\tvec3 rd = normalize(vec3(uv, -2.0));\r\n\t\r\n\tvec2 mouse = iMouse.xy / iResolution.xy;\r\n\tfloat roty = 0.0;\r\n\tfloat rotx = 0.0;\r\n\tif (iMouse.z > 0.0) {\r\n\t\trotx = (mouse.y-0.5)*3.0;\r\n\t\troty = -(mouse.x-0.5)*6.0;\r\n\t} else {\r\n\t\troty = sin(iTime*1.5);\r\n\t}\r\n\t\r\n    ro = rotateX(ro, rotx);\t\r\n    ro = rotateY(ro, roty);\t\r\n    rd = rotateX(rd, rotx);\r\n    rd = rotateY(rd, roty);\r\n\t\r\n\tfragColor = scene(ro, rd);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":null,"published":0}],"Info":{"Name":"furball","id":null,"date":null,"viewed":0,"name":"furball","description":"Kajiya & Kay style ray-marched fur.\r\n\r\nhttp://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.127.5564","likes":0,"published":null,"tags":["raymarch"," hair"," fur"," fluffy"]},"ver":null,"info":{"Name":"furball","id":null,"date":null,"viewed":0,"name":"furball","description":"Kajiya & Kay style ray-marched fur.\r\n\r\nhttp://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.127.5564","likes":0,"published":null,"tags":["raymarch"," hair"," fur"," fluffy"]},"renderpass":[{"Code":"// fur ball\r\n// (c) simon green 2013\r\n// @simesgreen\r\n// v1.1\r\n\r\nconst float uvScale = 1.0;\r\nconst float colorUvScale = 0.1;\r\nconst float furDepth = 0.2;\r\nconst int furLayers = 64;\r\nconst float rayStep = furDepth*2.0 / float(furLayers);\r\nconst float furThreshold = 0.4;\r\nconst float shininess = 50.0;\r\n\r\nbool intersectSphere(vec3 ro, vec3 rd, float r, out float t)\r\n{\r\n\tfloat b = dot(-ro, rd);\r\n\tfloat det = b*b - dot(ro, ro) + r*r;\r\n\tif (det < 0.0) return false;\r\n\tdet = sqrt(det);\r\n\tt = b - det;\r\n\treturn t > 0.0;\r\n}\r\n\r\nvec3 rotateX(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\r\n}\r\n\r\nvec3 rotateY(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\r\n}\r\n\r\nvec2 cartesianToSpherical(vec3 p)\r\n{\t\t\r\n\tfloat r = length(p);\r\n\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\t\r\n\tp = rotateX(p.zyx, -cos(iTime*1.5)*t*t*0.4).zyx;\t// curl\r\n\r\n\tp /= r;\t\r\n\tvec2 uv = vec2(atan(p.y, p.x), acos(p.z));\r\n\r\n\t//uv.x += cos(iTime*1.5)*t*t*0.4;\t// curl\r\n\t//uv.y += sin(iTime*1.7)*t*t*0.2;\r\n\tuv.y -= t*t*0.1;\t// curl down\r\n\treturn uv;\r\n}\r\n\r\n// returns fur density at given position\r\nfloat furDensity(vec3 pos, out vec2 uv)\r\n{\r\n\tuv = cartesianToSpherical(pos.xzy);\t\r\n\tvec4 tex = textureLod(iChannel0, uv*uvScale, 0.0);\r\n\r\n\t// thin out hair\r\n\tfloat density = smoothstep(furThreshold, 1.0, tex.x);\r\n\t\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\t\r\n\t// fade out along length\r\n\tfloat len = tex.y;\r\n\tdensity *= smoothstep(len, len-0.2, t);\r\n\r\n\treturn density;\t\r\n}\r\n\r\n// calculate normal from density\r\nvec3 furNormal(vec3 pos, float density)\r\n{\r\n    float eps = 0.01;\r\n    vec3 n;\r\n\tvec2 uv;\r\n    n.x = furDensity( vec3(pos.x+eps, pos.y, pos.z), uv ) - density;\r\n    n.y = furDensity( vec3(pos.x, pos.y+eps, pos.z), uv ) - density;\r\n    n.z = furDensity( vec3(pos.x, pos.y, pos.z+eps), uv ) - density;\r\n    return normalize(n);\r\n}\r\n\r\nvec3 furShade(vec3 pos, vec2 uv, vec3 ro, float density)\r\n{\r\n\t// lighting\r\n\tconst vec3 L = vec3(0, 1, 0);\r\n\tvec3 V = normalize(ro - pos);\r\n\tvec3 H = normalize(V + L);\r\n\r\n\tvec3 N = -furNormal(pos, density);\r\n\t//float diff = max(0.0, dot(N, L));\r\n\tfloat diff = max(0.0, dot(N, L)*0.5+0.5);\r\n\tfloat spec = pow(max(0.0, dot(N, H)), shininess);\r\n\t\r\n\t// base color\r\n\tvec3 color = textureLod(iChannel1, uv*colorUvScale, 0.0).xyz;\r\n\r\n\t// darken with depth\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\tt = clamp(t, 0.0, 1.0);\r\n\tfloat i = t*0.5+0.5;\r\n\t\t\r\n\treturn color*diff*i + vec3(spec*i);\r\n}\t\t\r\n\r\nvec4 scene(vec3 ro,vec3 rd)\r\n{\r\n\tvec3 p = vec3(0.0);\r\n\tconst float r = 1.0;\r\n\tfloat t;\t\t\t\t  \r\n\tbool hit = intersectSphere(ro - p, rd, r, t);\r\n\t\r\n\tvec4 c = vec4(0.0);\r\n\tif (hit) {\r\n\t\tvec3 pos = ro + rd*t;\r\n\r\n\t\t// ray-march into volume\r\n\t\tfor(int i=0; i<furLayers; i++) {\r\n\t\t\tvec4 sampleCol;\r\n\t\t\tvec2 uv;\r\n\t\t\tsampleCol.a = furDensity(pos, uv);\r\n\t\t\tif (sampleCol.a > 0.0) {\r\n\t\t\t\tsampleCol.rgb = furShade(pos, uv, ro, sampleCol.a);\r\n\r\n\t\t\t\t// pre-multiply alpha\r\n\t\t\t\tsampleCol.rgb *= sampleCol.a;\r\n\t\t\t\tc = c + sampleCol*(1.0 - c.a);\r\n\t\t\t\tif (c.a > 0.95) break;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpos += rd*rayStep;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tuv = uv*2.0-1.0;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n\t\r\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\r\n\tvec3 rd = normalize(vec3(uv, -2.0));\r\n\t\r\n\tvec2 mouse = iMouse.xy / iResolution.xy;\r\n\tfloat roty = 0.0;\r\n\tfloat rotx = 0.0;\r\n\tif (iMouse.z > 0.0) {\r\n\t\trotx = (mouse.y-0.5)*3.0;\r\n\t\troty = -(mouse.x-0.5)*6.0;\r\n\t} else {\r\n\t\troty = sin(iTime*1.5);\r\n\t}\r\n\t\r\n    ro = rotateX(ro, rotx);\t\r\n    ro = rotateY(ro, roty);\t\r\n    rd = rotateX(rd, rotx);\r\n    rd = rotateY(rd, roty);\r\n\t\r\n\tfragColor = scene(ro, rd);\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":null,"published":0}],"outputs":[],"code":"// fur ball\r\n// (c) simon green 2013\r\n// @simesgreen\r\n// v1.1\r\n\r\nconst float uvScale = 1.0;\r\nconst float colorUvScale = 0.1;\r\nconst float furDepth = 0.2;\r\nconst int furLayers = 64;\r\nconst float rayStep = furDepth*2.0 / float(furLayers);\r\nconst float furThreshold = 0.4;\r\nconst float shininess = 50.0;\r\n\r\nbool intersectSphere(vec3 ro, vec3 rd, float r, out float t)\r\n{\r\n\tfloat b = dot(-ro, rd);\r\n\tfloat det = b*b - dot(ro, ro) + r*r;\r\n\tif (det < 0.0) return false;\r\n\tdet = sqrt(det);\r\n\tt = b - det;\r\n\treturn t > 0.0;\r\n}\r\n\r\nvec3 rotateX(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\r\n}\r\n\r\nvec3 rotateY(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\r\n}\r\n\r\nvec2 cartesianToSpherical(vec3 p)\r\n{\t\t\r\n\tfloat r = length(p);\r\n\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\t\r\n\tp = rotateX(p.zyx, -cos(iTime*1.5)*t*t*0.4).zyx;\t// curl\r\n\r\n\tp /= r;\t\r\n\tvec2 uv = vec2(atan(p.y, p.x), acos(p.z));\r\n\r\n\t//uv.x += cos(iTime*1.5)*t*t*0.4;\t// curl\r\n\t//uv.y += sin(iTime*1.7)*t*t*0.2;\r\n\tuv.y -= t*t*0.1;\t// curl down\r\n\treturn uv;\r\n}\r\n\r\n// returns fur density at given position\r\nfloat furDensity(vec3 pos, out vec2 uv)\r\n{\r\n\tuv = cartesianToSpherical(pos.xzy);\t\r\n\tvec4 tex = textureLod(iChannel0, uv*uvScale, 0.0);\r\n\r\n\t// thin out hair\r\n\tfloat density = smoothstep(furThreshold, 1.0, tex.x);\r\n\t\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\t\r\n\t// fade out along length\r\n\tfloat len = tex.y;\r\n\tdensity *= smoothstep(len, len-0.2, t);\r\n\r\n\treturn density;\t\r\n}\r\n\r\n// calculate normal from density\r\nvec3 furNormal(vec3 pos, float density)\r\n{\r\n    float eps = 0.01;\r\n    vec3 n;\r\n\tvec2 uv;\r\n    n.x = furDensity( vec3(pos.x+eps, pos.y, pos.z), uv ) - density;\r\n    n.y = furDensity( vec3(pos.x, pos.y+eps, pos.z), uv ) - density;\r\n    n.z = furDensity( vec3(pos.x, pos.y, pos.z+eps), uv ) - density;\r\n    return normalize(n);\r\n}\r\n\r\nvec3 furShade(vec3 pos, vec2 uv, vec3 ro, float density)\r\n{\r\n\t// lighting\r\n\tconst vec3 L = vec3(0, 1, 0);\r\n\tvec3 V = normalize(ro - pos);\r\n\tvec3 H = normalize(V + L);\r\n\r\n\tvec3 N = -furNormal(pos, density);\r\n\t//float diff = max(0.0, dot(N, L));\r\n\tfloat diff = max(0.0, dot(N, L)*0.5+0.5);\r\n\tfloat spec = pow(max(0.0, dot(N, H)), shininess);\r\n\t\r\n\t// base color\r\n\tvec3 color = textureLod(iChannel1, uv*colorUvScale, 0.0).xyz;\r\n\r\n\t// darken with depth\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\tt = clamp(t, 0.0, 1.0);\r\n\tfloat i = t*0.5+0.5;\r\n\t\t\r\n\treturn color*diff*i + vec3(spec*i);\r\n}\t\t\r\n\r\nvec4 scene(vec3 ro,vec3 rd)\r\n{\r\n\tvec3 p = vec3(0.0);\r\n\tconst float r = 1.0;\r\n\tfloat t;\t\t\t\t  \r\n\tbool hit = intersectSphere(ro - p, rd, r, t);\r\n\t\r\n\tvec4 c = vec4(0.0);\r\n\tif (hit) {\r\n\t\tvec3 pos = ro + rd*t;\r\n\r\n\t\t// ray-march into volume\r\n\t\tfor(int i=0; i<furLayers; i++) {\r\n\t\t\tvec4 sampleCol;\r\n\t\t\tvec2 uv;\r\n\t\t\tsampleCol.a = furDensity(pos, uv);\r\n\t\t\tif (sampleCol.a > 0.0) {\r\n\t\t\t\tsampleCol.rgb = furShade(pos, uv, ro, sampleCol.a);\r\n\r\n\t\t\t\t// pre-multiply alpha\r\n\t\t\t\tsampleCol.rgb *= sampleCol.a;\r\n\t\t\t\tc = c + sampleCol*(1.0 - c.a);\r\n\t\t\t\tif (c.a > 0.95) break;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpos += rd*rayStep;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tuv = uv*2.0-1.0;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n\t\r\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\r\n\tvec3 rd = normalize(vec3(uv, -2.0));\r\n\t\r\n\tvec2 mouse = iMouse.xy / iResolution.xy;\r\n\tfloat roty = 0.0;\r\n\tfloat rotx = 0.0;\r\n\tif (iMouse.z > 0.0) {\r\n\t\trotx = (mouse.y-0.5)*3.0;\r\n\t\troty = -(mouse.x-0.5)*6.0;\r\n\t} else {\r\n\t\troty = sin(iTime*1.5);\r\n\t}\r\n\t\r\n    ro = rotateX(ro, rotx);\t\r\n    ro = rotateY(ro, roty);\t\r\n    rd = rotateX(rd, rotx);\r\n    rd = rotateY(rd, roty);\r\n\t\r\n\tfragColor = scene(ro, rd);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*\r\n\"Wet stone\" by Alexander Alekseev aka TDM - 2014\r\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\nContact: tdmaav@gmail.com\r\n*/\r\n\r\n#define SMOOTH\r\n#define AA\r\n\r\nconst int NUM_STEPS = 32;\r\nconst int AO_SAMPLES = 4;\r\nconst vec2 AO_PARAM = vec2(1.2, 3.5);\r\nconst vec2 CORNER_PARAM = vec2(0.25, 40.0);\r\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\r\nconst float TRESHOLD \t= 0.1;\r\nconst float EPSILON \t= 1e-3;\r\nconst float LIGHT_INTENSITY = 0.25;\r\nconst vec3 RED \t\t= vec3(1.0,0.7,0.7) * LIGHT_INTENSITY;\r\nconst vec3 ORANGE \t= vec3(1.0,0.67,0.43) * LIGHT_INTENSITY;\r\nconst vec3 BLUE \t= vec3(0.54,0.77,1.0) * LIGHT_INTENSITY;\r\nconst vec3 WHITE \t= vec3(1.2,1.07,0.98) * LIGHT_INTENSITY;\r\n\r\nconst float DISPLACEMENT = 0.1;\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nvec3 saturation(vec3 c, float t) {\r\n    return mix(vec3(dot(c,vec3(0.2126,0.7152,0.0722))),c,t);\r\n}\r\nfloat hash11(float p) {\r\n    return fract(sin(p * 727.1)*435.545);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*437.545);\r\n}\r\nvec3 hash31(float p) {\r\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\r\n    return fract(sin(h)*435.543);\r\n}\r\n\r\n// 3d noise\r\nfloat noise_3(in vec3 p) {\r\n    vec3 i = floor(p);\r\n    vec3 f = fract(p);\t\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    \r\n    vec2 ii = i.xy + i.z * vec2(5.0);\r\n    float a = hash12( ii + vec2(0.0,0.0) );\r\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \r\n    float c = hash12( ii + vec2(0.0,1.0) );\r\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \r\n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\r\n    \r\n    ii += vec2(5.0);\r\n    a = hash12( ii + vec2(0.0,0.0) );\r\n\tb = hash12( ii + vec2(1.0,0.0) );    \r\n    c = hash12( ii + vec2(0.0,1.0) );\r\n\td = hash12( ii + vec2(1.0,1.0) );\r\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\r\n        \r\n    return max(mix(v1,v2,u.z),0.0);\r\n}\r\n\r\n// fBm\r\nfloat fbm3(vec3 p, float a, float f) {\r\n    return noise_3(p);\r\n}\r\n\r\nfloat fbm3_high(vec3 p, float a, float f) {\r\n    float ret = 0.0;    \r\n    float amp = 1.0;\r\n    float frq = 1.0;\r\n    for(int i = 0; i < 5; i++) {\r\n        float n = pow(noise_3(p * frq),2.0);\r\n        ret += n * amp;\r\n        frq *= f;\r\n        amp *= a * (pow(n,0.2));\r\n    }\r\n    return ret;\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(max(dot(n,l),0.0),p); }\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// distance functions\r\nfloat plane(vec3 gp, vec4 p) {\r\n\treturn dot(p.xyz,gp+p.xyz*p.w);\r\n}\r\nfloat sphere(vec3 p,float r) {\r\n\treturn length(p)-r;\r\n}\r\nfloat capsule(vec3 p,float r,float h) {\r\n    p.y -= clamp(p.y,-h,h);\r\n\treturn length(p)-r;\r\n}\r\nfloat cylinder(vec3 p,float r,float h) {\r\n\treturn max(abs(p.y/h),capsule(p,r,h));\r\n}\r\nfloat box(vec3 p,vec3 s) {\r\n\tp = abs(p)-s;\r\n    return max(max(p.x,p.y),p.z);\r\n}\r\nfloat rbox(vec3 p,vec3 s) {\r\n\tp = abs(p)-s;\r\n    return length(p-min(p,0.0));\r\n}\r\nfloat quad(vec3 p,vec2 s) {\r\n\tp = abs(p) - vec3(s.x,0.0,s.y);\r\n    return max(max(p.x,p.y),p.z);\r\n}\r\n\r\n// boolean operations\r\nfloat boolUnion(float a,float b) { return min(a,b); }\r\nfloat boolIntersect(float a,float b) { return max(a,b); }\r\nfloat boolSub(float a,float b) { return max(a,-b); }\r\n\r\n// smooth operations. thanks to iq\r\nfloat boolSmoothIntersect(float a, float b, float k ) {\r\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\r\n    return mix(a,b,h) + k*h*(1.0-h);\r\n}\r\nfloat boolSmoothSub(float a, float b, float k ) {\r\n    return boolSmoothIntersect(a,-b,k);\r\n}\t\r\n\r\n// world\r\nfloat rock(vec3 p) {    \r\n    float d = sphere(p,1.0);    \r\n    for(int i = 0; i < 9; i++) {\r\n        float ii = float(i);\r\n        float r = 2.5 + hash11(ii);\r\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\r\n        #ifdef SMOOTH\r\n        d = boolSmoothSub(d,sphere(p+v*r,r * 0.8), 0.03);\r\n        #else\r\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));\r\n        #endif        \r\n    }\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float d = rock(p) + fbm3(p*4.0,0.4,2.96) * DISPLACEMENT;\r\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\r\n    return d;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float d = rock(p) + fbm3_high(p*4.0,0.4,2.96) * DISPLACEMENT;\r\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\r\n    return d;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float dens) {\r\n    vec3 n;\r\n    n.x = map_detailed(vec3(p.x+EPSILON,p.y,p.z));\r\n    n.y = map_detailed(vec3(p.x,p.y+EPSILON,p.z));\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+EPSILON));\r\n    return normalize(n-map_detailed(p));\r\n}\r\nvec2 getOcclusion(vec3 p, vec3 n) {\r\n    vec2 r = vec2(0.0);\r\n    for(int i = 0; i < AO_SAMPLES; i++) {\r\n        float f = float(i)*INV_AO_SAMPLES;\r\n        float hao = 0.01+f*AO_PARAM.x;\r\n        float hc = 0.01+f*CORNER_PARAM.x;\r\n        float dao = map(p + n * hao) - TRESHOLD;\r\n        float dc = map(p - n * hc) - TRESHOLD;\r\n        r.x += clamp(hao-dao,0.0,1.0) * (1.0-f);\r\n        r.y += clamp(hc+dc,0.0,1.0) * (1.0-f);\r\n    }    \r\n    r.x = clamp(1.0-r.x*INV_AO_SAMPLES*AO_PARAM.y,0.0,1.0);\r\n    r.y = clamp(r.y*INV_AO_SAMPLES*CORNER_PARAM.y,0.0,1.0);\r\n    return r;\r\n}\r\nvec2 spheretracing(vec3 ori, vec3 dir, out vec3 p) {\r\n    vec2 td = vec2(0.0);\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        p = ori + dir * td.x;\r\n        td.y = map(p);\r\n        if(td.y < TRESHOLD) break;\r\n        td.x += (td.y-TRESHOLD) * 0.9;\r\n    }\r\n    return td;\r\n}\r\n\r\n// stone\r\nvec3 getStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\r\n    c = min(c + pow(noise_3(vec3(p.x*20.0,0.0,p.z*20.0)),70.0) * 8.0, 1.0);\r\n    float ic = pow(1.0-c,0.5);\r\n    vec3 base = vec3(0.42,0.3,0.2) * 0.35;\r\n    vec3 sand = vec3(0.51,0.41,0.32)*0.9;\r\n    vec3 color = mix(base,sand,c);\r\n        \r\n    float f = pow(1.0 - max(dot(n,-e),0.0), 5.0) * 0.75 * ic;    \r\n    color += vec3(diffuse(n,l,0.5) * WHITE);\r\n    color += vec3(specular(n,l,e,8.0) * WHITE * 1.5 * ic);\r\n    n = normalize(n - normalize(p) * 0.4);    \r\n    color += vec3(specular(n,l,e,80.0) * WHITE * 1.5 * ic);    \r\n    color = mix(color,vec3(1.0),f); \r\n    \r\n    color *= sqrt(abs(p.y*0.5+0.5)) * 0.4 + 0.6;\r\n    color *= (n.y * 0.5 + 0.5) * 0.4 + 0.6; \r\n    \r\n    return color;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {\r\n    vec2 iuv = coord / iResolution.xy * 2.0 - 1.0;\r\n    vec2 uv = iuv;\r\n    uv.x *= iResolution.x / iResolution.y;\r\n        \r\n    // ray\r\n    vec3 ang = vec3(0.0,0.2,time);\r\n    if(iMouse.z > 0.0) ang = vec3(0.0,clamp(2.0-iMouse.y*0.01,0.0,3.1415),iMouse.x*0.01);\r\n\tmat3 rot = fromEuler(ang);\r\n    \r\n    vec3 ori = vec3(0.0,0.0,2.8);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0));    \r\n    ori = ori * rot;\r\n    dir = dir * rot;\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    vec2 td = spheretracing(ori,dir,p);\r\n    vec3 n = getNormal(p,td.y);\r\n    vec2 occ = getOcclusion(p,n);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.0)); \r\n         \r\n    // color\r\n    vec3 color = vec3(1.0);    \r\n    if(td.x < 3.5 && p.y > -0.89) color = getStoneColor(p,occ.y,light,n,dir);\r\n    color *= occ.x;\r\n    return color;\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3;\r\n        \r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++)\r\n    for(int j = -1; j <= 1; j++) {\r\n        vec2 uv = fragCoord+vec2(i,j)/3.0;\r\n        color += getPixel(uv, time);\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    color = sqrt(color);\r\n    color = saturation(color,1.7);\r\n               \r\n    // vignette\r\n    vec2 iuv = fragCoord / iResolution.xy * 2.0 - 1.0;\r\n    float vgn = smoothstep(1.2,0.7,abs(iuv.y)) * smoothstep(1.1,0.8,abs(iuv.x));\r\n    color *= 1.0 - (1.0 - vgn) * 0.15;\t\r\n    \r\n\tfragColor = vec4(color,1.0);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n\"Wet stone\" by Alexander Alekseev aka TDM - 2014\r\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\nContact: tdmaav@gmail.com\r\n*/\r\n\r\n#define SMOOTH\r\n#define AA\r\n\r\nconst int NUM_STEPS = 32;\r\nconst int AO_SAMPLES = 4;\r\nconst vec2 AO_PARAM = vec2(1.2, 3.5);\r\nconst vec2 CORNER_PARAM = vec2(0.25, 40.0);\r\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\r\nconst float TRESHOLD \t= 0.1;\r\nconst float EPSILON \t= 1e-3;\r\nconst float LIGHT_INTENSITY = 0.25;\r\nconst vec3 RED \t\t= vec3(1.0,0.7,0.7) * LIGHT_INTENSITY;\r\nconst vec3 ORANGE \t= vec3(1.0,0.67,0.43) * LIGHT_INTENSITY;\r\nconst vec3 BLUE \t= vec3(0.54,0.77,1.0) * LIGHT_INTENSITY;\r\nconst vec3 WHITE \t= vec3(1.2,1.07,0.98) * LIGHT_INTENSITY;\r\n\r\nconst float DISPLACEMENT = 0.1;\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nvec3 saturation(vec3 c, float t) {\r\n    return mix(vec3(dot(c,vec3(0.2126,0.7152,0.0722))),c,t);\r\n}\r\nfloat hash11(float p) {\r\n    return fract(sin(p * 727.1)*435.545);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*437.545);\r\n}\r\nvec3 hash31(float p) {\r\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\r\n    return fract(sin(h)*435.543);\r\n}\r\n\r\n// 3d noise\r\nfloat noise_3(in vec3 p) {\r\n    vec3 i = floor(p);\r\n    vec3 f = fract(p);\t\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    \r\n    vec2 ii = i.xy + i.z * vec2(5.0);\r\n    float a = hash12( ii + vec2(0.0,0.0) );\r\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \r\n    float c = hash12( ii + vec2(0.0,1.0) );\r\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \r\n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\r\n    \r\n    ii += vec2(5.0);\r\n    a = hash12( ii + vec2(0.0,0.0) );\r\n\tb = hash12( ii + vec2(1.0,0.0) );    \r\n    c = hash12( ii + vec2(0.0,1.0) );\r\n\td = hash12( ii + vec2(1.0,1.0) );\r\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\r\n        \r\n    return max(mix(v1,v2,u.z),0.0);\r\n}\r\n\r\n// fBm\r\nfloat fbm3(vec3 p, float a, float f) {\r\n    return noise_3(p);\r\n}\r\n\r\nfloat fbm3_high(vec3 p, float a, float f) {\r\n    float ret = 0.0;    \r\n    float amp = 1.0;\r\n    float frq = 1.0;\r\n    for(int i = 0; i < 5; i++) {\r\n        float n = pow(noise_3(p * frq),2.0);\r\n        ret += n * amp;\r\n        frq *= f;\r\n        amp *= a * (pow(n,0.2));\r\n    }\r\n    return ret;\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(max(dot(n,l),0.0),p); }\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// distance functions\r\nfloat plane(vec3 gp, vec4 p) {\r\n\treturn dot(p.xyz,gp+p.xyz*p.w);\r\n}\r\nfloat sphere(vec3 p,float r) {\r\n\treturn length(p)-r;\r\n}\r\nfloat capsule(vec3 p,float r,float h) {\r\n    p.y -= clamp(p.y,-h,h);\r\n\treturn length(p)-r;\r\n}\r\nfloat cylinder(vec3 p,float r,float h) {\r\n\treturn max(abs(p.y/h),capsule(p,r,h));\r\n}\r\nfloat box(vec3 p,vec3 s) {\r\n\tp = abs(p)-s;\r\n    return max(max(p.x,p.y),p.z);\r\n}\r\nfloat rbox(vec3 p,vec3 s) {\r\n\tp = abs(p)-s;\r\n    return length(p-min(p,0.0));\r\n}\r\nfloat quad(vec3 p,vec2 s) {\r\n\tp = abs(p) - vec3(s.x,0.0,s.y);\r\n    return max(max(p.x,p.y),p.z);\r\n}\r\n\r\n// boolean operations\r\nfloat boolUnion(float a,float b) { return min(a,b); }\r\nfloat boolIntersect(float a,float b) { return max(a,b); }\r\nfloat boolSub(float a,float b) { return max(a,-b); }\r\n\r\n// smooth operations. thanks to iq\r\nfloat boolSmoothIntersect(float a, float b, float k ) {\r\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\r\n    return mix(a,b,h) + k*h*(1.0-h);\r\n}\r\nfloat boolSmoothSub(float a, float b, float k ) {\r\n    return boolSmoothIntersect(a,-b,k);\r\n}\t\r\n\r\n// world\r\nfloat rock(vec3 p) {    \r\n    float d = sphere(p,1.0);    \r\n    for(int i = 0; i < 9; i++) {\r\n        float ii = float(i);\r\n        float r = 2.5 + hash11(ii);\r\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\r\n        #ifdef SMOOTH\r\n        d = boolSmoothSub(d,sphere(p+v*r,r * 0.8), 0.03);\r\n        #else\r\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));\r\n        #endif        \r\n    }\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float d = rock(p) + fbm3(p*4.0,0.4,2.96) * DISPLACEMENT;\r\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\r\n    return d;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float d = rock(p) + fbm3_high(p*4.0,0.4,2.96) * DISPLACEMENT;\r\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\r\n    return d;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float dens) {\r\n    vec3 n;\r\n    n.x = map_detailed(vec3(p.x+EPSILON,p.y,p.z));\r\n    n.y = map_detailed(vec3(p.x,p.y+EPSILON,p.z));\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+EPSILON));\r\n    return normalize(n-map_detailed(p));\r\n}\r\nvec2 getOcclusion(vec3 p, vec3 n) {\r\n    vec2 r = vec2(0.0);\r\n    for(int i = 0; i < AO_SAMPLES; i++) {\r\n        float f = float(i)*INV_AO_SAMPLES;\r\n        float hao = 0.01+f*AO_PARAM.x;\r\n        float hc = 0.01+f*CORNER_PARAM.x;\r\n        float dao = map(p + n * hao) - TRESHOLD;\r\n        float dc = map(p - n * hc) - TRESHOLD;\r\n        r.x += clamp(hao-dao,0.0,1.0) * (1.0-f);\r\n        r.y += clamp(hc+dc,0.0,1.0) * (1.0-f);\r\n    }    \r\n    r.x = clamp(1.0-r.x*INV_AO_SAMPLES*AO_PARAM.y,0.0,1.0);\r\n    r.y = clamp(r.y*INV_AO_SAMPLES*CORNER_PARAM.y,0.0,1.0);\r\n    return r;\r\n}\r\nvec2 spheretracing(vec3 ori, vec3 dir, out vec3 p) {\r\n    vec2 td = vec2(0.0);\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        p = ori + dir * td.x;\r\n        td.y = map(p);\r\n        if(td.y < TRESHOLD) break;\r\n        td.x += (td.y-TRESHOLD) * 0.9;\r\n    }\r\n    return td;\r\n}\r\n\r\n// stone\r\nvec3 getStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\r\n    c = min(c + pow(noise_3(vec3(p.x*20.0,0.0,p.z*20.0)),70.0) * 8.0, 1.0);\r\n    float ic = pow(1.0-c,0.5);\r\n    vec3 base = vec3(0.42,0.3,0.2) * 0.35;\r\n    vec3 sand = vec3(0.51,0.41,0.32)*0.9;\r\n    vec3 color = mix(base,sand,c);\r\n        \r\n    float f = pow(1.0 - max(dot(n,-e),0.0), 5.0) * 0.75 * ic;    \r\n    color += vec3(diffuse(n,l,0.5) * WHITE);\r\n    color += vec3(specular(n,l,e,8.0) * WHITE * 1.5 * ic);\r\n    n = normalize(n - normalize(p) * 0.4);    \r\n    color += vec3(specular(n,l,e,80.0) * WHITE * 1.5 * ic);    \r\n    color = mix(color,vec3(1.0),f); \r\n    \r\n    color *= sqrt(abs(p.y*0.5+0.5)) * 0.4 + 0.6;\r\n    color *= (n.y * 0.5 + 0.5) * 0.4 + 0.6; \r\n    \r\n    return color;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {\r\n    vec2 iuv = coord / iResolution.xy * 2.0 - 1.0;\r\n    vec2 uv = iuv;\r\n    uv.x *= iResolution.x / iResolution.y;\r\n        \r\n    // ray\r\n    vec3 ang = vec3(0.0,0.2,time);\r\n    if(iMouse.z > 0.0) ang = vec3(0.0,clamp(2.0-iMouse.y*0.01,0.0,3.1415),iMouse.x*0.01);\r\n\tmat3 rot = fromEuler(ang);\r\n    \r\n    vec3 ori = vec3(0.0,0.0,2.8);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0));    \r\n    ori = ori * rot;\r\n    dir = dir * rot;\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    vec2 td = spheretracing(ori,dir,p);\r\n    vec3 n = getNormal(p,td.y);\r\n    vec2 occ = getOcclusion(p,n);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.0)); \r\n         \r\n    // color\r\n    vec3 color = vec3(1.0);    \r\n    if(td.x < 3.5 && p.y > -0.89) color = getStoneColor(p,occ.y,light,n,dir);\r\n    color *= occ.x;\r\n    return color;\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3;\r\n        \r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++)\r\n    for(int j = -1; j <= 1; j++) {\r\n        vec2 uv = fragCoord+vec2(i,j)/3.0;\r\n        color += getPixel(uv, time);\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    color = sqrt(color);\r\n    color = saturation(color,1.7);\r\n               \r\n    // vignette\r\n    vec2 iuv = fragCoord / iResolution.xy * 2.0 - 1.0;\r\n    float vgn = smoothstep(1.2,0.7,abs(iuv.y)) * smoothstep(1.1,0.8,abs(iuv.x));\r\n    color *= 1.0 - (1.0 - vgn) * 0.15;\t\r\n    \r\n\tfragColor = vec4(color,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Wet stone ","id":null,"date":null,"viewed":0,"name":"Wet stone ","description":"stone generation","likes":0,"published":null,"tags":["procedural"," noise"," rock"," wet"," stone"]},"ver":null,"info":{"Name":"Wet stone ","id":null,"date":null,"viewed":0,"name":"Wet stone ","description":"stone generation","likes":0,"published":null,"tags":["procedural"," noise"," rock"," wet"," stone"]},"renderpass":[{"Code":"/*\r\n\"Wet stone\" by Alexander Alekseev aka TDM - 2014\r\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\nContact: tdmaav@gmail.com\r\n*/\r\n\r\n#define SMOOTH\r\n#define AA\r\n\r\nconst int NUM_STEPS = 32;\r\nconst int AO_SAMPLES = 4;\r\nconst vec2 AO_PARAM = vec2(1.2, 3.5);\r\nconst vec2 CORNER_PARAM = vec2(0.25, 40.0);\r\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\r\nconst float TRESHOLD \t= 0.1;\r\nconst float EPSILON \t= 1e-3;\r\nconst float LIGHT_INTENSITY = 0.25;\r\nconst vec3 RED \t\t= vec3(1.0,0.7,0.7) * LIGHT_INTENSITY;\r\nconst vec3 ORANGE \t= vec3(1.0,0.67,0.43) * LIGHT_INTENSITY;\r\nconst vec3 BLUE \t= vec3(0.54,0.77,1.0) * LIGHT_INTENSITY;\r\nconst vec3 WHITE \t= vec3(1.2,1.07,0.98) * LIGHT_INTENSITY;\r\n\r\nconst float DISPLACEMENT = 0.1;\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nvec3 saturation(vec3 c, float t) {\r\n    return mix(vec3(dot(c,vec3(0.2126,0.7152,0.0722))),c,t);\r\n}\r\nfloat hash11(float p) {\r\n    return fract(sin(p * 727.1)*435.545);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*437.545);\r\n}\r\nvec3 hash31(float p) {\r\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\r\n    return fract(sin(h)*435.543);\r\n}\r\n\r\n// 3d noise\r\nfloat noise_3(in vec3 p) {\r\n    vec3 i = floor(p);\r\n    vec3 f = fract(p);\t\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    \r\n    vec2 ii = i.xy + i.z * vec2(5.0);\r\n    float a = hash12( ii + vec2(0.0,0.0) );\r\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \r\n    float c = hash12( ii + vec2(0.0,1.0) );\r\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \r\n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\r\n    \r\n    ii += vec2(5.0);\r\n    a = hash12( ii + vec2(0.0,0.0) );\r\n\tb = hash12( ii + vec2(1.0,0.0) );    \r\n    c = hash12( ii + vec2(0.0,1.0) );\r\n\td = hash12( ii + vec2(1.0,1.0) );\r\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\r\n        \r\n    return max(mix(v1,v2,u.z),0.0);\r\n}\r\n\r\n// fBm\r\nfloat fbm3(vec3 p, float a, float f) {\r\n    return noise_3(p);\r\n}\r\n\r\nfloat fbm3_high(vec3 p, float a, float f) {\r\n    float ret = 0.0;    \r\n    float amp = 1.0;\r\n    float frq = 1.0;\r\n    for(int i = 0; i < 5; i++) {\r\n        float n = pow(noise_3(p * frq),2.0);\r\n        ret += n * amp;\r\n        frq *= f;\r\n        amp *= a * (pow(n,0.2));\r\n    }\r\n    return ret;\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(max(dot(n,l),0.0),p); }\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// distance functions\r\nfloat plane(vec3 gp, vec4 p) {\r\n\treturn dot(p.xyz,gp+p.xyz*p.w);\r\n}\r\nfloat sphere(vec3 p,float r) {\r\n\treturn length(p)-r;\r\n}\r\nfloat capsule(vec3 p,float r,float h) {\r\n    p.y -= clamp(p.y,-h,h);\r\n\treturn length(p)-r;\r\n}\r\nfloat cylinder(vec3 p,float r,float h) {\r\n\treturn max(abs(p.y/h),capsule(p,r,h));\r\n}\r\nfloat box(vec3 p,vec3 s) {\r\n\tp = abs(p)-s;\r\n    return max(max(p.x,p.y),p.z);\r\n}\r\nfloat rbox(vec3 p,vec3 s) {\r\n\tp = abs(p)-s;\r\n    return length(p-min(p,0.0));\r\n}\r\nfloat quad(vec3 p,vec2 s) {\r\n\tp = abs(p) - vec3(s.x,0.0,s.y);\r\n    return max(max(p.x,p.y),p.z);\r\n}\r\n\r\n// boolean operations\r\nfloat boolUnion(float a,float b) { return min(a,b); }\r\nfloat boolIntersect(float a,float b) { return max(a,b); }\r\nfloat boolSub(float a,float b) { return max(a,-b); }\r\n\r\n// smooth operations. thanks to iq\r\nfloat boolSmoothIntersect(float a, float b, float k ) {\r\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\r\n    return mix(a,b,h) + k*h*(1.0-h);\r\n}\r\nfloat boolSmoothSub(float a, float b, float k ) {\r\n    return boolSmoothIntersect(a,-b,k);\r\n}\t\r\n\r\n// world\r\nfloat rock(vec3 p) {    \r\n    float d = sphere(p,1.0);    \r\n    for(int i = 0; i < 9; i++) {\r\n        float ii = float(i);\r\n        float r = 2.5 + hash11(ii);\r\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\r\n        #ifdef SMOOTH\r\n        d = boolSmoothSub(d,sphere(p+v*r,r * 0.8), 0.03);\r\n        #else\r\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));\r\n        #endif        \r\n    }\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float d = rock(p) + fbm3(p*4.0,0.4,2.96) * DISPLACEMENT;\r\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\r\n    return d;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float d = rock(p) + fbm3_high(p*4.0,0.4,2.96) * DISPLACEMENT;\r\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\r\n    return d;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float dens) {\r\n    vec3 n;\r\n    n.x = map_detailed(vec3(p.x+EPSILON,p.y,p.z));\r\n    n.y = map_detailed(vec3(p.x,p.y+EPSILON,p.z));\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+EPSILON));\r\n    return normalize(n-map_detailed(p));\r\n}\r\nvec2 getOcclusion(vec3 p, vec3 n) {\r\n    vec2 r = vec2(0.0);\r\n    for(int i = 0; i < AO_SAMPLES; i++) {\r\n        float f = float(i)*INV_AO_SAMPLES;\r\n        float hao = 0.01+f*AO_PARAM.x;\r\n        float hc = 0.01+f*CORNER_PARAM.x;\r\n        float dao = map(p + n * hao) - TRESHOLD;\r\n        float dc = map(p - n * hc) - TRESHOLD;\r\n        r.x += clamp(hao-dao,0.0,1.0) * (1.0-f);\r\n        r.y += clamp(hc+dc,0.0,1.0) * (1.0-f);\r\n    }    \r\n    r.x = clamp(1.0-r.x*INV_AO_SAMPLES*AO_PARAM.y,0.0,1.0);\r\n    r.y = clamp(r.y*INV_AO_SAMPLES*CORNER_PARAM.y,0.0,1.0);\r\n    return r;\r\n}\r\nvec2 spheretracing(vec3 ori, vec3 dir, out vec3 p) {\r\n    vec2 td = vec2(0.0);\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        p = ori + dir * td.x;\r\n        td.y = map(p);\r\n        if(td.y < TRESHOLD) break;\r\n        td.x += (td.y-TRESHOLD) * 0.9;\r\n    }\r\n    return td;\r\n}\r\n\r\n// stone\r\nvec3 getStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\r\n    c = min(c + pow(noise_3(vec3(p.x*20.0,0.0,p.z*20.0)),70.0) * 8.0, 1.0);\r\n    float ic = pow(1.0-c,0.5);\r\n    vec3 base = vec3(0.42,0.3,0.2) * 0.35;\r\n    vec3 sand = vec3(0.51,0.41,0.32)*0.9;\r\n    vec3 color = mix(base,sand,c);\r\n        \r\n    float f = pow(1.0 - max(dot(n,-e),0.0), 5.0) * 0.75 * ic;    \r\n    color += vec3(diffuse(n,l,0.5) * WHITE);\r\n    color += vec3(specular(n,l,e,8.0) * WHITE * 1.5 * ic);\r\n    n = normalize(n - normalize(p) * 0.4);    \r\n    color += vec3(specular(n,l,e,80.0) * WHITE * 1.5 * ic);    \r\n    color = mix(color,vec3(1.0),f); \r\n    \r\n    color *= sqrt(abs(p.y*0.5+0.5)) * 0.4 + 0.6;\r\n    color *= (n.y * 0.5 + 0.5) * 0.4 + 0.6; \r\n    \r\n    return color;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {\r\n    vec2 iuv = coord / iResolution.xy * 2.0 - 1.0;\r\n    vec2 uv = iuv;\r\n    uv.x *= iResolution.x / iResolution.y;\r\n        \r\n    // ray\r\n    vec3 ang = vec3(0.0,0.2,time);\r\n    if(iMouse.z > 0.0) ang = vec3(0.0,clamp(2.0-iMouse.y*0.01,0.0,3.1415),iMouse.x*0.01);\r\n\tmat3 rot = fromEuler(ang);\r\n    \r\n    vec3 ori = vec3(0.0,0.0,2.8);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0));    \r\n    ori = ori * rot;\r\n    dir = dir * rot;\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    vec2 td = spheretracing(ori,dir,p);\r\n    vec3 n = getNormal(p,td.y);\r\n    vec2 occ = getOcclusion(p,n);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.0)); \r\n         \r\n    // color\r\n    vec3 color = vec3(1.0);    \r\n    if(td.x < 3.5 && p.y > -0.89) color = getStoneColor(p,occ.y,light,n,dir);\r\n    color *= occ.x;\r\n    return color;\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3;\r\n        \r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++)\r\n    for(int j = -1; j <= 1; j++) {\r\n        vec2 uv = fragCoord+vec2(i,j)/3.0;\r\n        color += getPixel(uv, time);\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    color = sqrt(color);\r\n    color = saturation(color,1.7);\r\n               \r\n    // vignette\r\n    vec2 iuv = fragCoord / iResolution.xy * 2.0 - 1.0;\r\n    float vgn = smoothstep(1.2,0.7,abs(iuv.y)) * smoothstep(1.1,0.8,abs(iuv.x));\r\n    color *= 1.0 - (1.0 - vgn) * 0.15;\t\r\n    \r\n\tfragColor = vec4(color,1.0);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n\"Wet stone\" by Alexander Alekseev aka TDM - 2014\r\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\nContact: tdmaav@gmail.com\r\n*/\r\n\r\n#define SMOOTH\r\n#define AA\r\n\r\nconst int NUM_STEPS = 32;\r\nconst int AO_SAMPLES = 4;\r\nconst vec2 AO_PARAM = vec2(1.2, 3.5);\r\nconst vec2 CORNER_PARAM = vec2(0.25, 40.0);\r\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\r\nconst float TRESHOLD \t= 0.1;\r\nconst float EPSILON \t= 1e-3;\r\nconst float LIGHT_INTENSITY = 0.25;\r\nconst vec3 RED \t\t= vec3(1.0,0.7,0.7) * LIGHT_INTENSITY;\r\nconst vec3 ORANGE \t= vec3(1.0,0.67,0.43) * LIGHT_INTENSITY;\r\nconst vec3 BLUE \t= vec3(0.54,0.77,1.0) * LIGHT_INTENSITY;\r\nconst vec3 WHITE \t= vec3(1.2,1.07,0.98) * LIGHT_INTENSITY;\r\n\r\nconst float DISPLACEMENT = 0.1;\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nvec3 saturation(vec3 c, float t) {\r\n    return mix(vec3(dot(c,vec3(0.2126,0.7152,0.0722))),c,t);\r\n}\r\nfloat hash11(float p) {\r\n    return fract(sin(p * 727.1)*435.545);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*437.545);\r\n}\r\nvec3 hash31(float p) {\r\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\r\n    return fract(sin(h)*435.543);\r\n}\r\n\r\n// 3d noise\r\nfloat noise_3(in vec3 p) {\r\n    vec3 i = floor(p);\r\n    vec3 f = fract(p);\t\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    \r\n    vec2 ii = i.xy + i.z * vec2(5.0);\r\n    float a = hash12( ii + vec2(0.0,0.0) );\r\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \r\n    float c = hash12( ii + vec2(0.0,1.0) );\r\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \r\n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\r\n    \r\n    ii += vec2(5.0);\r\n    a = hash12( ii + vec2(0.0,0.0) );\r\n\tb = hash12( ii + vec2(1.0,0.0) );    \r\n    c = hash12( ii + vec2(0.0,1.0) );\r\n\td = hash12( ii + vec2(1.0,1.0) );\r\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\r\n        \r\n    return max(mix(v1,v2,u.z),0.0);\r\n}\r\n\r\n// fBm\r\nfloat fbm3(vec3 p, float a, float f) {\r\n    return noise_3(p);\r\n}\r\n\r\nfloat fbm3_high(vec3 p, float a, float f) {\r\n    float ret = 0.0;    \r\n    float amp = 1.0;\r\n    float frq = 1.0;\r\n    for(int i = 0; i < 5; i++) {\r\n        float n = pow(noise_3(p * frq),2.0);\r\n        ret += n * amp;\r\n        frq *= f;\r\n        amp *= a * (pow(n,0.2));\r\n    }\r\n    return ret;\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(max(dot(n,l),0.0),p); }\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// distance functions\r\nfloat plane(vec3 gp, vec4 p) {\r\n\treturn dot(p.xyz,gp+p.xyz*p.w);\r\n}\r\nfloat sphere(vec3 p,float r) {\r\n\treturn length(p)-r;\r\n}\r\nfloat capsule(vec3 p,float r,float h) {\r\n    p.y -= clamp(p.y,-h,h);\r\n\treturn length(p)-r;\r\n}\r\nfloat cylinder(vec3 p,float r,float h) {\r\n\treturn max(abs(p.y/h),capsule(p,r,h));\r\n}\r\nfloat box(vec3 p,vec3 s) {\r\n\tp = abs(p)-s;\r\n    return max(max(p.x,p.y),p.z);\r\n}\r\nfloat rbox(vec3 p,vec3 s) {\r\n\tp = abs(p)-s;\r\n    return length(p-min(p,0.0));\r\n}\r\nfloat quad(vec3 p,vec2 s) {\r\n\tp = abs(p) - vec3(s.x,0.0,s.y);\r\n    return max(max(p.x,p.y),p.z);\r\n}\r\n\r\n// boolean operations\r\nfloat boolUnion(float a,float b) { return min(a,b); }\r\nfloat boolIntersect(float a,float b) { return max(a,b); }\r\nfloat boolSub(float a,float b) { return max(a,-b); }\r\n\r\n// smooth operations. thanks to iq\r\nfloat boolSmoothIntersect(float a, float b, float k ) {\r\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\r\n    return mix(a,b,h) + k*h*(1.0-h);\r\n}\r\nfloat boolSmoothSub(float a, float b, float k ) {\r\n    return boolSmoothIntersect(a,-b,k);\r\n}\t\r\n\r\n// world\r\nfloat rock(vec3 p) {    \r\n    float d = sphere(p,1.0);    \r\n    for(int i = 0; i < 9; i++) {\r\n        float ii = float(i);\r\n        float r = 2.5 + hash11(ii);\r\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\r\n        #ifdef SMOOTH\r\n        d = boolSmoothSub(d,sphere(p+v*r,r * 0.8), 0.03);\r\n        #else\r\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));\r\n        #endif        \r\n    }\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float d = rock(p) + fbm3(p*4.0,0.4,2.96) * DISPLACEMENT;\r\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\r\n    return d;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float d = rock(p) + fbm3_high(p*4.0,0.4,2.96) * DISPLACEMENT;\r\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\r\n    return d;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float dens) {\r\n    vec3 n;\r\n    n.x = map_detailed(vec3(p.x+EPSILON,p.y,p.z));\r\n    n.y = map_detailed(vec3(p.x,p.y+EPSILON,p.z));\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+EPSILON));\r\n    return normalize(n-map_detailed(p));\r\n}\r\nvec2 getOcclusion(vec3 p, vec3 n) {\r\n    vec2 r = vec2(0.0);\r\n    for(int i = 0; i < AO_SAMPLES; i++) {\r\n        float f = float(i)*INV_AO_SAMPLES;\r\n        float hao = 0.01+f*AO_PARAM.x;\r\n        float hc = 0.01+f*CORNER_PARAM.x;\r\n        float dao = map(p + n * hao) - TRESHOLD;\r\n        float dc = map(p - n * hc) - TRESHOLD;\r\n        r.x += clamp(hao-dao,0.0,1.0) * (1.0-f);\r\n        r.y += clamp(hc+dc,0.0,1.0) * (1.0-f);\r\n    }    \r\n    r.x = clamp(1.0-r.x*INV_AO_SAMPLES*AO_PARAM.y,0.0,1.0);\r\n    r.y = clamp(r.y*INV_AO_SAMPLES*CORNER_PARAM.y,0.0,1.0);\r\n    return r;\r\n}\r\nvec2 spheretracing(vec3 ori, vec3 dir, out vec3 p) {\r\n    vec2 td = vec2(0.0);\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        p = ori + dir * td.x;\r\n        td.y = map(p);\r\n        if(td.y < TRESHOLD) break;\r\n        td.x += (td.y-TRESHOLD) * 0.9;\r\n    }\r\n    return td;\r\n}\r\n\r\n// stone\r\nvec3 getStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\r\n    c = min(c + pow(noise_3(vec3(p.x*20.0,0.0,p.z*20.0)),70.0) * 8.0, 1.0);\r\n    float ic = pow(1.0-c,0.5);\r\n    vec3 base = vec3(0.42,0.3,0.2) * 0.35;\r\n    vec3 sand = vec3(0.51,0.41,0.32)*0.9;\r\n    vec3 color = mix(base,sand,c);\r\n        \r\n    float f = pow(1.0 - max(dot(n,-e),0.0), 5.0) * 0.75 * ic;    \r\n    color += vec3(diffuse(n,l,0.5) * WHITE);\r\n    color += vec3(specular(n,l,e,8.0) * WHITE * 1.5 * ic);\r\n    n = normalize(n - normalize(p) * 0.4);    \r\n    color += vec3(specular(n,l,e,80.0) * WHITE * 1.5 * ic);    \r\n    color = mix(color,vec3(1.0),f); \r\n    \r\n    color *= sqrt(abs(p.y*0.5+0.5)) * 0.4 + 0.6;\r\n    color *= (n.y * 0.5 + 0.5) * 0.4 + 0.6; \r\n    \r\n    return color;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {\r\n    vec2 iuv = coord / iResolution.xy * 2.0 - 1.0;\r\n    vec2 uv = iuv;\r\n    uv.x *= iResolution.x / iResolution.y;\r\n        \r\n    // ray\r\n    vec3 ang = vec3(0.0,0.2,time);\r\n    if(iMouse.z > 0.0) ang = vec3(0.0,clamp(2.0-iMouse.y*0.01,0.0,3.1415),iMouse.x*0.01);\r\n\tmat3 rot = fromEuler(ang);\r\n    \r\n    vec3 ori = vec3(0.0,0.0,2.8);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0));    \r\n    ori = ori * rot;\r\n    dir = dir * rot;\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    vec2 td = spheretracing(ori,dir,p);\r\n    vec3 n = getNormal(p,td.y);\r\n    vec2 occ = getOcclusion(p,n);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.0)); \r\n         \r\n    // color\r\n    vec3 color = vec3(1.0);    \r\n    if(td.x < 3.5 && p.y > -0.89) color = getStoneColor(p,occ.y,light,n,dir);\r\n    color *= occ.x;\r\n    return color;\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3;\r\n        \r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++)\r\n    for(int j = -1; j <= 1; j++) {\r\n        vec2 uv = fragCoord+vec2(i,j)/3.0;\r\n        color += getPixel(uv, time);\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    color = sqrt(color);\r\n    color = saturation(color,1.7);\r\n               \r\n    // vignette\r\n    vec2 iuv = fragCoord / iResolution.xy * 2.0 - 1.0;\r\n    float vgn = smoothstep(1.2,0.7,abs(iuv.y)) * smoothstep(1.1,0.8,abs(iuv.x));\r\n    color *= 1.0 - (1.0 - vgn) * 0.15;\t\r\n    \r\n\tfragColor = vec4(color,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// ---------------- Config ----------------\r\n// This is an option that lets you render high quality frames for screenshots. It enables\r\n// stochastic antialiasing and motion blur automatically for any shader.\r\n//#define NON_REALTIME_HQ_RENDER\r\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\r\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\r\n\r\n//#define MANUAL_CAMERA\r\n\r\n\r\n// --------------------------------------------------------\r\n// These variables are for the non-realtime block renderer.\r\nfloat localTime = 0.0;\r\nfloat seed = 1.0;\r\n\r\n// Animation variables\r\nfloat fade = 1.0;\r\nvec3 sunDir;\r\nvec3 sunCol;\r\nfloat exposure = 1.0;\r\nvec3 skyCol, horizonCol;\r\n\r\n// other\r\nfloat marchCount = 0.0;\r\n\r\n// ---- noise functions ----\r\nfloat v31(vec3 a)\r\n{\r\n    return a.x + a.y * 37.0 + a.z * 521.0;\r\n}\r\nfloat v21(vec2 a)\r\n{\r\n    return a.x + a.y * 37.0;\r\n}\r\nfloat Hash11(float a)\r\n{\r\n    return fract(sin(a)*10403.9);\r\n}\r\nfloat Hash21(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nvec2 Hash22(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nvec2 Hash12(float f)\r\n{\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nfloat Hash1d(float u)\r\n{\r\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nconst float PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*150.0)*7000.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\r\n{\r\n    // fade the sky color, multiply sunset dimming\r\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\r\n    // make clouds - just a horizontal plane with noise\r\n    float n = noise2d(rayDir.xz/rayDir.y*1.0);\r\n    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\r\n    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\r\n    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\r\n    n = pow(abs(n), 3.0);\r\n    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance\r\n    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));\r\n\r\n    // add the sun\r\n    finalColor += GetSunColorSmall(rayDir, sunDir);\r\n    return finalColor;\r\n}\r\n\r\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)\r\n{\r\n    vec3 finalColor = GetEnvMap(rayDir, sunDir);\r\n\r\n    // Make a skyscraper skyline reflection.\r\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\r\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\r\n    radial *= 4.0;\r\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\r\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\r\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\r\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\r\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\r\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\r\n\r\n\treturn finalColor;\r\n}\r\n\r\n// min function that supports materials in the y component\r\nvec2 matmin(vec2 a, vec2 b)\r\n{\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n}\r\n\r\n// ---- shapes defined by distance fields ----\r\n// See this site for a reference to more distance functions...\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n\r\n// signed box distance field\r\nfloat sdBox(vec3 p, vec3 radius)\r\n{\r\n  vec3 dist = abs(p) - radius;\r\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\r\n}\r\n\r\n// capped cylinder distance field\r\nfloat cylCap(vec3 p, float r, float lenRad)\r\n{\r\n    float a = length(p.xy) - r;\r\n    a = max(a, abs(p.z) - lenRad);\r\n    return a;\r\n}\r\n\r\n// k should be negative. -4.0 works nicely.\r\n// smooth blending function\r\nfloat smin(float a, float b, float k)\r\n{\r\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\r\n}\r\n\r\nfloat Repeat(float a, float len)\r\n{\r\n    return mod(a, len) - 0.5 * len;\r\n}\r\n\r\n// Distance function that defines the car.\r\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\r\nvec2 Car(vec3 baseCenter, float unique)\r\n{\r\n    // bottom box\r\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.001), vec3(0.01, 0.00225, 0.0275));\r\n    // top box smooth blended\r\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.008), vec3(0.005, 0.0005, 0.01)), -160.0);\r\n    // mirror the z axis to duplicate the cylinders for wheels\r\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.0);\r\n    wMirror.z = abs(wMirror.z)-0.02;\r\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\r\n    // Set materials\r\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\r\n    // Car material is some big number that's unique to each car\r\n    // so I can have each car be a different color\r\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\r\n    return distAndMat;\r\n}\r\n\r\n// How much space between voxel borders and geometry for voxel ray march optimization\r\nfloat voxelPad = 0.2;\r\n// p should be in [0..1] range on xz plane\r\n// pint is an integer pair saying which city block you are on\r\nvec2 CityBlock(vec3 p, vec2 pint)\r\n{\r\n    // Get random numbers for this block by hashing the city block variable\r\n    vec4 rand;\r\n    rand.xy = Hash22(pint);\r\n    rand.zw = Hash22(rand.xy);\r\n    vec2 rand2 = Hash22(rand.zw);\r\n\r\n    // Radius of the building\r\n    float baseRad = 0.2 + (rand.x) * 0.1;\r\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\r\n\r\n    // make position relative to the middle of the block\r\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\r\n    float height = rand.w*rand.z + 0.1; // height of first building block\r\n    // Make the city skyline higher in the middle of the city.\r\n    float downtown = saturate(4.0 / length(pint.xy));\r\n    height *= downtown;\r\n    height *= 1.5+(baseRad-0.15)*20.0;\r\n    height += 0.1;\t// minimum building height\r\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\r\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\r\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\r\n\r\n    // road\r\n    d = min(d, p.y);\r\n\r\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\r\n\r\n    // height of second building section\r\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\r\n    height2 = floor(height2*20.0)*0.05;\t// floor units\r\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\r\n    // size pieces of building\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\r\n    // second building section\r\n    if (rand2.y > 0.25)\r\n    {\r\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\r\n        // subtract off piece from top so it looks like there's a wall around the roof.\r\n        float topWidth = baseRad;\r\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\r\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\r\n    }\r\n    else\r\n    {\r\n        // Cylinder top section of building\r\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\r\n    }\r\n    // mini elevator shaft boxes on top of building\r\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\r\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\r\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\r\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\r\n    float big = sign(boxPos.x);\r\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\r\n\td = min(d, sdBox(boxPos,\r\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\r\n\r\n    // Put domes on some building tops for variety\r\n    if (rand.y < 0.04)\r\n    {\r\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\r\n    }\r\n\r\n    //d = max(d, p.y);  // flatten the city for debugging cars\r\n\r\n    // Need to make a material variable.\r\n    vec2 distAndMat = vec2(d, 0.0);\r\n    // sidewalk box with material\r\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This is the distance function that defines all the scene's geometry.\r\n// The input is a position in space.\r\n// The output is the distance to the nearest surface and a material index.\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills\r\n    vec3 rep = p;\r\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\r\n    vec2 distAndMat = CityBlock(rep, floor(p.xz));\r\n\r\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\r\n    // only want to do a single call to the car distance function for all the\r\n    // cars in the scene. And there's a lot of traffic!\r\n    vec3 p2 = p;\r\n    rep.xyz = p2;\r\n    float carTime = localTime*0.2;  // Speed of car driving\r\n    float crossStreet = 1.0;  // whether we are north/south or east/west\r\n    float repeatDist = 0.25;  // Car density bumper to bumper\r\n    // If we are going north/south instead of east/west (?) make cars that are\r\n    // stopped in the street so we don't have collisions.\r\n    if (abs(fract(rep.x)-0.5) < 0.35)\r\n    {\r\n        p2.x += 0.05;\r\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\r\n        rep.xz = p2.xz;\r\n        crossStreet = 0.0;\r\n        repeatDist = 0.1;  // Denser traffic on cross streets\r\n    }\r\n    \r\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\r\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\r\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\r\n    rep.x = (rep.x*sign(rep.x))-0.09;\r\n    rep.z -= carTime * crossStreet;\t// make cars move\r\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\r\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\r\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\r\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\r\n    frontBack *= sin(localTime*2.0 + uniqueID);\r\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\r\n    vec2 carDist = Car(rep, uniqueID); // car distance function\r\n\r\n    // Drop the cars in the scene with materials\r\n    distAndMat = matmin(distAndMat, carDist);\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This basically makes a procedural texture map for the sides of the buildings.\r\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\r\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\r\n{\r\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\r\n    texColor += hue*0.4;\r\n    texColor *= 0.75;\r\n    float window = 0.0;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\r\n    if (pos.y < 0.05) window = 1.0;\r\n    float winWidth = Hash21(block*4.321)*2.0;\r\n    if ((winWidth < 1.3) && (winWidth >= 1.0)) winWidth = 1.3;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\r\n    if (window < 0.5)\r\n    {\r\n        windowRef += 1.0;\r\n    }\r\n    window *= Hash21(block*1.123);\r\n    texColor *= window;\r\n\r\n    float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\r\n    normal.y -= max(-1.0, min(1.0, -wave*0.5));\r\n    float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\r\n    normal.z += pits*0.25;\r\n    pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\r\n    normal.x += pits*0.25;\r\n}\r\n\r\n// Input is UV coordinate of pixel to render.\r\n// Output is RGB color.\r\nvec3 RayTrace(in vec2 fragCoord )\r\n{\r\n    marchCount = 0.0;\r\n\t// -------------------------------- animate ---------------------------------------\r\n    sunCol = vec3(258.0, 248.0, 200.0) / 3555.0;\r\n\tsunDir = normalize(vec3(0.93, 1.0, 1.0));\r\n    horizonCol = vec3(1.0, 0.95, 0.85)*0.9;\r\n    skyCol = vec3(0.3,0.5,0.95);\r\n    exposure = 1.0;\r\n    fade = 1.0;\r\n\r\n\tvec3 camPos, camUp, camLookat;\r\n\t// ------------------- Set up the camera rays for ray marching --------------------\r\n    // Map uv to [-1.0..1.0]\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n    uv /= 2.0;  // zoom in\r\n\r\n#ifdef MANUAL_CAMERA\r\n    // Camera up vector.\r\n\tcamUp=vec3(0,1,0);\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\r\n\r\n    // debugging camera\r\n    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\r\n\tfloat my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\r\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.35;//7.35\r\n#else\r\n    // Do the camera fly-by animation and different scenes.\r\n    // Time variables for start and end of each scene\r\n    const float t0 = 0.0;\r\n    const float t1 = 8.0;\r\n    const float t2 = 14.0;\r\n    const float t3 = 24.0;\r\n    const float t4 = 38.0;\r\n    const float t5 = 56.0;\r\n    const float t6 = 58.0;\r\n    /*const float t0 = 0.0;\r\n    const float t1 = 0.0;\r\n    const float t2 = 0.0;\r\n    const float t3 = 0.0;\r\n    const float t4 = 0.0;\r\n    const float t5 = 16.0;\r\n    const float t6 = 18.0;*/\r\n    // Repeat the animation after time t6\r\n    localTime = fract(localTime / t6) * t6;\r\n    if (localTime < t1)\r\n    {\r\n        float time = localTime - t0;\r\n        float alpha = time / (t1 - t0);\r\n        fade = saturate(time);\r\n        fade *= saturate(t1 - localTime);\r\n        camPos = vec3(13.0, 3.3, -3.5);\r\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0,1.5,1.5);\r\n    } else if (localTime < t2)\r\n    {\r\n        float time = localTime - t1;\r\n        float alpha = time / (t2 - t1);\r\n        fade = saturate(time);\r\n        fade *= saturate(t2 - localTime);\r\n        camPos = vec3(26.0, 0.05+smoothstep(0.0, 1.0, alpha)*0.4, 2.0);\r\n        camPos.z -= alpha * 2.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(camPos.x-0.3,-8.15,-40.0);\r\n        \r\n        sunDir = normalize(vec3(0.95, 0.6, 1.0));\r\n        sunCol = vec3(258.0, 248.0, 160.0) / 3555.0;\r\n        exposure *= 0.7;\r\n        skyCol *= 1.5;\r\n    } else if (localTime < t3)\r\n    {\r\n        float time = localTime - t2;\r\n        float alpha = time / (t3 - t2);\r\n        fade = saturate(time);\r\n        fade *= saturate(t3 - localTime);\r\n        camPos = vec3(12.0, 6.3, -0.5);\r\n        camPos.y -= alpha * 5.5;\r\n        camPos.x = cos(alpha*1.0) * 5.2;\r\n        camPos.z = sin(alpha*1.0) * 5.2;\r\n        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));\r\n        camLookat=vec3(0,1.0,-0.5);\r\n    } else if (localTime < t4)\r\n    {\r\n        float time = localTime - t3;\r\n        float alpha = time / (t4 - t3);\r\n        fade = saturate(time);\r\n        fade *= saturate(t4 - localTime);\r\n        camPos = vec3(2.15-alpha*0.5, 0.02, -1.0-alpha*0.2);\r\n        camPos.y += smoothstep(0.0,1.0,alpha*alpha) * 3.4;\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(0,0.5+alpha,alpha*5.0);\r\n    } else if (localTime < t5)\r\n    {\r\n        float time = localTime - t4;\r\n        float alpha = time / (t5 - t4);\r\n        fade = saturate(time);\r\n        fade *= saturate(t5 - localTime);\r\n        camPos = vec3(-2.0, 1.3- alpha*1.2, -10.5-alpha*0.5);\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(-2.0,0.3+alpha,-0.0);\r\n        sunDir = normalize(vec3(0.5-alpha*0.6, 0.3-alpha*0.3, 1.0));\r\n        sunCol = vec3(258.0, 148.0, 60.0) / 3555.0;\r\n        localTime *= 16.0;\r\n        exposure *= 0.4;\r\n        horizonCol = vec3(1.0, 0.5, 0.35)*2.0;\r\n        skyCol = vec3(0.75,0.5,0.95);\r\n\r\n    } else if (localTime < t6)\r\n    {\r\n        fade = 0.0;\r\n        camPos = vec3(26.0, 100.0, 2.0);\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0.3,0.15,0.0);\r\n    }\r\n#endif\r\n\r\n\t// Camera setup for ray tracing / marching\r\n\tvec3 camVec=normalize(camLookat - camPos);\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\r\n\tvec3 upNorm=cross(camVec, sideNorm);\r\n\tvec3 worldFacing=(camPos + camVec);\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\r\n\tvec3 rayVec = normalize(worldPix - camPos);\r\n\r\n\t// ----------------------------- Ray march the scene ------------------------------\r\n\tvec2 distAndMat;  // Distance and material\r\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\r\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\r\n\tvec3 pos = vec3(0.0);\r\n    const float smallVal = 0.000625;\r\n\t// ray marching time\r\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\r\n    {\r\n        marchCount+=1.0;\r\n        // Step along the ray.\r\n        pos = (camPos + rayVec * t);\r\n        // This is _the_ function that defines the \"distance field\".\r\n        // It's really what makes the scene geometry. The idea is that the\r\n        // distance field returns the distance to the closest object, and then\r\n        // we know we are safe to \"march\" along the ray by that much distance\r\n        // without hitting anything. We repeat this until we get really close\r\n        // and then break because we have effectively hit the object.\r\n        distAndMat = DistanceToObject(pos);\r\n\r\n        // 2d voxel walk through the city blocks.\r\n        // The distance function is not continuous at city block boundaries,\r\n        // so we have to pause our ray march at each voxel boundary.\r\n        float walk = distAndMat.x;\r\n        float dx = -fract(pos.x);\r\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\r\n        float dz = -fract(pos.z);\r\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\r\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\r\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\r\n        walk = min(walk, nearestVoxel);\r\n\r\n        // move down the ray a safe amount\r\n        t += walk;\r\n        // If we are very close to the object, let's call it a hit and exit this loop.\r\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\r\n    }\r\n\r\n    // Ray trace a ground plane to infinity\r\n    float alpha = -camPos.y / rayVec.y;\r\n    if ((t > maxDepth) && (rayVec.y < -0.0))\r\n    {\r\n        pos.xz = camPos.xz + rayVec.xz * alpha;\r\n        pos.y = -0.0;\r\n        t = alpha;\r\n        distAndMat.y = 0.0;\r\n        distAndMat.x = 0.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n    if ((t <= maxDepth) || (t == alpha))\r\n\t{\r\n        float dist = distAndMat.x;\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(smallVal, 0, 0);\r\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\r\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(rayVec, normal);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.01;\r\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\r\n\t\tfor (int i = 0; i < 40; i++)\r\n        {\r\n            vec3 shadowPos = nudgePos + sunDir * iter;\r\n            float tempDist = DistanceToObject(shadowPos).x;\r\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\r\n            if (tempDist <= 0.0) break;\r\n\r\n            float walk = tempDist;\r\n            float dx = -fract(shadowPos.x);\r\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\r\n            float dz = -fract(shadowPos.z);\r\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\r\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\r\n            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n            walk = min(walk, nearestVoxel);\r\n\r\n            iter += max(0.01, walk);\r\n            if (iter > 4.5) break;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // make a few frequencies of noise to give it some texture\r\n        float n =0.0;\r\n        n += noise(pos*32.0);\r\n        n += noise(pos*64.0);\r\n        n += noise(pos*128.0);\r\n        n += noise(pos*256.0);\r\n        n += noise(pos*512.0);\r\n        n = mix(0.7, 0.95, n);\r\n\r\n        // ------ Calculate texture color  ------\r\n        vec2 block = floor(pos.xz);\r\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\r\n        texColor *= 0.8;\r\n        float windowRef = 0.0;\r\n        // texture map the sides of buildings\r\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\r\n        {\r\n            vec3 posdx = dFdx(pos);\r\n            vec3 posdy = dFdy(pos);\r\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\r\n\r\n            // Quincunx antialias the building texture and normal map.\r\n            // I guess procedural textures are hard to mipmap.\r\n            vec3 colTotal = vec3(0.0);\r\n            vec3 colTemp = texColor;\r\n            vec3 nTemp = vec3(0.0);\r\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\r\n            colTotal = colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            texColor = colTotal * 0.2;\r\n            windowRef *= 0.2;\r\n\r\n            normal = normalize(normal + nTemp * 0.2);\r\n        }\r\n        else\r\n        {\r\n            // Draw the road\r\n            float xroad = abs(fract(pos.x+0.5)-0.5);\r\n            float zroad = abs(fract(pos.z+0.5)-0.5);\r\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\r\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\r\n            texColor *= mix(0.1, 1.0, road);\r\n\r\n            // double yellow line in middle of road\r\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\r\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\r\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\r\n\r\n            // white dashed lines on road\r\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\r\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            // crosswalk\r\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((zroad-0.15)*880.0);\r\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((xroad-0.15)*880.0);\r\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n\r\n            {\r\n                // sidewalk cracks\r\n                float sidewalk = 1.0;\r\n                vec2 blockSize = vec2(100.0);\r\n                if (pos.y > 0.1) blockSize = vec2(10.0, 50);\r\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\r\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\r\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\r\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\r\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\r\n                sidewalk = saturate((1.0-road) + sidewalk);\r\n                texColor *= sidewalk;\r\n            }\r\n        }\r\n        // Car tires are almost black to not call attention to their ugly.\r\n        if (distAndMat.y == 3.0)\r\n        {\r\n            texColor = vec3(0.05);\r\n        }\r\n\r\n        // apply noise\r\n        texColor *= vec3(1.0)*n*0.05;\r\n        texColor *= 0.7;\r\n        texColor = saturate(texColor);\r\n\r\n        float windowMask = 0.0;\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            // car texture and windows\r\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\r\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\r\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\r\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\r\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\r\n            windowMask = saturate( max(0.0, abs(pos.y - 0.0175)*3800.0)-10.0);\r\n            vec2 dirNorm = abs(normalize(normal.xz));\r\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\r\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\r\n            windowMask = max(windowMask, pillars);\r\n            texColor *= windowMask;\r\n        }\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = vec3(100.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\r\n        // weighted average the near ambient occlusion with the far for just the right look\r\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\r\n        // Add sky color with ambient acclusion\r\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*2.5;\r\n        lightColor *= 4.0;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n        // Reflections for cars\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\r\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*0.3*yfade*max(0.4,sunShadow);\r\n            finalColor += saturate(texture(iChannel0, ref.xy).xyz-0.35)*0.15*max(0.2,sunShadow);\r\n        }\r\n        // reflections for building windows\r\n        if (windowRef != 0.0)\r\n        {\r\n            finalColor *= mix(1.0, 0.6, windowRef);\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.5)*0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\r\n            finalColor += saturate(texture(iChannel0, ref.xy).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n        }\r\n        finalColor *= 0.9;\r\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\r\n        vec3 rv2 = rayVec;\r\n        rv2.y *= saturate(sign(rv2.y));\r\n        vec3 fogColor = GetEnvMap(rv2, sunDir);\r\n        fogColor = min(vec3(9.0), fogColor);\r\n        finalColor = mix(fogColor, finalColor, exp(-t*0.02));\r\n\r\n        // visualize length of gradient of distance field to check distance field correctness\r\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\r\n        //finalColor = vec3(marchCount)/255.0;\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        finalColor = GetEnvMap(rayVec, sunDir);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.3*exposure;\r\n\r\n\t// output the final color without gamma correction - will do gamma later.\r\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.2));\r\n}\r\n\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n// This function breaks the image down into blocks and scans\r\n// through them, rendering 1 block at a time. It's for non-\r\n// realtime things that take a long time to render.\r\n\r\n// This is the frame rate to render at. Too fast and you will\r\n// miss some blocks.\r\nconst float blockRate = 20.0;\r\nvoid BlockRender(in vec2 fragCoord)\r\n{\r\n    // blockSize is how much it will try to render in 1 frame.\r\n    // adjust this smaller for more complex scenes, bigger for\r\n    // faster render times.\r\n    const float blockSize = 64.0;\r\n    // Make the block repeatedly scan across the image based on time.\r\n    float frame = floor(iTime * blockRate);\r\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\r\n    // ugly bug with mod.\r\n    //float blockX = mod(frame, blockRes.x);\r\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\r\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\r\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\r\n    // Don't draw anything outside the current block.\r\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\r\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\r\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\r\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\r\n    {\r\n        discard;\r\n    }\r\n}\r\n#endif\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    // Optionally render a non-realtime scene with high quality\r\n    BlockRender(fragCoord);\r\n#endif\r\n\r\n    // Do a multi-pass render\r\n    vec3 finalColor = vec3(0.0);\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    for (float i = 0.0; i < antialiasingSamples; i++)\r\n    {\r\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\r\n        // Set this to the time in seconds of the frame to render.\r\n\t    localTime = frameToRenderHQ;\r\n        // This line will motion-blur the renders\r\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\r\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\r\n        vec2 jittered = fragCoord.xy + vec2(\r\n            Hash21(fragCoord + seed),\r\n            Hash21(fragCoord*7.234567 + seed)\r\n            );\r\n        // don't antialias if only 1 sample.\r\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\r\n        // Accumulate one pass of raytracing into our pixel value\r\n\t    finalColor += RayTrace(jittered);\r\n        // Change the random seed for each pass.\r\n\t    seed *= 1.01234567;\r\n    }\r\n    // Average all accumulated pixel intensities\r\n    finalColor /= antialiasingSamples;\r\n#else\r\n    // Regular real-time rendering\r\n    localTime = iTime;\r\n    finalColor = RayTrace(fragCoord);\r\n#endif\r\n\r\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// ---------------- Config ----------------\r\n// This is an option that lets you render high quality frames for screenshots. It enables\r\n// stochastic antialiasing and motion blur automatically for any shader.\r\n//#define NON_REALTIME_HQ_RENDER\r\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\r\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\r\n\r\n//#define MANUAL_CAMERA\r\n\r\n\r\n// --------------------------------------------------------\r\n// These variables are for the non-realtime block renderer.\r\nfloat localTime = 0.0;\r\nfloat seed = 1.0;\r\n\r\n// Animation variables\r\nfloat fade = 1.0;\r\nvec3 sunDir;\r\nvec3 sunCol;\r\nfloat exposure = 1.0;\r\nvec3 skyCol, horizonCol;\r\n\r\n// other\r\nfloat marchCount = 0.0;\r\n\r\n// ---- noise functions ----\r\nfloat v31(vec3 a)\r\n{\r\n    return a.x + a.y * 37.0 + a.z * 521.0;\r\n}\r\nfloat v21(vec2 a)\r\n{\r\n    return a.x + a.y * 37.0;\r\n}\r\nfloat Hash11(float a)\r\n{\r\n    return fract(sin(a)*10403.9);\r\n}\r\nfloat Hash21(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nvec2 Hash22(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nvec2 Hash12(float f)\r\n{\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nfloat Hash1d(float u)\r\n{\r\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nconst float PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*150.0)*7000.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\r\n{\r\n    // fade the sky color, multiply sunset dimming\r\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\r\n    // make clouds - just a horizontal plane with noise\r\n    float n = noise2d(rayDir.xz/rayDir.y*1.0);\r\n    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\r\n    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\r\n    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\r\n    n = pow(abs(n), 3.0);\r\n    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance\r\n    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));\r\n\r\n    // add the sun\r\n    finalColor += GetSunColorSmall(rayDir, sunDir);\r\n    return finalColor;\r\n}\r\n\r\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)\r\n{\r\n    vec3 finalColor = GetEnvMap(rayDir, sunDir);\r\n\r\n    // Make a skyscraper skyline reflection.\r\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\r\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\r\n    radial *= 4.0;\r\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\r\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\r\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\r\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\r\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\r\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\r\n\r\n\treturn finalColor;\r\n}\r\n\r\n// min function that supports materials in the y component\r\nvec2 matmin(vec2 a, vec2 b)\r\n{\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n}\r\n\r\n// ---- shapes defined by distance fields ----\r\n// See this site for a reference to more distance functions...\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n\r\n// signed box distance field\r\nfloat sdBox(vec3 p, vec3 radius)\r\n{\r\n  vec3 dist = abs(p) - radius;\r\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\r\n}\r\n\r\n// capped cylinder distance field\r\nfloat cylCap(vec3 p, float r, float lenRad)\r\n{\r\n    float a = length(p.xy) - r;\r\n    a = max(a, abs(p.z) - lenRad);\r\n    return a;\r\n}\r\n\r\n// k should be negative. -4.0 works nicely.\r\n// smooth blending function\r\nfloat smin(float a, float b, float k)\r\n{\r\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\r\n}\r\n\r\nfloat Repeat(float a, float len)\r\n{\r\n    return mod(a, len) - 0.5 * len;\r\n}\r\n\r\n// Distance function that defines the car.\r\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\r\nvec2 Car(vec3 baseCenter, float unique)\r\n{\r\n    // bottom box\r\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.001), vec3(0.01, 0.00225, 0.0275));\r\n    // top box smooth blended\r\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.008), vec3(0.005, 0.0005, 0.01)), -160.0);\r\n    // mirror the z axis to duplicate the cylinders for wheels\r\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.0);\r\n    wMirror.z = abs(wMirror.z)-0.02;\r\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\r\n    // Set materials\r\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\r\n    // Car material is some big number that's unique to each car\r\n    // so I can have each car be a different color\r\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\r\n    return distAndMat;\r\n}\r\n\r\n// How much space between voxel borders and geometry for voxel ray march optimization\r\nfloat voxelPad = 0.2;\r\n// p should be in [0..1] range on xz plane\r\n// pint is an integer pair saying which city block you are on\r\nvec2 CityBlock(vec3 p, vec2 pint)\r\n{\r\n    // Get random numbers for this block by hashing the city block variable\r\n    vec4 rand;\r\n    rand.xy = Hash22(pint);\r\n    rand.zw = Hash22(rand.xy);\r\n    vec2 rand2 = Hash22(rand.zw);\r\n\r\n    // Radius of the building\r\n    float baseRad = 0.2 + (rand.x) * 0.1;\r\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\r\n\r\n    // make position relative to the middle of the block\r\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\r\n    float height = rand.w*rand.z + 0.1; // height of first building block\r\n    // Make the city skyline higher in the middle of the city.\r\n    float downtown = saturate(4.0 / length(pint.xy));\r\n    height *= downtown;\r\n    height *= 1.5+(baseRad-0.15)*20.0;\r\n    height += 0.1;\t// minimum building height\r\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\r\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\r\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\r\n\r\n    // road\r\n    d = min(d, p.y);\r\n\r\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\r\n\r\n    // height of second building section\r\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\r\n    height2 = floor(height2*20.0)*0.05;\t// floor units\r\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\r\n    // size pieces of building\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\r\n    // second building section\r\n    if (rand2.y > 0.25)\r\n    {\r\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\r\n        // subtract off piece from top so it looks like there's a wall around the roof.\r\n        float topWidth = baseRad;\r\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\r\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\r\n    }\r\n    else\r\n    {\r\n        // Cylinder top section of building\r\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\r\n    }\r\n    // mini elevator shaft boxes on top of building\r\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\r\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\r\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\r\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\r\n    float big = sign(boxPos.x);\r\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\r\n\td = min(d, sdBox(boxPos,\r\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\r\n\r\n    // Put domes on some building tops for variety\r\n    if (rand.y < 0.04)\r\n    {\r\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\r\n    }\r\n\r\n    //d = max(d, p.y);  // flatten the city for debugging cars\r\n\r\n    // Need to make a material variable.\r\n    vec2 distAndMat = vec2(d, 0.0);\r\n    // sidewalk box with material\r\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This is the distance function that defines all the scene's geometry.\r\n// The input is a position in space.\r\n// The output is the distance to the nearest surface and a material index.\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills\r\n    vec3 rep = p;\r\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\r\n    vec2 distAndMat = CityBlock(rep, floor(p.xz));\r\n\r\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\r\n    // only want to do a single call to the car distance function for all the\r\n    // cars in the scene. And there's a lot of traffic!\r\n    vec3 p2 = p;\r\n    rep.xyz = p2;\r\n    float carTime = localTime*0.2;  // Speed of car driving\r\n    float crossStreet = 1.0;  // whether we are north/south or east/west\r\n    float repeatDist = 0.25;  // Car density bumper to bumper\r\n    // If we are going north/south instead of east/west (?) make cars that are\r\n    // stopped in the street so we don't have collisions.\r\n    if (abs(fract(rep.x)-0.5) < 0.35)\r\n    {\r\n        p2.x += 0.05;\r\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\r\n        rep.xz = p2.xz;\r\n        crossStreet = 0.0;\r\n        repeatDist = 0.1;  // Denser traffic on cross streets\r\n    }\r\n    \r\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\r\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\r\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\r\n    rep.x = (rep.x*sign(rep.x))-0.09;\r\n    rep.z -= carTime * crossStreet;\t// make cars move\r\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\r\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\r\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\r\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\r\n    frontBack *= sin(localTime*2.0 + uniqueID);\r\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\r\n    vec2 carDist = Car(rep, uniqueID); // car distance function\r\n\r\n    // Drop the cars in the scene with materials\r\n    distAndMat = matmin(distAndMat, carDist);\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This basically makes a procedural texture map for the sides of the buildings.\r\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\r\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\r\n{\r\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\r\n    texColor += hue*0.4;\r\n    texColor *= 0.75;\r\n    float window = 0.0;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\r\n    if (pos.y < 0.05) window = 1.0;\r\n    float winWidth = Hash21(block*4.321)*2.0;\r\n    if ((winWidth < 1.3) && (winWidth >= 1.0)) winWidth = 1.3;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\r\n    if (window < 0.5)\r\n    {\r\n        windowRef += 1.0;\r\n    }\r\n    window *= Hash21(block*1.123);\r\n    texColor *= window;\r\n\r\n    float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\r\n    normal.y -= max(-1.0, min(1.0, -wave*0.5));\r\n    float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\r\n    normal.z += pits*0.25;\r\n    pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\r\n    normal.x += pits*0.25;\r\n}\r\n\r\n// Input is UV coordinate of pixel to render.\r\n// Output is RGB color.\r\nvec3 RayTrace(in vec2 fragCoord )\r\n{\r\n    marchCount = 0.0;\r\n\t// -------------------------------- animate ---------------------------------------\r\n    sunCol = vec3(258.0, 248.0, 200.0) / 3555.0;\r\n\tsunDir = normalize(vec3(0.93, 1.0, 1.0));\r\n    horizonCol = vec3(1.0, 0.95, 0.85)*0.9;\r\n    skyCol = vec3(0.3,0.5,0.95);\r\n    exposure = 1.0;\r\n    fade = 1.0;\r\n\r\n\tvec3 camPos, camUp, camLookat;\r\n\t// ------------------- Set up the camera rays for ray marching --------------------\r\n    // Map uv to [-1.0..1.0]\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n    uv /= 2.0;  // zoom in\r\n\r\n#ifdef MANUAL_CAMERA\r\n    // Camera up vector.\r\n\tcamUp=vec3(0,1,0);\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\r\n\r\n    // debugging camera\r\n    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\r\n\tfloat my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\r\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.35;//7.35\r\n#else\r\n    // Do the camera fly-by animation and different scenes.\r\n    // Time variables for start and end of each scene\r\n    const float t0 = 0.0;\r\n    const float t1 = 8.0;\r\n    const float t2 = 14.0;\r\n    const float t3 = 24.0;\r\n    const float t4 = 38.0;\r\n    const float t5 = 56.0;\r\n    const float t6 = 58.0;\r\n    /*const float t0 = 0.0;\r\n    const float t1 = 0.0;\r\n    const float t2 = 0.0;\r\n    const float t3 = 0.0;\r\n    const float t4 = 0.0;\r\n    const float t5 = 16.0;\r\n    const float t6 = 18.0;*/\r\n    // Repeat the animation after time t6\r\n    localTime = fract(localTime / t6) * t6;\r\n    if (localTime < t1)\r\n    {\r\n        float time = localTime - t0;\r\n        float alpha = time / (t1 - t0);\r\n        fade = saturate(time);\r\n        fade *= saturate(t1 - localTime);\r\n        camPos = vec3(13.0, 3.3, -3.5);\r\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0,1.5,1.5);\r\n    } else if (localTime < t2)\r\n    {\r\n        float time = localTime - t1;\r\n        float alpha = time / (t2 - t1);\r\n        fade = saturate(time);\r\n        fade *= saturate(t2 - localTime);\r\n        camPos = vec3(26.0, 0.05+smoothstep(0.0, 1.0, alpha)*0.4, 2.0);\r\n        camPos.z -= alpha * 2.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(camPos.x-0.3,-8.15,-40.0);\r\n        \r\n        sunDir = normalize(vec3(0.95, 0.6, 1.0));\r\n        sunCol = vec3(258.0, 248.0, 160.0) / 3555.0;\r\n        exposure *= 0.7;\r\n        skyCol *= 1.5;\r\n    } else if (localTime < t3)\r\n    {\r\n        float time = localTime - t2;\r\n        float alpha = time / (t3 - t2);\r\n        fade = saturate(time);\r\n        fade *= saturate(t3 - localTime);\r\n        camPos = vec3(12.0, 6.3, -0.5);\r\n        camPos.y -= alpha * 5.5;\r\n        camPos.x = cos(alpha*1.0) * 5.2;\r\n        camPos.z = sin(alpha*1.0) * 5.2;\r\n        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));\r\n        camLookat=vec3(0,1.0,-0.5);\r\n    } else if (localTime < t4)\r\n    {\r\n        float time = localTime - t3;\r\n        float alpha = time / (t4 - t3);\r\n        fade = saturate(time);\r\n        fade *= saturate(t4 - localTime);\r\n        camPos = vec3(2.15-alpha*0.5, 0.02, -1.0-alpha*0.2);\r\n        camPos.y += smoothstep(0.0,1.0,alpha*alpha) * 3.4;\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(0,0.5+alpha,alpha*5.0);\r\n    } else if (localTime < t5)\r\n    {\r\n        float time = localTime - t4;\r\n        float alpha = time / (t5 - t4);\r\n        fade = saturate(time);\r\n        fade *= saturate(t5 - localTime);\r\n        camPos = vec3(-2.0, 1.3- alpha*1.2, -10.5-alpha*0.5);\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(-2.0,0.3+alpha,-0.0);\r\n        sunDir = normalize(vec3(0.5-alpha*0.6, 0.3-alpha*0.3, 1.0));\r\n        sunCol = vec3(258.0, 148.0, 60.0) / 3555.0;\r\n        localTime *= 16.0;\r\n        exposure *= 0.4;\r\n        horizonCol = vec3(1.0, 0.5, 0.35)*2.0;\r\n        skyCol = vec3(0.75,0.5,0.95);\r\n\r\n    } else if (localTime < t6)\r\n    {\r\n        fade = 0.0;\r\n        camPos = vec3(26.0, 100.0, 2.0);\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0.3,0.15,0.0);\r\n    }\r\n#endif\r\n\r\n\t// Camera setup for ray tracing / marching\r\n\tvec3 camVec=normalize(camLookat - camPos);\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\r\n\tvec3 upNorm=cross(camVec, sideNorm);\r\n\tvec3 worldFacing=(camPos + camVec);\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\r\n\tvec3 rayVec = normalize(worldPix - camPos);\r\n\r\n\t// ----------------------------- Ray march the scene ------------------------------\r\n\tvec2 distAndMat;  // Distance and material\r\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\r\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\r\n\tvec3 pos = vec3(0.0);\r\n    const float smallVal = 0.000625;\r\n\t// ray marching time\r\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\r\n    {\r\n        marchCount+=1.0;\r\n        // Step along the ray.\r\n        pos = (camPos + rayVec * t);\r\n        // This is _the_ function that defines the \"distance field\".\r\n        // It's really what makes the scene geometry. The idea is that the\r\n        // distance field returns the distance to the closest object, and then\r\n        // we know we are safe to \"march\" along the ray by that much distance\r\n        // without hitting anything. We repeat this until we get really close\r\n        // and then break because we have effectively hit the object.\r\n        distAndMat = DistanceToObject(pos);\r\n\r\n        // 2d voxel walk through the city blocks.\r\n        // The distance function is not continuous at city block boundaries,\r\n        // so we have to pause our ray march at each voxel boundary.\r\n        float walk = distAndMat.x;\r\n        float dx = -fract(pos.x);\r\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\r\n        float dz = -fract(pos.z);\r\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\r\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\r\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\r\n        walk = min(walk, nearestVoxel);\r\n\r\n        // move down the ray a safe amount\r\n        t += walk;\r\n        // If we are very close to the object, let's call it a hit and exit this loop.\r\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\r\n    }\r\n\r\n    // Ray trace a ground plane to infinity\r\n    float alpha = -camPos.y / rayVec.y;\r\n    if ((t > maxDepth) && (rayVec.y < -0.0))\r\n    {\r\n        pos.xz = camPos.xz + rayVec.xz * alpha;\r\n        pos.y = -0.0;\r\n        t = alpha;\r\n        distAndMat.y = 0.0;\r\n        distAndMat.x = 0.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n    if ((t <= maxDepth) || (t == alpha))\r\n\t{\r\n        float dist = distAndMat.x;\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(smallVal, 0, 0);\r\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\r\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(rayVec, normal);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.01;\r\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\r\n\t\tfor (int i = 0; i < 40; i++)\r\n        {\r\n            vec3 shadowPos = nudgePos + sunDir * iter;\r\n            float tempDist = DistanceToObject(shadowPos).x;\r\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\r\n            if (tempDist <= 0.0) break;\r\n\r\n            float walk = tempDist;\r\n            float dx = -fract(shadowPos.x);\r\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\r\n            float dz = -fract(shadowPos.z);\r\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\r\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\r\n            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n            walk = min(walk, nearestVoxel);\r\n\r\n            iter += max(0.01, walk);\r\n            if (iter > 4.5) break;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // make a few frequencies of noise to give it some texture\r\n        float n =0.0;\r\n        n += noise(pos*32.0);\r\n        n += noise(pos*64.0);\r\n        n += noise(pos*128.0);\r\n        n += noise(pos*256.0);\r\n        n += noise(pos*512.0);\r\n        n = mix(0.7, 0.95, n);\r\n\r\n        // ------ Calculate texture color  ------\r\n        vec2 block = floor(pos.xz);\r\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\r\n        texColor *= 0.8;\r\n        float windowRef = 0.0;\r\n        // texture map the sides of buildings\r\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\r\n        {\r\n            vec3 posdx = dFdx(pos);\r\n            vec3 posdy = dFdy(pos);\r\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\r\n\r\n            // Quincunx antialias the building texture and normal map.\r\n            // I guess procedural textures are hard to mipmap.\r\n            vec3 colTotal = vec3(0.0);\r\n            vec3 colTemp = texColor;\r\n            vec3 nTemp = vec3(0.0);\r\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\r\n            colTotal = colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            texColor = colTotal * 0.2;\r\n            windowRef *= 0.2;\r\n\r\n            normal = normalize(normal + nTemp * 0.2);\r\n        }\r\n        else\r\n        {\r\n            // Draw the road\r\n            float xroad = abs(fract(pos.x+0.5)-0.5);\r\n            float zroad = abs(fract(pos.z+0.5)-0.5);\r\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\r\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\r\n            texColor *= mix(0.1, 1.0, road);\r\n\r\n            // double yellow line in middle of road\r\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\r\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\r\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\r\n\r\n            // white dashed lines on road\r\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\r\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            // crosswalk\r\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((zroad-0.15)*880.0);\r\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((xroad-0.15)*880.0);\r\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n\r\n            {\r\n                // sidewalk cracks\r\n                float sidewalk = 1.0;\r\n                vec2 blockSize = vec2(100.0);\r\n                if (pos.y > 0.1) blockSize = vec2(10.0, 50);\r\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\r\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\r\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\r\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\r\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\r\n                sidewalk = saturate((1.0-road) + sidewalk);\r\n                texColor *= sidewalk;\r\n            }\r\n        }\r\n        // Car tires are almost black to not call attention to their ugly.\r\n        if (distAndMat.y == 3.0)\r\n        {\r\n            texColor = vec3(0.05);\r\n        }\r\n\r\n        // apply noise\r\n        texColor *= vec3(1.0)*n*0.05;\r\n        texColor *= 0.7;\r\n        texColor = saturate(texColor);\r\n\r\n        float windowMask = 0.0;\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            // car texture and windows\r\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\r\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\r\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\r\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\r\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\r\n            windowMask = saturate( max(0.0, abs(pos.y - 0.0175)*3800.0)-10.0);\r\n            vec2 dirNorm = abs(normalize(normal.xz));\r\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\r\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\r\n            windowMask = max(windowMask, pillars);\r\n            texColor *= windowMask;\r\n        }\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = vec3(100.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\r\n        // weighted average the near ambient occlusion with the far for just the right look\r\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\r\n        // Add sky color with ambient acclusion\r\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*2.5;\r\n        lightColor *= 4.0;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n        // Reflections for cars\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\r\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*0.3*yfade*max(0.4,sunShadow);\r\n            finalColor += saturate(texture(iChannel0, ref.xy).xyz-0.35)*0.15*max(0.2,sunShadow);\r\n        }\r\n        // reflections for building windows\r\n        if (windowRef != 0.0)\r\n        {\r\n            finalColor *= mix(1.0, 0.6, windowRef);\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.5)*0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\r\n            finalColor += saturate(texture(iChannel0, ref.xy).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n        }\r\n        finalColor *= 0.9;\r\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\r\n        vec3 rv2 = rayVec;\r\n        rv2.y *= saturate(sign(rv2.y));\r\n        vec3 fogColor = GetEnvMap(rv2, sunDir);\r\n        fogColor = min(vec3(9.0), fogColor);\r\n        finalColor = mix(fogColor, finalColor, exp(-t*0.02));\r\n\r\n        // visualize length of gradient of distance field to check distance field correctness\r\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\r\n        //finalColor = vec3(marchCount)/255.0;\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        finalColor = GetEnvMap(rayVec, sunDir);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.3*exposure;\r\n\r\n\t// output the final color without gamma correction - will do gamma later.\r\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.2));\r\n}\r\n\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n// This function breaks the image down into blocks and scans\r\n// through them, rendering 1 block at a time. It's for non-\r\n// realtime things that take a long time to render.\r\n\r\n// This is the frame rate to render at. Too fast and you will\r\n// miss some blocks.\r\nconst float blockRate = 20.0;\r\nvoid BlockRender(in vec2 fragCoord)\r\n{\r\n    // blockSize is how much it will try to render in 1 frame.\r\n    // adjust this smaller for more complex scenes, bigger for\r\n    // faster render times.\r\n    const float blockSize = 64.0;\r\n    // Make the block repeatedly scan across the image based on time.\r\n    float frame = floor(iTime * blockRate);\r\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\r\n    // ugly bug with mod.\r\n    //float blockX = mod(frame, blockRes.x);\r\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\r\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\r\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\r\n    // Don't draw anything outside the current block.\r\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\r\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\r\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\r\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\r\n    {\r\n        discard;\r\n    }\r\n}\r\n#endif\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    // Optionally render a non-realtime scene with high quality\r\n    BlockRender(fragCoord);\r\n#endif\r\n\r\n    // Do a multi-pass render\r\n    vec3 finalColor = vec3(0.0);\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    for (float i = 0.0; i < antialiasingSamples; i++)\r\n    {\r\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\r\n        // Set this to the time in seconds of the frame to render.\r\n\t    localTime = frameToRenderHQ;\r\n        // This line will motion-blur the renders\r\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\r\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\r\n        vec2 jittered = fragCoord.xy + vec2(\r\n            Hash21(fragCoord + seed),\r\n            Hash21(fragCoord*7.234567 + seed)\r\n            );\r\n        // don't antialias if only 1 sample.\r\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\r\n        // Accumulate one pass of raytracing into our pixel value\r\n\t    finalColor += RayTrace(jittered);\r\n        // Change the random seed for each pass.\r\n\t    seed *= 1.01234567;\r\n    }\r\n    // Average all accumulated pixel intensities\r\n    finalColor /= antialiasingSamples;\r\n#else\r\n    // Regular real-time rendering\r\n    localTime = iTime;\r\n    finalColor = RayTrace(fragCoord);\r\n#endif\r\n\r\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Skyline","id":null,"date":null,"viewed":0,"name":"Skyline","description":"I have always wanted to make a procedural city. The architecture was limited by what I could do in real-time, but I tried to give it enough complexity that it would look realistic.","likes":0,"published":null,"tags":["procedural"," raymarch"," city"," skyline"]},"ver":null,"info":{"Name":"Skyline","id":null,"date":null,"viewed":0,"name":"Skyline","description":"I have always wanted to make a procedural city. The architecture was limited by what I could do in real-time, but I tried to give it enough complexity that it would look realistic.","likes":0,"published":null,"tags":["procedural"," raymarch"," city"," skyline"]},"renderpass":[{"Code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// ---------------- Config ----------------\r\n// This is an option that lets you render high quality frames for screenshots. It enables\r\n// stochastic antialiasing and motion blur automatically for any shader.\r\n//#define NON_REALTIME_HQ_RENDER\r\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\r\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\r\n\r\n//#define MANUAL_CAMERA\r\n\r\n\r\n// --------------------------------------------------------\r\n// These variables are for the non-realtime block renderer.\r\nfloat localTime = 0.0;\r\nfloat seed = 1.0;\r\n\r\n// Animation variables\r\nfloat fade = 1.0;\r\nvec3 sunDir;\r\nvec3 sunCol;\r\nfloat exposure = 1.0;\r\nvec3 skyCol, horizonCol;\r\n\r\n// other\r\nfloat marchCount = 0.0;\r\n\r\n// ---- noise functions ----\r\nfloat v31(vec3 a)\r\n{\r\n    return a.x + a.y * 37.0 + a.z * 521.0;\r\n}\r\nfloat v21(vec2 a)\r\n{\r\n    return a.x + a.y * 37.0;\r\n}\r\nfloat Hash11(float a)\r\n{\r\n    return fract(sin(a)*10403.9);\r\n}\r\nfloat Hash21(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nvec2 Hash22(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nvec2 Hash12(float f)\r\n{\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nfloat Hash1d(float u)\r\n{\r\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nconst float PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*150.0)*7000.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\r\n{\r\n    // fade the sky color, multiply sunset dimming\r\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\r\n    // make clouds - just a horizontal plane with noise\r\n    float n = noise2d(rayDir.xz/rayDir.y*1.0);\r\n    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\r\n    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\r\n    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\r\n    n = pow(abs(n), 3.0);\r\n    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance\r\n    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));\r\n\r\n    // add the sun\r\n    finalColor += GetSunColorSmall(rayDir, sunDir);\r\n    return finalColor;\r\n}\r\n\r\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)\r\n{\r\n    vec3 finalColor = GetEnvMap(rayDir, sunDir);\r\n\r\n    // Make a skyscraper skyline reflection.\r\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\r\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\r\n    radial *= 4.0;\r\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\r\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\r\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\r\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\r\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\r\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\r\n\r\n\treturn finalColor;\r\n}\r\n\r\n// min function that supports materials in the y component\r\nvec2 matmin(vec2 a, vec2 b)\r\n{\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n}\r\n\r\n// ---- shapes defined by distance fields ----\r\n// See this site for a reference to more distance functions...\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n\r\n// signed box distance field\r\nfloat sdBox(vec3 p, vec3 radius)\r\n{\r\n  vec3 dist = abs(p) - radius;\r\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\r\n}\r\n\r\n// capped cylinder distance field\r\nfloat cylCap(vec3 p, float r, float lenRad)\r\n{\r\n    float a = length(p.xy) - r;\r\n    a = max(a, abs(p.z) - lenRad);\r\n    return a;\r\n}\r\n\r\n// k should be negative. -4.0 works nicely.\r\n// smooth blending function\r\nfloat smin(float a, float b, float k)\r\n{\r\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\r\n}\r\n\r\nfloat Repeat(float a, float len)\r\n{\r\n    return mod(a, len) - 0.5 * len;\r\n}\r\n\r\n// Distance function that defines the car.\r\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\r\nvec2 Car(vec3 baseCenter, float unique)\r\n{\r\n    // bottom box\r\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.001), vec3(0.01, 0.00225, 0.0275));\r\n    // top box smooth blended\r\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.008), vec3(0.005, 0.0005, 0.01)), -160.0);\r\n    // mirror the z axis to duplicate the cylinders for wheels\r\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.0);\r\n    wMirror.z = abs(wMirror.z)-0.02;\r\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\r\n    // Set materials\r\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\r\n    // Car material is some big number that's unique to each car\r\n    // so I can have each car be a different color\r\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\r\n    return distAndMat;\r\n}\r\n\r\n// How much space between voxel borders and geometry for voxel ray march optimization\r\nfloat voxelPad = 0.2;\r\n// p should be in [0..1] range on xz plane\r\n// pint is an integer pair saying which city block you are on\r\nvec2 CityBlock(vec3 p, vec2 pint)\r\n{\r\n    // Get random numbers for this block by hashing the city block variable\r\n    vec4 rand;\r\n    rand.xy = Hash22(pint);\r\n    rand.zw = Hash22(rand.xy);\r\n    vec2 rand2 = Hash22(rand.zw);\r\n\r\n    // Radius of the building\r\n    float baseRad = 0.2 + (rand.x) * 0.1;\r\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\r\n\r\n    // make position relative to the middle of the block\r\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\r\n    float height = rand.w*rand.z + 0.1; // height of first building block\r\n    // Make the city skyline higher in the middle of the city.\r\n    float downtown = saturate(4.0 / length(pint.xy));\r\n    height *= downtown;\r\n    height *= 1.5+(baseRad-0.15)*20.0;\r\n    height += 0.1;\t// minimum building height\r\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\r\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\r\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\r\n\r\n    // road\r\n    d = min(d, p.y);\r\n\r\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\r\n\r\n    // height of second building section\r\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\r\n    height2 = floor(height2*20.0)*0.05;\t// floor units\r\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\r\n    // size pieces of building\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\r\n    // second building section\r\n    if (rand2.y > 0.25)\r\n    {\r\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\r\n        // subtract off piece from top so it looks like there's a wall around the roof.\r\n        float topWidth = baseRad;\r\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\r\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\r\n    }\r\n    else\r\n    {\r\n        // Cylinder top section of building\r\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\r\n    }\r\n    // mini elevator shaft boxes on top of building\r\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\r\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\r\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\r\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\r\n    float big = sign(boxPos.x);\r\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\r\n\td = min(d, sdBox(boxPos,\r\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\r\n\r\n    // Put domes on some building tops for variety\r\n    if (rand.y < 0.04)\r\n    {\r\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\r\n    }\r\n\r\n    //d = max(d, p.y);  // flatten the city for debugging cars\r\n\r\n    // Need to make a material variable.\r\n    vec2 distAndMat = vec2(d, 0.0);\r\n    // sidewalk box with material\r\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This is the distance function that defines all the scene's geometry.\r\n// The input is a position in space.\r\n// The output is the distance to the nearest surface and a material index.\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills\r\n    vec3 rep = p;\r\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\r\n    vec2 distAndMat = CityBlock(rep, floor(p.xz));\r\n\r\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\r\n    // only want to do a single call to the car distance function for all the\r\n    // cars in the scene. And there's a lot of traffic!\r\n    vec3 p2 = p;\r\n    rep.xyz = p2;\r\n    float carTime = localTime*0.2;  // Speed of car driving\r\n    float crossStreet = 1.0;  // whether we are north/south or east/west\r\n    float repeatDist = 0.25;  // Car density bumper to bumper\r\n    // If we are going north/south instead of east/west (?) make cars that are\r\n    // stopped in the street so we don't have collisions.\r\n    if (abs(fract(rep.x)-0.5) < 0.35)\r\n    {\r\n        p2.x += 0.05;\r\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\r\n        rep.xz = p2.xz;\r\n        crossStreet = 0.0;\r\n        repeatDist = 0.1;  // Denser traffic on cross streets\r\n    }\r\n    \r\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\r\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\r\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\r\n    rep.x = (rep.x*sign(rep.x))-0.09;\r\n    rep.z -= carTime * crossStreet;\t// make cars move\r\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\r\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\r\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\r\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\r\n    frontBack *= sin(localTime*2.0 + uniqueID);\r\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\r\n    vec2 carDist = Car(rep, uniqueID); // car distance function\r\n\r\n    // Drop the cars in the scene with materials\r\n    distAndMat = matmin(distAndMat, carDist);\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This basically makes a procedural texture map for the sides of the buildings.\r\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\r\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\r\n{\r\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\r\n    texColor += hue*0.4;\r\n    texColor *= 0.75;\r\n    float window = 0.0;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\r\n    if (pos.y < 0.05) window = 1.0;\r\n    float winWidth = Hash21(block*4.321)*2.0;\r\n    if ((winWidth < 1.3) && (winWidth >= 1.0)) winWidth = 1.3;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\r\n    if (window < 0.5)\r\n    {\r\n        windowRef += 1.0;\r\n    }\r\n    window *= Hash21(block*1.123);\r\n    texColor *= window;\r\n\r\n    float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\r\n    normal.y -= max(-1.0, min(1.0, -wave*0.5));\r\n    float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\r\n    normal.z += pits*0.25;\r\n    pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\r\n    normal.x += pits*0.25;\r\n}\r\n\r\n// Input is UV coordinate of pixel to render.\r\n// Output is RGB color.\r\nvec3 RayTrace(in vec2 fragCoord )\r\n{\r\n    marchCount = 0.0;\r\n\t// -------------------------------- animate ---------------------------------------\r\n    sunCol = vec3(258.0, 248.0, 200.0) / 3555.0;\r\n\tsunDir = normalize(vec3(0.93, 1.0, 1.0));\r\n    horizonCol = vec3(1.0, 0.95, 0.85)*0.9;\r\n    skyCol = vec3(0.3,0.5,0.95);\r\n    exposure = 1.0;\r\n    fade = 1.0;\r\n\r\n\tvec3 camPos, camUp, camLookat;\r\n\t// ------------------- Set up the camera rays for ray marching --------------------\r\n    // Map uv to [-1.0..1.0]\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n    uv /= 2.0;  // zoom in\r\n\r\n#ifdef MANUAL_CAMERA\r\n    // Camera up vector.\r\n\tcamUp=vec3(0,1,0);\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\r\n\r\n    // debugging camera\r\n    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\r\n\tfloat my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\r\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.35;//7.35\r\n#else\r\n    // Do the camera fly-by animation and different scenes.\r\n    // Time variables for start and end of each scene\r\n    const float t0 = 0.0;\r\n    const float t1 = 8.0;\r\n    const float t2 = 14.0;\r\n    const float t3 = 24.0;\r\n    const float t4 = 38.0;\r\n    const float t5 = 56.0;\r\n    const float t6 = 58.0;\r\n    /*const float t0 = 0.0;\r\n    const float t1 = 0.0;\r\n    const float t2 = 0.0;\r\n    const float t3 = 0.0;\r\n    const float t4 = 0.0;\r\n    const float t5 = 16.0;\r\n    const float t6 = 18.0;*/\r\n    // Repeat the animation after time t6\r\n    localTime = fract(localTime / t6) * t6;\r\n    if (localTime < t1)\r\n    {\r\n        float time = localTime - t0;\r\n        float alpha = time / (t1 - t0);\r\n        fade = saturate(time);\r\n        fade *= saturate(t1 - localTime);\r\n        camPos = vec3(13.0, 3.3, -3.5);\r\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0,1.5,1.5);\r\n    } else if (localTime < t2)\r\n    {\r\n        float time = localTime - t1;\r\n        float alpha = time / (t2 - t1);\r\n        fade = saturate(time);\r\n        fade *= saturate(t2 - localTime);\r\n        camPos = vec3(26.0, 0.05+smoothstep(0.0, 1.0, alpha)*0.4, 2.0);\r\n        camPos.z -= alpha * 2.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(camPos.x-0.3,-8.15,-40.0);\r\n        \r\n        sunDir = normalize(vec3(0.95, 0.6, 1.0));\r\n        sunCol = vec3(258.0, 248.0, 160.0) / 3555.0;\r\n        exposure *= 0.7;\r\n        skyCol *= 1.5;\r\n    } else if (localTime < t3)\r\n    {\r\n        float time = localTime - t2;\r\n        float alpha = time / (t3 - t2);\r\n        fade = saturate(time);\r\n        fade *= saturate(t3 - localTime);\r\n        camPos = vec3(12.0, 6.3, -0.5);\r\n        camPos.y -= alpha * 5.5;\r\n        camPos.x = cos(alpha*1.0) * 5.2;\r\n        camPos.z = sin(alpha*1.0) * 5.2;\r\n        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));\r\n        camLookat=vec3(0,1.0,-0.5);\r\n    } else if (localTime < t4)\r\n    {\r\n        float time = localTime - t3;\r\n        float alpha = time / (t4 - t3);\r\n        fade = saturate(time);\r\n        fade *= saturate(t4 - localTime);\r\n        camPos = vec3(2.15-alpha*0.5, 0.02, -1.0-alpha*0.2);\r\n        camPos.y += smoothstep(0.0,1.0,alpha*alpha) * 3.4;\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(0,0.5+alpha,alpha*5.0);\r\n    } else if (localTime < t5)\r\n    {\r\n        float time = localTime - t4;\r\n        float alpha = time / (t5 - t4);\r\n        fade = saturate(time);\r\n        fade *= saturate(t5 - localTime);\r\n        camPos = vec3(-2.0, 1.3- alpha*1.2, -10.5-alpha*0.5);\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(-2.0,0.3+alpha,-0.0);\r\n        sunDir = normalize(vec3(0.5-alpha*0.6, 0.3-alpha*0.3, 1.0));\r\n        sunCol = vec3(258.0, 148.0, 60.0) / 3555.0;\r\n        localTime *= 16.0;\r\n        exposure *= 0.4;\r\n        horizonCol = vec3(1.0, 0.5, 0.35)*2.0;\r\n        skyCol = vec3(0.75,0.5,0.95);\r\n\r\n    } else if (localTime < t6)\r\n    {\r\n        fade = 0.0;\r\n        camPos = vec3(26.0, 100.0, 2.0);\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0.3,0.15,0.0);\r\n    }\r\n#endif\r\n\r\n\t// Camera setup for ray tracing / marching\r\n\tvec3 camVec=normalize(camLookat - camPos);\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\r\n\tvec3 upNorm=cross(camVec, sideNorm);\r\n\tvec3 worldFacing=(camPos + camVec);\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\r\n\tvec3 rayVec = normalize(worldPix - camPos);\r\n\r\n\t// ----------------------------- Ray march the scene ------------------------------\r\n\tvec2 distAndMat;  // Distance and material\r\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\r\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\r\n\tvec3 pos = vec3(0.0);\r\n    const float smallVal = 0.000625;\r\n\t// ray marching time\r\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\r\n    {\r\n        marchCount+=1.0;\r\n        // Step along the ray.\r\n        pos = (camPos + rayVec * t);\r\n        // This is _the_ function that defines the \"distance field\".\r\n        // It's really what makes the scene geometry. The idea is that the\r\n        // distance field returns the distance to the closest object, and then\r\n        // we know we are safe to \"march\" along the ray by that much distance\r\n        // without hitting anything. We repeat this until we get really close\r\n        // and then break because we have effectively hit the object.\r\n        distAndMat = DistanceToObject(pos);\r\n\r\n        // 2d voxel walk through the city blocks.\r\n        // The distance function is not continuous at city block boundaries,\r\n        // so we have to pause our ray march at each voxel boundary.\r\n        float walk = distAndMat.x;\r\n        float dx = -fract(pos.x);\r\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\r\n        float dz = -fract(pos.z);\r\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\r\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\r\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\r\n        walk = min(walk, nearestVoxel);\r\n\r\n        // move down the ray a safe amount\r\n        t += walk;\r\n        // If we are very close to the object, let's call it a hit and exit this loop.\r\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\r\n    }\r\n\r\n    // Ray trace a ground plane to infinity\r\n    float alpha = -camPos.y / rayVec.y;\r\n    if ((t > maxDepth) && (rayVec.y < -0.0))\r\n    {\r\n        pos.xz = camPos.xz + rayVec.xz * alpha;\r\n        pos.y = -0.0;\r\n        t = alpha;\r\n        distAndMat.y = 0.0;\r\n        distAndMat.x = 0.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n    if ((t <= maxDepth) || (t == alpha))\r\n\t{\r\n        float dist = distAndMat.x;\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(smallVal, 0, 0);\r\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\r\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(rayVec, normal);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.01;\r\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\r\n\t\tfor (int i = 0; i < 40; i++)\r\n        {\r\n            vec3 shadowPos = nudgePos + sunDir * iter;\r\n            float tempDist = DistanceToObject(shadowPos).x;\r\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\r\n            if (tempDist <= 0.0) break;\r\n\r\n            float walk = tempDist;\r\n            float dx = -fract(shadowPos.x);\r\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\r\n            float dz = -fract(shadowPos.z);\r\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\r\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\r\n            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n            walk = min(walk, nearestVoxel);\r\n\r\n            iter += max(0.01, walk);\r\n            if (iter > 4.5) break;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // make a few frequencies of noise to give it some texture\r\n        float n =0.0;\r\n        n += noise(pos*32.0);\r\n        n += noise(pos*64.0);\r\n        n += noise(pos*128.0);\r\n        n += noise(pos*256.0);\r\n        n += noise(pos*512.0);\r\n        n = mix(0.7, 0.95, n);\r\n\r\n        // ------ Calculate texture color  ------\r\n        vec2 block = floor(pos.xz);\r\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\r\n        texColor *= 0.8;\r\n        float windowRef = 0.0;\r\n        // texture map the sides of buildings\r\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\r\n        {\r\n            vec3 posdx = dFdx(pos);\r\n            vec3 posdy = dFdy(pos);\r\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\r\n\r\n            // Quincunx antialias the building texture and normal map.\r\n            // I guess procedural textures are hard to mipmap.\r\n            vec3 colTotal = vec3(0.0);\r\n            vec3 colTemp = texColor;\r\n            vec3 nTemp = vec3(0.0);\r\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\r\n            colTotal = colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            texColor = colTotal * 0.2;\r\n            windowRef *= 0.2;\r\n\r\n            normal = normalize(normal + nTemp * 0.2);\r\n        }\r\n        else\r\n        {\r\n            // Draw the road\r\n            float xroad = abs(fract(pos.x+0.5)-0.5);\r\n            float zroad = abs(fract(pos.z+0.5)-0.5);\r\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\r\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\r\n            texColor *= mix(0.1, 1.0, road);\r\n\r\n            // double yellow line in middle of road\r\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\r\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\r\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\r\n\r\n            // white dashed lines on road\r\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\r\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            // crosswalk\r\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((zroad-0.15)*880.0);\r\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((xroad-0.15)*880.0);\r\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n\r\n            {\r\n                // sidewalk cracks\r\n                float sidewalk = 1.0;\r\n                vec2 blockSize = vec2(100.0);\r\n                if (pos.y > 0.1) blockSize = vec2(10.0, 50);\r\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\r\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\r\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\r\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\r\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\r\n                sidewalk = saturate((1.0-road) + sidewalk);\r\n                texColor *= sidewalk;\r\n            }\r\n        }\r\n        // Car tires are almost black to not call attention to their ugly.\r\n        if (distAndMat.y == 3.0)\r\n        {\r\n            texColor = vec3(0.05);\r\n        }\r\n\r\n        // apply noise\r\n        texColor *= vec3(1.0)*n*0.05;\r\n        texColor *= 0.7;\r\n        texColor = saturate(texColor);\r\n\r\n        float windowMask = 0.0;\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            // car texture and windows\r\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\r\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\r\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\r\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\r\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\r\n            windowMask = saturate( max(0.0, abs(pos.y - 0.0175)*3800.0)-10.0);\r\n            vec2 dirNorm = abs(normalize(normal.xz));\r\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\r\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\r\n            windowMask = max(windowMask, pillars);\r\n            texColor *= windowMask;\r\n        }\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = vec3(100.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\r\n        // weighted average the near ambient occlusion with the far for just the right look\r\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\r\n        // Add sky color with ambient acclusion\r\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*2.5;\r\n        lightColor *= 4.0;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n        // Reflections for cars\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\r\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*0.3*yfade*max(0.4,sunShadow);\r\n            finalColor += saturate(texture(iChannel0, ref.xy).xyz-0.35)*0.15*max(0.2,sunShadow);\r\n        }\r\n        // reflections for building windows\r\n        if (windowRef != 0.0)\r\n        {\r\n            finalColor *= mix(1.0, 0.6, windowRef);\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.5)*0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\r\n            finalColor += saturate(texture(iChannel0, ref.xy).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n        }\r\n        finalColor *= 0.9;\r\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\r\n        vec3 rv2 = rayVec;\r\n        rv2.y *= saturate(sign(rv2.y));\r\n        vec3 fogColor = GetEnvMap(rv2, sunDir);\r\n        fogColor = min(vec3(9.0), fogColor);\r\n        finalColor = mix(fogColor, finalColor, exp(-t*0.02));\r\n\r\n        // visualize length of gradient of distance field to check distance field correctness\r\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\r\n        //finalColor = vec3(marchCount)/255.0;\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        finalColor = GetEnvMap(rayVec, sunDir);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.3*exposure;\r\n\r\n\t// output the final color without gamma correction - will do gamma later.\r\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.2));\r\n}\r\n\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n// This function breaks the image down into blocks and scans\r\n// through them, rendering 1 block at a time. It's for non-\r\n// realtime things that take a long time to render.\r\n\r\n// This is the frame rate to render at. Too fast and you will\r\n// miss some blocks.\r\nconst float blockRate = 20.0;\r\nvoid BlockRender(in vec2 fragCoord)\r\n{\r\n    // blockSize is how much it will try to render in 1 frame.\r\n    // adjust this smaller for more complex scenes, bigger for\r\n    // faster render times.\r\n    const float blockSize = 64.0;\r\n    // Make the block repeatedly scan across the image based on time.\r\n    float frame = floor(iTime * blockRate);\r\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\r\n    // ugly bug with mod.\r\n    //float blockX = mod(frame, blockRes.x);\r\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\r\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\r\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\r\n    // Don't draw anything outside the current block.\r\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\r\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\r\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\r\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\r\n    {\r\n        discard;\r\n    }\r\n}\r\n#endif\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    // Optionally render a non-realtime scene with high quality\r\n    BlockRender(fragCoord);\r\n#endif\r\n\r\n    // Do a multi-pass render\r\n    vec3 finalColor = vec3(0.0);\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    for (float i = 0.0; i < antialiasingSamples; i++)\r\n    {\r\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\r\n        // Set this to the time in seconds of the frame to render.\r\n\t    localTime = frameToRenderHQ;\r\n        // This line will motion-blur the renders\r\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\r\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\r\n        vec2 jittered = fragCoord.xy + vec2(\r\n            Hash21(fragCoord + seed),\r\n            Hash21(fragCoord*7.234567 + seed)\r\n            );\r\n        // don't antialias if only 1 sample.\r\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\r\n        // Accumulate one pass of raytracing into our pixel value\r\n\t    finalColor += RayTrace(jittered);\r\n        // Change the random seed for each pass.\r\n\t    seed *= 1.01234567;\r\n    }\r\n    // Average all accumulated pixel intensities\r\n    finalColor /= antialiasingSamples;\r\n#else\r\n    // Regular real-time rendering\r\n    localTime = iTime;\r\n    finalColor = RayTrace(fragCoord);\r\n#endif\r\n\r\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// ---------------- Config ----------------\r\n// This is an option that lets you render high quality frames for screenshots. It enables\r\n// stochastic antialiasing and motion blur automatically for any shader.\r\n//#define NON_REALTIME_HQ_RENDER\r\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\r\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\r\n\r\n//#define MANUAL_CAMERA\r\n\r\n\r\n// --------------------------------------------------------\r\n// These variables are for the non-realtime block renderer.\r\nfloat localTime = 0.0;\r\nfloat seed = 1.0;\r\n\r\n// Animation variables\r\nfloat fade = 1.0;\r\nvec3 sunDir;\r\nvec3 sunCol;\r\nfloat exposure = 1.0;\r\nvec3 skyCol, horizonCol;\r\n\r\n// other\r\nfloat marchCount = 0.0;\r\n\r\n// ---- noise functions ----\r\nfloat v31(vec3 a)\r\n{\r\n    return a.x + a.y * 37.0 + a.z * 521.0;\r\n}\r\nfloat v21(vec2 a)\r\n{\r\n    return a.x + a.y * 37.0;\r\n}\r\nfloat Hash11(float a)\r\n{\r\n    return fract(sin(a)*10403.9);\r\n}\r\nfloat Hash21(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nvec2 Hash22(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nvec2 Hash12(float f)\r\n{\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nfloat Hash1d(float u)\r\n{\r\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nconst float PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*150.0)*7000.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\r\n{\r\n    // fade the sky color, multiply sunset dimming\r\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\r\n    // make clouds - just a horizontal plane with noise\r\n    float n = noise2d(rayDir.xz/rayDir.y*1.0);\r\n    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\r\n    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\r\n    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\r\n    n = pow(abs(n), 3.0);\r\n    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance\r\n    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));\r\n\r\n    // add the sun\r\n    finalColor += GetSunColorSmall(rayDir, sunDir);\r\n    return finalColor;\r\n}\r\n\r\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)\r\n{\r\n    vec3 finalColor = GetEnvMap(rayDir, sunDir);\r\n\r\n    // Make a skyscraper skyline reflection.\r\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\r\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\r\n    radial *= 4.0;\r\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\r\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\r\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\r\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\r\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\r\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\r\n\r\n\treturn finalColor;\r\n}\r\n\r\n// min function that supports materials in the y component\r\nvec2 matmin(vec2 a, vec2 b)\r\n{\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n}\r\n\r\n// ---- shapes defined by distance fields ----\r\n// See this site for a reference to more distance functions...\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n\r\n// signed box distance field\r\nfloat sdBox(vec3 p, vec3 radius)\r\n{\r\n  vec3 dist = abs(p) - radius;\r\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\r\n}\r\n\r\n// capped cylinder distance field\r\nfloat cylCap(vec3 p, float r, float lenRad)\r\n{\r\n    float a = length(p.xy) - r;\r\n    a = max(a, abs(p.z) - lenRad);\r\n    return a;\r\n}\r\n\r\n// k should be negative. -4.0 works nicely.\r\n// smooth blending function\r\nfloat smin(float a, float b, float k)\r\n{\r\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\r\n}\r\n\r\nfloat Repeat(float a, float len)\r\n{\r\n    return mod(a, len) - 0.5 * len;\r\n}\r\n\r\n// Distance function that defines the car.\r\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\r\nvec2 Car(vec3 baseCenter, float unique)\r\n{\r\n    // bottom box\r\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.001), vec3(0.01, 0.00225, 0.0275));\r\n    // top box smooth blended\r\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.008), vec3(0.005, 0.0005, 0.01)), -160.0);\r\n    // mirror the z axis to duplicate the cylinders for wheels\r\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.0);\r\n    wMirror.z = abs(wMirror.z)-0.02;\r\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\r\n    // Set materials\r\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\r\n    // Car material is some big number that's unique to each car\r\n    // so I can have each car be a different color\r\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\r\n    return distAndMat;\r\n}\r\n\r\n// How much space between voxel borders and geometry for voxel ray march optimization\r\nfloat voxelPad = 0.2;\r\n// p should be in [0..1] range on xz plane\r\n// pint is an integer pair saying which city block you are on\r\nvec2 CityBlock(vec3 p, vec2 pint)\r\n{\r\n    // Get random numbers for this block by hashing the city block variable\r\n    vec4 rand;\r\n    rand.xy = Hash22(pint);\r\n    rand.zw = Hash22(rand.xy);\r\n    vec2 rand2 = Hash22(rand.zw);\r\n\r\n    // Radius of the building\r\n    float baseRad = 0.2 + (rand.x) * 0.1;\r\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\r\n\r\n    // make position relative to the middle of the block\r\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\r\n    float height = rand.w*rand.z + 0.1; // height of first building block\r\n    // Make the city skyline higher in the middle of the city.\r\n    float downtown = saturate(4.0 / length(pint.xy));\r\n    height *= downtown;\r\n    height *= 1.5+(baseRad-0.15)*20.0;\r\n    height += 0.1;\t// minimum building height\r\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\r\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\r\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\r\n\r\n    // road\r\n    d = min(d, p.y);\r\n\r\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\r\n\r\n    // height of second building section\r\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\r\n    height2 = floor(height2*20.0)*0.05;\t// floor units\r\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\r\n    // size pieces of building\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\r\n    // second building section\r\n    if (rand2.y > 0.25)\r\n    {\r\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\r\n        // subtract off piece from top so it looks like there's a wall around the roof.\r\n        float topWidth = baseRad;\r\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\r\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\r\n    }\r\n    else\r\n    {\r\n        // Cylinder top section of building\r\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\r\n    }\r\n    // mini elevator shaft boxes on top of building\r\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\r\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\r\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\r\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\r\n    float big = sign(boxPos.x);\r\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\r\n\td = min(d, sdBox(boxPos,\r\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\r\n\r\n    // Put domes on some building tops for variety\r\n    if (rand.y < 0.04)\r\n    {\r\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\r\n    }\r\n\r\n    //d = max(d, p.y);  // flatten the city for debugging cars\r\n\r\n    // Need to make a material variable.\r\n    vec2 distAndMat = vec2(d, 0.0);\r\n    // sidewalk box with material\r\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This is the distance function that defines all the scene's geometry.\r\n// The input is a position in space.\r\n// The output is the distance to the nearest surface and a material index.\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills\r\n    vec3 rep = p;\r\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\r\n    vec2 distAndMat = CityBlock(rep, floor(p.xz));\r\n\r\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\r\n    // only want to do a single call to the car distance function for all the\r\n    // cars in the scene. And there's a lot of traffic!\r\n    vec3 p2 = p;\r\n    rep.xyz = p2;\r\n    float carTime = localTime*0.2;  // Speed of car driving\r\n    float crossStreet = 1.0;  // whether we are north/south or east/west\r\n    float repeatDist = 0.25;  // Car density bumper to bumper\r\n    // If we are going north/south instead of east/west (?) make cars that are\r\n    // stopped in the street so we don't have collisions.\r\n    if (abs(fract(rep.x)-0.5) < 0.35)\r\n    {\r\n        p2.x += 0.05;\r\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\r\n        rep.xz = p2.xz;\r\n        crossStreet = 0.0;\r\n        repeatDist = 0.1;  // Denser traffic on cross streets\r\n    }\r\n    \r\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\r\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\r\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\r\n    rep.x = (rep.x*sign(rep.x))-0.09;\r\n    rep.z -= carTime * crossStreet;\t// make cars move\r\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\r\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\r\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\r\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\r\n    frontBack *= sin(localTime*2.0 + uniqueID);\r\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\r\n    vec2 carDist = Car(rep, uniqueID); // car distance function\r\n\r\n    // Drop the cars in the scene with materials\r\n    distAndMat = matmin(distAndMat, carDist);\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This basically makes a procedural texture map for the sides of the buildings.\r\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\r\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\r\n{\r\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\r\n    texColor += hue*0.4;\r\n    texColor *= 0.75;\r\n    float window = 0.0;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\r\n    if (pos.y < 0.05) window = 1.0;\r\n    float winWidth = Hash21(block*4.321)*2.0;\r\n    if ((winWidth < 1.3) && (winWidth >= 1.0)) winWidth = 1.3;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\r\n    if (window < 0.5)\r\n    {\r\n        windowRef += 1.0;\r\n    }\r\n    window *= Hash21(block*1.123);\r\n    texColor *= window;\r\n\r\n    float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\r\n    normal.y -= max(-1.0, min(1.0, -wave*0.5));\r\n    float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\r\n    normal.z += pits*0.25;\r\n    pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\r\n    normal.x += pits*0.25;\r\n}\r\n\r\n// Input is UV coordinate of pixel to render.\r\n// Output is RGB color.\r\nvec3 RayTrace(in vec2 fragCoord )\r\n{\r\n    marchCount = 0.0;\r\n\t// -------------------------------- animate ---------------------------------------\r\n    sunCol = vec3(258.0, 248.0, 200.0) / 3555.0;\r\n\tsunDir = normalize(vec3(0.93, 1.0, 1.0));\r\n    horizonCol = vec3(1.0, 0.95, 0.85)*0.9;\r\n    skyCol = vec3(0.3,0.5,0.95);\r\n    exposure = 1.0;\r\n    fade = 1.0;\r\n\r\n\tvec3 camPos, camUp, camLookat;\r\n\t// ------------------- Set up the camera rays for ray marching --------------------\r\n    // Map uv to [-1.0..1.0]\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n    uv /= 2.0;  // zoom in\r\n\r\n#ifdef MANUAL_CAMERA\r\n    // Camera up vector.\r\n\tcamUp=vec3(0,1,0);\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\r\n\r\n    // debugging camera\r\n    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\r\n\tfloat my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\r\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.35;//7.35\r\n#else\r\n    // Do the camera fly-by animation and different scenes.\r\n    // Time variables for start and end of each scene\r\n    const float t0 = 0.0;\r\n    const float t1 = 8.0;\r\n    const float t2 = 14.0;\r\n    const float t3 = 24.0;\r\n    const float t4 = 38.0;\r\n    const float t5 = 56.0;\r\n    const float t6 = 58.0;\r\n    /*const float t0 = 0.0;\r\n    const float t1 = 0.0;\r\n    const float t2 = 0.0;\r\n    const float t3 = 0.0;\r\n    const float t4 = 0.0;\r\n    const float t5 = 16.0;\r\n    const float t6 = 18.0;*/\r\n    // Repeat the animation after time t6\r\n    localTime = fract(localTime / t6) * t6;\r\n    if (localTime < t1)\r\n    {\r\n        float time = localTime - t0;\r\n        float alpha = time / (t1 - t0);\r\n        fade = saturate(time);\r\n        fade *= saturate(t1 - localTime);\r\n        camPos = vec3(13.0, 3.3, -3.5);\r\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0,1.5,1.5);\r\n    } else if (localTime < t2)\r\n    {\r\n        float time = localTime - t1;\r\n        float alpha = time / (t2 - t1);\r\n        fade = saturate(time);\r\n        fade *= saturate(t2 - localTime);\r\n        camPos = vec3(26.0, 0.05+smoothstep(0.0, 1.0, alpha)*0.4, 2.0);\r\n        camPos.z -= alpha * 2.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(camPos.x-0.3,-8.15,-40.0);\r\n        \r\n        sunDir = normalize(vec3(0.95, 0.6, 1.0));\r\n        sunCol = vec3(258.0, 248.0, 160.0) / 3555.0;\r\n        exposure *= 0.7;\r\n        skyCol *= 1.5;\r\n    } else if (localTime < t3)\r\n    {\r\n        float time = localTime - t2;\r\n        float alpha = time / (t3 - t2);\r\n        fade = saturate(time);\r\n        fade *= saturate(t3 - localTime);\r\n        camPos = vec3(12.0, 6.3, -0.5);\r\n        camPos.y -= alpha * 5.5;\r\n        camPos.x = cos(alpha*1.0) * 5.2;\r\n        camPos.z = sin(alpha*1.0) * 5.2;\r\n        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));\r\n        camLookat=vec3(0,1.0,-0.5);\r\n    } else if (localTime < t4)\r\n    {\r\n        float time = localTime - t3;\r\n        float alpha = time / (t4 - t3);\r\n        fade = saturate(time);\r\n        fade *= saturate(t4 - localTime);\r\n        camPos = vec3(2.15-alpha*0.5, 0.02, -1.0-alpha*0.2);\r\n        camPos.y += smoothstep(0.0,1.0,alpha*alpha) * 3.4;\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(0,0.5+alpha,alpha*5.0);\r\n    } else if (localTime < t5)\r\n    {\r\n        float time = localTime - t4;\r\n        float alpha = time / (t5 - t4);\r\n        fade = saturate(time);\r\n        fade *= saturate(t5 - localTime);\r\n        camPos = vec3(-2.0, 1.3- alpha*1.2, -10.5-alpha*0.5);\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(-2.0,0.3+alpha,-0.0);\r\n        sunDir = normalize(vec3(0.5-alpha*0.6, 0.3-alpha*0.3, 1.0));\r\n        sunCol = vec3(258.0, 148.0, 60.0) / 3555.0;\r\n        localTime *= 16.0;\r\n        exposure *= 0.4;\r\n        horizonCol = vec3(1.0, 0.5, 0.35)*2.0;\r\n        skyCol = vec3(0.75,0.5,0.95);\r\n\r\n    } else if (localTime < t6)\r\n    {\r\n        fade = 0.0;\r\n        camPos = vec3(26.0, 100.0, 2.0);\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0.3,0.15,0.0);\r\n    }\r\n#endif\r\n\r\n\t// Camera setup for ray tracing / marching\r\n\tvec3 camVec=normalize(camLookat - camPos);\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\r\n\tvec3 upNorm=cross(camVec, sideNorm);\r\n\tvec3 worldFacing=(camPos + camVec);\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\r\n\tvec3 rayVec = normalize(worldPix - camPos);\r\n\r\n\t// ----------------------------- Ray march the scene ------------------------------\r\n\tvec2 distAndMat;  // Distance and material\r\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\r\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\r\n\tvec3 pos = vec3(0.0);\r\n    const float smallVal = 0.000625;\r\n\t// ray marching time\r\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\r\n    {\r\n        marchCount+=1.0;\r\n        // Step along the ray.\r\n        pos = (camPos + rayVec * t);\r\n        // This is _the_ function that defines the \"distance field\".\r\n        // It's really what makes the scene geometry. The idea is that the\r\n        // distance field returns the distance to the closest object, and then\r\n        // we know we are safe to \"march\" along the ray by that much distance\r\n        // without hitting anything. We repeat this until we get really close\r\n        // and then break because we have effectively hit the object.\r\n        distAndMat = DistanceToObject(pos);\r\n\r\n        // 2d voxel walk through the city blocks.\r\n        // The distance function is not continuous at city block boundaries,\r\n        // so we have to pause our ray march at each voxel boundary.\r\n        float walk = distAndMat.x;\r\n        float dx = -fract(pos.x);\r\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\r\n        float dz = -fract(pos.z);\r\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\r\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\r\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\r\n        walk = min(walk, nearestVoxel);\r\n\r\n        // move down the ray a safe amount\r\n        t += walk;\r\n        // If we are very close to the object, let's call it a hit and exit this loop.\r\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\r\n    }\r\n\r\n    // Ray trace a ground plane to infinity\r\n    float alpha = -camPos.y / rayVec.y;\r\n    if ((t > maxDepth) && (rayVec.y < -0.0))\r\n    {\r\n        pos.xz = camPos.xz + rayVec.xz * alpha;\r\n        pos.y = -0.0;\r\n        t = alpha;\r\n        distAndMat.y = 0.0;\r\n        distAndMat.x = 0.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n    if ((t <= maxDepth) || (t == alpha))\r\n\t{\r\n        float dist = distAndMat.x;\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(smallVal, 0, 0);\r\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\r\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(rayVec, normal);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.01;\r\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\r\n\t\tfor (int i = 0; i < 40; i++)\r\n        {\r\n            vec3 shadowPos = nudgePos + sunDir * iter;\r\n            float tempDist = DistanceToObject(shadowPos).x;\r\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\r\n            if (tempDist <= 0.0) break;\r\n\r\n            float walk = tempDist;\r\n            float dx = -fract(shadowPos.x);\r\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\r\n            float dz = -fract(shadowPos.z);\r\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\r\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\r\n            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n            walk = min(walk, nearestVoxel);\r\n\r\n            iter += max(0.01, walk);\r\n            if (iter > 4.5) break;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // make a few frequencies of noise to give it some texture\r\n        float n =0.0;\r\n        n += noise(pos*32.0);\r\n        n += noise(pos*64.0);\r\n        n += noise(pos*128.0);\r\n        n += noise(pos*256.0);\r\n        n += noise(pos*512.0);\r\n        n = mix(0.7, 0.95, n);\r\n\r\n        // ------ Calculate texture color  ------\r\n        vec2 block = floor(pos.xz);\r\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\r\n        texColor *= 0.8;\r\n        float windowRef = 0.0;\r\n        // texture map the sides of buildings\r\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\r\n        {\r\n            vec3 posdx = dFdx(pos);\r\n            vec3 posdy = dFdy(pos);\r\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\r\n\r\n            // Quincunx antialias the building texture and normal map.\r\n            // I guess procedural textures are hard to mipmap.\r\n            vec3 colTotal = vec3(0.0);\r\n            vec3 colTemp = texColor;\r\n            vec3 nTemp = vec3(0.0);\r\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\r\n            colTotal = colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            texColor = colTotal * 0.2;\r\n            windowRef *= 0.2;\r\n\r\n            normal = normalize(normal + nTemp * 0.2);\r\n        }\r\n        else\r\n        {\r\n            // Draw the road\r\n            float xroad = abs(fract(pos.x+0.5)-0.5);\r\n            float zroad = abs(fract(pos.z+0.5)-0.5);\r\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\r\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\r\n            texColor *= mix(0.1, 1.0, road);\r\n\r\n            // double yellow line in middle of road\r\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\r\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\r\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\r\n\r\n            // white dashed lines on road\r\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\r\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            // crosswalk\r\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((zroad-0.15)*880.0);\r\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((xroad-0.15)*880.0);\r\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n\r\n            {\r\n                // sidewalk cracks\r\n                float sidewalk = 1.0;\r\n                vec2 blockSize = vec2(100.0);\r\n                if (pos.y > 0.1) blockSize = vec2(10.0, 50);\r\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\r\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\r\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\r\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\r\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\r\n                sidewalk = saturate((1.0-road) + sidewalk);\r\n                texColor *= sidewalk;\r\n            }\r\n        }\r\n        // Car tires are almost black to not call attention to their ugly.\r\n        if (distAndMat.y == 3.0)\r\n        {\r\n            texColor = vec3(0.05);\r\n        }\r\n\r\n        // apply noise\r\n        texColor *= vec3(1.0)*n*0.05;\r\n        texColor *= 0.7;\r\n        texColor = saturate(texColor);\r\n\r\n        float windowMask = 0.0;\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            // car texture and windows\r\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\r\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\r\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\r\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\r\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\r\n            windowMask = saturate( max(0.0, abs(pos.y - 0.0175)*3800.0)-10.0);\r\n            vec2 dirNorm = abs(normalize(normal.xz));\r\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\r\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\r\n            windowMask = max(windowMask, pillars);\r\n            texColor *= windowMask;\r\n        }\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = vec3(100.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\r\n        // weighted average the near ambient occlusion with the far for just the right look\r\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\r\n        // Add sky color with ambient acclusion\r\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*2.5;\r\n        lightColor *= 4.0;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n        // Reflections for cars\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\r\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*0.3*yfade*max(0.4,sunShadow);\r\n            finalColor += saturate(texture(iChannel0, ref.xy).xyz-0.35)*0.15*max(0.2,sunShadow);\r\n        }\r\n        // reflections for building windows\r\n        if (windowRef != 0.0)\r\n        {\r\n            finalColor *= mix(1.0, 0.6, windowRef);\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.5)*0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\r\n            finalColor += saturate(texture(iChannel0, ref.xy).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n        }\r\n        finalColor *= 0.9;\r\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\r\n        vec3 rv2 = rayVec;\r\n        rv2.y *= saturate(sign(rv2.y));\r\n        vec3 fogColor = GetEnvMap(rv2, sunDir);\r\n        fogColor = min(vec3(9.0), fogColor);\r\n        finalColor = mix(fogColor, finalColor, exp(-t*0.02));\r\n\r\n        // visualize length of gradient of distance field to check distance field correctness\r\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\r\n        //finalColor = vec3(marchCount)/255.0;\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        finalColor = GetEnvMap(rayVec, sunDir);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.3*exposure;\r\n\r\n\t// output the final color without gamma correction - will do gamma later.\r\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.2));\r\n}\r\n\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n// This function breaks the image down into blocks and scans\r\n// through them, rendering 1 block at a time. It's for non-\r\n// realtime things that take a long time to render.\r\n\r\n// This is the frame rate to render at. Too fast and you will\r\n// miss some blocks.\r\nconst float blockRate = 20.0;\r\nvoid BlockRender(in vec2 fragCoord)\r\n{\r\n    // blockSize is how much it will try to render in 1 frame.\r\n    // adjust this smaller for more complex scenes, bigger for\r\n    // faster render times.\r\n    const float blockSize = 64.0;\r\n    // Make the block repeatedly scan across the image based on time.\r\n    float frame = floor(iTime * blockRate);\r\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\r\n    // ugly bug with mod.\r\n    //float blockX = mod(frame, blockRes.x);\r\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\r\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\r\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\r\n    // Don't draw anything outside the current block.\r\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\r\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\r\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\r\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\r\n    {\r\n        discard;\r\n    }\r\n}\r\n#endif\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    // Optionally render a non-realtime scene with high quality\r\n    BlockRender(fragCoord);\r\n#endif\r\n\r\n    // Do a multi-pass render\r\n    vec3 finalColor = vec3(0.0);\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    for (float i = 0.0; i < antialiasingSamples; i++)\r\n    {\r\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\r\n        // Set this to the time in seconds of the frame to render.\r\n\t    localTime = frameToRenderHQ;\r\n        // This line will motion-blur the renders\r\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\r\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\r\n        vec2 jittered = fragCoord.xy + vec2(\r\n            Hash21(fragCoord + seed),\r\n            Hash21(fragCoord*7.234567 + seed)\r\n            );\r\n        // don't antialias if only 1 sample.\r\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\r\n        // Accumulate one pass of raytracing into our pixel value\r\n\t    finalColor += RayTrace(jittered);\r\n        // Change the random seed for each pass.\r\n\t    seed *= 1.01234567;\r\n    }\r\n    // Average all accumulated pixel intensities\r\n    finalColor /= antialiasingSamples;\r\n#else\r\n    // Regular real-time rendering\r\n    localTime = iTime;\r\n    finalColor = RayTrace(fragCoord);\r\n#endif\r\n\r\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n        p =.7*abs(p)/dot(p,p) -.7;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = texture(iChannel0, rd.xy).rgb;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += texture(iChannel0, nor.xy).rgb * fre;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n        p =.7*abs(p)/dot(p,p) -.7;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = texture(iChannel0, rd.xy).rgb;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += texture(iChannel0, nor.xy).rgb * fre;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":null,"published":0}],"Info":{"Name":"Playing marble ","id":null,"date":null,"viewed":0,"name":"Playing marble ","description":"3d marble texture ","likes":0,"published":null,"tags":["3d"," fractal"," volumetric"]},"ver":null,"info":{"Name":"Playing marble ","id":null,"date":null,"viewed":0,"name":"Playing marble ","description":"3d marble texture ","likes":0,"published":null,"tags":["3d"," fractal"," volumetric"]},"renderpass":[{"Code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n        p =.7*abs(p)/dot(p,p) -.7;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = texture(iChannel0, rd.xy).rgb;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += texture(iChannel0, nor.xy).rgb * fre;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n        p =.7*abs(p)/dot(p,p) -.7;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = texture(iChannel0, rd.xy).rgb;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += texture(iChannel0, nor.xy).rgb * fre;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Auroras by nimitz 2017 (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n/*\r\n\t\r\n\tThere are two main hurdles I encountered rendering this effect. \r\n\tFirst, the nature of the texture that needs to be generated to get a believable effect\r\n\tneeds to be very specific, with large scale band-like structures, small scale non-smooth variations\r\n\tto create the trail-like effect, a method for animating said texture smoothly and finally doing all\r\n\tof this cheaply enough to be able to evaluate it several times per fragment/pixel.\r\n\r\n\tThe second obstacle is the need to render a large volume while keeping the computational cost low.\r\n\tSince the effect requires the trails to extend way up in the atmosphere to look good, this means\r\n\tthat the evaluated volume cannot be as constrained as with cloud effects. My solution was to make\r\n\tthe sample stride increase polynomially, which works very well as long as the trails are lower opcaity than\r\n\tthe rest of the effect. Which is always the case for auroras.\r\n\r\n\tAfter that, there were some issues with getting the correct emission curves and removing banding at lowered\r\n\tsample densities, this was fixed by a combination of sample number influenced dithering and slight sample blending.\r\n\r\n\tN.B. the base setup is from an old shader and ideally the effect would take an arbitrary ray origin and\r\n\tdirection. But this was not required for this demo and would be trivial to fix.\r\n*/\r\n\r\n#define time iTime\r\n\r\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\r\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\r\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\r\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\r\n\r\nfloat triNoise2d(in vec2 p, float spd)\r\n{\r\n    float z=1.8;\r\n    float z2=2.5;\r\n\tfloat rz = 0.;\r\n    p *= mm2(p.x*0.06);\r\n    vec2 bp = p;\r\n\tfor (float i=0.; i<5.; i++ )\r\n\t{\r\n        vec2 dg = tri2(bp*1.85)*.75;\r\n        dg *= mm2(time*spd);\r\n        p -= dg/z2;\r\n\r\n        bp *= 1.3;\r\n        z2 *= .45;\r\n        z *= .42;\r\n\t\tp *= 1.21 + (rz-1.0)*.02;\r\n        \r\n        rz += tri(p.x+tri(p.y))*z;\r\n        p*= -m2;\r\n\t}\r\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\r\n}\r\n\r\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\r\nvec4 aurora(vec3 ro, vec3 rd)\r\n{\r\n    vec4 col = vec4(0);\r\n    vec4 avgCol = vec4(0);\r\n    \r\n    for(float i=0.;i<50.;i++)\r\n    {\r\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\r\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\r\n        pt -= of;\r\n    \tvec3 bpos = ro + pt*rd;\r\n        vec2 p = bpos.zx;\r\n        float rzt = triNoise2d(p, 0.06);\r\n        vec4 col2 = vec4(0,0,0, rzt);\r\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\r\n        avgCol =  mix(avgCol, col2, .5);\r\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\r\n        \r\n    }\r\n    \r\n    col *= (clamp(rd.y*15.+.4,0.,1.));\r\n    \r\n    \r\n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\r\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\r\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\r\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\r\n    \r\n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\r\n    return col*1.8;\r\n    //return pow(col,vec4(1.))*2.\r\n}\r\n\r\n\r\n//-------------------Background and Stars--------------------\r\n\r\nvec3 nmzHash33(vec3 q)\r\n{\r\n    uvec3 p = uvec3(ivec3(q));\r\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\r\n    p = p.yzx*(p.zxy^(p >> 3U));\r\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\r\n}\r\n\r\nvec3 stars(in vec3 p)\r\n{\r\n    vec3 c = vec3(0.);\r\n    float res = iResolution.x*1.;\r\n    \r\n\tfor (float i=0.;i<4.;i++)\r\n    {\r\n        vec3 q = fract(p*(.15*res))-0.5;\r\n        vec3 id = floor(p*(.15*res));\r\n        vec2 rn = nmzHash33(id).xy;\r\n        float c2 = 1.-smoothstep(0.,.6,length(q));\r\n        c2 *= step(rn.x,.0005+i*i*0.001);\r\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\r\n        p *= 1.3;\r\n    }\r\n    return c*c*.8;\r\n}\r\n\r\nvec3 bg(in vec3 rd)\r\n{\r\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\r\n    sd = pow(sd, 5.);\r\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\r\n    return col*.63;\r\n}\r\n//-----------------------------------------------------------\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = q - 0.5;\r\n\tp.x*=iResolution.x/iResolution.y;\r\n    \r\n    vec3 ro = vec3(0,0,-6.7);\r\n    vec3 rd = normalize(vec3(p,1.3));\r\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\r\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\r\n\tmo.x *= iResolution.x/iResolution.y;\r\n    rd.yz *= mm2(mo.y);\r\n    rd.xz *= mm2(mo.x + sin(time*0.05)*0.2);\r\n    \r\n    vec3 col = vec3(0.);\r\n    vec3 brd = rd;\r\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\r\n    \r\n    col = bg(rd)*fade;\r\n    \r\n    if (rd.y > 0.){\r\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\r\n        col += stars(rd);\r\n        col = col*(1.-aur.a) + aur.rgb;\r\n    }\r\n    else //Reflections\r\n    {\r\n        rd.y = abs(rd.y);\r\n        col = bg(rd)*fade*0.6;\r\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\r\n        col += stars(rd)*0.1;\r\n        col = col*(1.-aur.a) + aur.rgb;\r\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\r\n        float nz2 = triNoise2d(pos.xz*vec2(.5,.7), 0.);\r\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\r\n    }\r\n    \r\n\tfragColor = vec4(col, 1.);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Auroras by nimitz 2017 (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n/*\r\n\t\r\n\tThere are two main hurdles I encountered rendering this effect. \r\n\tFirst, the nature of the texture that needs to be generated to get a believable effect\r\n\tneeds to be very specific, with large scale band-like structures, small scale non-smooth variations\r\n\tto create the trail-like effect, a method for animating said texture smoothly and finally doing all\r\n\tof this cheaply enough to be able to evaluate it several times per fragment/pixel.\r\n\r\n\tThe second obstacle is the need to render a large volume while keeping the computational cost low.\r\n\tSince the effect requires the trails to extend way up in the atmosphere to look good, this means\r\n\tthat the evaluated volume cannot be as constrained as with cloud effects. My solution was to make\r\n\tthe sample stride increase polynomially, which works very well as long as the trails are lower opcaity than\r\n\tthe rest of the effect. Which is always the case for auroras.\r\n\r\n\tAfter that, there were some issues with getting the correct emission curves and removing banding at lowered\r\n\tsample densities, this was fixed by a combination of sample number influenced dithering and slight sample blending.\r\n\r\n\tN.B. the base setup is from an old shader and ideally the effect would take an arbitrary ray origin and\r\n\tdirection. But this was not required for this demo and would be trivial to fix.\r\n*/\r\n\r\n#define time iTime\r\n\r\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\r\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\r\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\r\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\r\n\r\nfloat triNoise2d(in vec2 p, float spd)\r\n{\r\n    float z=1.8;\r\n    float z2=2.5;\r\n\tfloat rz = 0.;\r\n    p *= mm2(p.x*0.06);\r\n    vec2 bp = p;\r\n\tfor (float i=0.; i<5.; i++ )\r\n\t{\r\n        vec2 dg = tri2(bp*1.85)*.75;\r\n        dg *= mm2(time*spd);\r\n        p -= dg/z2;\r\n\r\n        bp *= 1.3;\r\n        z2 *= .45;\r\n        z *= .42;\r\n\t\tp *= 1.21 + (rz-1.0)*.02;\r\n        \r\n        rz += tri(p.x+tri(p.y))*z;\r\n        p*= -m2;\r\n\t}\r\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\r\n}\r\n\r\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\r\nvec4 aurora(vec3 ro, vec3 rd)\r\n{\r\n    vec4 col = vec4(0);\r\n    vec4 avgCol = vec4(0);\r\n    \r\n    for(float i=0.;i<50.;i++)\r\n    {\r\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\r\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\r\n        pt -= of;\r\n    \tvec3 bpos = ro + pt*rd;\r\n        vec2 p = bpos.zx;\r\n        float rzt = triNoise2d(p, 0.06);\r\n        vec4 col2 = vec4(0,0,0, rzt);\r\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\r\n        avgCol =  mix(avgCol, col2, .5);\r\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\r\n        \r\n    }\r\n    \r\n    col *= (clamp(rd.y*15.+.4,0.,1.));\r\n    \r\n    \r\n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\r\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\r\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\r\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\r\n    \r\n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\r\n    return col*1.8;\r\n    //return pow(col,vec4(1.))*2.\r\n}\r\n\r\n\r\n//-------------------Background and Stars--------------------\r\n\r\nvec3 nmzHash33(vec3 q)\r\n{\r\n    uvec3 p = uvec3(ivec3(q));\r\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\r\n    p = p.yzx*(p.zxy^(p >> 3U));\r\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\r\n}\r\n\r\nvec3 stars(in vec3 p)\r\n{\r\n    vec3 c = vec3(0.);\r\n    float res = iResolution.x*1.;\r\n    \r\n\tfor (float i=0.;i<4.;i++)\r\n    {\r\n        vec3 q = fract(p*(.15*res))-0.5;\r\n        vec3 id = floor(p*(.15*res));\r\n        vec2 rn = nmzHash33(id).xy;\r\n        float c2 = 1.-smoothstep(0.,.6,length(q));\r\n        c2 *= step(rn.x,.0005+i*i*0.001);\r\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\r\n        p *= 1.3;\r\n    }\r\n    return c*c*.8;\r\n}\r\n\r\nvec3 bg(in vec3 rd)\r\n{\r\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\r\n    sd = pow(sd, 5.);\r\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\r\n    return col*.63;\r\n}\r\n//-----------------------------------------------------------\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = q - 0.5;\r\n\tp.x*=iResolution.x/iResolution.y;\r\n    \r\n    vec3 ro = vec3(0,0,-6.7);\r\n    vec3 rd = normalize(vec3(p,1.3));\r\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\r\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\r\n\tmo.x *= iResolution.x/iResolution.y;\r\n    rd.yz *= mm2(mo.y);\r\n    rd.xz *= mm2(mo.x + sin(time*0.05)*0.2);\r\n    \r\n    vec3 col = vec3(0.);\r\n    vec3 brd = rd;\r\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\r\n    \r\n    col = bg(rd)*fade;\r\n    \r\n    if (rd.y > 0.){\r\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\r\n        col += stars(rd);\r\n        col = col*(1.-aur.a) + aur.rgb;\r\n    }\r\n    else //Reflections\r\n    {\r\n        rd.y = abs(rd.y);\r\n        col = bg(rd)*fade*0.6;\r\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\r\n        col += stars(rd)*0.1;\r\n        col = col*(1.-aur.a) + aur.rgb;\r\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\r\n        float nz2 = triNoise2d(pos.xz*vec2(.5,.7), 0.);\r\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\r\n    }\r\n    \r\n\tfragColor = vec4(col, 1.);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Auroras","id":null,"date":null,"viewed":0,"name":"Auroras","description":"Trying to get cheap and fully procedural northern lights effect. Looks better in full screen. Could still be improved...","likes":0,"published":null,"tags":["procedural"," aurora"," atmosphere"," weather"]},"ver":null,"info":{"Name":"Auroras","id":null,"date":null,"viewed":0,"name":"Auroras","description":"Trying to get cheap and fully procedural northern lights effect. Looks better in full screen. Could still be improved...","likes":0,"published":null,"tags":["procedural"," aurora"," atmosphere"," weather"]},"renderpass":[{"Code":"// Auroras by nimitz 2017 (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n/*\r\n\t\r\n\tThere are two main hurdles I encountered rendering this effect. \r\n\tFirst, the nature of the texture that needs to be generated to get a believable effect\r\n\tneeds to be very specific, with large scale band-like structures, small scale non-smooth variations\r\n\tto create the trail-like effect, a method for animating said texture smoothly and finally doing all\r\n\tof this cheaply enough to be able to evaluate it several times per fragment/pixel.\r\n\r\n\tThe second obstacle is the need to render a large volume while keeping the computational cost low.\r\n\tSince the effect requires the trails to extend way up in the atmosphere to look good, this means\r\n\tthat the evaluated volume cannot be as constrained as with cloud effects. My solution was to make\r\n\tthe sample stride increase polynomially, which works very well as long as the trails are lower opcaity than\r\n\tthe rest of the effect. Which is always the case for auroras.\r\n\r\n\tAfter that, there were some issues with getting the correct emission curves and removing banding at lowered\r\n\tsample densities, this was fixed by a combination of sample number influenced dithering and slight sample blending.\r\n\r\n\tN.B. the base setup is from an old shader and ideally the effect would take an arbitrary ray origin and\r\n\tdirection. But this was not required for this demo and would be trivial to fix.\r\n*/\r\n\r\n#define time iTime\r\n\r\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\r\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\r\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\r\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\r\n\r\nfloat triNoise2d(in vec2 p, float spd)\r\n{\r\n    float z=1.8;\r\n    float z2=2.5;\r\n\tfloat rz = 0.;\r\n    p *= mm2(p.x*0.06);\r\n    vec2 bp = p;\r\n\tfor (float i=0.; i<5.; i++ )\r\n\t{\r\n        vec2 dg = tri2(bp*1.85)*.75;\r\n        dg *= mm2(time*spd);\r\n        p -= dg/z2;\r\n\r\n        bp *= 1.3;\r\n        z2 *= .45;\r\n        z *= .42;\r\n\t\tp *= 1.21 + (rz-1.0)*.02;\r\n        \r\n        rz += tri(p.x+tri(p.y))*z;\r\n        p*= -m2;\r\n\t}\r\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\r\n}\r\n\r\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\r\nvec4 aurora(vec3 ro, vec3 rd)\r\n{\r\n    vec4 col = vec4(0);\r\n    vec4 avgCol = vec4(0);\r\n    \r\n    for(float i=0.;i<50.;i++)\r\n    {\r\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\r\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\r\n        pt -= of;\r\n    \tvec3 bpos = ro + pt*rd;\r\n        vec2 p = bpos.zx;\r\n        float rzt = triNoise2d(p, 0.06);\r\n        vec4 col2 = vec4(0,0,0, rzt);\r\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\r\n        avgCol =  mix(avgCol, col2, .5);\r\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\r\n        \r\n    }\r\n    \r\n    col *= (clamp(rd.y*15.+.4,0.,1.));\r\n    \r\n    \r\n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\r\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\r\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\r\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\r\n    \r\n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\r\n    return col*1.8;\r\n    //return pow(col,vec4(1.))*2.\r\n}\r\n\r\n\r\n//-------------------Background and Stars--------------------\r\n\r\nvec3 nmzHash33(vec3 q)\r\n{\r\n    uvec3 p = uvec3(ivec3(q));\r\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\r\n    p = p.yzx*(p.zxy^(p >> 3U));\r\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\r\n}\r\n\r\nvec3 stars(in vec3 p)\r\n{\r\n    vec3 c = vec3(0.);\r\n    float res = iResolution.x*1.;\r\n    \r\n\tfor (float i=0.;i<4.;i++)\r\n    {\r\n        vec3 q = fract(p*(.15*res))-0.5;\r\n        vec3 id = floor(p*(.15*res));\r\n        vec2 rn = nmzHash33(id).xy;\r\n        float c2 = 1.-smoothstep(0.,.6,length(q));\r\n        c2 *= step(rn.x,.0005+i*i*0.001);\r\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\r\n        p *= 1.3;\r\n    }\r\n    return c*c*.8;\r\n}\r\n\r\nvec3 bg(in vec3 rd)\r\n{\r\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\r\n    sd = pow(sd, 5.);\r\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\r\n    return col*.63;\r\n}\r\n//-----------------------------------------------------------\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = q - 0.5;\r\n\tp.x*=iResolution.x/iResolution.y;\r\n    \r\n    vec3 ro = vec3(0,0,-6.7);\r\n    vec3 rd = normalize(vec3(p,1.3));\r\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\r\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\r\n\tmo.x *= iResolution.x/iResolution.y;\r\n    rd.yz *= mm2(mo.y);\r\n    rd.xz *= mm2(mo.x + sin(time*0.05)*0.2);\r\n    \r\n    vec3 col = vec3(0.);\r\n    vec3 brd = rd;\r\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\r\n    \r\n    col = bg(rd)*fade;\r\n    \r\n    if (rd.y > 0.){\r\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\r\n        col += stars(rd);\r\n        col = col*(1.-aur.a) + aur.rgb;\r\n    }\r\n    else //Reflections\r\n    {\r\n        rd.y = abs(rd.y);\r\n        col = bg(rd)*fade*0.6;\r\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\r\n        col += stars(rd)*0.1;\r\n        col = col*(1.-aur.a) + aur.rgb;\r\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\r\n        float nz2 = triNoise2d(pos.xz*vec2(.5,.7), 0.);\r\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\r\n    }\r\n    \r\n\tfragColor = vec4(col, 1.);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Auroras by nimitz 2017 (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n/*\r\n\t\r\n\tThere are two main hurdles I encountered rendering this effect. \r\n\tFirst, the nature of the texture that needs to be generated to get a believable effect\r\n\tneeds to be very specific, with large scale band-like structures, small scale non-smooth variations\r\n\tto create the trail-like effect, a method for animating said texture smoothly and finally doing all\r\n\tof this cheaply enough to be able to evaluate it several times per fragment/pixel.\r\n\r\n\tThe second obstacle is the need to render a large volume while keeping the computational cost low.\r\n\tSince the effect requires the trails to extend way up in the atmosphere to look good, this means\r\n\tthat the evaluated volume cannot be as constrained as with cloud effects. My solution was to make\r\n\tthe sample stride increase polynomially, which works very well as long as the trails are lower opcaity than\r\n\tthe rest of the effect. Which is always the case for auroras.\r\n\r\n\tAfter that, there were some issues with getting the correct emission curves and removing banding at lowered\r\n\tsample densities, this was fixed by a combination of sample number influenced dithering and slight sample blending.\r\n\r\n\tN.B. the base setup is from an old shader and ideally the effect would take an arbitrary ray origin and\r\n\tdirection. But this was not required for this demo and would be trivial to fix.\r\n*/\r\n\r\n#define time iTime\r\n\r\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\r\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\r\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\r\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\r\n\r\nfloat triNoise2d(in vec2 p, float spd)\r\n{\r\n    float z=1.8;\r\n    float z2=2.5;\r\n\tfloat rz = 0.;\r\n    p *= mm2(p.x*0.06);\r\n    vec2 bp = p;\r\n\tfor (float i=0.; i<5.; i++ )\r\n\t{\r\n        vec2 dg = tri2(bp*1.85)*.75;\r\n        dg *= mm2(time*spd);\r\n        p -= dg/z2;\r\n\r\n        bp *= 1.3;\r\n        z2 *= .45;\r\n        z *= .42;\r\n\t\tp *= 1.21 + (rz-1.0)*.02;\r\n        \r\n        rz += tri(p.x+tri(p.y))*z;\r\n        p*= -m2;\r\n\t}\r\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\r\n}\r\n\r\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\r\nvec4 aurora(vec3 ro, vec3 rd)\r\n{\r\n    vec4 col = vec4(0);\r\n    vec4 avgCol = vec4(0);\r\n    \r\n    for(float i=0.;i<50.;i++)\r\n    {\r\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\r\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\r\n        pt -= of;\r\n    \tvec3 bpos = ro + pt*rd;\r\n        vec2 p = bpos.zx;\r\n        float rzt = triNoise2d(p, 0.06);\r\n        vec4 col2 = vec4(0,0,0, rzt);\r\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\r\n        avgCol =  mix(avgCol, col2, .5);\r\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\r\n        \r\n    }\r\n    \r\n    col *= (clamp(rd.y*15.+.4,0.,1.));\r\n    \r\n    \r\n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\r\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\r\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\r\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\r\n    \r\n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\r\n    return col*1.8;\r\n    //return pow(col,vec4(1.))*2.\r\n}\r\n\r\n\r\n//-------------------Background and Stars--------------------\r\n\r\nvec3 nmzHash33(vec3 q)\r\n{\r\n    uvec3 p = uvec3(ivec3(q));\r\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\r\n    p = p.yzx*(p.zxy^(p >> 3U));\r\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\r\n}\r\n\r\nvec3 stars(in vec3 p)\r\n{\r\n    vec3 c = vec3(0.);\r\n    float res = iResolution.x*1.;\r\n    \r\n\tfor (float i=0.;i<4.;i++)\r\n    {\r\n        vec3 q = fract(p*(.15*res))-0.5;\r\n        vec3 id = floor(p*(.15*res));\r\n        vec2 rn = nmzHash33(id).xy;\r\n        float c2 = 1.-smoothstep(0.,.6,length(q));\r\n        c2 *= step(rn.x,.0005+i*i*0.001);\r\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\r\n        p *= 1.3;\r\n    }\r\n    return c*c*.8;\r\n}\r\n\r\nvec3 bg(in vec3 rd)\r\n{\r\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\r\n    sd = pow(sd, 5.);\r\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\r\n    return col*.63;\r\n}\r\n//-----------------------------------------------------------\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = q - 0.5;\r\n\tp.x*=iResolution.x/iResolution.y;\r\n    \r\n    vec3 ro = vec3(0,0,-6.7);\r\n    vec3 rd = normalize(vec3(p,1.3));\r\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\r\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\r\n\tmo.x *= iResolution.x/iResolution.y;\r\n    rd.yz *= mm2(mo.y);\r\n    rd.xz *= mm2(mo.x + sin(time*0.05)*0.2);\r\n    \r\n    vec3 col = vec3(0.);\r\n    vec3 brd = rd;\r\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\r\n    \r\n    col = bg(rd)*fade;\r\n    \r\n    if (rd.y > 0.){\r\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\r\n        col += stars(rd);\r\n        col = col*(1.-aur.a) + aur.rgb;\r\n    }\r\n    else //Reflections\r\n    {\r\n        rd.y = abs(rd.y);\r\n        col = bg(rd)*fade*0.6;\r\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\r\n        col += stars(rd)*0.1;\r\n        col = col*(1.-aur.a) + aur.rgb;\r\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\r\n        float nz2 = triNoise2d(pos.xz*vec2(.5,.7), 0.);\r\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\r\n    }\r\n    \r\n\tfragColor = vec4(col, 1.);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2015\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\r\n{\r\n    vec3 colx = texture( sam, 0.5 + s*d.yz/d.x, b ).xyz;\r\n    vec3 coly = texture( sam, 0.5 + s*d.zx/d.y, b ).xyz;\r\n    vec3 colz = texture( sam, 0.5 + s*d.xy/d.z, b ).xyz;\r\n    \r\n    vec3 n = d*d;\r\n    \r\n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\r\n}\r\n\r\n\r\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\r\n\r\nvec2 voronoi( in vec2 x )\r\n{\r\n    vec2 n = floor( x );\r\n    vec2 f = fract( x );\r\n\r\n\tvec3 m = vec3( 8.0 );\r\n    for( int j=-1; j<=1; j++ )\r\n    for( int i=-1; i<=1; i++ )\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash( n + g );\r\n        vec2  r = g - f + o;\r\n\t\tfloat d = dot( r, r );\r\n        if( d<m.x )\r\n            m = vec3( d, o );\r\n    }\r\n\r\n    return vec2( sqrt(m.x), m.y+m.z );\r\n}\r\n\r\nfloat shpIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\r\n{\r\n    vec3 oc = ro - sph.xyz;\r\n    float b = dot( rd, oc );\r\n    float c = dot( oc, oc ) - sph.w*sph.w;\r\n    float h = b*b - c;\r\n    if( h>0.0 ) h = -b - sqrt( h );\r\n    return h;\r\n}\r\n\r\nfloat sphDistance( in vec3 ro, in vec3 rd, in vec4 sph )\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n    float b = dot( oc, rd );\r\n    float h = dot( oc, oc ) - b*b;\r\n    return sqrt( max(0.0,h)) - sph.w;\r\n}\r\n\r\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\r\n{\r\n    vec3 oc = sph.xyz - ro;\r\n    float b = dot( oc, rd );\r\n    float c = dot( oc, oc ) - sph.w*sph.w;\r\n    float h = b*b - c;\r\n    return (b<0.0) ? 1.0 : 1.0 - smoothstep( 0.0, 1.0, k*h/b );\r\n}    \r\n   \r\n\r\nvec3 sphNormal( in vec3 pos, in vec4 sph )\r\n{\r\n    return (pos - sph.xyz)/sph.w;    \r\n}\r\n\r\n//=======================================================\r\n\r\nvec3 background( in vec3 d, in vec3 l )\r\n{\r\n    vec3 col = vec3(0.0);\r\n         col += 0.5*pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\r\n         col += 0.2*pow( fancyCube( iChannel1, d, 0.10, 3.0 ).zyx, vec3(1.5) );\r\n         col += 0.8*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\r\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel1, d, 0.91, 0.0 ).x );\r\n\r\n    \r\n    vec3 n = abs(d);\r\n    n = n*n*n;\r\n    \r\n    vec2 vxy = voronoi( 50.0*d.xy );\r\n    vec2 vyz = voronoi( 50.0*d.yz );\r\n    vec2 vzx = voronoi( 50.0*d.zx );\r\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) / (n.x+n.y+n.z);\r\n    col += 0.9 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\r\n\r\n    col = 1.5*col - 0.2;\r\n    col += vec3(-0.05,0.1,0.0);\r\n\r\n    float s = clamp( dot(d,l), 0.0, 1.0 );\r\n    col += 0.4*pow(s,5.0)*vec3(1.0,0.7,0.6)*2.0;\r\n    col += 0.4*pow(s,64.0)*vec3(1.0,0.9,0.8)*2.0;\r\n    \r\n    return col;\r\n\r\n}\r\n\r\n//--------------------------------------------------------------------\r\n\r\nvec4 sph1 = vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\nfloat rayTrace( in vec3 ro, in vec3 rd )\r\n{\r\n    return shpIntersect( ro, rd, sph1 );\r\n}\r\n\r\nfloat map( in vec3 pos )\r\n{\r\n    vec2 r = pos.xz - sph1.xz;\r\n    float h = 1.0-2.0/(1.0 + 0.3*dot(r,r));\r\n    return pos.y - h;\r\n}\r\n\r\nfloat rayMarch( in vec3 ro, in vec3 rd, float tmax )\r\n{\r\n    float t = 0.0;\r\n    \r\n    // bounding plane\r\n    float h = (1.0-ro.y)/rd.y;\r\n    if( h>0.0 ) t=h;\r\n\r\n    // raymarch\r\n    for( int i=0; i<20; i++ )    \r\n    {        \r\n        vec3 pos = ro + t*rd;\r\n        float h = map( pos );\r\n        if( h<0.001 || t>tmax ) break;\r\n        t += h;\r\n    }\r\n    return t;    \r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 lig = normalize( vec3(1.0,0.2,1.0) );\r\n    vec3 col = background( rd, lig );\r\n    \r\n    // raytrace stuff    \r\n    float t = rayTrace( ro, rd );\r\n\r\n    if( t>0.0 )\r\n    {\r\n        vec3 mat = vec3( 0.18 );\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = sphNormal( pos, sph1 );\r\n            \r\n        float am = 0.1*iTime;\r\n        vec2 pr = vec2( cos(am), sin(am) );\r\n        vec3 tnor = nor;\r\n        tnor.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor.xz;\r\n\r\n        float am2 = 0.08*iTime - 1.0*(1.0-nor.y*nor.y);\r\n        pr = vec2( cos(am2), sin(am2) );\r\n        vec3 tnor2 = nor;\r\n        tnor2.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor2.xz;\r\n\r\n        vec3 ref = reflect( rd, nor );\r\n        float fre = clamp( 1.0+dot( nor, rd ), 0.0 ,1.0 );\r\n\r\n        float l = fancyCube( iChannel0, tnor, 0.03, 0.0 ).x;\r\n        l += -0.1 + 0.3*fancyCube( iChannel0, tnor, 8.0, 0.0 ).x;\r\n\r\n        vec3 sea  = mix( vec3(0.0,0.07,0.2), vec3(0.0,0.01,0.3), fre );\r\n        sea *= 0.15;\r\n\r\n        vec3 land = vec3(0.02,0.04,0.0);\r\n        land = mix( land, vec3(0.05,0.1,0.0), smoothstep(0.4,1.0,fancyCube( iChannel0, tnor, 0.1, 0.0 ).x ));\r\n        land *= fancyCube( iChannel0, tnor, 0.3, 0.0 ).xyz;\r\n        land *= 0.5;\r\n\r\n        float los = smoothstep(0.45,0.46, l);\r\n        mat = mix( sea, land, los );\r\n\r\n        vec3 wrap = -1.0 + 2.0*fancyCube( iChannel1, tnor2.xzy, 0.025, 0.0 ).xyz;\r\n        float cc1 = fancyCube( iChannel1, tnor2 + 0.2*wrap, 0.05, 0.0 ).y;\r\n        float clouds = smoothstep( 0.3, 0.6, cc1 );\r\n\r\n        mat = mix( mat, vec3(0.93*0.15), clouds );\r\n\r\n        float dif = clamp( dot(nor, lig), 0.0, 1.0 );\r\n        mat *= 0.8;\r\n        vec3 lin  = vec3(3.0,2.5,2.0)*dif;\r\n        lin += 0.01;\r\n        col = mat * lin;\r\n        col = pow( col, vec3(0.4545) );\r\n        col += 0.6*fre*fre*vec3(0.9,0.9,1.0)*(0.3+0.7*dif);\r\n\r\n        float spe = clamp( dot(ref,lig), 0.0, 1.0 );\r\n        float tspe = pow( spe, 3.0 ) + 0.5*pow( spe, 16.0 );\r\n        col += (1.0-0.5*los)*clamp(1.0-2.0*clouds,0.0,1.0)*0.3*vec3(0.5,0.4,0.3)*tspe*dif;;\r\n    }\r\n    \r\n    // raymarch stuff    \r\n    float tmax = 20.0;\r\n    if( t>0.0 ) tmax = t; \r\n    t = rayMarch( ro, rd, tmax );    \r\n    if( t<tmax )\r\n    {\r\n            vec3 pos = ro + t*rd;\r\n\r\n            vec2 scp = sin(2.0*6.2831*pos.xz);\r\n            \r\n            vec3 wir = vec3( 0.0 );\r\n            wir += 1.0*exp(-12.0*abs(scp.x));\r\n            wir += 1.0*exp(-12.0*abs(scp.y));\r\n            wir += 0.5*exp( -4.0*abs(scp.x));\r\n            wir += 0.5*exp( -4.0*abs(scp.y));\r\n            wir *= 0.2 + 1.0*sphSoftShadow( pos, lig, sph1, 4.0 );\r\n\r\n            col += wir*0.5*exp( -0.05*t*t );;\r\n    }        \r\n\r\n    if( dot(rd,sph1.xyz-ro)>0.0 )\r\n    {\r\n    float d = sphDistance( ro, rd, sph1 );\r\n    vec3 glo = vec3(0.0);\r\n    glo += vec3(0.6,0.7,1.0)*0.3*exp(-2.0*abs(d))*step(0.0,d);\r\n    glo += 0.6*vec3(0.6,0.7,1.0)*0.3*exp(-8.0*abs(d));\r\n    glo += 0.6*vec3(0.8,0.9,1.0)*0.4*exp(-100.0*abs(d));\r\n    col += glo*2.0;\r\n    }        \r\n    \r\n    col *= smoothstep( 0.0, 6.0, iTime );\r\n\r\n    return col;\r\n}\r\n\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\r\n{\r\n\tvec3 cw = normalize(rt-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, -cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy +2.0*fragCoord.xy) / iResolution.y;\r\n\r\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\r\n    float an = 3.0 + 0.05*iTime + 6.0*iMouse.x/iResolution.x;\r\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\r\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\r\n    mat3 cam = setCamera( ro, rt, 0.35 );\r\n    vec3 rd = normalize( cam * vec3( p, -2.0) );\r\n\r\n    vec3 col = render( ro, rd );\r\n    \r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\r\n{\r\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\r\n    float an = 3.0 + 0.05*iTime;\r\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\r\n\r\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\r\n    mat3 cam = setCamera( ro, rt, 0.35 );\r\n    \r\n    fragColor = vec4( render( ro + cam*fragRayOri,\r\n                                   cam*fragRayDir ), 1.0 );\r\n\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":null,"published":0}],"outputs":[],"code":"// Created by inigo quilez - iq/2015\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\r\n{\r\n    vec3 colx = texture( sam, 0.5 + s*d.yz/d.x, b ).xyz;\r\n    vec3 coly = texture( sam, 0.5 + s*d.zx/d.y, b ).xyz;\r\n    vec3 colz = texture( sam, 0.5 + s*d.xy/d.z, b ).xyz;\r\n    \r\n    vec3 n = d*d;\r\n    \r\n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\r\n}\r\n\r\n\r\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\r\n\r\nvec2 voronoi( in vec2 x )\r\n{\r\n    vec2 n = floor( x );\r\n    vec2 f = fract( x );\r\n\r\n\tvec3 m = vec3( 8.0 );\r\n    for( int j=-1; j<=1; j++ )\r\n    for( int i=-1; i<=1; i++ )\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash( n + g );\r\n        vec2  r = g - f + o;\r\n\t\tfloat d = dot( r, r );\r\n        if( d<m.x )\r\n            m = vec3( d, o );\r\n    }\r\n\r\n    return vec2( sqrt(m.x), m.y+m.z );\r\n}\r\n\r\nfloat shpIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\r\n{\r\n    vec3 oc = ro - sph.xyz;\r\n    float b = dot( rd, oc );\r\n    float c = dot( oc, oc ) - sph.w*sph.w;\r\n    float h = b*b - c;\r\n    if( h>0.0 ) h = -b - sqrt( h );\r\n    return h;\r\n}\r\n\r\nfloat sphDistance( in vec3 ro, in vec3 rd, in vec4 sph )\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n    float b = dot( oc, rd );\r\n    float h = dot( oc, oc ) - b*b;\r\n    return sqrt( max(0.0,h)) - sph.w;\r\n}\r\n\r\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\r\n{\r\n    vec3 oc = sph.xyz - ro;\r\n    float b = dot( oc, rd );\r\n    float c = dot( oc, oc ) - sph.w*sph.w;\r\n    float h = b*b - c;\r\n    return (b<0.0) ? 1.0 : 1.0 - smoothstep( 0.0, 1.0, k*h/b );\r\n}    \r\n   \r\n\r\nvec3 sphNormal( in vec3 pos, in vec4 sph )\r\n{\r\n    return (pos - sph.xyz)/sph.w;    \r\n}\r\n\r\n//=======================================================\r\n\r\nvec3 background( in vec3 d, in vec3 l )\r\n{\r\n    vec3 col = vec3(0.0);\r\n         col += 0.5*pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\r\n         col += 0.2*pow( fancyCube( iChannel1, d, 0.10, 3.0 ).zyx, vec3(1.5) );\r\n         col += 0.8*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\r\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel1, d, 0.91, 0.0 ).x );\r\n\r\n    \r\n    vec3 n = abs(d);\r\n    n = n*n*n;\r\n    \r\n    vec2 vxy = voronoi( 50.0*d.xy );\r\n    vec2 vyz = voronoi( 50.0*d.yz );\r\n    vec2 vzx = voronoi( 50.0*d.zx );\r\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) / (n.x+n.y+n.z);\r\n    col += 0.9 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\r\n\r\n    col = 1.5*col - 0.2;\r\n    col += vec3(-0.05,0.1,0.0);\r\n\r\n    float s = clamp( dot(d,l), 0.0, 1.0 );\r\n    col += 0.4*pow(s,5.0)*vec3(1.0,0.7,0.6)*2.0;\r\n    col += 0.4*pow(s,64.0)*vec3(1.0,0.9,0.8)*2.0;\r\n    \r\n    return col;\r\n\r\n}\r\n\r\n//--------------------------------------------------------------------\r\n\r\nvec4 sph1 = vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\nfloat rayTrace( in vec3 ro, in vec3 rd )\r\n{\r\n    return shpIntersect( ro, rd, sph1 );\r\n}\r\n\r\nfloat map( in vec3 pos )\r\n{\r\n    vec2 r = pos.xz - sph1.xz;\r\n    float h = 1.0-2.0/(1.0 + 0.3*dot(r,r));\r\n    return pos.y - h;\r\n}\r\n\r\nfloat rayMarch( in vec3 ro, in vec3 rd, float tmax )\r\n{\r\n    float t = 0.0;\r\n    \r\n    // bounding plane\r\n    float h = (1.0-ro.y)/rd.y;\r\n    if( h>0.0 ) t=h;\r\n\r\n    // raymarch\r\n    for( int i=0; i<20; i++ )    \r\n    {        \r\n        vec3 pos = ro + t*rd;\r\n        float h = map( pos );\r\n        if( h<0.001 || t>tmax ) break;\r\n        t += h;\r\n    }\r\n    return t;    \r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 lig = normalize( vec3(1.0,0.2,1.0) );\r\n    vec3 col = background( rd, lig );\r\n    \r\n    // raytrace stuff    \r\n    float t = rayTrace( ro, rd );\r\n\r\n    if( t>0.0 )\r\n    {\r\n        vec3 mat = vec3( 0.18 );\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = sphNormal( pos, sph1 );\r\n            \r\n        float am = 0.1*iTime;\r\n        vec2 pr = vec2( cos(am), sin(am) );\r\n        vec3 tnor = nor;\r\n        tnor.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor.xz;\r\n\r\n        float am2 = 0.08*iTime - 1.0*(1.0-nor.y*nor.y);\r\n        pr = vec2( cos(am2), sin(am2) );\r\n        vec3 tnor2 = nor;\r\n        tnor2.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor2.xz;\r\n\r\n        vec3 ref = reflect( rd, nor );\r\n        float fre = clamp( 1.0+dot( nor, rd ), 0.0 ,1.0 );\r\n\r\n        float l = fancyCube( iChannel0, tnor, 0.03, 0.0 ).x;\r\n        l += -0.1 + 0.3*fancyCube( iChannel0, tnor, 8.0, 0.0 ).x;\r\n\r\n        vec3 sea  = mix( vec3(0.0,0.07,0.2), vec3(0.0,0.01,0.3), fre );\r\n        sea *= 0.15;\r\n\r\n        vec3 land = vec3(0.02,0.04,0.0);\r\n        land = mix( land, vec3(0.05,0.1,0.0), smoothstep(0.4,1.0,fancyCube( iChannel0, tnor, 0.1, 0.0 ).x ));\r\n        land *= fancyCube( iChannel0, tnor, 0.3, 0.0 ).xyz;\r\n        land *= 0.5;\r\n\r\n        float los = smoothstep(0.45,0.46, l);\r\n        mat = mix( sea, land, los );\r\n\r\n        vec3 wrap = -1.0 + 2.0*fancyCube( iChannel1, tnor2.xzy, 0.025, 0.0 ).xyz;\r\n        float cc1 = fancyCube( iChannel1, tnor2 + 0.2*wrap, 0.05, 0.0 ).y;\r\n        float clouds = smoothstep( 0.3, 0.6, cc1 );\r\n\r\n        mat = mix( mat, vec3(0.93*0.15), clouds );\r\n\r\n        float dif = clamp( dot(nor, lig), 0.0, 1.0 );\r\n        mat *= 0.8;\r\n        vec3 lin  = vec3(3.0,2.5,2.0)*dif;\r\n        lin += 0.01;\r\n        col = mat * lin;\r\n        col = pow( col, vec3(0.4545) );\r\n        col += 0.6*fre*fre*vec3(0.9,0.9,1.0)*(0.3+0.7*dif);\r\n\r\n        float spe = clamp( dot(ref,lig), 0.0, 1.0 );\r\n        float tspe = pow( spe, 3.0 ) + 0.5*pow( spe, 16.0 );\r\n        col += (1.0-0.5*los)*clamp(1.0-2.0*clouds,0.0,1.0)*0.3*vec3(0.5,0.4,0.3)*tspe*dif;;\r\n    }\r\n    \r\n    // raymarch stuff    \r\n    float tmax = 20.0;\r\n    if( t>0.0 ) tmax = t; \r\n    t = rayMarch( ro, rd, tmax );    \r\n    if( t<tmax )\r\n    {\r\n            vec3 pos = ro + t*rd;\r\n\r\n            vec2 scp = sin(2.0*6.2831*pos.xz);\r\n            \r\n            vec3 wir = vec3( 0.0 );\r\n            wir += 1.0*exp(-12.0*abs(scp.x));\r\n            wir += 1.0*exp(-12.0*abs(scp.y));\r\n            wir += 0.5*exp( -4.0*abs(scp.x));\r\n            wir += 0.5*exp( -4.0*abs(scp.y));\r\n            wir *= 0.2 + 1.0*sphSoftShadow( pos, lig, sph1, 4.0 );\r\n\r\n            col += wir*0.5*exp( -0.05*t*t );;\r\n    }        \r\n\r\n    if( dot(rd,sph1.xyz-ro)>0.0 )\r\n    {\r\n    float d = sphDistance( ro, rd, sph1 );\r\n    vec3 glo = vec3(0.0);\r\n    glo += vec3(0.6,0.7,1.0)*0.3*exp(-2.0*abs(d))*step(0.0,d);\r\n    glo += 0.6*vec3(0.6,0.7,1.0)*0.3*exp(-8.0*abs(d));\r\n    glo += 0.6*vec3(0.8,0.9,1.0)*0.4*exp(-100.0*abs(d));\r\n    col += glo*2.0;\r\n    }        \r\n    \r\n    col *= smoothstep( 0.0, 6.0, iTime );\r\n\r\n    return col;\r\n}\r\n\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\r\n{\r\n\tvec3 cw = normalize(rt-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, -cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy +2.0*fragCoord.xy) / iResolution.y;\r\n\r\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\r\n    float an = 3.0 + 0.05*iTime + 6.0*iMouse.x/iResolution.x;\r\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\r\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\r\n    mat3 cam = setCamera( ro, rt, 0.35 );\r\n    vec3 rd = normalize( cam * vec3( p, -2.0) );\r\n\r\n    vec3 col = render( ro, rd );\r\n    \r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\r\n{\r\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\r\n    float an = 3.0 + 0.05*iTime;\r\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\r\n\r\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\r\n    mat3 cam = setCamera( ro, rt, 0.35 );\r\n    \r\n    fragColor = vec4( render( ro + cam*fragRayOri,\r\n                                   cam*fragRayDir ), 1.0 );\r\n\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":null,"published":0}],"Info":{"Name":"[NV15] Space Curvature","id":null,"date":null,"viewed":0,"name":"[NV15] Space Curvature","description":"Space curvature","likes":0,"published":null,"tags":["3d"," raytracing"," raymarching"," space"," vr"," nv15"]},"ver":null,"info":{"Name":"[NV15] Space Curvature","id":null,"date":null,"viewed":0,"name":"[NV15] Space Curvature","description":"Space curvature","likes":0,"published":null,"tags":["3d"," raytracing"," raymarching"," space"," vr"," nv15"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2015\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\r\n{\r\n    vec3 colx = texture( sam, 0.5 + s*d.yz/d.x, b ).xyz;\r\n    vec3 coly = texture( sam, 0.5 + s*d.zx/d.y, b ).xyz;\r\n    vec3 colz = texture( sam, 0.5 + s*d.xy/d.z, b ).xyz;\r\n    \r\n    vec3 n = d*d;\r\n    \r\n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\r\n}\r\n\r\n\r\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\r\n\r\nvec2 voronoi( in vec2 x )\r\n{\r\n    vec2 n = floor( x );\r\n    vec2 f = fract( x );\r\n\r\n\tvec3 m = vec3( 8.0 );\r\n    for( int j=-1; j<=1; j++ )\r\n    for( int i=-1; i<=1; i++ )\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash( n + g );\r\n        vec2  r = g - f + o;\r\n\t\tfloat d = dot( r, r );\r\n        if( d<m.x )\r\n            m = vec3( d, o );\r\n    }\r\n\r\n    return vec2( sqrt(m.x), m.y+m.z );\r\n}\r\n\r\nfloat shpIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\r\n{\r\n    vec3 oc = ro - sph.xyz;\r\n    float b = dot( rd, oc );\r\n    float c = dot( oc, oc ) - sph.w*sph.w;\r\n    float h = b*b - c;\r\n    if( h>0.0 ) h = -b - sqrt( h );\r\n    return h;\r\n}\r\n\r\nfloat sphDistance( in vec3 ro, in vec3 rd, in vec4 sph )\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n    float b = dot( oc, rd );\r\n    float h = dot( oc, oc ) - b*b;\r\n    return sqrt( max(0.0,h)) - sph.w;\r\n}\r\n\r\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\r\n{\r\n    vec3 oc = sph.xyz - ro;\r\n    float b = dot( oc, rd );\r\n    float c = dot( oc, oc ) - sph.w*sph.w;\r\n    float h = b*b - c;\r\n    return (b<0.0) ? 1.0 : 1.0 - smoothstep( 0.0, 1.0, k*h/b );\r\n}    \r\n   \r\n\r\nvec3 sphNormal( in vec3 pos, in vec4 sph )\r\n{\r\n    return (pos - sph.xyz)/sph.w;    \r\n}\r\n\r\n//=======================================================\r\n\r\nvec3 background( in vec3 d, in vec3 l )\r\n{\r\n    vec3 col = vec3(0.0);\r\n         col += 0.5*pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\r\n         col += 0.2*pow( fancyCube( iChannel1, d, 0.10, 3.0 ).zyx, vec3(1.5) );\r\n         col += 0.8*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\r\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel1, d, 0.91, 0.0 ).x );\r\n\r\n    \r\n    vec3 n = abs(d);\r\n    n = n*n*n;\r\n    \r\n    vec2 vxy = voronoi( 50.0*d.xy );\r\n    vec2 vyz = voronoi( 50.0*d.yz );\r\n    vec2 vzx = voronoi( 50.0*d.zx );\r\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) / (n.x+n.y+n.z);\r\n    col += 0.9 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\r\n\r\n    col = 1.5*col - 0.2;\r\n    col += vec3(-0.05,0.1,0.0);\r\n\r\n    float s = clamp( dot(d,l), 0.0, 1.0 );\r\n    col += 0.4*pow(s,5.0)*vec3(1.0,0.7,0.6)*2.0;\r\n    col += 0.4*pow(s,64.0)*vec3(1.0,0.9,0.8)*2.0;\r\n    \r\n    return col;\r\n\r\n}\r\n\r\n//--------------------------------------------------------------------\r\n\r\nvec4 sph1 = vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\nfloat rayTrace( in vec3 ro, in vec3 rd )\r\n{\r\n    return shpIntersect( ro, rd, sph1 );\r\n}\r\n\r\nfloat map( in vec3 pos )\r\n{\r\n    vec2 r = pos.xz - sph1.xz;\r\n    float h = 1.0-2.0/(1.0 + 0.3*dot(r,r));\r\n    return pos.y - h;\r\n}\r\n\r\nfloat rayMarch( in vec3 ro, in vec3 rd, float tmax )\r\n{\r\n    float t = 0.0;\r\n    \r\n    // bounding plane\r\n    float h = (1.0-ro.y)/rd.y;\r\n    if( h>0.0 ) t=h;\r\n\r\n    // raymarch\r\n    for( int i=0; i<20; i++ )    \r\n    {        \r\n        vec3 pos = ro + t*rd;\r\n        float h = map( pos );\r\n        if( h<0.001 || t>tmax ) break;\r\n        t += h;\r\n    }\r\n    return t;    \r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 lig = normalize( vec3(1.0,0.2,1.0) );\r\n    vec3 col = background( rd, lig );\r\n    \r\n    // raytrace stuff    \r\n    float t = rayTrace( ro, rd );\r\n\r\n    if( t>0.0 )\r\n    {\r\n        vec3 mat = vec3( 0.18 );\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = sphNormal( pos, sph1 );\r\n            \r\n        float am = 0.1*iTime;\r\n        vec2 pr = vec2( cos(am), sin(am) );\r\n        vec3 tnor = nor;\r\n        tnor.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor.xz;\r\n\r\n        float am2 = 0.08*iTime - 1.0*(1.0-nor.y*nor.y);\r\n        pr = vec2( cos(am2), sin(am2) );\r\n        vec3 tnor2 = nor;\r\n        tnor2.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor2.xz;\r\n\r\n        vec3 ref = reflect( rd, nor );\r\n        float fre = clamp( 1.0+dot( nor, rd ), 0.0 ,1.0 );\r\n\r\n        float l = fancyCube( iChannel0, tnor, 0.03, 0.0 ).x;\r\n        l += -0.1 + 0.3*fancyCube( iChannel0, tnor, 8.0, 0.0 ).x;\r\n\r\n        vec3 sea  = mix( vec3(0.0,0.07,0.2), vec3(0.0,0.01,0.3), fre );\r\n        sea *= 0.15;\r\n\r\n        vec3 land = vec3(0.02,0.04,0.0);\r\n        land = mix( land, vec3(0.05,0.1,0.0), smoothstep(0.4,1.0,fancyCube( iChannel0, tnor, 0.1, 0.0 ).x ));\r\n        land *= fancyCube( iChannel0, tnor, 0.3, 0.0 ).xyz;\r\n        land *= 0.5;\r\n\r\n        float los = smoothstep(0.45,0.46, l);\r\n        mat = mix( sea, land, los );\r\n\r\n        vec3 wrap = -1.0 + 2.0*fancyCube( iChannel1, tnor2.xzy, 0.025, 0.0 ).xyz;\r\n        float cc1 = fancyCube( iChannel1, tnor2 + 0.2*wrap, 0.05, 0.0 ).y;\r\n        float clouds = smoothstep( 0.3, 0.6, cc1 );\r\n\r\n        mat = mix( mat, vec3(0.93*0.15), clouds );\r\n\r\n        float dif = clamp( dot(nor, lig), 0.0, 1.0 );\r\n        mat *= 0.8;\r\n        vec3 lin  = vec3(3.0,2.5,2.0)*dif;\r\n        lin += 0.01;\r\n        col = mat * lin;\r\n        col = pow( col, vec3(0.4545) );\r\n        col += 0.6*fre*fre*vec3(0.9,0.9,1.0)*(0.3+0.7*dif);\r\n\r\n        float spe = clamp( dot(ref,lig), 0.0, 1.0 );\r\n        float tspe = pow( spe, 3.0 ) + 0.5*pow( spe, 16.0 );\r\n        col += (1.0-0.5*los)*clamp(1.0-2.0*clouds,0.0,1.0)*0.3*vec3(0.5,0.4,0.3)*tspe*dif;;\r\n    }\r\n    \r\n    // raymarch stuff    \r\n    float tmax = 20.0;\r\n    if( t>0.0 ) tmax = t; \r\n    t = rayMarch( ro, rd, tmax );    \r\n    if( t<tmax )\r\n    {\r\n            vec3 pos = ro + t*rd;\r\n\r\n            vec2 scp = sin(2.0*6.2831*pos.xz);\r\n            \r\n            vec3 wir = vec3( 0.0 );\r\n            wir += 1.0*exp(-12.0*abs(scp.x));\r\n            wir += 1.0*exp(-12.0*abs(scp.y));\r\n            wir += 0.5*exp( -4.0*abs(scp.x));\r\n            wir += 0.5*exp( -4.0*abs(scp.y));\r\n            wir *= 0.2 + 1.0*sphSoftShadow( pos, lig, sph1, 4.0 );\r\n\r\n            col += wir*0.5*exp( -0.05*t*t );;\r\n    }        \r\n\r\n    if( dot(rd,sph1.xyz-ro)>0.0 )\r\n    {\r\n    float d = sphDistance( ro, rd, sph1 );\r\n    vec3 glo = vec3(0.0);\r\n    glo += vec3(0.6,0.7,1.0)*0.3*exp(-2.0*abs(d))*step(0.0,d);\r\n    glo += 0.6*vec3(0.6,0.7,1.0)*0.3*exp(-8.0*abs(d));\r\n    glo += 0.6*vec3(0.8,0.9,1.0)*0.4*exp(-100.0*abs(d));\r\n    col += glo*2.0;\r\n    }        \r\n    \r\n    col *= smoothstep( 0.0, 6.0, iTime );\r\n\r\n    return col;\r\n}\r\n\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\r\n{\r\n\tvec3 cw = normalize(rt-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, -cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy +2.0*fragCoord.xy) / iResolution.y;\r\n\r\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\r\n    float an = 3.0 + 0.05*iTime + 6.0*iMouse.x/iResolution.x;\r\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\r\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\r\n    mat3 cam = setCamera( ro, rt, 0.35 );\r\n    vec3 rd = normalize( cam * vec3( p, -2.0) );\r\n\r\n    vec3 col = render( ro, rd );\r\n    \r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\r\n{\r\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\r\n    float an = 3.0 + 0.05*iTime;\r\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\r\n\r\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\r\n    mat3 cam = setCamera( ro, rt, 0.35 );\r\n    \r\n    fragColor = vec4( render( ro + cam*fragRayOri,\r\n                                   cam*fragRayDir ), 1.0 );\r\n\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":null,"published":0}],"outputs":[],"code":"// Created by inigo quilez - iq/2015\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\r\n{\r\n    vec3 colx = texture( sam, 0.5 + s*d.yz/d.x, b ).xyz;\r\n    vec3 coly = texture( sam, 0.5 + s*d.zx/d.y, b ).xyz;\r\n    vec3 colz = texture( sam, 0.5 + s*d.xy/d.z, b ).xyz;\r\n    \r\n    vec3 n = d*d;\r\n    \r\n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\r\n}\r\n\r\n\r\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\r\n\r\nvec2 voronoi( in vec2 x )\r\n{\r\n    vec2 n = floor( x );\r\n    vec2 f = fract( x );\r\n\r\n\tvec3 m = vec3( 8.0 );\r\n    for( int j=-1; j<=1; j++ )\r\n    for( int i=-1; i<=1; i++ )\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash( n + g );\r\n        vec2  r = g - f + o;\r\n\t\tfloat d = dot( r, r );\r\n        if( d<m.x )\r\n            m = vec3( d, o );\r\n    }\r\n\r\n    return vec2( sqrt(m.x), m.y+m.z );\r\n}\r\n\r\nfloat shpIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\r\n{\r\n    vec3 oc = ro - sph.xyz;\r\n    float b = dot( rd, oc );\r\n    float c = dot( oc, oc ) - sph.w*sph.w;\r\n    float h = b*b - c;\r\n    if( h>0.0 ) h = -b - sqrt( h );\r\n    return h;\r\n}\r\n\r\nfloat sphDistance( in vec3 ro, in vec3 rd, in vec4 sph )\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n    float b = dot( oc, rd );\r\n    float h = dot( oc, oc ) - b*b;\r\n    return sqrt( max(0.0,h)) - sph.w;\r\n}\r\n\r\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\r\n{\r\n    vec3 oc = sph.xyz - ro;\r\n    float b = dot( oc, rd );\r\n    float c = dot( oc, oc ) - sph.w*sph.w;\r\n    float h = b*b - c;\r\n    return (b<0.0) ? 1.0 : 1.0 - smoothstep( 0.0, 1.0, k*h/b );\r\n}    \r\n   \r\n\r\nvec3 sphNormal( in vec3 pos, in vec4 sph )\r\n{\r\n    return (pos - sph.xyz)/sph.w;    \r\n}\r\n\r\n//=======================================================\r\n\r\nvec3 background( in vec3 d, in vec3 l )\r\n{\r\n    vec3 col = vec3(0.0);\r\n         col += 0.5*pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\r\n         col += 0.2*pow( fancyCube( iChannel1, d, 0.10, 3.0 ).zyx, vec3(1.5) );\r\n         col += 0.8*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\r\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel1, d, 0.91, 0.0 ).x );\r\n\r\n    \r\n    vec3 n = abs(d);\r\n    n = n*n*n;\r\n    \r\n    vec2 vxy = voronoi( 50.0*d.xy );\r\n    vec2 vyz = voronoi( 50.0*d.yz );\r\n    vec2 vzx = voronoi( 50.0*d.zx );\r\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) / (n.x+n.y+n.z);\r\n    col += 0.9 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\r\n\r\n    col = 1.5*col - 0.2;\r\n    col += vec3(-0.05,0.1,0.0);\r\n\r\n    float s = clamp( dot(d,l), 0.0, 1.0 );\r\n    col += 0.4*pow(s,5.0)*vec3(1.0,0.7,0.6)*2.0;\r\n    col += 0.4*pow(s,64.0)*vec3(1.0,0.9,0.8)*2.0;\r\n    \r\n    return col;\r\n\r\n}\r\n\r\n//--------------------------------------------------------------------\r\n\r\nvec4 sph1 = vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\nfloat rayTrace( in vec3 ro, in vec3 rd )\r\n{\r\n    return shpIntersect( ro, rd, sph1 );\r\n}\r\n\r\nfloat map( in vec3 pos )\r\n{\r\n    vec2 r = pos.xz - sph1.xz;\r\n    float h = 1.0-2.0/(1.0 + 0.3*dot(r,r));\r\n    return pos.y - h;\r\n}\r\n\r\nfloat rayMarch( in vec3 ro, in vec3 rd, float tmax )\r\n{\r\n    float t = 0.0;\r\n    \r\n    // bounding plane\r\n    float h = (1.0-ro.y)/rd.y;\r\n    if( h>0.0 ) t=h;\r\n\r\n    // raymarch\r\n    for( int i=0; i<20; i++ )    \r\n    {        \r\n        vec3 pos = ro + t*rd;\r\n        float h = map( pos );\r\n        if( h<0.001 || t>tmax ) break;\r\n        t += h;\r\n    }\r\n    return t;    \r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 lig = normalize( vec3(1.0,0.2,1.0) );\r\n    vec3 col = background( rd, lig );\r\n    \r\n    // raytrace stuff    \r\n    float t = rayTrace( ro, rd );\r\n\r\n    if( t>0.0 )\r\n    {\r\n        vec3 mat = vec3( 0.18 );\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = sphNormal( pos, sph1 );\r\n            \r\n        float am = 0.1*iTime;\r\n        vec2 pr = vec2( cos(am), sin(am) );\r\n        vec3 tnor = nor;\r\n        tnor.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor.xz;\r\n\r\n        float am2 = 0.08*iTime - 1.0*(1.0-nor.y*nor.y);\r\n        pr = vec2( cos(am2), sin(am2) );\r\n        vec3 tnor2 = nor;\r\n        tnor2.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor2.xz;\r\n\r\n        vec3 ref = reflect( rd, nor );\r\n        float fre = clamp( 1.0+dot( nor, rd ), 0.0 ,1.0 );\r\n\r\n        float l = fancyCube( iChannel0, tnor, 0.03, 0.0 ).x;\r\n        l += -0.1 + 0.3*fancyCube( iChannel0, tnor, 8.0, 0.0 ).x;\r\n\r\n        vec3 sea  = mix( vec3(0.0,0.07,0.2), vec3(0.0,0.01,0.3), fre );\r\n        sea *= 0.15;\r\n\r\n        vec3 land = vec3(0.02,0.04,0.0);\r\n        land = mix( land, vec3(0.05,0.1,0.0), smoothstep(0.4,1.0,fancyCube( iChannel0, tnor, 0.1, 0.0 ).x ));\r\n        land *= fancyCube( iChannel0, tnor, 0.3, 0.0 ).xyz;\r\n        land *= 0.5;\r\n\r\n        float los = smoothstep(0.45,0.46, l);\r\n        mat = mix( sea, land, los );\r\n\r\n        vec3 wrap = -1.0 + 2.0*fancyCube( iChannel1, tnor2.xzy, 0.025, 0.0 ).xyz;\r\n        float cc1 = fancyCube( iChannel1, tnor2 + 0.2*wrap, 0.05, 0.0 ).y;\r\n        float clouds = smoothstep( 0.3, 0.6, cc1 );\r\n\r\n        mat = mix( mat, vec3(0.93*0.15), clouds );\r\n\r\n        float dif = clamp( dot(nor, lig), 0.0, 1.0 );\r\n        mat *= 0.8;\r\n        vec3 lin  = vec3(3.0,2.5,2.0)*dif;\r\n        lin += 0.01;\r\n        col = mat * lin;\r\n        col = pow( col, vec3(0.4545) );\r\n        col += 0.6*fre*fre*vec3(0.9,0.9,1.0)*(0.3+0.7*dif);\r\n\r\n        float spe = clamp( dot(ref,lig), 0.0, 1.0 );\r\n        float tspe = pow( spe, 3.0 ) + 0.5*pow( spe, 16.0 );\r\n        col += (1.0-0.5*los)*clamp(1.0-2.0*clouds,0.0,1.0)*0.3*vec3(0.5,0.4,0.3)*tspe*dif;;\r\n    }\r\n    \r\n    // raymarch stuff    \r\n    float tmax = 20.0;\r\n    if( t>0.0 ) tmax = t; \r\n    t = rayMarch( ro, rd, tmax );    \r\n    if( t<tmax )\r\n    {\r\n            vec3 pos = ro + t*rd;\r\n\r\n            vec2 scp = sin(2.0*6.2831*pos.xz);\r\n            \r\n            vec3 wir = vec3( 0.0 );\r\n            wir += 1.0*exp(-12.0*abs(scp.x));\r\n            wir += 1.0*exp(-12.0*abs(scp.y));\r\n            wir += 0.5*exp( -4.0*abs(scp.x));\r\n            wir += 0.5*exp( -4.0*abs(scp.y));\r\n            wir *= 0.2 + 1.0*sphSoftShadow( pos, lig, sph1, 4.0 );\r\n\r\n            col += wir*0.5*exp( -0.05*t*t );;\r\n    }        \r\n\r\n    if( dot(rd,sph1.xyz-ro)>0.0 )\r\n    {\r\n    float d = sphDistance( ro, rd, sph1 );\r\n    vec3 glo = vec3(0.0);\r\n    glo += vec3(0.6,0.7,1.0)*0.3*exp(-2.0*abs(d))*step(0.0,d);\r\n    glo += 0.6*vec3(0.6,0.7,1.0)*0.3*exp(-8.0*abs(d));\r\n    glo += 0.6*vec3(0.8,0.9,1.0)*0.4*exp(-100.0*abs(d));\r\n    col += glo*2.0;\r\n    }        \r\n    \r\n    col *= smoothstep( 0.0, 6.0, iTime );\r\n\r\n    return col;\r\n}\r\n\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\r\n{\r\n\tvec3 cw = normalize(rt-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, -cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy +2.0*fragCoord.xy) / iResolution.y;\r\n\r\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\r\n    float an = 3.0 + 0.05*iTime + 6.0*iMouse.x/iResolution.x;\r\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\r\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\r\n    mat3 cam = setCamera( ro, rt, 0.35 );\r\n    vec3 rd = normalize( cam * vec3( p, -2.0) );\r\n\r\n    vec3 col = render( ro, rd );\r\n    \r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\r\n\tfragColor = vec4( col, 1.0 );\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\r\n{\r\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\r\n    float an = 3.0 + 0.05*iTime;\r\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\r\n\r\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\r\n    mat3 cam = setCamera( ro, rt, 0.35 );\r\n    \r\n    fragColor = vec4( render( ro + cam*fragRayOri,\r\n                                   cam*fragRayDir ), 1.0 );\r\n\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Sirenian Dawn by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/XsyGWV\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n/*\r\n\tSee: https://en.wikipedia.org/wiki/Terra_Sirenum\r\n\r\n\tThings of interest in this shader:\r\n\t\t-A technique I call \"relaxation marching\", see march() function\r\n\t\t-A buffer based technique for anti-alisaing\r\n\t\t-Cheap and smooth procedural starfield\r\n\t\t-Non-constant fog from iq\r\n\t\t-Completely faked atmosphere :)\r\n\t\t-Terrain based on noise derivatives\r\n*/\r\n\r\n/*\r\n\tMore about the antialiasing:\r\n\t\tThe fragments with high enough iteration count/distance ratio \r\n\t\tget blended with the past frame, I tried a few different \r\n\t\tinput for the blend trigger: distance delta, color delta, \r\n\t\tnormal delta, scene curvature.  But none of them provides \r\n\t\tgood enough info about the problem areas to allow for proper\r\n\t\tantialiasing without making the whole scene blurry.\r\n\t\t\r\n\t\tOn the other hand iteration count (modulated by a power\r\n\t\tof distance) does a pretty good job without requiring to\r\n\t\tstore past frame info in the alpha channel (which can then\r\n\t\tbe used for something else, nothing in this case)\r\n\r\n*/\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).rgb, 1.0);\r\n}","inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":null,"published":0}],"outputs":[],"code":"// Sirenian Dawn by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/XsyGWV\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n/*\r\n\tSee: https://en.wikipedia.org/wiki/Terra_Sirenum\r\n\r\n\tThings of interest in this shader:\r\n\t\t-A technique I call \"relaxation marching\", see march() function\r\n\t\t-A buffer based technique for anti-alisaing\r\n\t\t-Cheap and smooth procedural starfield\r\n\t\t-Non-constant fog from iq\r\n\t\t-Completely faked atmosphere :)\r\n\t\t-Terrain based on noise derivatives\r\n*/\r\n\r\n/*\r\n\tMore about the antialiasing:\r\n\t\tThe fragments with high enough iteration count/distance ratio \r\n\t\tget blended with the past frame, I tried a few different \r\n\t\tinput for the blend trigger: distance delta, color delta, \r\n\t\tnormal delta, scene curvature.  But none of them provides \r\n\t\tgood enough info about the problem areas to allow for proper\r\n\t\tantialiasing without making the whole scene blurry.\r\n\t\t\r\n\t\tOn the other hand iteration count (modulated by a power\r\n\t\tof distance) does a pretty good job without requiring to\r\n\t\tstore past frame info in the alpha channel (which can then\r\n\t\tbe used for something else, nothing in this case)\r\n\r\n*/\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).rgb, 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":null,"published":0}],"Info":{"Name":"Sirenian Dawn","id":null,"date":null,"viewed":0,"name":"Sirenian Dawn","description":"Experiments in raymarched terrain rendering.","likes":0,"published":null,"tags":[" fog"," mars"," aa"," atmosphere"," dawn"]},"ver":null,"info":{"Name":"Sirenian Dawn","id":null,"date":null,"viewed":0,"name":"Sirenian Dawn","description":"Experiments in raymarched terrain rendering.","likes":0,"published":null,"tags":[" fog"," mars"," aa"," atmosphere"," dawn"]},"renderpass":[{"Code":"// Sirenian Dawn by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/XsyGWV\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n/*\r\n\tSee: https://en.wikipedia.org/wiki/Terra_Sirenum\r\n\r\n\tThings of interest in this shader:\r\n\t\t-A technique I call \"relaxation marching\", see march() function\r\n\t\t-A buffer based technique for anti-alisaing\r\n\t\t-Cheap and smooth procedural starfield\r\n\t\t-Non-constant fog from iq\r\n\t\t-Completely faked atmosphere :)\r\n\t\t-Terrain based on noise derivatives\r\n*/\r\n\r\n/*\r\n\tMore about the antialiasing:\r\n\t\tThe fragments with high enough iteration count/distance ratio \r\n\t\tget blended with the past frame, I tried a few different \r\n\t\tinput for the blend trigger: distance delta, color delta, \r\n\t\tnormal delta, scene curvature.  But none of them provides \r\n\t\tgood enough info about the problem areas to allow for proper\r\n\t\tantialiasing without making the whole scene blurry.\r\n\t\t\r\n\t\tOn the other hand iteration count (modulated by a power\r\n\t\tof distance) does a pretty good job without requiring to\r\n\t\tstore past frame info in the alpha channel (which can then\r\n\t\tbe used for something else, nothing in this case)\r\n\r\n*/\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).rgb, 1.0);\r\n}","inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":null,"published":0}],"outputs":[],"code":"// Sirenian Dawn by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/XsyGWV\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n/*\r\n\tSee: https://en.wikipedia.org/wiki/Terra_Sirenum\r\n\r\n\tThings of interest in this shader:\r\n\t\t-A technique I call \"relaxation marching\", see march() function\r\n\t\t-A buffer based technique for anti-alisaing\r\n\t\t-Cheap and smooth procedural starfield\r\n\t\t-Non-constant fog from iq\r\n\t\t-Completely faked atmosphere :)\r\n\t\t-Terrain based on noise derivatives\r\n*/\r\n\r\n/*\r\n\tMore about the antialiasing:\r\n\t\tThe fragments with high enough iteration count/distance ratio \r\n\t\tget blended with the past frame, I tried a few different \r\n\t\tinput for the blend trigger: distance delta, color delta, \r\n\t\tnormal delta, scene curvature.  But none of them provides \r\n\t\tgood enough info about the problem areas to allow for proper\r\n\t\tantialiasing without making the whole scene blurry.\r\n\t\t\r\n\t\tOn the other hand iteration count (modulated by a power\r\n\t\tof distance) does a pretty good job without requiring to\r\n\t\tstore past frame info in the alpha channel (which can then\r\n\t\tbe used for something else, nothing in this case)\r\n\r\n*/\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).rgb, 1.0);\r\n}","name":"Image","description":null,"type":"image"},{"Code":"//Sirenian Dawn by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/XsyGWV\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n\r\n#define ITR 90\r\n#define FAR 400.\r\n#define time iTime\r\n\r\nconst vec3 lgt = vec3(-.523, .41, -.747);\r\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\n//form iq, see: http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\r\nvec3 noised( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\tfloat a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\r\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\r\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\r\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\r\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\n\r\nfloat terrain( in vec2 p)\r\n{\r\n    float rz = 0.;\r\n    float z = 1.;\r\n\tvec2  d = vec2(0.0);\r\n    float scl = 2.95;\r\n    float zscl = -.4;\r\n    float zz = 5.;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        vec3 n = noised(p);\r\n        d += pow(abs(n.yz),vec2(zz));\r\n        d -= smoothstep(-.5,1.5,n.yz);\r\n        zz -= 1.;\r\n        rz += z*n.x/(dot(d,d)+.85);\r\n        z *= zscl;\r\n        zscl *= .8;\r\n        p = m2*p*scl;\r\n    }\r\n    \r\n    rz /= smoothstep(1.5,-.5,rz)+.75;\r\n    return rz;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    return p.y-(terrain(p.zx*0.07))*2.7-1.;\r\n}\r\n\r\n/*\tThe idea is simple, as the ray gets further from the eye, I increase \r\n\tthe step size of the raymarching and lower the target precision, \r\n\tthis allows for better performance with virtually no loss in visual quality. */\r\nfloat march(in vec3 ro, in vec3 rd, out float itrc)\r\n{\r\n    float t = 0.;\r\n    float d = map(rd*t+ro);\r\n    float precis = 0.0001;\r\n    for (int i=0;i<=ITR;i++)\r\n    {\r\n        if (abs(d) < precis || t > FAR) break;\r\n        precis = t*0.0001;\r\n        float rl = max(t*0.02,1.);\r\n        t += d*rl;\r\n        d = map(rd*t+ro)*0.7;\r\n        itrc++;\r\n    }\r\n\r\n    return t;\r\n}\r\n\r\nvec3 rotx(vec3 p, float a){\r\n    float s = sin(a), c = cos(a);\r\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\r\n}\r\n\r\nvec3 roty(vec3 p, float a){\r\n    float s = sin(a), c = cos(a);\r\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\r\n}\r\n\r\nvec3 rotz(vec3 p, float a){\r\n    float s = sin(a), c = cos(a);\r\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\r\n}\r\n\r\nvec3 normal(in vec3 p, in float ds)\r\n{  \r\n    vec2 e = vec2(-1., 1.)*0.0005*pow(ds,1.);\r\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \r\n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \r\n}\r\n\r\nfloat noise(in vec2 x){return texture(iChannel0, x*.01).x;}\r\nfloat fbm(in vec2 p)\r\n{\t\r\n\tfloat z=.5;\r\n\tfloat rz = 0.;\r\n\tfor (float i= 0.;i<3.;i++ )\r\n\t{\r\n        rz+= (sin(noise(p)*5.)*0.5+0.5) *z;\r\n\t\tz *= 0.5;\r\n\t\tp = p*2.;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\nfloat bnoise(in vec2 p){ return fbm(p*3.); }\r\nvec3 bump(in vec3 p, in vec3 n, in float ds)\r\n{\r\n    vec2 e = vec2(0.005*ds,0);\r\n    float n0 = bnoise(p.zx);\r\n    vec3 d = vec3(bnoise(p.zx+e.xy)-n0, 1., bnoise(p.zx+e.yx)-n0)/e.x*0.025;\r\n    d -= n*dot(n,d);\r\n    n = normalize(n-d);\r\n    return n;\r\n}\r\n\r\nfloat curv(in vec3 p, in float w)\r\n{\r\n    vec2 e = vec2(-1., 1.)*w;   \r\n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\r\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\r\n    return .15/e.y *(t1 + t2 + t3 + t4 - 4. * map(p));\r\n}\r\n\r\n//Based on: http://www.iquilezles.org/www/articles/fog/fog.htm\r\nvec3 fog(vec3 ro, vec3 rd, vec3 col, float ds)\r\n{\r\n    vec3 pos = ro + rd*ds;\r\n    float mx = (fbm(pos.zx*0.1-time*0.05)-0.5)*.2;\r\n    \r\n    const float b= 1.;\r\n    float den = 0.3*exp(-ro.y*b)*(1.0-exp( -ds*rd.y*b ))/rd.y;\r\n    float sdt = max(dot(rd, lgt), 0.);\r\n    vec3  fogColor  = mix(vec3(0.5,0.2,0.15)*1.2, vec3(1.1,0.6,0.45)*1.3, pow(sdt,2.0)+mx*0.5);\r\n    return mix( col, fogColor, clamp(den + mx,0.,1.) );\r\n}\r\n\r\nfloat linstep(in float mn, in float mx, in float x){\r\n\treturn clamp((x - mn)/(mx - mn), 0., 1.);\r\n}\r\n\r\n//Complete hack, but looks good enough :)\r\nvec3 scatter(vec3 ro, vec3 rd)\r\n{   \r\n    float sd= max(dot(lgt, rd)*0.5+0.5,0.);\r\n    float dtp = 13.-(ro + rd*(FAR)).y*3.5;\r\n    float hori = (linstep(-1500., 0.0, dtp) - linstep(11., 500., dtp))*1.;\r\n    hori *= pow(sd,.04);\r\n    \r\n    vec3 col = vec3(0);\r\n    col += pow(hori, 200.)*vec3(1.0, 0.7,  0.5)*3.;\r\n    col += pow(hori, 25.)* vec3(1.0, 0.5,  0.25)*.3;\r\n    col += pow(hori, 7.)* vec3(1.0, 0.4, 0.25)*.8;\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 nmzHash33(vec3 q)\r\n{\r\n    uvec3 p = uvec3(ivec3(q));\r\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\r\n    p = p.yzx*(p.zxy^(p >> 3U));\r\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\r\n}\r\n\r\n//Very happy with this star function, cheap and smooth\r\nvec3 stars(in vec3 p)\r\n{\r\n    vec3 c = vec3(0.);\r\n    float res = iResolution.x*0.8;\r\n    \r\n\tfor (float i=0.;i<3.;i++)\r\n    {\r\n        vec3 q = fract(p*(.15*res))-0.5;\r\n        vec3 id = floor(p*(.15*res));\r\n        vec2 rn = nmzHash33(id).xy;\r\n        float c2 = 1.-smoothstep(0.,.6,length(q));\r\n        c2 *= step(rn.x,.0005+i*i*0.001);\r\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\r\n        p *= 1.4;\r\n    }\r\n    return c*c*.7;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\t\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = q - 0.5;\r\n\tp.x*=iResolution.x/iResolution.y;\r\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\r\n    mo = (mo==vec2(-.5))?mo=vec2(-.2,0.3):mo;\r\n    mo.x *= 1.2;\r\n    mo -= vec2(1.2,-0.1);\r\n\tmo.x *= iResolution.x/iResolution.y;\r\n    mo.x += sin(time*0.15)*0.2;\r\n\t\r\n    vec3 ro = vec3(650., sin(time*0.2)*0.25+10.,-time);\r\n    vec3 eye = normalize(vec3(cos(mo.x),-0.5+mo.y,sin(mo.x)));\r\n    vec3 right = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\r\n    vec3 up = normalize(cross(right, eye));\r\n\tvec3 rd = normalize((p.x*right + p.y*up)*1.05 + eye);\r\n    rd.y += abs(p.x*p.x*0.015);\r\n    rd = normalize(rd);\r\n\t\r\n    float count = 0.;\r\n\tfloat rz = march(ro,rd, count);\r\n    \r\n    vec3 scatt = scatter(ro, rd);\r\n    \r\n    vec3 bg = stars(rd)*(1.0-clamp(dot(scatt, vec3(1.3)),0.,1.));\r\n    vec3 col = bg;\r\n    \r\n    vec3 pos = ro+rz*rd;\r\n    vec3 nor= normal( pos, rz );\r\n    if ( rz < FAR )\r\n    {\r\n        nor = bump(pos,nor,rz);\r\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\r\n        float dif = clamp( dot( nor, lgt ), 0.0, 1.0 );\r\n        float bac = clamp( dot( nor, normalize(vec3(-lgt.x,0.0,-lgt.z))), 0.0, 1.0 );\r\n        float spe = pow(clamp( dot( reflect(rd,nor), lgt ), 0.0, 1.0 ),500.);\r\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\r\n        vec3 brdf = 1.*amb*vec3(0.10,0.11,0.12);\r\n        brdf += bac*vec3(0.15,0.05,0.04);\r\n        brdf += 2.3*dif*vec3(.9,0.4,0.25);\r\n        col = vec3(0.25,0.25,0.3);\r\n        float crv = curv(pos, 2.)*1.;\r\n        float crv2 = curv(pos, .4)*2.5;\r\n        \r\n        col += clamp(crv*0.9,-1.,1.)*vec3(0.25,.6,.5);\r\n        col = col*brdf + col*spe*.1 +.1*fre*col;\r\n        col *= crv*1.+1.;\r\n        col *= crv2*1.+1.;\r\n    }\r\n\t\r\n    col = fog(ro, rd, col, rz);\r\n    col = mix(col,bg,smoothstep(FAR-150., FAR, rz));\r\n    col += scatt;\r\n    \r\n    col = pow( col, vec3(0.93,1.0,1.0) );\r\n    col = mix(col, smoothstep(0.,1.,col), 0.2);\r\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.9+0.1;\r\n    \r\n    vec4 past = texture(iChannel1, q);\r\n    float tOver = clamp(iTimeDelta-(1./60.),0.,1.);\r\n    \r\n    //if (count/pow(rz, 0.65) > 3.3) col = mix(col, past.rgb, clamp(1.0-iResolution.x*0.0003,0.,1.));\r\n    if (count/pow(rz, 0.65) > 3.3) col = mix(col, past.rgb, clamp(0.85-iTimeDelta*7.,0.,1.));\r\n    \r\n\tfragColor = vec4(col, 1.0);\r\n}","inputs":[],"outputs":[],"code":"//Sirenian Dawn by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/XsyGWV\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n\r\n#define ITR 90\r\n#define FAR 400.\r\n#define time iTime\r\n\r\nconst vec3 lgt = vec3(-.523, .41, -.747);\r\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\n//form iq, see: http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\r\nvec3 noised( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\tfloat a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\r\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\r\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\r\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\r\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\n\r\nfloat terrain( in vec2 p)\r\n{\r\n    float rz = 0.;\r\n    float z = 1.;\r\n\tvec2  d = vec2(0.0);\r\n    float scl = 2.95;\r\n    float zscl = -.4;\r\n    float zz = 5.;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        vec3 n = noised(p);\r\n        d += pow(abs(n.yz),vec2(zz));\r\n        d -= smoothstep(-.5,1.5,n.yz);\r\n        zz -= 1.;\r\n        rz += z*n.x/(dot(d,d)+.85);\r\n        z *= zscl;\r\n        zscl *= .8;\r\n        p = m2*p*scl;\r\n    }\r\n    \r\n    rz /= smoothstep(1.5,-.5,rz)+.75;\r\n    return rz;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    return p.y-(terrain(p.zx*0.07))*2.7-1.;\r\n}\r\n\r\n/*\tThe idea is simple, as the ray gets further from the eye, I increase \r\n\tthe step size of the raymarching and lower the target precision, \r\n\tthis allows for better performance with virtually no loss in visual quality. */\r\nfloat march(in vec3 ro, in vec3 rd, out float itrc)\r\n{\r\n    float t = 0.;\r\n    float d = map(rd*t+ro);\r\n    float precis = 0.0001;\r\n    for (int i=0;i<=ITR;i++)\r\n    {\r\n        if (abs(d) < precis || t > FAR) break;\r\n        precis = t*0.0001;\r\n        float rl = max(t*0.02,1.);\r\n        t += d*rl;\r\n        d = map(rd*t+ro)*0.7;\r\n        itrc++;\r\n    }\r\n\r\n    return t;\r\n}\r\n\r\nvec3 rotx(vec3 p, float a){\r\n    float s = sin(a), c = cos(a);\r\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\r\n}\r\n\r\nvec3 roty(vec3 p, float a){\r\n    float s = sin(a), c = cos(a);\r\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\r\n}\r\n\r\nvec3 rotz(vec3 p, float a){\r\n    float s = sin(a), c = cos(a);\r\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\r\n}\r\n\r\nvec3 normal(in vec3 p, in float ds)\r\n{  \r\n    vec2 e = vec2(-1., 1.)*0.0005*pow(ds,1.);\r\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \r\n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \r\n}\r\n\r\nfloat noise(in vec2 x){return texture(iChannel0, x*.01).x;}\r\nfloat fbm(in vec2 p)\r\n{\t\r\n\tfloat z=.5;\r\n\tfloat rz = 0.;\r\n\tfor (float i= 0.;i<3.;i++ )\r\n\t{\r\n        rz+= (sin(noise(p)*5.)*0.5+0.5) *z;\r\n\t\tz *= 0.5;\r\n\t\tp = p*2.;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\nfloat bnoise(in vec2 p){ return fbm(p*3.); }\r\nvec3 bump(in vec3 p, in vec3 n, in float ds)\r\n{\r\n    vec2 e = vec2(0.005*ds,0);\r\n    float n0 = bnoise(p.zx);\r\n    vec3 d = vec3(bnoise(p.zx+e.xy)-n0, 1., bnoise(p.zx+e.yx)-n0)/e.x*0.025;\r\n    d -= n*dot(n,d);\r\n    n = normalize(n-d);\r\n    return n;\r\n}\r\n\r\nfloat curv(in vec3 p, in float w)\r\n{\r\n    vec2 e = vec2(-1., 1.)*w;   \r\n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\r\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\r\n    return .15/e.y *(t1 + t2 + t3 + t4 - 4. * map(p));\r\n}\r\n\r\n//Based on: http://www.iquilezles.org/www/articles/fog/fog.htm\r\nvec3 fog(vec3 ro, vec3 rd, vec3 col, float ds)\r\n{\r\n    vec3 pos = ro + rd*ds;\r\n    float mx = (fbm(pos.zx*0.1-time*0.05)-0.5)*.2;\r\n    \r\n    const float b= 1.;\r\n    float den = 0.3*exp(-ro.y*b)*(1.0-exp( -ds*rd.y*b ))/rd.y;\r\n    float sdt = max(dot(rd, lgt), 0.);\r\n    vec3  fogColor  = mix(vec3(0.5,0.2,0.15)*1.2, vec3(1.1,0.6,0.45)*1.3, pow(sdt,2.0)+mx*0.5);\r\n    return mix( col, fogColor, clamp(den + mx,0.,1.) );\r\n}\r\n\r\nfloat linstep(in float mn, in float mx, in float x){\r\n\treturn clamp((x - mn)/(mx - mn), 0., 1.);\r\n}\r\n\r\n//Complete hack, but looks good enough :)\r\nvec3 scatter(vec3 ro, vec3 rd)\r\n{   \r\n    float sd= max(dot(lgt, rd)*0.5+0.5,0.);\r\n    float dtp = 13.-(ro + rd*(FAR)).y*3.5;\r\n    float hori = (linstep(-1500., 0.0, dtp) - linstep(11., 500., dtp))*1.;\r\n    hori *= pow(sd,.04);\r\n    \r\n    vec3 col = vec3(0);\r\n    col += pow(hori, 200.)*vec3(1.0, 0.7,  0.5)*3.;\r\n    col += pow(hori, 25.)* vec3(1.0, 0.5,  0.25)*.3;\r\n    col += pow(hori, 7.)* vec3(1.0, 0.4, 0.25)*.8;\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 nmzHash33(vec3 q)\r\n{\r\n    uvec3 p = uvec3(ivec3(q));\r\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\r\n    p = p.yzx*(p.zxy^(p >> 3U));\r\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\r\n}\r\n\r\n//Very happy with this star function, cheap and smooth\r\nvec3 stars(in vec3 p)\r\n{\r\n    vec3 c = vec3(0.);\r\n    float res = iResolution.x*0.8;\r\n    \r\n\tfor (float i=0.;i<3.;i++)\r\n    {\r\n        vec3 q = fract(p*(.15*res))-0.5;\r\n        vec3 id = floor(p*(.15*res));\r\n        vec2 rn = nmzHash33(id).xy;\r\n        float c2 = 1.-smoothstep(0.,.6,length(q));\r\n        c2 *= step(rn.x,.0005+i*i*0.001);\r\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\r\n        p *= 1.4;\r\n    }\r\n    return c*c*.7;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\t\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = q - 0.5;\r\n\tp.x*=iResolution.x/iResolution.y;\r\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\r\n    mo = (mo==vec2(-.5))?mo=vec2(-.2,0.3):mo;\r\n    mo.x *= 1.2;\r\n    mo -= vec2(1.2,-0.1);\r\n\tmo.x *= iResolution.x/iResolution.y;\r\n    mo.x += sin(time*0.15)*0.2;\r\n\t\r\n    vec3 ro = vec3(650., sin(time*0.2)*0.25+10.,-time);\r\n    vec3 eye = normalize(vec3(cos(mo.x),-0.5+mo.y,sin(mo.x)));\r\n    vec3 right = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\r\n    vec3 up = normalize(cross(right, eye));\r\n\tvec3 rd = normalize((p.x*right + p.y*up)*1.05 + eye);\r\n    rd.y += abs(p.x*p.x*0.015);\r\n    rd = normalize(rd);\r\n\t\r\n    float count = 0.;\r\n\tfloat rz = march(ro,rd, count);\r\n    \r\n    vec3 scatt = scatter(ro, rd);\r\n    \r\n    vec3 bg = stars(rd)*(1.0-clamp(dot(scatt, vec3(1.3)),0.,1.));\r\n    vec3 col = bg;\r\n    \r\n    vec3 pos = ro+rz*rd;\r\n    vec3 nor= normal( pos, rz );\r\n    if ( rz < FAR )\r\n    {\r\n        nor = bump(pos,nor,rz);\r\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\r\n        float dif = clamp( dot( nor, lgt ), 0.0, 1.0 );\r\n        float bac = clamp( dot( nor, normalize(vec3(-lgt.x,0.0,-lgt.z))), 0.0, 1.0 );\r\n        float spe = pow(clamp( dot( reflect(rd,nor), lgt ), 0.0, 1.0 ),500.);\r\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\r\n        vec3 brdf = 1.*amb*vec3(0.10,0.11,0.12);\r\n        brdf += bac*vec3(0.15,0.05,0.04);\r\n        brdf += 2.3*dif*vec3(.9,0.4,0.25);\r\n        col = vec3(0.25,0.25,0.3);\r\n        float crv = curv(pos, 2.)*1.;\r\n        float crv2 = curv(pos, .4)*2.5;\r\n        \r\n        col += clamp(crv*0.9,-1.,1.)*vec3(0.25,.6,.5);\r\n        col = col*brdf + col*spe*.1 +.1*fre*col;\r\n        col *= crv*1.+1.;\r\n        col *= crv2*1.+1.;\r\n    }\r\n\t\r\n    col = fog(ro, rd, col, rz);\r\n    col = mix(col,bg,smoothstep(FAR-150., FAR, rz));\r\n    col += scatt;\r\n    \r\n    col = pow( col, vec3(0.93,1.0,1.0) );\r\n    col = mix(col, smoothstep(0.,1.,col), 0.2);\r\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.9+0.1;\r\n    \r\n    vec4 past = texture(iChannel1, q);\r\n    float tOver = clamp(iTimeDelta-(1./60.),0.,1.);\r\n    \r\n    //if (count/pow(rz, 0.65) > 3.3) col = mix(col, past.rgb, clamp(1.0-iResolution.x*0.0003,0.,1.));\r\n    if (count/pow(rz, 0.65) > 3.3) col = mix(col, past.rgb, clamp(0.85-iTimeDelta*7.,0.,1.));\r\n    \r\n\tfragColor = vec4(col, 1.0);\r\n}","name":"Buf A","description":null,"type":null}]},{"Ver":null,"ImageRenderpass":{"Code":"/*\r\n\tBefore you continue reading, feast your eyes on these beautiful Color Schemes (0,1,2)\r\n*/\r\n\r\n// Modify the number to 0,1,2 or 3 and press play button at bottom for different schemes.\r\n#define COLOR_SCHEME 1\r\n\r\n/*\r\n\tThis shader is just a tribute to \"Journey\" game by That Game Company. Some answers:\r\n\t1) No, I do not have any affiliation with That Game Company.\r\n\t2) Yes, Journey is one of the best games ever made\r\n\t3) It has taken me around 3-4 months from start to finish, evenings and weekends\r\n\t4) Most of the time was spent getting the details right\r\n\t5) Yes, the character needs more work. One day I will finish it\r\n\t6) Yes, if anybody comes up with something cool to add, I would love to improve :)\r\n\t7) There is nothing mathemagically amazing in this shader. I hope you do find it pretty though!\r\n\t8) Yes, the code is fairly ugly. But look at the colors - PRETTY!\r\n\t9) If you have any other questions, I will be happy to answer\r\n\r\n\tThis shader started as a learning playground, but around January, I finished my second round of Journey\r\n\tand thought, well why the hell not, and so here we are.\r\n\r\n\tSpecial thanks to Thibault Girard and Jack Hamilton for their artistic input. Also bigs up to Peter Pimley\r\n\tfor his constant optimism.\r\n\r\n\tYou are hereby granted your wish to follow me on twitter: @shakemayster\r\n\r\n\tOther authors (With BIG thanks !!!) \r\n\tDave_Hoskins\r\n\tDila\r\n\tMaurogik\r\n\tFabriceNeyret2\r\n*/\r\n\r\n#define RGB vec3\r\n#define mul(a,b) b*a\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n\r\n\r\n#if COLOR_SCHEME == 0\r\nconst float _FogMul = -0.00100 ;\r\nconst float _FogPow = 1.82000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.22632, 0.88099, -0.4155) ;\r\nconst float _Brightness = 1.00000 ;\r\nconst float _Contrast = 1.00000 ;\r\nconst float _Saturation = 1.00000 ;\r\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\r\nconst float _SunSize = 26.00000 ;\r\nconst float _SunScale = 15.00000 ;\r\nconst float _ExposureOffset = 11.10000 ;\r\nconst float _ExposurePower = 0.52000 ;\r\nconst float _ExposureStrength = 0.09000 ;\r\nconst RGB _SunColor = RGB(1, 0.73741, 0.63971) ;\r\nconst RGB _Zenith = RGB(0.67128, 0.94118, 0.69204) ;\r\nconst float _ZenithFallOff = 1.42000 ;\r\nconst RGB _Nadir = RGB(0, 0, 0) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.80147, 0.80147, 0.80147) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.57353, 0.1488, 0.067474) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.375, 0.21885, 0.15993) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.38971, 0.10735, 0.054444) ;\r\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.35588, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\r\nconst float _CharacterBloomScale = 0.87000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 3.84000 ;\r\nconst float _CharacterFogScale = 20.00000 ;\r\nconst float _CloudTransparencyMul = 0.90000 ;\r\nconst RGB _CloudCol = RGB(1, 0.96957, 0.88235) ;\r\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\r\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.47735, 0.59559, 0.49705) ;\r\nconst RGB _TombScarfColor = RGB(0.45588, 0.093858, 0.093858) ;\r\nconst RGB _PyramidCol = RGB(0.30147, 0.28329, 0.21059) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.05) ;\r\nconst RGB _TerrainCol = RGB(0.76863, 0.55294, 0.47059) ;\r\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 1.56000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 1.94000 ;\r\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 2.00000 ;\r\nconst float _TerrainRimSpecPower = 1.46000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.40441, 0.34106, 0.31818) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.81471, 0.74265) ;\r\nconst float _TerrainDistanceShadowPower = 0.11000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.80882, 0.11671, 0.017842) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.56187, 0.0073529) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 1.91000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 4.00000 ;\r\n#endif\r\n\r\n#if COLOR_SCHEME == 1\r\nconst float _FogMul = -0.00800 ;\r\nconst float _FogPow = 1.00000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\r\nconst float _Brightness = 0.40000 ;\r\nconst float _Contrast = 0.83000 ;\r\nconst float _Saturation = 1.21000 ;\r\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\r\nconst float _SunSize = 26.00000 ;\r\nconst float _SunScale = 15.00000 ;\r\nconst float _ExposureOffset = 11.10000 ;\r\nconst float _ExposurePower = 0.52000 ;\r\nconst float _ExposureStrength = 0.09000 ;\r\nconst RGB _SunColor = RGB(1, 0.95441, 0.77206) ;\r\nconst RGB _Zenith = RGB(0.77941, 0.5898, 0.41263) ;\r\nconst float _ZenithFallOff = 2.36000 ;\r\nconst RGB _Nadir = RGB(1, 0.93103, 0) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.96324, 0.80163, 0.38954) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.35294, 0.16016, 0.12197) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.25735, 0.028557, 0.0056769) ;\r\nconst RGB _CharacterYellowColor = RGB(0.88971, 0.34975, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(0.9928, 1, 0.47794) ;\r\nconst float _CharacterBloomScale = 0.70000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 3.84000 ;\r\nconst float _CharacterFogScale = 4.55000 ;\r\nconst float _CloudTransparencyMul = 0.90000 ;\r\nconst RGB _CloudCol = RGB(1, 0.84926, 0.69853) ;\r\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\r\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.64706, 0.38039, 0.27451) ;\r\nconst RGB _TombScarfColor = RGB(0.38971, 0.10029, 0.10029) ;\r\nconst RGB _PyramidCol = RGB(0.69853, 0.40389, 0.22086) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.3) ;\r\nconst RGB _TerrainCol = RGB(0.56618, 0.29249, 0.1915) ;\r\nconst RGB _TerrainSpecColor = RGB(1, 0.77637, 0.53676) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 1.56000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 3.20000 ;\r\nconst RGB _TerrainRimColor = RGB(0.16176, 0.13131, 0.098724) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 1.61000 ;\r\nconst float _TerrainRimSpecPower = 2.88000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.48529, 0.13282, 0) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(0.70588, 0.4644, 0.36851) ;\r\nconst float _TerrainDistanceShadowPower = 0.11000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.85294, 0.11759, 0.012543) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.3931, 0) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 2.61000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 1.75000 ;\r\n#endif\r\n\r\n#if COLOR_SCHEME == 2\r\nconst float _FogMul = -0.00100 ;\r\nconst float _FogPow = 1.68000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\r\nconst float _Brightness = 0.40000 ;\r\nconst float _Contrast = 0.82000 ;\r\nconst float _Saturation = 1.21000 ;\r\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\r\nconst float _SunSize = 26.00000 ;\r\nconst float _SunScale = 15.00000 ;\r\nconst float _ExposureOffset = 11.10000 ;\r\nconst float _ExposurePower = 0.52000 ;\r\nconst float _ExposureStrength = 0.09000 ;\r\nconst RGB _SunColor = RGB(0.97059, 0.97059, 0.97059) ;\r\nconst RGB _Zenith = RGB(0.98039, 0.83137, 0.53725) ;\r\nconst float _ZenithFallOff = 2.36000 ;\r\nconst RGB _Nadir = RGB(0, 0, 0) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.84559, 0.77688, 0.6031) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.5, 0.3404, 0.12868) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.31618, 0.14042, 0.039522) ;\r\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.30233, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\r\nconst float _CharacterBloomScale = 0.87000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 3.84000 ;\r\nconst float _CharacterFogScale = 12.47000 ;\r\nconst float _CloudTransparencyMul = 0.80000 ;\r\nconst RGB _CloudCol = RGB(0.99216, 0.9451, 0.76471) ;\r\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\r\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.94118, 0.82759, 0.45675) ;\r\nconst RGB _TombScarfColor = RGB(0.44118, 0.19989, 0.14922) ;\r\nconst RGB _PyramidCol = RGB(0.92647, 0.73579, 0.3338) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 4.65) ;\r\nconst RGB _TerrainCol = RGB(0.71324, 0.5076, 0.236) ;\r\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 0.03000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 3.20000 ;\r\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 1.61000 ;\r\nconst float _TerrainRimSpecPower = 0.38000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.66912, 0.52969, 0.369) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.75466, 0.43382) ;\r\nconst float _TerrainDistanceShadowPower = 0.11000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.91912, 0.30412, 0.21626) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(0.98529, 0.60477, 0.12316) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 1.91000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 4.00000 ;\r\n#endif\r\n\r\n#if COLOR_SCHEME == 3\r\nconst float _FogMul = -0.00100 ;\r\nconst float _FogPow = 1.82000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.29644, 0.6859, -0.66458) ;\r\nconst float _Brightness = 1.00000 ;\r\nconst float _Contrast = 1.00000 ;\r\nconst float _Saturation = 1.00000 ;\r\nconst vec3 _SunStar = vec3(20.45, 1.49, 0.5) ;\r\nconst float _SunSize = 26.09000 ;\r\nconst float _SunScale = 15.04000 ;\r\nconst float _ExposureOffset = 13.72000 ;\r\nconst float _ExposurePower = 0.60000 ;\r\nconst float _ExposureStrength = 0.02000 ;\r\nconst RGB _SunColor = RGB(0.51471, 0.79919, 1) ;\r\nconst RGB _Zenith = RGB(0, 0.053922, 0.16176) ;\r\nconst float _ZenithFallOff = 1.42000 ;\r\nconst RGB _Nadir = RGB(0.21569, 0.2549, 0.36078) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.35191, 0.30223, 0.47794) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.36765, 0.097656, 0.045956) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.083261, 0.11379, 0.16176) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.073529, 0.011604, 0) ;\r\nconst RGB _CharacterYellowColor = RGB(0.60294, 0.33162, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\r\nconst float _CharacterBloomScale = 0.87000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 19.83000 ;\r\nconst float _CharacterFogScale = 60.00000 ;\r\nconst float _CloudTransparencyMul = 0.90000 ;\r\nconst RGB _CloudCol = RGB(0.0069204, 0.15969, 0.23529) ;\r\nconst RGB _BackCloudCol = RGB(0, 0.10969, 0.15441) ;\r\nconst RGB _CloudSpecCol = RGB(0.11765, 0.11765, 0.11765) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.080882, 0.080882, 0.080882) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.23789, 0.27707, 0.40441) ;\r\nconst RGB _TombScarfColor = RGB(0.066176, 0, 0.034229) ;\r\nconst RGB _PyramidCol = RGB(0, 0, 0) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.92) ;\r\nconst RGB _TerrainCol = RGB(0, 0.058832, 0.10294) ;\r\nconst RGB _TerrainSpecColor = RGB(0.24622, 0.29188, 0.33824) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 1.56000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 1.94000 ;\r\nconst RGB _TerrainRimColor = RGB(0.091021, 0.057093, 0.16176) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 2.00000 ;\r\nconst float _TerrainRimSpecPower = 1.46000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.37) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.11029, 0.11029, 0.11029) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(0.0034061, 0.073181, 0.15441) ;\r\nconst float _TerrainDistanceShadowPower = 0.06000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.12661, 0.004109, 0.13971) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(0.48529, 0.2711, 0) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 1.91000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 5.51000 ;\r\n#endif\r\n\r\n//==========================================================================================\r\n// Play with these at your own risk. Expect, unexpected results!\r\n//==========================================================================================\r\n\r\nconst mat4 _CameraInvViewMatrix = mat4( 1, 0, 0, 1.04, \r\n0, 0.9684963, 0.2490279, 2.2, \r\n0, 0.2490279, -0.9684963, 18.6, \r\n0, 0, 0, 1 ) ;\r\nconst vec3 _CameraFOV = vec3(1.038, 0.78984, -1) ;\r\nconst vec3 _CameraPos = vec3(1.0, 2.2, 18.6) ;\r\nconst vec4 _CameraMovement = vec4(0.15, 0.1, 0.2, 0.25) ;\r\n\r\nconst vec3 _WindDirection = vec3(-0.27, -0.12, 0) ;\r\n\r\nconst float _DrawDistance = 70.00000 ;\r\nconst float _MaxSteps = 64.00000 ;\r\n\r\nconst vec3 _SunPosition = vec3(0.2, 56, -40.1) ;\r\nconst float _CharacterRotation = 0.17000 ;\r\nconst vec3 _CharacterPosition = vec3(0.52, 2.35, 17.6) ;\r\nconst vec3 _CharacterScale = vec3(0.4, 0.53, 0.38) ;\r\nconst float _MainClothRotation = 0.30000 ;\r\nconst vec3 _MainClothScale = vec3(0.3, 0.68, 0.31) ;\r\nconst vec3 _MainClothPosition = vec3(0, -0.12, 0) ;\r\nconst vec3 _MainClothBotCutPos = vec3(0, -0.52, 0) ;\r\nconst vec3 _MainClothDetail = vec3(6, 0.04, 1.3) ;\r\nconst float _HeadScarfRotation = -0.19000 ;\r\nconst vec3 _HeadScarfPosition = vec3(-0.005, -0.16, -0.01) ;\r\nconst vec3 _HeadScarfScale = vec3(0.18, 0.2, 0.03) ;\r\nconst float _HeadRotationX = -0.30000 ;\r\nconst float _HeadRotationY = 0.29000 ;\r\nconst float _HeadRotationZ = 0.00000 ;\r\nconst vec3 _HeadPos = vec3(0, -0.04, 0.01) ;\r\nconst vec3 _LongScarfPos = vec3(0.01, -0.15, 0.09) ;\r\nconst vec3 _LongScarfScale = vec3(0.05, 1.25, 0.001) ;\r\nconst vec4 _LongScarfWindStrength = vec4(0.3, 4.52, 5.2, 0.02) ;\r\nconst float _LongScarfRotX = 1.43000 ;\r\nconst float _LongScarfMaxRad = 1.99000 ;\r\nconst vec3 _FacePosition = vec3(0, -0.01, 0.05) ;\r\nconst vec3 _FaceSize = vec3(0.038, 0.05, 0.03) ;\r\nconst vec3 _UpperLeftLegA = vec3(-0.02, -0.37, 0.01) ;\r\nconst vec3 _UpperLeftLegB = vec3(-0.02, -0.67, -0.059999) ;\r\nconst vec3 _UpperLeftLegParams = vec3(0.026, 1, 1) ;\r\nconst vec3 _LowerLeftLegA = vec3(-0.02, -0.67, -0.059999) ;\r\nconst vec3 _LowerLeftLegB = vec3(-0.02, -0.77, 0.12) ;\r\nconst vec3 _LowerLeftLegParams = vec3(0.028, 0.03, 0.01) ;\r\nconst vec3 _UpperRightLegA = vec3(0.07, -0.5, 0.02) ;\r\nconst vec3 _UpperRightLegB = vec3(0.07, -0.61, 0.09) ;\r\nconst vec3 _UpperRightLegParams = vec3(0.026, 1, 1) ;\r\nconst vec3 _LowerRightLegA = vec3(0.07, -0.61, 0.09) ;\r\nconst vec3 _LowerRightLegB = vec3(0.07, -0.91, 0.22) ;\r\nconst vec3 _LowerRightLegParams = vec3(0.028, 0.03, 0.01) ;\r\nconst vec3 _BodyPos = vec3(0, -0.45, -0.03) ;\r\nconst vec3 _CharacterTrailOffset = vec3(0.72, 0.01, 0.06) ;\r\nconst vec3 _CharacterTrailScale = vec3(0.001, 0, 0.5) ;\r\nconst vec3 _CharacterTrailWave = vec3(1.97, 0, 0.34) ;\r\nconst vec2 _CharacterHeightTerrainMix = vec2(1.95, -30) ;\r\nconst vec3 _CloudNoiseStrength = vec3(0.2, 0.16, 0.1) ;\r\nconst vec3 _FrontCloudsPos = vec3(9.91, 8.6, -12.88) ;\r\nconst vec3 _FrontCloudsOffsetA = vec3(-9.1, 3.04, 0) ;\r\nconst vec3 _FrontCloudsOffsetB = vec3(-2.97, 3.72, -0.05) ;\r\nconst vec3 _FrontCloudParams = vec3(5.02, 3.79, 5) ;\r\nconst vec3 _FrontCloudParamsA = vec3(3.04, 0.16, 2) ;\r\nconst vec3 _FrontCloudParamsB = vec3(1.34, 0.3, 3.15) ;\r\nconst vec3 _BackCloudsPos = vec3(29.99, 13.61, -18.8) ;\r\nconst vec3 _BackCloudsOffsetA = vec3(24.87, -1.49, 0) ;\r\nconst vec3 _BackCloudParams = vec3(7.12, 4.26, 1.68) ;\r\nconst vec3 _BackCloudParamsA = vec3(6.37, 2.23, 2.07) ;\r\nconst vec3 _PlaneParams = vec3(7.64, 10.85, 3.76) ;\r\nconst vec3 _CloudGlobalParams = vec3(0.123, 2.1, 0.5) ;\r\nconst vec3 _CloudBackGlobalParams = vec3(0.16, 1.4, -0.01) ;\r\nconst vec3 _CloudNormalMod = vec3(0.26, -0.13, 1.22) ;\r\nconst float _CloudSpecPower = 24.04000 ;\r\nconst float _CloudPyramidDistance = 0.14500 ;\r\nconst vec3 _TombPosition = vec3(5, 5, 9.28) ;\r\nconst vec3 _TombScale = vec3(0.07, 0.5, 0.006) ;\r\nconst vec3 _TombBevelParams = vec3(0.44, 0.66, 0.01) ;\r\nconst float _TombRepScale = 0.79000 ;\r\nconst vec3 _TombCutOutScale = vec3(0.39, 0.06, -14.92) ;\r\nconst vec3 _TombScarfOffset = vec3(0, 0.46, 0) ;\r\nconst vec3 _TombScarfWindParams = vec3(-1.61, 6, 0.05) ;\r\nconst vec3 _TombScarfScale = vec3(0.03, 0.002, 0.5) ;\r\nconst float _TombScarfRot = -0.88000 ;\r\nconst mat4 _TombScarfMat = mat4( 0.9362437, 0, -0.3513514, 0, \r\n0, 1, 0, 0, \r\n0.3513514, 0, 0.9362437, 0, \r\n0, 0, 0, 1 ) ;\r\nconst vec3 _PyramidPos = vec3(0, 10.9, -50) ;\r\nconst vec3 _PyramidScale = vec3(34.1, 24.9, 18) ;\r\nconst vec3 _PrismScale = vec3(1, 1.9, 1) ;\r\nconst vec3 _PyramidNoisePrams = vec3(1.5, 1, 1) ;\r\nconst vec3 _PrismEyeScale = vec3(0.7, 1.9, 51.5) ;\r\nconst vec3 _PyramidEyeOffset = vec3(2.0, -4.9, 0) ;\r\nconst float _PrismEyeWidth = 5.86000 ;\r\nconst float _TerrainMaxDistance = 30.04000 ;\r\nconst float _SmallDetailStrength = 0.00600 ;\r\nconst vec3 _SmallWaveDetail = vec3(3.19, 16, 6.05) ;\r\nconst vec2 _WindSpeed = vec2(2, 0.6) ;\r\nconst float _MediumDetailStrength = 0.05000 ;\r\nconst vec2 _MediumWaveDetail = vec2(2, 50) ;\r\nconst vec3 _MediumWaveOffset = vec3(0.3, -2, 0.1) ;\r\nconst vec2 _LargeWaveDetail = vec2(0.25, 0.73) ;\r\nconst vec3 _LargeWavePowStre = vec3(0.6, 2.96, -2.08) ;\r\nconst vec3 _LargeWaveOffset = vec3(-3.65, 4.41, -11.64) ;\r\nconst vec3 _FlyingHelperPos = vec3(2.15, 4.68, 14.4) ;\r\nconst vec3 _FlyingHelperScale = vec3(0.25, 0.001, 0.3) ;\r\nconst vec3 _FlyingHelperMovement = vec3(0.44, 1.44, -2.98) ;\r\nconst vec3 _FlyingHelperScarfScale = vec3(0.1, 0.001, 1.5) ;\r\nconst vec3 _FlyingHelperScarfWindParams = vec3(-0.06, 0.31, 0.47) ;\r\nconst vec3 _FlyingHelperScarfWindDetailParams = vec3(3.93, 0.005, -45.32) ;\r\nconst vec3 _FlyingHelperSideScarfOffset = vec3(0.16, -0.01, 0) ;\r\nconst vec3 _FlyingHelperSideScarfScale = vec3(0.06, 0.001, 0.8) ;\r\nconst vec4 _FlyingScarfSideWindParams = vec4(2.46, -1.59, -0.05, 0.21) ;\r\n\r\n// Material ID definitions\r\n#define MAT_PYRAMID 1.0\r\n\r\n#define MAT_TERRAIN 10.0\r\n#define MAT_TERRAIN_TRAIL 11.0\r\n\r\n#define MAT_BACK_CLOUDS 20.0\r\n#define MAT_FRONT_CLOUDS 21.0\r\n\r\n#define MAT_TOMB 30.0\r\n#define MAT_TOMB_SCARF 31.0\r\n\r\n#define MAT_FLYING_HELPERS 40.0\r\n#define MAT_FLYING_HELPER_SCARF 41.0\r\n\r\n#define MAT_CHARACTER_BASE 50.0\r\n#define MAT_CHARACTER_MAIN_CLOAK 51.0\r\n#define MAT_CHARACTER_NECK_SCARF 52.0\r\n#define MAT_CHARACTER_LONG_SCARF 53.0\r\n#define MAT_CHARACTER_FACE 54.0\r\n\r\n#define TEST_MAT_LESS( a, b ) a < (b + 0.1)\r\n#define TEST_MAT_GREATER( a, b ) a > (b - 0.1)\r\n\r\n//==========================================================================================\r\n// Primitive functions by IQ\r\n//==========================================================================================\r\nfloat sdRoundBox(vec3 p, vec3 b, float r)\r\n{\r\n\treturn length( max( abs(p) - b, 0.0) ) - r;\r\n}\r\n\r\nfloat sdSphere(vec3 p, float s)\r\n{\r\n\treturn length(p) - s;\r\n}\r\n\r\nfloat sdPlane( vec3 p )\r\n{\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b)\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) +\r\n\t\tlength(max(d, 0.0));\r\n}\r\n\r\nfloat sdCylinder(vec3 p, vec2 h)\r\n{\r\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\r\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nfloat sdPlane(vec3 p, vec4 n)\r\n{\r\n\t// n must be normalized\r\n\treturn dot(p, n.xyz) + n.w;\r\n}\r\n\r\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\r\n{\r\n\tvec3 pa = p - a, ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn vec2( length( pa - ba*h ), h );\r\n}\r\n\r\nfloat sdEllipsoid(in vec3 p, in vec3 r)\r\n{\r\n\treturn (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\r\n}\r\n\r\nfloat sdTriPrism( vec3 p, vec2 h )\r\n{\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\n\r\n//==========================================================================================\r\n// distance field operations\r\n//==========================================================================================\r\nvec2 min_mat( vec2 d1, vec2 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\r\n    return mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\nvec2 smin_mat( vec2 a, vec2 b, float k, float c )\r\n{\r\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\r\n    float x = mix( b.x, a.x, h ) - k*h*(1.0-h);\r\n    return vec2( x, ( h < c ) ? b.y : a.y);\r\n}\r\n\r\nfloat smax( float a, float b, float k )\r\n{\r\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\r\n\treturn mix( a, b, h ) + k*h*(1.0-h);\r\n}\r\n\r\n//==========================================================================================\r\n// Rotations\r\n//==========================================================================================\r\nvoid rX(inout vec3 p, float a) {\r\n    vec3 q = p;\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    p.y = c * q.y - s * q.z;\r\n    p.z = s * q.y + c * q.z;\r\n}\r\n\r\nvoid rY(inout vec3 p, float a) {\r\n    vec3 q = p;\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    p.x = c * q.x + s * q.z;\r\n    p.z = -s * q.x + c * q.z;\r\n}\r\n\r\nvoid rZ(inout vec3 p, float a) {\r\n    vec3 q = p;\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    p.x = c * q.x + s * q.y;\r\n    p.y = -s * q.x + c * q.y;\r\n}\r\n\r\n//==========================================================================================\r\n// Value noise and its derivatives: https://www.shadertoy.com/view/MdX3Rr\r\n//==========================================================================================\r\nvec3 noised( in vec2 x )\r\n{\r\n    vec2 f = fract(x);\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\r\n#if 0\r\n    // texel fetch version\r\n    ivec2 p = ivec2(floor(x));\r\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\r\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\r\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\r\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\r\n#else    \r\n    // texture version    \r\n    vec2 p = floor(x);\r\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n#endif\r\n    \r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\r\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\n\r\n//==========================================================================================\r\n// Noise function: https://www.shadertoy.com/view/4sfGRH \r\n//==========================================================================================\r\nfloat pn(vec3 p) {\r\n    vec3 i = floor(p); \r\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\r\n    vec3 f = cos((p-i)*3.141592653589793)*(-.5) + .5;  \r\n\ta = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\r\n    a.xy = mix(a.xz, a.yw, f.y);   \r\n\treturn mix(a.x, a.y, f.z);\r\n}\r\n\r\n//==========================================================================================\r\n// Sin Wave approximation http://http.developer.nvidia.com/GPUGems3/gpugems3_ch16.html\r\n//==========================================================================================\r\nvec4  SmoothCurve( vec4 x ) {  \r\n  return x * x * ( 3.0 - 2.0 * x );  \r\n}\r\n\r\nvec4 TriangleWave( vec4 x ) {  \r\n  return abs( fract( x + 0.5 ) * 2.0 - 1.0 );  \r\n}\r\n\r\nvec4 SmoothTriangleWave( vec4 x ) {  \r\n  return SmoothCurve( TriangleWave( x ) );  \r\n}  \r\n\r\nfloat SmoothTriangleWave( float x )\r\n{\r\n  return SmoothCurve( TriangleWave( vec4(x,x,x,x) ) ).x;  \r\n}  \r\n\r\nvoid Bend(inout vec3 vPos, vec2 vWind, float fBendScale)\r\n{\r\n\tfloat fLength = length(vPos);\r\n\tfloat fBF = vPos.y * fBendScale;  \r\n\tfBF += 1.0;  \r\n\tfBF *= fBF;  \r\n\tfBF = fBF * fBF - fBF;  \r\n\tvec3 vNewPos = vPos;  \r\n\tvNewPos.xz += vWind.xy * fBF;  \r\n\tvPos.xyz = normalize(vNewPos.xyz)* fLength;  \r\n}\r\n\r\n//==========================================================================================\r\n// Modified cone versions for scarf and main cloak\r\n//==========================================================================================\r\nfloat sdScarfCone( in vec3 p, in float h, in float r1, in float r2 )\r\n{\r\n    float d1 = -p.y - h;\r\n    float q = (p.y - h);\r\n    float si = 0.5*(r1-r2)/h;\r\n    p.z = mix(p.z, p.z * 0.2, q);\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\n\r\nvec2 sdCloakCone( in vec3 p, in float h, in float r1, in float r2 )\r\n{\r\n    float d1 = -p.y - h;\r\n    float q = (p.y - h);\r\n    r2 = (q * r2) + 0.08;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return vec2(length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.), q);\r\n}\r\n\r\n//==========================================================================================\r\n// Character\r\n//==========================================================================================\r\nvec3 headScarfMatUVW;\r\nfloat sdHeadScarf(vec3 pos)\r\n{\r\n\t\r\n    vec3 headScarfPos = pos - _HeadScarfPosition;\r\n    rX( headScarfPos, _HeadScarfRotation );\r\n\r\n    float distanceToTop =  min(0.0,(pos.y + 0.01));\r\n\r\n    // Put a slight twist in the middle. Gives the feel that the head scarf\r\n    // is sitting on shoulders. Very subtle, but I can see it :D\r\n    float midBend = abs( fract( distanceToTop + 0.5 ) * 2.0 - 1.0 );\r\n    headScarfPos.x += (cos( 2.0 + headScarfPos.y * 50.0 ) * 0.05 * midBend);\r\n    headScarfPos.z += (sin( 2.0 + headScarfPos.y * 50.0 ) * 0.03 * midBend);\r\n\r\n    // Apply wind to head Scarf    \r\n    headScarfPos += SmoothTriangleWave(vec4(pos.xyz * 5.0+ iTime,1.0) ).xyz * 0.05 * distanceToTop;\r\n\r\n    // Scarf shape    \r\n    float headScarf = sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z );\r\n    headScarf = max(headScarf, -sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z - 0.011));\r\n    \r\n    // Cut out the bottom of the head scarf. I have no idea what I was thinking, when I wrote this\r\n    vec3 cutOutPos = headScarfPos - vec3( 0.0, 0.08, 0.0);\r\n    vec3 r = vec3(0.12, 0.8, 0.2);\r\n    float smallestSize = min(min(r.x,r.y),r.z);\r\n\tvec3 dp = cutOutPos/r;\r\n    float h = min(1.0, abs(1.0 - abs(dp.y)) );\r\n\r\n    // Apply some crazy power until it looks like a scarf sitting on shoulders\r\n    h =  pow(h, 5.5);\r\n    \r\n    float rad = h ;\r\n    float d = length( cutOutPos/r );\r\n    \r\n    float cutOut = (d - rad) * smallestSize;\r\n    headScarf\t= max(headScarf, cutOut);\r\n\r\n    // material information\r\n    float materialVal = 1.0 - pow(d - rad, 0.02);\r\n\theadScarfMatUVW = smoothstep( -1.0, 1.0, materialVal / _HeadScarfScale);\r\n\r\n\t// Chop the top off, to make room for head\r\n    vec3 headPos = pos - vec3(0.0, 0.25, 0.0);\r\n    float head   = sdBox(headPos, vec3(0.2, 0.19, 0.2)); \r\n    headScarf = max(headScarf, -head);\r\n    \r\n    return headScarf;\r\n}\r\nvec3 mainCloakMatUVW;\r\nfloat sdMainCloak(vec3 pos)\r\n{\r\n    vec3 cloakPos = pos - _MainClothPosition;\r\n    float q =  min(0.0,(cloakPos.y + 0.05));\r\n    rX( cloakPos, _MainClothRotation );\r\n    \r\n    // Apply detailing\r\n    cloakPos += SmoothTriangleWave(vec4(pos.xyz * _MainClothDetail.x + iTime,1.0) ).xyz * _MainClothDetail.y * q;\r\n    \r\n    // Add main Wind direction\r\n    Bend(cloakPos, _WindDirection.xy, _MainClothDetail.z);\r\n    \r\n    vec2 cloak = sdCloakCone( cloakPos, _MainClothScale.y, _MainClothScale.x, _MainClothScale.z);\r\n    // Cut out the internals of the cloak\r\n    cloak.x = max( cloak.x, -sdCloakCone( cloakPos, _MainClothScale.y * 1.05, _MainClothScale.x * 0.95, _MainClothScale.z * 1.01).x);\r\n\r\n    // UV Information\r\n    mainCloakMatUVW = smoothstep( -1.0, 1.0, cloakPos / _MainClothScale);\r\n\r\n    // Cut out the top section\r\n    vec3 headPos = cloakPos - vec3(0.0, 0.69, 0.0);\r\n    float head   = sdBox(headPos, vec3(0.2, 0.67, 0.2)); \r\n\tcloak.x = max(cloak.x, -head);\r\n    \r\n    // Cut the bottom\r\n    float bottomCut   = sdPlane(cloakPos - _MainClothBotCutPos); \r\n    cloak.x = max(cloak.x, -bottomCut);\r\n    \r\n    return cloak.x;\r\n}\r\n\r\nfloat earWigs(in vec3 pos) \r\n{   \r\n\t// Symmetrical ear wigs. Is that even a word... Ear Wigs!\r\n    pos.x = abs(pos.x);\r\n\r\n    vec2  earWig = sdSegment( pos, vec3(0.02, 0.11, 0.0), vec3(0.07, 0.16, 0.05));\r\n    float ear  = earWig.x - 0.026  + (earWig.y * 0.03);\r\n    return ear;\r\n}\r\n\r\n\r\nfloat sdHead( vec3 pos )\r\n{\r\n    vec3 headPos = pos - _HeadPos;\r\n\r\n    // Slight tilt\r\n    rY(headPos, _HeadRotationY ); // 1.2\r\n    rX(headPos, _HeadRotationX );\r\n\r\n    float head = sdCylinder( headPos, vec2(0.05, 0.13) );\r\n    head = smin(earWigs(headPos), head, 0.04 );\r\n    return head;\r\n}\r\n\r\nvec3 longScarfMatUVW;\r\nfloat sdScarf(vec3 pos) \r\n{\r\n    vec3 scarfPos = pos - _LongScarfPos;\r\n    vec3 scale \t= _LongScarfScale;\r\n\r\n\r\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.04);\r\n    scarfPos.x += (sin( scarfPos.z * _LongScarfWindStrength.x + iTime ) * 0.1 * distanceToPoint);\r\n    scarfPos.y += (sin( scarfPos.z * _LongScarfWindStrength.y + iTime ) * 0.1 * distanceToPoint);\r\n\r\n    // Apply detailing\r\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _LongScarfWindStrength.z + iTime,1.0) ).xyz * _LongScarfWindStrength.w * distanceToPoint;\r\n\r\n    // Essentially a box pivoted at a specific point\r\n    vec3 scarfOffset = vec3(0.0, 0.0, -scale.y);\r\n\r\n    rX(scarfPos, _LongScarfRotX) ;\r\n    float scarf = sdBox(scarfPos - scarfOffset.xzy , scale);\r\n\r\n    longScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos - scarfOffset.xzy ) / scale);\r\n\r\n    return max(scarf, sdSphere( scarfPos, _LongScarfMaxRad ));\r\n}\r\n\r\nfloat sdLegs( in vec3 pos  )\r\n{\r\n    vec2  upperLeftLeg = sdSegment( pos, _UpperLeftLegA, _UpperLeftLegB );\r\n    float leftLeg  = upperLeftLeg.x - _UpperLeftLegParams.x;\r\n    vec2 lowerLeftLeg = sdSegment( pos, _LowerLeftLegA, _LowerLeftLegB );\r\n    leftLeg  = smin( leftLeg, lowerLeftLeg.x - _LowerLeftLegParams.x + (lowerLeftLeg.y * _LowerLeftLegParams.y), _LowerLeftLegParams.z);\r\n\r\n    // cut bottom of left leg otherwise looks nasty with harsh tip\r\n    leftLeg = max( leftLeg, -(length( pos - _LowerLeftLegB) - 0.06 ) );\r\n\r\n    vec2  upperRightLeg = sdSegment( pos, _UpperRightLegA, _UpperRightLegB );\r\n    float rightLeg  = upperRightLeg.x - _UpperRightLegParams.x;\r\n    vec2 lowerRightLeg = sdSegment( pos, _LowerRightLegA, _LowerRightLegB );\r\n    rightLeg  = smin( rightLeg, lowerRightLeg.x - _LowerRightLegParams.x + (lowerRightLeg.y * _LowerRightLegParams.y), _LowerRightLegParams.z);\r\n\r\n    return min( leftLeg, rightLeg );\r\n}\r\n\r\nvec2 sdFace( vec3 pos, vec2 currentDistance )\r\n{\r\n    vec3 headPos = pos - vec3(0.0, -0.05, 0.0);\r\n    rX( headPos, _HeadRotationX );\r\n    rY(headPos, _HeadRotationY );\r\n\r\n    // head hole - Fire in the hole!    \r\n    // OK this does not look right. Actually looks like there was \"fire in the hole\" for \r\n    // the poor travellers face. Need to come back to it one day and finish it. Maybe!\r\n    vec3 headHole = headPos - vec3(0.0, 0.1, -0.07);\r\n    float hole = sdEllipsoid( headHole,vec3(0.05, 0.03, 0.04) );\r\n    hole  = smin ( hole, sdEllipsoid( headHole - vec3(0.0, -0.03, 0.0), vec3(0.03,0.03, 0.04)), 0.05 );\r\n\r\n    // Cut it OUT!\r\n    float character =  smax( currentDistance.x, -hole, 0.001);\r\n\r\n    // face. Meh just an ellipsoid. Need to add eyes and bandana\r\n    float face = sdEllipsoid( headHole - _FacePosition.xyz, _FaceSize );\r\n    return smin_mat( vec2(face, MAT_CHARACTER_FACE), vec2(character,currentDistance.y), 0.01, 0.2 );\r\n}\r\n\r\nvec2 sdCharacter( vec3 pos )\r\n{\r\n    // Now we are in character space - Booo YA! - I never ever say Boooo YA!. Peter Pimley \r\n    // says that. Peter: have you been putting comments in my code?\r\n    pos -= _CharacterPosition;\r\n    vec3 scale = _CharacterScale;\r\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\r\n    \r\n    rY(pos, _CharacterRotation);\r\n\r\n    pos /= scale;\r\n\r\n    float mainCloak = sdMainCloak( pos );\r\n    vec2  mainCloakMat = vec2(mainCloak, MAT_CHARACTER_MAIN_CLOAK );\r\n\r\n    float headScarf = sdHeadScarf(pos);\r\n    vec2  headScarfMat = vec2(headScarf, MAT_CHARACTER_NECK_SCARF );\r\n\r\n    float longScarf = sdScarf(pos);\r\n    vec2  longScarfMat = vec2( longScarf, MAT_CHARACTER_LONG_SCARF );\r\n    headScarfMat = smin_mat( headScarfMat, longScarfMat, 0.02, 0.1 );\r\n\r\n    float head      = sdHead( pos );\r\n    vec2  headMat\t= vec2( head, MAT_CHARACTER_BASE );\r\n    headScarfMat    = smin_mat(headScarfMat, headMat, 0.05, 0.75);\r\n\r\n    vec2  characterMat = min_mat(mainCloakMat, headScarfMat); \r\n    characterMat = sdFace( pos, characterMat );\r\n\r\n    vec2 legsMat = vec2( sdLegs(pos), MAT_CHARACTER_BASE );\r\n    characterMat = min_mat( characterMat, legsMat );\r\n\r\n    // chope the bottom. This is to chop the bottom of right leg. Though\r\n    // I have positioned the character so that the right leg is hidden by terrain. \r\n    // Commenting it out for now\r\n//    characterMat.x = max( characterMat.x, -sdPlane( pos - vec3(0.0, -0.85, 0.0) ) );\r\n    characterMat.x *= scaleMul;\r\n\r\n\r\n    return characterMat;\r\n}\r\n\r\n//==========================================================================================\r\n// Clouds\r\n//==========================================================================================\r\nfloat sdCloud( in vec3 pos, vec3 cloudPos, float rad, float spread, float phaseOffset, vec3 globalParams)\r\n{ \r\n\t// Clouds are simple. A bunch of spheres with varying phase offset, size and \r\n\t// frequency values. They are also scaled along the z-Axis so more like circles\r\n\t// than spheres. With additional noise to make them look fluffy. \r\n\t// While rendering them we \"perturb\" #SpellCheck the normals to get strong specular\r\n\t// highlights\r\n\r\n\t// Add noise to the clouds\r\n\tpos += pn( pos ) * _CloudNoiseStrength;\r\n\tpos = pos - cloudPos;\r\n\r\n\t// Make us 2d-ish - My artists have confirmed me: 2D is COOL!\r\n\tpos.z /= globalParams.x;\r\n\r\n\t// Repeat the space\r\n\tfloat repitition = rad * 2.0 + spread;\r\n\tvec3  repSpace = pos - mod( pos - repitition * 0.5, repitition);\r\n\r\n\t// Create the overall shape to create clouds on\r\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.23  )  * globalParams.y ;\r\n\r\n\t// Creates clouds with offset on the main path\r\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.9 ) * globalParams.z;\r\n\r\n\t// repeated spheres\r\n\tpos.x = fract( (pos.x + repitition * 0.5) / repitition ) * repitition - repitition * 0.5;\r\n\r\n\t// return the spheres  \r\n\tfloat sphere = length(pos)- rad;\r\n\treturn sphere * globalParams.x;\r\n}\r\n\r\nvec2 sdClouds( in vec3 pos )\r\n{\r\n\t// Two layers of clouds. A layer in front of the big pyramid\r\n    float c1 = sdCloud( pos, _FrontCloudsPos, _FrontCloudParams.x, _FrontCloudParams.y, _FrontCloudParams.z, _CloudGlobalParams );\r\n    float c2 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetA, _FrontCloudParamsA.x, _FrontCloudParamsA.y, _FrontCloudParamsA.z, _CloudGlobalParams );\r\n    float c3 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetB, _FrontCloudParamsB.x, _FrontCloudParamsB.y, _FrontCloudParamsB.z, _CloudGlobalParams);\r\n    float frontClouds = min(c3, min(c1, c2));\r\n\r\n    // This plane hides the empty spaces between the front cloud spheres. Not needed\r\n    // for back spheres, they are covered by front spheres\r\n  \tfloat mainPlane = length(pos.z - _FrontCloudsPos.z) / _CloudGlobalParams.x + (pos.y - _PlaneParams.y  + sin(_PlaneParams.x + pos.x * 0.23 ) * _PlaneParams.z);// - rad;\r\n  \tfrontClouds = min(mainPlane * _CloudGlobalParams.x, frontClouds);\r\n\r\n\t// Second layer behind the big Pyramid\r\n    float c4 = sdCloud( pos, _BackCloudsPos, _BackCloudParams.x, _BackCloudParams.y, _BackCloudParams.z, _CloudBackGlobalParams );\r\n    float c5 = sdCloud( pos, _BackCloudsPos + _BackCloudsOffsetA, _BackCloudParamsA.x, _BackCloudParamsA.y, _BackCloudParamsA.z, _CloudBackGlobalParams );\r\n    float backClouds = min(c4,c5);\r\n    return min_mat(vec2(frontClouds,MAT_FRONT_CLOUDS), vec2(backClouds,MAT_BACK_CLOUDS));\r\n}\r\n\r\n//==========================================================================================\r\n// This should really be called Kites. No such thing as Flying Helplers...\r\n//==========================================================================================\r\nvec3 helperScarfMatUVW;\r\nfloat sdHelperScarf(vec3 pos, vec3 scarfOffset, vec3 originalPos ) \r\n{\r\n    vec3 scarfPos = pos - scarfOffset;\r\n\r\n    vec3 scale = _FlyingHelperScarfScale;\r\n\r\n    // How far are we from pivot of scarf\r\n    float distanceToPoint = length(scarfPos );\r\n\r\n    // Apply some motion\r\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _FlyingHelperScarfWindDetailParams.x + iTime,1.0) ).xyz * _FlyingHelperScarfWindDetailParams.y * distanceToPoint;\r\n\r\n    vec2 wave;\r\n    wave.x = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.x  );\r\n    wave.y = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.z  );\r\n\r\n    scarfPos.xy += ( wave * _FlyingHelperScarfWindParams.y * distanceToPoint);\r\n    vec3  pivotOffset = vec3(0.0, 0.0, scale.z);\r\n    float scarf = sdBox(scarfPos - pivotOffset, scale);\r\n\r\n    // Move us along the z-axis because we chop a sphere in the box. Shows borders otherwise\r\n    vec3 UVWOffset = vec3(0.0, 0.0, 1.0);\r\n    helperScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos + UVWOffset - pivotOffset.xzy ) / scale);\r\n\r\n    // Two scarf on each side of the big'un\r\n    pivotOffset.z = _FlyingHelperSideScarfScale.z;\r\n\r\n\twave.y = originalPos.x > 0.0 ? wave.y * _FlyingScarfSideWindParams.x : wave.y * _FlyingScarfSideWindParams.y;\r\n\tscarfPos.xy += scarfPos.x > 0.0 ? wave * _FlyingScarfSideWindParams.z : wave * _FlyingScarfSideWindParams.w;\r\n\r\n\t// legit mirroring!\r\n\tscarfPos.x = -abs(scarfPos.x);\r\n\tfloat sideScarfs = sdBox(scarfPos - pivotOffset + _FlyingHelperSideScarfOffset, _FlyingHelperSideScarfScale);\r\n\r\n\t// Just override the helperScarfMatUVW value for side scarfs. Too tired to create another variable and use that, not too tired\r\n\t// to write this long comment of no value\r\n    helperScarfMatUVW = scarf < sideScarfs ? helperScarfMatUVW : smoothstep(-1.0, 1.0, ( scarfPos - pivotOffset + _FlyingHelperSideScarfOffset ) / _FlyingHelperSideScarfScale);\r\n\r\n    // Combine'em\r\n    scarf = min( scarf, sideScarfs );\r\n    return scarf;\r\n}\r\n\r\nvec2 sdFlyingHelpers( vec3 pos )\r\n{\r\n\tvec3 originalPos = pos;\r\n\tfloat flyingHelper = _DrawDistance;\r\n\r\n\t// Using pos.x to determine, whether we are rendering left or right scarf.\r\n\tvec3 helperPos = _FlyingHelperPos;\r\n\thelperPos = pos.x > 0.0 ? helperPos - _FlyingHelperMovement : helperPos;\r\n\r\n\t// Rest is just mirroring\r\n\tpos.x = abs(pos.x);\r\n\tpos = pos - helperPos;\r\n\r\n\tfloat helperScarf = sdHelperScarf( pos, vec3(0.0, 0.0, 0.0), originalPos);\r\n\r\n\t// Main helper is a box with a cutout sphere at back. In-game it is more sophisticated. But\r\n\t// I am running out of time. Maybe will do a proper one, one day!\r\n\tfloat helper = sdBox( pos, _FlyingHelperScale );\r\n\thelper\t= max( helper, -sdSphere( pos - vec3(0.0, 0.0, _FlyingHelperScale.z ), _FlyingHelperScale.z) );\r\n\r\n\t// Material and combine scarf with main body\r\n\tvec2 helperMat = smin_mat( vec2(helper,MAT_FLYING_HELPERS), vec2(helperScarf,MAT_FLYING_HELPER_SCARF), 0.01, 0.1);\r\n\thelperScarfMatUVW = helper < helperScarf ? smoothstep(-1.0, 1.0, (pos + vec3(0.0,0.0,_FlyingHelperScale.z*0.5)) / _FlyingHelperScale) : helperScarfMatUVW;\r\n\r\n\treturn helperMat;\r\n}\r\n\r\n//==========================================================================================\r\n// The big mountain in the distance. Again, not a pyramid\r\n//==========================================================================================\r\nfloat sdBigMountain( in vec3 pos )\r\n{\r\n    float scaleMul = min(_PyramidScale.x, min(_PyramidScale.y, _PyramidScale.z));\r\n    vec3 posPyramid\t= pos - _PyramidPos;\r\n\r\n    // Apply noise derivative, then we can use a blocky looking texture to make the mountain\r\n    // look edgy (for lack of better word)\r\n    float derNoise\t\t= sin(noised(posPyramid.xz * _PyramidNoisePrams.x).x) * _PyramidNoisePrams.y;\r\n    posPyramid.x\t\t= posPyramid.x + derNoise;\r\n\r\n    posPyramid /= _PyramidScale;\r\n    float pyramid = sdTriPrism(  posPyramid, _PrismScale.xy ) * scaleMul;\r\n\r\n    // The piercing eye. Which is just an inverted pyrmaid on top of main pyramid.\r\n    float eyeScale = _PyramidScale.x;\r\n\r\n    vec3 posEye = pos;\r\n    posEye.y = _PrismEyeScale.z - pos.y;\r\n    posEye.x = pos.x * _PrismEyeWidth;\r\n\r\n\tfloat eye = sdTriPrism(  (posEye -_PyramidEyeOffset) / eyeScale, _PrismEyeScale.xy ) * eyeScale;\r\n\treturn max(pyramid, -eye);\r\n}\r\n\r\n//==========================================================================================\r\n// Main desert shape\r\n//==========================================================================================\r\nfloat sdLargeWaves( in vec3 pos )\r\n{\r\n\t// The main shape of terrain. Just sin waves, along X and Z axis, with a power\r\n\t// curve to make the shape more pointy \r\n\r\n    // Manipulate the height as we go in the distance\r\n    // We want terrain to be a specific way closer to character, showing a path, but the path \r\n    // gets muddier as wo go in the distance.\r\n\r\n    float distZ = abs(pos.z - _CameraPos.z);\r\n    float distX = abs(pos.x - _CameraPos.x);\r\n    float dist = (distZ ) + (distX * 0.1);\r\n    dist = dist * dist * 0.01;\r\n\r\n    float detailNoise = noised(pos.xz).x * -2.5; \r\n\tfloat largeWaves = (sin(_LargeWaveOffset.z + pos.z * _LargeWaveDetail.y + pos.z * 0.02)  \r\n\t\t\t\t\t  * sin((_LargeWaveOffset.x + dist) + (pos.x * _LargeWaveDetail.x) ) * 0.5) + 0.5;\r\n    largeWaves = -_LargeWaveOffset.y + pow( largeWaves, _LargeWavePowStre.x) *  _LargeWavePowStre.y - detailNoise * 0.1 ;// - (-pos.z*_LargeWavePowStre.z);// \r\n\r\n    // Smoothly merge with the bottom plane of terrain\r\n    largeWaves = smin(largeWaves, _LargeWavePowStre.z, 0.2);\r\n    largeWaves = (largeWaves - dist);\r\n    return largeWaves * 0.9;\r\n}\r\n\r\nfloat sdSmallWaves( in vec3 pos )\r\n{\r\n\t// The small waves are used for adding detail to the main shape of terrain\r\n\tfloat distanceToCharacter = length( pos.xz - _CharacterPosition.xz );\r\n\r\n    // movement to give feel of wind blowing\r\n    float detailNoise = noised(pos.xz).x * _SmallWaveDetail.z; \r\n\tfloat smallWaves = sin(pos.z * _SmallWaveDetail.y + detailNoise + iTime * _WindSpeed.y ) * \r\n\t\t\t\t\t   sin(pos.x * _SmallWaveDetail.x + detailNoise + iTime * _WindSpeed.x ) * _SmallDetailStrength;// * min(1.0, distanceToCharacter);\r\n\t\r\n\treturn smallWaves * 0.9;\r\n}\r\n\r\nfloat sdTerrain( in vec3 pos)\r\n{\r\n\tfloat smallWaves = sdSmallWaves( pos );\r\n\tfloat largeWaves = sdLargeWaves( pos );\r\n\r\n    return (smallWaves + largeWaves);\r\n}\r\n\r\nvec2 sdDesert( in vec3 pos, in float terrain )\r\n{\r\n    float distanceToPos = length(pos.xz - _CameraPos.xz);\r\n    if( distanceToPos > _TerrainMaxDistance)\r\n        return vec2(_DrawDistance, 0.0);\t\r\n\r\n   \tfloat mat = 9.0;//length(pos.xyz) > 9.0 ? 10.0 : 40.0;\r\n    return vec2( pos.y + terrain, MAT_TERRAIN );\r\n}\r\n\r\n//==========================================================================================\r\n// Character trail in the sand\r\n//==========================================================================================\r\nfloat sdCharacterTrail( vec3 pos, in float terrain )\r\n{\r\n\tvec3 trailOffset = (_CharacterPosition);\r\n\ttrailOffset.yz  += (_CharacterTrailOffset).yz;\r\n    trailOffset.y = -terrain + _CharacterTrailOffset.y; \r\n\r\n    vec3 trailPos = pos - trailOffset;\r\n    float distanceToPoint = length(trailPos);\r\n    trailPos.x -= _CharacterTrailOffset.x * distanceToPoint;\r\n\r\n    // Make it wavy\r\n    trailPos.x += (SmoothTriangleWave( trailPos.z * _CharacterTrailWave.x  ) * _CharacterTrailWave.z * distanceToPoint);\r\n\r\n    float trail = sdBox(trailPos - vec3(0.0, 0.0, _CharacterTrailScale.z) , _CharacterTrailScale);\r\n    return trail;\r\n}\r\n\r\n//==========================================================================================\r\n// The tombs\r\n//==========================================================================================\r\nfloat sdTombScarf(vec3 pos, vec3 scarfOffset, float t ) \r\n{ \r\n\t//  scarfs, done same as other scarfs\r\n\r\n    vec3 scarfPos = pos - scarfOffset;\r\n\r\n    scarfPos =  (mul(  _TombScarfMat, vec4(scarfPos,1.0) )).xyz;\r\n\r\n    vec3 scale = _TombScarfScale;\r\n    scale.z  += (t + 1.0 ) * 0.2;\r\n\r\n    // How far are we from pivot of scarf\r\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.1);\r\n\r\n    // Make the scarf thicker as it goes out\r\n    scale.x += distanceToPoint * 0.04;\r\n\r\n    // Apply some motion\r\n    scarfPos.x += (sin( pos.z * _TombScarfWindParams.x + iTime) * _TombScarfWindParams.z * distanceToPoint);\r\n    scarfPos.y += (sin( pos.z * _TombScarfWindParams.y + iTime) * _TombScarfWindParams.z * distanceToPoint);\r\n\r\n     vec3 pivotOffset = vec3(0.0, 0.0, scale.z);\r\n    rX(scarfPos, _TombScarfRot + ((t - 0.5)* 0.15) + SmoothTriangleWave((iTime + 1.45) * 0.1) * 0.3 );\r\n\r\n    float scarf = sdBox(scarfPos - pivotOffset , scale);\r\n    return scarf;\r\n}\r\n\r\nvec2 sdTombs( in vec3 p )\r\n{\r\n\tvec2 mainTomb = vec2(_DrawDistance, MAT_TOMB);\r\n\r\n\t// We draw two tombs, t goes -1 -> 1 so we can use negative and positive values\r\n\t// to mainpulate them both individually\r\n\tfor( float t = -1.0; t <= 1.0; t += 2.0 )\r\n\t{\r\n\t\tvec3 tombPos = (_TombPosition + vec3(-0.25 * t, t * 0.05, 0.1 * t ));\r\n\r\n\t\tvec3 pos = p - tombPos;\r\n\t\trZ( pos, 0.1 * t );\r\n\r\n\t\tfloat tombScarf = sdTombScarf( pos, _TombScarfOffset, t + 1.0);\r\n\r\n\t\tpos.x = abs(pos.x);\r\n\r\n\t\t// Taper them beyond a certain height. Rest is just a rounded box\r\n\t\tpos.x += abs( pos.y > _TombBevelParams.x  ? (pos.y - _TombBevelParams.x) * _TombBevelParams.y: 0.0 );\r\n\t\tfloat tTomb = sdRoundBox( pos, _TombScale, _TombBevelParams.z);\r\n\r\n\t\t// Cut out a sphere at top\r\n\t\ttTomb = max( tTomb, -sdSphere( pos - vec3(0.0, _TombCutOutScale.x, 0.0), _TombCutOutScale.y ) );\r\n\r\n\t\t// create scarfs at cut off points\r\n\t\tvec2 tTombMat = min_mat( vec2(tTomb, MAT_TOMB), vec2(tombScarf, MAT_TOMB_SCARF));\r\n\t\tmainTomb = min_mat( mainTomb, tTombMat);\r\n\t}\r\n\treturn mainTomb;\r\n}\r\n\r\n//==========================================================================================\r\n// The main map function\r\n//==========================================================================================\r\nvec2 map( in vec3 pos )\r\n{\r\n\tvec2 character = sdCharacter(pos);\r\n\tvec2 res = character;\r\n\r\n\t// I am assuming that since character covers a large portion of screen\r\n\t// This early out should help and same with the terrain. Assumption only, \r\n\t// need to look into it \r\n    if( res.x > 0.01 )\r\n    {\r\n    \tfloat desert = sdTerrain(pos);\r\n\t    vec2 terrain   = sdDesert( pos, desert );\r\n\t    vec2 trail\t   = vec2(-sdCharacterTrail(pos, desert), MAT_TERRAIN_TRAIL );\r\n\t    terrain.y\t\t= terrain.x > trail.x ? terrain.y : trail.y;\r\n\t\tterrain.x\t\t= smax( terrain.x, trail.x, 0.05);\r\n\r\n\t\tres\t= min_mat( res, terrain); \r\n        if( terrain.x > 0.01 )\r\n        {\r\n\t\t\tvec2 tombs\t   =  sdTombs(pos);\r\n            res = smin_mat( res, tombs, 0.2, 0.15 );\r\n\r\n            vec2 pyramid   = vec2(sdBigMountain(pos), MAT_PYRAMID);\r\n            res = min_mat( res, pyramid );\r\n\r\n            vec2 clouds\t   = sdClouds(pos);\r\n            res = min_mat( res, clouds );\r\n\r\n            vec2 flyingHelpers = sdFlyingHelpers( pos );\r\n            res = min_mat( res, flyingHelpers );\r\n        }\r\n\t}\r\n    return res;\r\n}\r\n\r\n\r\n//==========================================================================================\r\n// Used for generating normals. As it turns out that only the big mountain doesn't need\r\n// normals. Everything else does. Hey Ho!\r\n//==========================================================================================\r\nvec2 mapSimple( in vec3 pos )\r\n{\r\n\treturn map( pos );\r\n\t/*\r\n    vec2 character = sdCharacter(pos);\r\n    vec2 flyingHelpers = vec2( sdFlyingHelpers( pos ), 50.0 );\r\n    vec2 clouds\t   = sdClouds(pos);\r\n   \tfloat desert   = sdTerrain(pos);\r\n    vec2 terrain   = sdDesert( pos, desert );\r\n    terrain.x = smax( terrain.x, -sdCharacterTrail(pos, desert), 0.1 );\r\n    vec2 tombs\t   =  vec2(sdTombs(pos), 50.0);\r\n\r\n    vec2 res = character;\r\n    min_mat( res, flyingHelpers );\r\n\tres = min_mat( res, clouds );\r\n    res\t= min_mat( res, terrain); \r\n    res\t= min_mat( res, flyingHelpers); \r\n    res = smin_mat( res, tombs, 0.2, 0.15 );\r\n    return res;\r\n    */\r\n}\r\n\r\n//==========================================================================================\r\n// Raycasting: https://www.shadertoy.com/view/Xds3zN\r\n//==========================================================================================\r\nvec3 castRay(vec3 ro, vec3 rd) \r\n{\r\n    float tmin = 0.1;\r\n    float tmax = _DrawDistance;\r\n   \r\n    float t = tmin;\r\n    float m = -1.0;\r\n    float p = 0.0;\r\n    float maxSteps = _MaxSteps;\r\n    float j = 0.0;\r\n    for( float i = 0.0; i < _MaxSteps; i += 1.0 )\r\n    {\r\n        j = i;\r\n\t    float precis = 0.0005*t;\r\n\t    vec2 res = map( ro+rd*t );\r\n        if( res.x<precis || t>tmax ) \r\n        \tbreak;\r\n        t += res.x;\r\n\t    m = res.y;\r\n    }\r\n\tp = j / maxSteps;\r\n    if( t>tmax ) m=-1.0;\r\n    return vec3( t, m, p );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\r\n    return normalize( e.xyy*mapSimple( pos + e.xyy ).x + \r\n\t\t\t\t\t  e.yyx*mapSimple( pos + e.yyx ).x + \r\n\t\t\t\t\t  e.yxy*mapSimple( pos + e.yxy ).x + \r\n\t\t\t\t\t  e.xxx*mapSimple( pos + e.xxx ).x );\r\n}\r\n\r\n//==========================================================================================\r\n// Ambient Occlusion, only applied to the Traveller\r\n//==========================================================================================\r\nfloat AmbientOcclusion(vec3 p, vec3 N, float stepSize, float k)\r\n{\r\n    float r = 0.0;\r\n    float t = 0.0;\r\n  \r\n    for(int i = 0; i < 2; i++)\r\n    {\r\n        t += stepSize;\r\n        r += (1.0 / pow(2.0, t)) * (t - sdCharacter(p + (N * t)).x);\r\n    }\r\n    return max(0.0, 1.0 - (k * r));\r\n}\r\n\r\n//==========================================================================================\r\n// Simplified version of Traveller for shadow casting\r\n//==========================================================================================\r\nfloat sdCharacterShadow( vec3 pos )\r\n{\r\n    pos -= _CharacterPosition;\r\n    vec3 scale = _CharacterScale;\r\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\r\n    \r\n    rY(pos, _CharacterRotation);\r\n\r\n    pos /= scale;\r\n\r\n    float mainCloak = sdMainCloak( pos );\r\n    float longScarf = sdScarf(pos);\r\n\r\n    return min( mainCloak, longScarf) * scaleMul;\r\n}\r\n\r\n//==========================================================================================\r\n// Only character, flying helpers and tombs cast shadows. Only terrain recieves shadows\r\n//==========================================================================================\r\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\r\n{\r\n    float res = 1.0;\r\n    float t = mint;\r\n    for(int i = 0; i < 100; ++i)\r\n    {\r\n        if (t >= maxt) {\r\n            break;\r\n        }\r\n    \tfloat flyingHelpers = sdFlyingHelpers( ro + rd * t).x;\r\n    \tfloat tombs = sdTombs( ro + rd * t ).x;\r\n        float h = min( sdCharacterShadow( ro + rd*t), min(flyingHelpers, tombs) );\r\n        if( h<0.001 )\r\n            return 0.1;\r\n        res = min( res, k*h/t );\r\n        t += h;\r\n    }\r\n\treturn res;\r\n}\r\n\r\n//==========================================================================================\r\n// Hi Hussain!\r\n// Again, somebody wrote Hi Hussain here. It wasn't me, but hi back atcha!\r\n// Sky\r\n//==========================================================================================\r\nvec3 sky( vec3 ro, vec3 rd )\r\n{\r\n    // Sun calculation\r\n    float sunDistance = length( _SunPosition );\r\n\r\n    vec3 delta = _SunPosition.xyz - (ro + rd * sunDistance);\r\n    float dist \t= length(delta);\r\n\r\n    // Turn Sun into a star, because the big mountain has a star like shape\r\n    // coming from top\r\n    delta.xy *= _SunStar.xy;\r\n    float sunDist = length(delta);\r\n    float spot = 1.0 - smoothstep(0.0, _SunSize, sunDist);\r\n    vec3 sun = clamp(_SunScale * spot * spot * spot, 0.0, 1.0) * _SunColor.rgb;\r\n\t\r\n\t// Changing color on bases of distance from Sun. To get a strong halo around\r\n\t// the sun\r\n   \tfloat expDist = clamp((dist - _ExposureOffset)  * _ExposureStrength, 0.0, 1.0);\r\n   \tfloat expControl = pow(expDist,_ExposurePower);\r\n\r\n    // Sky colors\r\n    float y = rd.y;\r\n    float zen = 1.0 - pow (min (1.0, 1.0 - y), _ZenithFallOff);\r\n    vec3 zenithColor\t= _Zenith.rgb  * zen;\r\n    zenithColor = mix( _SunColor.rgb, zenithColor, expControl );\r\n\r\n    float nad = 1.0 - pow (min (1.0, 1.0 + y), _NadirFallOff);\r\n    vec3 nadirColor\t= _Nadir.rgb * nad;\r\n\r\n    float hor = 1.0 - zen - nad;\r\n    vec3 horizonColor\t= _Horizon.rgb * hor;\r\n\r\n    // Add stars for Color Scheme 3\r\nfloat stars  = 0.0;\r\n#if COLOR_SCHEME == 3\r\n    vec3 starPos = ro + ( (rd + vec3(iTime * 0.001, 0.0, 0.0) ) * sunDistance);\r\n    starPos.xyz += iTime*0.01 + noised(starPos.xy) * 3.0;\r\n\r\n    starPos      = mod( starPos, 1.5) - 0.75;\r\n    stars  \t\t = length(starPos);\r\n\r\n\tfloat starsA \t= (step( 0.9, 1.0 - stars) * 1.0 - (stars)) * 2.0;\r\n\tfloat starsB\t= (step( 0.93, 1.0 - stars) * 1.0 - (stars)) * 1.5;\r\n\tstars = starsA + starsB;\r\n\r\n    stars = stars * pow(zen * expControl, 5.0);\r\n    stars = step( 0.01, stars) * stars * 2.0;\r\n#endif\r\n    return stars + (sun * _SunStar.z + zenithColor + horizonColor + nadirColor);\r\n}\r\n\r\n//==========================================================================================\r\n// The rendering, based on: https://www.shadertoy.com/view/Xds3zN\r\n//==========================================================================================\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{ \r\n\t// res.z contains the iteration count / max iterations. This gives kind of a nice glow\r\n\t// effect around foreground objects. Looks particularly nice on sky, with clouds in\r\n\t// front and also on terrain. Gives rim kind of look!\r\n\tvec3 res\t= castRay(ro,rd);\r\n\tvec3 skyCol = sky( ro, rd );\r\n\tvec3 col\t= skyCol;\r\n\r\n\t#if defined (DEBUG_PERFORMANCE)\r\n\treturn (res.z);\r\n\t#endif\r\n\r\n\tfloat t = res.x;\r\n\tfloat m = res.y;\r\n\r\n\tvec3 pos = ro + t*rd;\r\n\r\n\t// Return sky\r\n\tif( m < 0.0 )\r\n\t{\r\n\t\t// Bloom for the background clouds. We want Big Mountain to be engulfed with fog. So just chop out\r\n\t\t// areas around right and left side of BigMountain for creating fake bloom for background clouds by\r\n\t\t// using the iteration count needed to generate the distance function\r\n\t\tfloat rightSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(45.0, -5.0, _SunPosition.z));\r\n\t\tfloat leftSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(-50.0, -5.0, _SunPosition.z));\r\n\t\tif( rightSideCloudDist < 40.0 )\r\n\t\t{\r\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, rightSideCloudDist / 40.0);\r\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\r\n\t\t}\r\n\t\telse if( leftSideCloudDist < 40.0 )\r\n\t\t{\r\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, leftSideCloudDist / 40.0);\r\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\r\n\t\t}\r\n        else\r\n\t\t\treturn col;\r\n\t}\r\n\r\n\tfloat skyFog = 1.0-exp( _FogMul * t * pow(pos.y, _FogPow) );\r\n\t#if defined (DEBUG_FOG)\r\n\treturn (skyFog);\r\n\t#endif\r\n\r\n\t// Render the big mountain. Keep track of it's color, so we can use it for transparency for clouds later\r\n\tvec3 pyramidCol = vec3(0.0, 0.0, 0.0);\r\n\tpyramidCol\t\t= mix( _PyramidCol, skyCol, skyFog * 0.5  ); \r\n\r\n\tif( TEST_MAT_LESS( m, MAT_PYRAMID) )\r\n\t{\r\n\t\t// Height fog, with strong fade to sky \r\n\t\tfloat nh = (pos.y / _PyramidHeightFog.x);\r\n\t\tnh = nh*nh*nh*nh*nh;\r\n\t\tfloat heightFog = pow(clamp(1.0 - (nh), 0.0, 1.0), _PyramidHeightFog.y);\r\n\t\theightFog\t\t= clamp( heightFog, 0.0, 1.0 );\r\n\t\tpyramidCol\t\t= mix( pyramidCol, skyCol, heightFog ); \r\n\t\treturn pyramidCol;       \r\n\t}\r\n\r\n\t// Calculate normal after calculating sky and big mountain\r\n\tvec3 nor = calcNormal(pos);\r\n\t// Terrain: https://archive.org/details/GDC2013Edwards\r\n\tif( TEST_MAT_LESS (m, MAT_TERRAIN_TRAIL ) )\r\n\t{\r\n\t\tfloat shadow = softShadow( pos - (rd * 0.01), _LightDir.xyz, _TerrainShadowParams.x, _TerrainShadowParams.y, _TerrainShadowParams.z);\r\n\t\tshadow\t\t = clamp( shadow + _TerrainShadowParams.w, 0.0, 1.0 );\r\n\r\n\t\tvec3 shadowCol = mix( shadow * _TerrainShadowColor, _TerrainDistanceShadowColor, pow(skyFog, _TerrainFogPower * _TerrainDistanceShadowPower) );\r\n\r\n\t\t// Strong rim lighting\r\n\t\tfloat rim\t= (1.0 - saturate(dot( nor , -rd ))); \r\n\t\trim\t\t\t= saturate(pow( rim, _TerrainRimPower)) *_TerrainRimStrength ; \r\n\t\tvec3 rimColor\t= rim * _TerrainRimColor;\r\n\r\n\t\t// Specular highlights\r\n\t\tvec3 ref\t\t= reflect(rd, nor);\r\n\t    vec3 halfDir\t= normalize(_LightDir + rd);\r\n\r\n\t    // The strong ocean specular highlight\r\n\t    float mainSpec = clamp( dot( ref, halfDir ), 0.0, 1.0 );\r\n\t    if ( TEST_MAT_LESS( m, MAT_TERRAIN ) )\r\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 2.0 ;\r\n\t    else\r\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 4.0;\r\n\r\n\t    float textureGlitter  = textureLod(iChannel1,pos.xz * _TerrainGlitterRep, 2.2).x * 1.15;\r\n\t    textureGlitter\t= pow(textureGlitter , _TerrainGlitterPower);\r\n\t    mainSpec \t\t*= textureGlitter;\r\n\r\n\t\t// The glitter around terrain, looks decent based on rim value\r\n\t    float rimSpec\t= (pow(rim, _TerrainRimSpecPower)) * textureGlitter;\r\n\t    vec3 specColor\t= (mainSpec + rimSpec) * _TerrainSpecColor;\r\n\t\tvec3 terrainCol\t= mix( (rimColor + specColor * shadow) + _TerrainCol, skyCol, pow(skyFog, _TerrainFogPower) ) + res.z * 0.2;  \r\n\r\n\t\t// maybe add a fake AO from player, just a sphere should do!\r\n\t\treturn mix( shadowCol, terrainCol, shadow );\r\n\t}\r\n\r\n\t// Clouds\r\n\tif( TEST_MAT_LESS (m, MAT_FRONT_CLOUDS ) )\r\n\t{\r\n\t\t// Modify the normals so that they create strong specular highlights\r\n\t\t// towards the top edge of clouds\r\n\t\tnor\t\t\t\t= normalize( nor + _CloudNormalMod);\r\n\t\tfloat dotProd\t= dot( nor, vec3(1.0,-3.5,1.0) );\r\n\r\n\t\tfloat spec\t\t=  1.0 -  clamp( pow(dotProd, _CloudSpecPower), 0.0, 1.0 );\r\n\t\tspec \t\t\t*= 2.0;\r\n\t\tvec3 cloudCol\t= spec * _CloudSpecCol + _CloudCol;\r\n\r\n\t\t// Transparency for mountain\r\n\t\tif( sdBigMountain( pos + (rd * t * _CloudPyramidDistance)) < 0.2 )\r\n\t \t{\r\n\t \t\tcloudCol = mix( pyramidCol, cloudCol, _CloudTransparencyMul ); \r\n\t\t}\r\n\r\n\t\t// Mixing for backdrop mountains. Backdrop mountains take more color from Sky. Foreground mountains\r\n\t\t// retain their own color values, so I can adjust their darkness\r\n\t\tvec3 inCloudCol = mix(cloudCol, _BackCloudCol + skyCol * 0.5 + spec * _BackCloudSpecCol, MAT_FRONT_CLOUDS - m);\r\n\t\treturn mix( inCloudCol , skyCol, skyFog * _CloudFogStrength );    \r\n\t}\r\n\r\n\t// Tombs\r\n\tif( TEST_MAT_LESS(m, MAT_TOMB_SCARF ) )\r\n\t{\r\n\t\t// Simple strong diffuse\r\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.0, 0.0, 1.0);\r\n\t\tvec3 col\t= mix( _TombMainColor, _TombScarfColor * 2.0, m - MAT_TOMB );\r\n\t\treturn mix( diff * col, skyCol, skyFog);\r\n\t}\r\n\r\n\t// Flying Helpers\r\n\tif( TEST_MAT_LESS(m, MAT_FLYING_HELPER_SCARF ) )\r\n\t{\r\n\t\tfloat fres\t= pow( clamp(1.0+dot(nor,rd) + 0.75,0.0,1.0), _FlyingHelperFrePower ) * _FlyingHelperFreScale;\r\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.5,0.0,1.0);\r\n\t\tvec3 col = _FlyingHelperYellowColor;\r\n\r\n\t\t// The main head\r\n\t\tif ( TEST_MAT_LESS( m, MAT_FLYING_HELPERS ) )\r\n\t\t{\r\n\t\t\tcol = _FlyingHelperMainColor;\r\n\r\n\t\t\t// Yellow borders\r\n\t\t\tfloat outerBorder = step( 0.95, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\r\n\t\t\tcol  = mix( col * diff, _FlyingHelperYellowColor,  outerBorder );\r\n\r\n\t\t\t// cubes in middle\r\n\t\t\tfloat rectsY = abs(helperScarfMatUVW.z * 2.0 - 1.0);\r\n\t\t\tfloat rectsX = abs(helperScarfMatUVW.x * 2.0 - 1.0);\r\n\r\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\r\n\t\t\tcircles = step( 0.5, circles );\r\n\r\n\t\t\t// Ideally want to do a separate bass for bloom. maybe one day\r\n\t\t\tfloat bloomCircle = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1); \r\n\t\t\tfloat bloom  = max( bloomCircle - 0.5, 0.0);\r\n\r\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\r\n\t\t\trectsX = 1.0 - step( 0.5, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\r\n\r\n\t\t\tfloat rects = min(rectsX, rectsY);\r\n\r\n\t\t\tfloat symbolsX = fract(rects/(helperScarfMatUVW.z * 20.0) * 20.0);\r\n\t\t\tfloat symbolsY = fract(rects/(helperScarfMatUVW.x * 2.0) * 2.0);\r\n\t\t\tfloat symbolsZ = fract(rects/((helperScarfMatUVW.z + 0.1) * 16.0) * 16.0);\r\n\t\t\tfloat symbolsW = fract(rects/((helperScarfMatUVW.x + 0.1) * 3.0) * 3.0);\r\n\r\n\t\t\tfloat symbols = symbolsY;\r\n\t\t\tsymbols = max( symbols, symbolsZ );\r\n\t\t\tsymbols = min(symbols , max(symbolsX, symbolsW));\r\n\t\t\tsymbols = step( 0.5, symbols ); \r\n\r\n\t\t\tsymbols = min( symbols, circles );\r\n\r\n\t\t\t//  float rects = min(rectsX, max(circles,rectsY));\r\n\r\n\t\t\tcol = mix( col, _FlyingHelperYellowColor, circles);\r\n\t\t\tcol = mix( col, _FlyingHelperWhiteColor * 2.0, symbols)  + bloom  * _FlyingHelperBloomScale;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// The scarfs, just have a yellow border\r\n\t\t\tfloat outerBorder = step( 0.9, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\r\n\t\t\tcol \t= mix( _FlyingHelperMainColor * diff, _FlyingHelperYellowColor,  outerBorder );\r\n\t\t}\r\n\t\treturn mix( fres * col, skyCol, skyFog * _FlyingHelperFogScale );\r\n\t}\r\n\r\n\t// Character\r\n\tif( TEST_MAT_GREATER (m, MAT_CHARACTER_BASE ) )\r\n\t{\r\n\t\tfloat diff = _CharacterDiffScale * clamp( dot( nor, _LightDir ), 0.0, 1.0 );\r\n\r\n\t\t// Why did I fudge these normals, I can't remember. It does look good though, so keep it :)\r\n\t\tnor\t\t= normalize( nor + vec3(0.3,-0.1,1.0));\r\n\t\tnor.y\t*= 0.3;\r\n\r\n\t\tfloat fres\t= pow( clamp( 1.0 + dot(nor,rd) + 0.75, 0.0, 1.0), _CharacterFrePower ) * _CharacterFreScale;\r\n\t\tvec3 col\t= _CharacterMainColor;\r\n\r\n\t\t// Just base color\r\n\t\tif( TEST_MAT_LESS( m, MAT_CHARACTER_BASE) )\r\n\t\t{\r\n\t\t\t// Add sand fade to legs. Mixing terrain color at bottom of legs\r\n\t\t\tfloat heightTerrainMix\t= pow((pos.y / _CharacterHeightTerrainMix.x), _CharacterHeightTerrainMix.y);\r\n\t\t\theightTerrainMix\t\t= clamp( heightTerrainMix, 0.0, 1.0 );\r\n\t\t\tcol\t= mix( _CharacterMainColor, _CharacterTerrainCol, heightTerrainMix );\r\n\t\t}\r\n\t\t// Main Cloak\r\n\t\telse if( TEST_MAT_LESS( m,MAT_CHARACTER_MAIN_CLOAK) )\r\n\t\t{\r\n\t\t\t// Cone kind of shapes\r\n\t\t\tfloat rectsX\t= fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 7.0) ;\r\n\t\t\trectsX\t\t\t= abs(rectsX * 2.0 - 1.0);\r\n\t\t\tfloat rects\t\t= rectsX;\r\n\t\t\trects\t\t\t= step( 0.5, rects * (1.0 - mainCloakMatUVW.y*3.5) );\r\n\t\t\tcol = mix( col, _CharacterCloakDarkColor, rects );\r\n\r\n\t\t\t// Yellow borders, two lines\r\n\t\t\tfloat outerBorder\t\t= step( 0.915, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\r\n\t\t\tfloat betweenBorders\t= step( 0.88, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\r\n\t\t\tfloat innerBorder\t\t= step( 0.87, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\r\n\r\n\t\t\tinnerBorder = min( innerBorder, 1.0 - betweenBorders );\r\n\r\n\t\t\tcol  = mix( col, _CharacterCloakDarkColor,  betweenBorders );\r\n\t\t\tcol  = mix( col, _CharacterYellowColor,  outerBorder );\r\n\t\t\tcol  = mix( col, _CharacterYellowColor,  innerBorder);\r\n\r\n\t\t\t// The verticle cubes/lines running across the bottom of cloak\r\n\t\t\tfloat cubes = abs(fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 10.0)  * 2.0 - 1.0);\r\n\t\t\tcubes\t\t= min(betweenBorders, step( 0.9, cubes) );\r\n\t\t\tcol\t\t\t= mix( col, _CharacterYellowColor,  cubes);\r\n\t\t}\r\n\t\t// headscarf\r\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_NECK_SCARF) )\r\n\t\t{\r\n\t\t\tcol = mix( col, _CharacterYellowColor, step( 0.7, headScarfMatUVW.y) );\r\n\t\t}\r\n\t\t// Long Scarf\r\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_LONG_SCARF) )\r\n\t\t{\r\n\t\t\tcol = _CharacterYellowColor;\r\n\r\n\t\t\t// Yellow borders, two lines\r\n\t\t\tfloat outerBorder = step( 0.9, abs(longScarfMatUVW.x * 2.0 - 1.0) );\r\n\t\t\tfloat innerBorder = step( 0.7, abs(longScarfMatUVW.x * 2.0 - 1.0) );\r\n\r\n\t\t\tinnerBorder = min( innerBorder, 1.0 - step( 0.8, abs(longScarfMatUVW.x * 2.0 - 1.0) ) );\r\n\r\n\t\t\t// Mix borders\r\n\t\t\tcol  = mix( col, _CharacterMainColor,  outerBorder );\r\n\t\t\tcol  = mix( col, _CharacterMainColor,  innerBorder);\r\n\r\n\t\t\t// cubes in middle\r\n\t\t\tfloat rectsY = abs(fract( longScarfMatUVW.y/ 0.10 ) * 2.0 - 1.0);// - 0.5 * 0.10;\r\n\t\t\tfloat rectsX = abs(longScarfMatUVW.x * 2.0 - 1.0);\r\n\r\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\r\n\t\t\tcircles = step( 0.5, circles );\r\n\r\n\t\t\tfloat bloomCircle\t= 1.0 - (length( vec2(rectsY, rectsX * 0.7) ) - 0.1); \r\n\t\t\tfloat bloom \t\t= max( bloomCircle - 0.45, 0.0);\r\n\r\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\r\n\t\t\trectsX = 1.0 - step( 0.5, abs(longScarfMatUVW.x * 2.0 - 1.0) );\r\n\r\n\t\t\tfloat rects = min(rectsX, rectsY);\r\n\r\n\t\t\t// There are better ways of doing symbols. Spend some time on it, buddy!\r\n\t\t\tfloat symbolsX = fract(rects/(longScarfMatUVW.y * 0.17) * 10.0);\r\n\t\t\tfloat symbolsY = fract(rects/(longScarfMatUVW.x * 18.5) * 10.0);\r\n\r\n\t\t\tfloat symbols\t= symbolsX;\r\n\t\t\tsymbols\t\t\t= max( symbols, symbolsY );\r\n\t\t\tsymbols\t\t\t= step( 0.5, symbols ); \r\n\r\n\t\t\tsymbols = min( symbols, circles );\r\n\r\n\t\t\t//        float rects = min(rectsX, max(circles,rectsY));\r\n\t\t\tcol = mix( col, _CharacterMainColor, circles);\r\n\t\t\tcol = mix( col, _CharacterWhiteColor * 2.0, symbols)  + bloom * _CharacterBloomScale;\r\n\r\n\t\t\t// White glow and disintegrating the scarf, showing depleting scarf energy. Needs bloom effect :(\r\n\t\t\tcol = mix( col, _CharacterMainColor, 1.0 - smoothstep(0.4, 0.6, longScarfMatUVW.y));\r\n\t\t\tvec3 whiteMiddle = mix( col, _CharacterWhiteColor + bloom * _CharacterBloomScale, step(0.48, longScarfMatUVW.y));\r\n\t\t\tcol = mix( whiteMiddle, col, step(0.5, longScarfMatUVW.y));\r\n\t\t}\r\n\t\t// Face\r\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_FACE)  )\r\n\t\t{\r\n\t\t\tcol = vec3(0,0,0);\r\n\t\t}\r\n\t\tfloat ao = AmbientOcclusion(pos - (rd * 0.01), nor, _CharacterAOParams.x, _CharacterAOParams.y); \r\n\t\treturn ao * mix( (fres + diff) * col, skyCol, skyFog * _CharacterFogScale );\r\n\t}\r\n\treturn vec3( clamp(col * 0.0,0.0,1.0) );\r\n}\r\n\r\n\r\nfloat rand(float n)\r\n{\r\n\treturn fract(sin(n) * 43758.5453123);\r\n}\r\n\r\nfloat noise(float p)\r\n{\r\n\tfloat fl = floor(p);\r\n\tfloat fc = fract(p);\r\n    fc = fc*fc*(3.0-2.0*fc);\r\n    return mix(rand(fl), rand(fl + 1.0), fc);\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// Move camera using noise. This is probably quite expensive way of doing it :(\r\n\tfloat unitNoiseX = (noise(iTime * _CameraMovement.w ) * 2.0)  - 1.0;\r\n\tfloat unitNoiseY = (noise((iTime * _CameraMovement.w ) + 32.0) * 2.0)  -1.0;\r\n\tfloat unitNoiseZ = (noise((iTime * _CameraMovement.w ) + 48.0) * 2.0)  -1.0;\r\n\tvec3 ro = _CameraPos + vec3(unitNoiseX, unitNoiseY, unitNoiseZ) * _CameraMovement.xyz;\r\n\r\n\r\n\tvec3 screenRay\t\t= vec3(fragCoord / iResolution.xy, 1.0);\r\n\tvec2 screenCoord\t= screenRay.xy * 2.0 - 1.0;\r\n\r\n\t// Screen ray frustum aligned\r\n\tscreenRay.xy = screenCoord * _CameraFOV.xy;\r\n    screenRay.x\t\t\t*= 1.35;\r\n\tscreenRay.z  = -_CameraFOV.z;\r\n\tscreenRay /= abs( _CameraFOV.z); \r\n\r\n    // In camera space\r\n\tvec3 rd = normalize(mul( _CameraInvViewMatrix, vec4(screenRay,0.0))).xyz;\r\n\r\n\t// Do the render\r\n\tvec4 col = vec4(render(ro, rd), 0.0);\r\n\r\n\t// No it does not need gamma correct or tone mapping or any other effect that you heard about\r\n\t// and thought was cool. This is not realistic lighting\r\n\r\n\t// vignette\r\n\tfloat vig = pow(1.0 - 0.4 * dot(screenCoord, screenCoord), 0.6) * 1.25;\r\n\tvig = min( vig, 1.0);\r\n\tcol *= vig;\r\n\r\n\t// Final color\r\n\tfragColor =  col;\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\none.png","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"/*\r\n\tBefore you continue reading, feast your eyes on these beautiful Color Schemes (0,1,2)\r\n*/\r\n\r\n// Modify the number to 0,1,2 or 3 and press play button at bottom for different schemes.\r\n#define COLOR_SCHEME 1\r\n\r\n/*\r\n\tThis shader is just a tribute to \"Journey\" game by That Game Company. Some answers:\r\n\t1) No, I do not have any affiliation with That Game Company.\r\n\t2) Yes, Journey is one of the best games ever made\r\n\t3) It has taken me around 3-4 months from start to finish, evenings and weekends\r\n\t4) Most of the time was spent getting the details right\r\n\t5) Yes, the character needs more work. One day I will finish it\r\n\t6) Yes, if anybody comes up with something cool to add, I would love to improve :)\r\n\t7) There is nothing mathemagically amazing in this shader. I hope you do find it pretty though!\r\n\t8) Yes, the code is fairly ugly. But look at the colors - PRETTY!\r\n\t9) If you have any other questions, I will be happy to answer\r\n\r\n\tThis shader started as a learning playground, but around January, I finished my second round of Journey\r\n\tand thought, well why the hell not, and so here we are.\r\n\r\n\tSpecial thanks to Thibault Girard and Jack Hamilton for their artistic input. Also bigs up to Peter Pimley\r\n\tfor his constant optimism.\r\n\r\n\tYou are hereby granted your wish to follow me on twitter: @shakemayster\r\n\r\n\tOther authors (With BIG thanks !!!) \r\n\tDave_Hoskins\r\n\tDila\r\n\tMaurogik\r\n\tFabriceNeyret2\r\n*/\r\n\r\n#define RGB vec3\r\n#define mul(a,b) b*a\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n\r\n\r\n#if COLOR_SCHEME == 0\r\nconst float _FogMul = -0.00100 ;\r\nconst float _FogPow = 1.82000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.22632, 0.88099, -0.4155) ;\r\nconst float _Brightness = 1.00000 ;\r\nconst float _Contrast = 1.00000 ;\r\nconst float _Saturation = 1.00000 ;\r\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\r\nconst float _SunSize = 26.00000 ;\r\nconst float _SunScale = 15.00000 ;\r\nconst float _ExposureOffset = 11.10000 ;\r\nconst float _ExposurePower = 0.52000 ;\r\nconst float _ExposureStrength = 0.09000 ;\r\nconst RGB _SunColor = RGB(1, 0.73741, 0.63971) ;\r\nconst RGB _Zenith = RGB(0.67128, 0.94118, 0.69204) ;\r\nconst float _ZenithFallOff = 1.42000 ;\r\nconst RGB _Nadir = RGB(0, 0, 0) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.80147, 0.80147, 0.80147) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.57353, 0.1488, 0.067474) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.375, 0.21885, 0.15993) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.38971, 0.10735, 0.054444) ;\r\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.35588, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\r\nconst float _CharacterBloomScale = 0.87000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 3.84000 ;\r\nconst float _CharacterFogScale = 20.00000 ;\r\nconst float _CloudTransparencyMul = 0.90000 ;\r\nconst RGB _CloudCol = RGB(1, 0.96957, 0.88235) ;\r\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\r\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.47735, 0.59559, 0.49705) ;\r\nconst RGB _TombScarfColor = RGB(0.45588, 0.093858, 0.093858) ;\r\nconst RGB _PyramidCol = RGB(0.30147, 0.28329, 0.21059) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.05) ;\r\nconst RGB _TerrainCol = RGB(0.76863, 0.55294, 0.47059) ;\r\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 1.56000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 1.94000 ;\r\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 2.00000 ;\r\nconst float _TerrainRimSpecPower = 1.46000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.40441, 0.34106, 0.31818) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.81471, 0.74265) ;\r\nconst float _TerrainDistanceShadowPower = 0.11000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.80882, 0.11671, 0.017842) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.56187, 0.0073529) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 1.91000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 4.00000 ;\r\n#endif\r\n\r\n#if COLOR_SCHEME == 1\r\nconst float _FogMul = -0.00800 ;\r\nconst float _FogPow = 1.00000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\r\nconst float _Brightness = 0.40000 ;\r\nconst float _Contrast = 0.83000 ;\r\nconst float _Saturation = 1.21000 ;\r\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\r\nconst float _SunSize = 26.00000 ;\r\nconst float _SunScale = 15.00000 ;\r\nconst float _ExposureOffset = 11.10000 ;\r\nconst float _ExposurePower = 0.52000 ;\r\nconst float _ExposureStrength = 0.09000 ;\r\nconst RGB _SunColor = RGB(1, 0.95441, 0.77206) ;\r\nconst RGB _Zenith = RGB(0.77941, 0.5898, 0.41263) ;\r\nconst float _ZenithFallOff = 2.36000 ;\r\nconst RGB _Nadir = RGB(1, 0.93103, 0) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.96324, 0.80163, 0.38954) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.35294, 0.16016, 0.12197) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.25735, 0.028557, 0.0056769) ;\r\nconst RGB _CharacterYellowColor = RGB(0.88971, 0.34975, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(0.9928, 1, 0.47794) ;\r\nconst float _CharacterBloomScale = 0.70000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 3.84000 ;\r\nconst float _CharacterFogScale = 4.55000 ;\r\nconst float _CloudTransparencyMul = 0.90000 ;\r\nconst RGB _CloudCol = RGB(1, 0.84926, 0.69853) ;\r\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\r\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.64706, 0.38039, 0.27451) ;\r\nconst RGB _TombScarfColor = RGB(0.38971, 0.10029, 0.10029) ;\r\nconst RGB _PyramidCol = RGB(0.69853, 0.40389, 0.22086) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.3) ;\r\nconst RGB _TerrainCol = RGB(0.56618, 0.29249, 0.1915) ;\r\nconst RGB _TerrainSpecColor = RGB(1, 0.77637, 0.53676) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 1.56000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 3.20000 ;\r\nconst RGB _TerrainRimColor = RGB(0.16176, 0.13131, 0.098724) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 1.61000 ;\r\nconst float _TerrainRimSpecPower = 2.88000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.48529, 0.13282, 0) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(0.70588, 0.4644, 0.36851) ;\r\nconst float _TerrainDistanceShadowPower = 0.11000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.85294, 0.11759, 0.012543) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.3931, 0) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 2.61000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 1.75000 ;\r\n#endif\r\n\r\n#if COLOR_SCHEME == 2\r\nconst float _FogMul = -0.00100 ;\r\nconst float _FogPow = 1.68000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\r\nconst float _Brightness = 0.40000 ;\r\nconst float _Contrast = 0.82000 ;\r\nconst float _Saturation = 1.21000 ;\r\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\r\nconst float _SunSize = 26.00000 ;\r\nconst float _SunScale = 15.00000 ;\r\nconst float _ExposureOffset = 11.10000 ;\r\nconst float _ExposurePower = 0.52000 ;\r\nconst float _ExposureStrength = 0.09000 ;\r\nconst RGB _SunColor = RGB(0.97059, 0.97059, 0.97059) ;\r\nconst RGB _Zenith = RGB(0.98039, 0.83137, 0.53725) ;\r\nconst float _ZenithFallOff = 2.36000 ;\r\nconst RGB _Nadir = RGB(0, 0, 0) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.84559, 0.77688, 0.6031) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.5, 0.3404, 0.12868) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.31618, 0.14042, 0.039522) ;\r\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.30233, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\r\nconst float _CharacterBloomScale = 0.87000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 3.84000 ;\r\nconst float _CharacterFogScale = 12.47000 ;\r\nconst float _CloudTransparencyMul = 0.80000 ;\r\nconst RGB _CloudCol = RGB(0.99216, 0.9451, 0.76471) ;\r\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\r\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.94118, 0.82759, 0.45675) ;\r\nconst RGB _TombScarfColor = RGB(0.44118, 0.19989, 0.14922) ;\r\nconst RGB _PyramidCol = RGB(0.92647, 0.73579, 0.3338) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 4.65) ;\r\nconst RGB _TerrainCol = RGB(0.71324, 0.5076, 0.236) ;\r\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 0.03000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 3.20000 ;\r\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 1.61000 ;\r\nconst float _TerrainRimSpecPower = 0.38000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.66912, 0.52969, 0.369) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.75466, 0.43382) ;\r\nconst float _TerrainDistanceShadowPower = 0.11000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.91912, 0.30412, 0.21626) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(0.98529, 0.60477, 0.12316) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 1.91000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 4.00000 ;\r\n#endif\r\n\r\n#if COLOR_SCHEME == 3\r\nconst float _FogMul = -0.00100 ;\r\nconst float _FogPow = 1.82000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.29644, 0.6859, -0.66458) ;\r\nconst float _Brightness = 1.00000 ;\r\nconst float _Contrast = 1.00000 ;\r\nconst float _Saturation = 1.00000 ;\r\nconst vec3 _SunStar = vec3(20.45, 1.49, 0.5) ;\r\nconst float _SunSize = 26.09000 ;\r\nconst float _SunScale = 15.04000 ;\r\nconst float _ExposureOffset = 13.72000 ;\r\nconst float _ExposurePower = 0.60000 ;\r\nconst float _ExposureStrength = 0.02000 ;\r\nconst RGB _SunColor = RGB(0.51471, 0.79919, 1) ;\r\nconst RGB _Zenith = RGB(0, 0.053922, 0.16176) ;\r\nconst float _ZenithFallOff = 1.42000 ;\r\nconst RGB _Nadir = RGB(0.21569, 0.2549, 0.36078) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.35191, 0.30223, 0.47794) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.36765, 0.097656, 0.045956) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.083261, 0.11379, 0.16176) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.073529, 0.011604, 0) ;\r\nconst RGB _CharacterYellowColor = RGB(0.60294, 0.33162, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\r\nconst float _CharacterBloomScale = 0.87000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 19.83000 ;\r\nconst float _CharacterFogScale = 60.00000 ;\r\nconst float _CloudTransparencyMul = 0.90000 ;\r\nconst RGB _CloudCol = RGB(0.0069204, 0.15969, 0.23529) ;\r\nconst RGB _BackCloudCol = RGB(0, 0.10969, 0.15441) ;\r\nconst RGB _CloudSpecCol = RGB(0.11765, 0.11765, 0.11765) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.080882, 0.080882, 0.080882) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.23789, 0.27707, 0.40441) ;\r\nconst RGB _TombScarfColor = RGB(0.066176, 0, 0.034229) ;\r\nconst RGB _PyramidCol = RGB(0, 0, 0) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.92) ;\r\nconst RGB _TerrainCol = RGB(0, 0.058832, 0.10294) ;\r\nconst RGB _TerrainSpecColor = RGB(0.24622, 0.29188, 0.33824) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 1.56000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 1.94000 ;\r\nconst RGB _TerrainRimColor = RGB(0.091021, 0.057093, 0.16176) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 2.00000 ;\r\nconst float _TerrainRimSpecPower = 1.46000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.37) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.11029, 0.11029, 0.11029) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(0.0034061, 0.073181, 0.15441) ;\r\nconst float _TerrainDistanceShadowPower = 0.06000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.12661, 0.004109, 0.13971) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(0.48529, 0.2711, 0) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 1.91000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 5.51000 ;\r\n#endif\r\n\r\n//==========================================================================================\r\n// Play with these at your own risk. Expect, unexpected results!\r\n//==========================================================================================\r\n\r\nconst mat4 _CameraInvViewMatrix = mat4( 1, 0, 0, 1.04, \r\n0, 0.9684963, 0.2490279, 2.2, \r\n0, 0.2490279, -0.9684963, 18.6, \r\n0, 0, 0, 1 ) ;\r\nconst vec3 _CameraFOV = vec3(1.038, 0.78984, -1) ;\r\nconst vec3 _CameraPos = vec3(1.0, 2.2, 18.6) ;\r\nconst vec4 _CameraMovement = vec4(0.15, 0.1, 0.2, 0.25) ;\r\n\r\nconst vec3 _WindDirection = vec3(-0.27, -0.12, 0) ;\r\n\r\nconst float _DrawDistance = 70.00000 ;\r\nconst float _MaxSteps = 64.00000 ;\r\n\r\nconst vec3 _SunPosition = vec3(0.2, 56, -40.1) ;\r\nconst float _CharacterRotation = 0.17000 ;\r\nconst vec3 _CharacterPosition = vec3(0.52, 2.35, 17.6) ;\r\nconst vec3 _CharacterScale = vec3(0.4, 0.53, 0.38) ;\r\nconst float _MainClothRotation = 0.30000 ;\r\nconst vec3 _MainClothScale = vec3(0.3, 0.68, 0.31) ;\r\nconst vec3 _MainClothPosition = vec3(0, -0.12, 0) ;\r\nconst vec3 _MainClothBotCutPos = vec3(0, -0.52, 0) ;\r\nconst vec3 _MainClothDetail = vec3(6, 0.04, 1.3) ;\r\nconst float _HeadScarfRotation = -0.19000 ;\r\nconst vec3 _HeadScarfPosition = vec3(-0.005, -0.16, -0.01) ;\r\nconst vec3 _HeadScarfScale = vec3(0.18, 0.2, 0.03) ;\r\nconst float _HeadRotationX = -0.30000 ;\r\nconst float _HeadRotationY = 0.29000 ;\r\nconst float _HeadRotationZ = 0.00000 ;\r\nconst vec3 _HeadPos = vec3(0, -0.04, 0.01) ;\r\nconst vec3 _LongScarfPos = vec3(0.01, -0.15, 0.09) ;\r\nconst vec3 _LongScarfScale = vec3(0.05, 1.25, 0.001) ;\r\nconst vec4 _LongScarfWindStrength = vec4(0.3, 4.52, 5.2, 0.02) ;\r\nconst float _LongScarfRotX = 1.43000 ;\r\nconst float _LongScarfMaxRad = 1.99000 ;\r\nconst vec3 _FacePosition = vec3(0, -0.01, 0.05) ;\r\nconst vec3 _FaceSize = vec3(0.038, 0.05, 0.03) ;\r\nconst vec3 _UpperLeftLegA = vec3(-0.02, -0.37, 0.01) ;\r\nconst vec3 _UpperLeftLegB = vec3(-0.02, -0.67, -0.059999) ;\r\nconst vec3 _UpperLeftLegParams = vec3(0.026, 1, 1) ;\r\nconst vec3 _LowerLeftLegA = vec3(-0.02, -0.67, -0.059999) ;\r\nconst vec3 _LowerLeftLegB = vec3(-0.02, -0.77, 0.12) ;\r\nconst vec3 _LowerLeftLegParams = vec3(0.028, 0.03, 0.01) ;\r\nconst vec3 _UpperRightLegA = vec3(0.07, -0.5, 0.02) ;\r\nconst vec3 _UpperRightLegB = vec3(0.07, -0.61, 0.09) ;\r\nconst vec3 _UpperRightLegParams = vec3(0.026, 1, 1) ;\r\nconst vec3 _LowerRightLegA = vec3(0.07, -0.61, 0.09) ;\r\nconst vec3 _LowerRightLegB = vec3(0.07, -0.91, 0.22) ;\r\nconst vec3 _LowerRightLegParams = vec3(0.028, 0.03, 0.01) ;\r\nconst vec3 _BodyPos = vec3(0, -0.45, -0.03) ;\r\nconst vec3 _CharacterTrailOffset = vec3(0.72, 0.01, 0.06) ;\r\nconst vec3 _CharacterTrailScale = vec3(0.001, 0, 0.5) ;\r\nconst vec3 _CharacterTrailWave = vec3(1.97, 0, 0.34) ;\r\nconst vec2 _CharacterHeightTerrainMix = vec2(1.95, -30) ;\r\nconst vec3 _CloudNoiseStrength = vec3(0.2, 0.16, 0.1) ;\r\nconst vec3 _FrontCloudsPos = vec3(9.91, 8.6, -12.88) ;\r\nconst vec3 _FrontCloudsOffsetA = vec3(-9.1, 3.04, 0) ;\r\nconst vec3 _FrontCloudsOffsetB = vec3(-2.97, 3.72, -0.05) ;\r\nconst vec3 _FrontCloudParams = vec3(5.02, 3.79, 5) ;\r\nconst vec3 _FrontCloudParamsA = vec3(3.04, 0.16, 2) ;\r\nconst vec3 _FrontCloudParamsB = vec3(1.34, 0.3, 3.15) ;\r\nconst vec3 _BackCloudsPos = vec3(29.99, 13.61, -18.8) ;\r\nconst vec3 _BackCloudsOffsetA = vec3(24.87, -1.49, 0) ;\r\nconst vec3 _BackCloudParams = vec3(7.12, 4.26, 1.68) ;\r\nconst vec3 _BackCloudParamsA = vec3(6.37, 2.23, 2.07) ;\r\nconst vec3 _PlaneParams = vec3(7.64, 10.85, 3.76) ;\r\nconst vec3 _CloudGlobalParams = vec3(0.123, 2.1, 0.5) ;\r\nconst vec3 _CloudBackGlobalParams = vec3(0.16, 1.4, -0.01) ;\r\nconst vec3 _CloudNormalMod = vec3(0.26, -0.13, 1.22) ;\r\nconst float _CloudSpecPower = 24.04000 ;\r\nconst float _CloudPyramidDistance = 0.14500 ;\r\nconst vec3 _TombPosition = vec3(5, 5, 9.28) ;\r\nconst vec3 _TombScale = vec3(0.07, 0.5, 0.006) ;\r\nconst vec3 _TombBevelParams = vec3(0.44, 0.66, 0.01) ;\r\nconst float _TombRepScale = 0.79000 ;\r\nconst vec3 _TombCutOutScale = vec3(0.39, 0.06, -14.92) ;\r\nconst vec3 _TombScarfOffset = vec3(0, 0.46, 0) ;\r\nconst vec3 _TombScarfWindParams = vec3(-1.61, 6, 0.05) ;\r\nconst vec3 _TombScarfScale = vec3(0.03, 0.002, 0.5) ;\r\nconst float _TombScarfRot = -0.88000 ;\r\nconst mat4 _TombScarfMat = mat4( 0.9362437, 0, -0.3513514, 0, \r\n0, 1, 0, 0, \r\n0.3513514, 0, 0.9362437, 0, \r\n0, 0, 0, 1 ) ;\r\nconst vec3 _PyramidPos = vec3(0, 10.9, -50) ;\r\nconst vec3 _PyramidScale = vec3(34.1, 24.9, 18) ;\r\nconst vec3 _PrismScale = vec3(1, 1.9, 1) ;\r\nconst vec3 _PyramidNoisePrams = vec3(1.5, 1, 1) ;\r\nconst vec3 _PrismEyeScale = vec3(0.7, 1.9, 51.5) ;\r\nconst vec3 _PyramidEyeOffset = vec3(2.0, -4.9, 0) ;\r\nconst float _PrismEyeWidth = 5.86000 ;\r\nconst float _TerrainMaxDistance = 30.04000 ;\r\nconst float _SmallDetailStrength = 0.00600 ;\r\nconst vec3 _SmallWaveDetail = vec3(3.19, 16, 6.05) ;\r\nconst vec2 _WindSpeed = vec2(2, 0.6) ;\r\nconst float _MediumDetailStrength = 0.05000 ;\r\nconst vec2 _MediumWaveDetail = vec2(2, 50) ;\r\nconst vec3 _MediumWaveOffset = vec3(0.3, -2, 0.1) ;\r\nconst vec2 _LargeWaveDetail = vec2(0.25, 0.73) ;\r\nconst vec3 _LargeWavePowStre = vec3(0.6, 2.96, -2.08) ;\r\nconst vec3 _LargeWaveOffset = vec3(-3.65, 4.41, -11.64) ;\r\nconst vec3 _FlyingHelperPos = vec3(2.15, 4.68, 14.4) ;\r\nconst vec3 _FlyingHelperScale = vec3(0.25, 0.001, 0.3) ;\r\nconst vec3 _FlyingHelperMovement = vec3(0.44, 1.44, -2.98) ;\r\nconst vec3 _FlyingHelperScarfScale = vec3(0.1, 0.001, 1.5) ;\r\nconst vec3 _FlyingHelperScarfWindParams = vec3(-0.06, 0.31, 0.47) ;\r\nconst vec3 _FlyingHelperScarfWindDetailParams = vec3(3.93, 0.005, -45.32) ;\r\nconst vec3 _FlyingHelperSideScarfOffset = vec3(0.16, -0.01, 0) ;\r\nconst vec3 _FlyingHelperSideScarfScale = vec3(0.06, 0.001, 0.8) ;\r\nconst vec4 _FlyingScarfSideWindParams = vec4(2.46, -1.59, -0.05, 0.21) ;\r\n\r\n// Material ID definitions\r\n#define MAT_PYRAMID 1.0\r\n\r\n#define MAT_TERRAIN 10.0\r\n#define MAT_TERRAIN_TRAIL 11.0\r\n\r\n#define MAT_BACK_CLOUDS 20.0\r\n#define MAT_FRONT_CLOUDS 21.0\r\n\r\n#define MAT_TOMB 30.0\r\n#define MAT_TOMB_SCARF 31.0\r\n\r\n#define MAT_FLYING_HELPERS 40.0\r\n#define MAT_FLYING_HELPER_SCARF 41.0\r\n\r\n#define MAT_CHARACTER_BASE 50.0\r\n#define MAT_CHARACTER_MAIN_CLOAK 51.0\r\n#define MAT_CHARACTER_NECK_SCARF 52.0\r\n#define MAT_CHARACTER_LONG_SCARF 53.0\r\n#define MAT_CHARACTER_FACE 54.0\r\n\r\n#define TEST_MAT_LESS( a, b ) a < (b + 0.1)\r\n#define TEST_MAT_GREATER( a, b ) a > (b - 0.1)\r\n\r\n//==========================================================================================\r\n// Primitive functions by IQ\r\n//==========================================================================================\r\nfloat sdRoundBox(vec3 p, vec3 b, float r)\r\n{\r\n\treturn length( max( abs(p) - b, 0.0) ) - r;\r\n}\r\n\r\nfloat sdSphere(vec3 p, float s)\r\n{\r\n\treturn length(p) - s;\r\n}\r\n\r\nfloat sdPlane( vec3 p )\r\n{\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b)\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) +\r\n\t\tlength(max(d, 0.0));\r\n}\r\n\r\nfloat sdCylinder(vec3 p, vec2 h)\r\n{\r\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\r\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nfloat sdPlane(vec3 p, vec4 n)\r\n{\r\n\t// n must be normalized\r\n\treturn dot(p, n.xyz) + n.w;\r\n}\r\n\r\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\r\n{\r\n\tvec3 pa = p - a, ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn vec2( length( pa - ba*h ), h );\r\n}\r\n\r\nfloat sdEllipsoid(in vec3 p, in vec3 r)\r\n{\r\n\treturn (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\r\n}\r\n\r\nfloat sdTriPrism( vec3 p, vec2 h )\r\n{\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\n\r\n//==========================================================================================\r\n// distance field operations\r\n//==========================================================================================\r\nvec2 min_mat( vec2 d1, vec2 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\r\n    return mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\nvec2 smin_mat( vec2 a, vec2 b, float k, float c )\r\n{\r\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\r\n    float x = mix( b.x, a.x, h ) - k*h*(1.0-h);\r\n    return vec2( x, ( h < c ) ? b.y : a.y);\r\n}\r\n\r\nfloat smax( float a, float b, float k )\r\n{\r\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\r\n\treturn mix( a, b, h ) + k*h*(1.0-h);\r\n}\r\n\r\n//==========================================================================================\r\n// Rotations\r\n//==========================================================================================\r\nvoid rX(inout vec3 p, float a) {\r\n    vec3 q = p;\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    p.y = c * q.y - s * q.z;\r\n    p.z = s * q.y + c * q.z;\r\n}\r\n\r\nvoid rY(inout vec3 p, float a) {\r\n    vec3 q = p;\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    p.x = c * q.x + s * q.z;\r\n    p.z = -s * q.x + c * q.z;\r\n}\r\n\r\nvoid rZ(inout vec3 p, float a) {\r\n    vec3 q = p;\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    p.x = c * q.x + s * q.y;\r\n    p.y = -s * q.x + c * q.y;\r\n}\r\n\r\n//==========================================================================================\r\n// Value noise and its derivatives: https://www.shadertoy.com/view/MdX3Rr\r\n//==========================================================================================\r\nvec3 noised( in vec2 x )\r\n{\r\n    vec2 f = fract(x);\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\r\n#if 0\r\n    // texel fetch version\r\n    ivec2 p = ivec2(floor(x));\r\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\r\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\r\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\r\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\r\n#else    \r\n    // texture version    \r\n    vec2 p = floor(x);\r\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n#endif\r\n    \r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\r\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\n\r\n//==========================================================================================\r\n// Noise function: https://www.shadertoy.com/view/4sfGRH \r\n//==========================================================================================\r\nfloat pn(vec3 p) {\r\n    vec3 i = floor(p); \r\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\r\n    vec3 f = cos((p-i)*3.141592653589793)*(-.5) + .5;  \r\n\ta = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\r\n    a.xy = mix(a.xz, a.yw, f.y);   \r\n\treturn mix(a.x, a.y, f.z);\r\n}\r\n\r\n//==========================================================================================\r\n// Sin Wave approximation http://http.developer.nvidia.com/GPUGems3/gpugems3_ch16.html\r\n//==========================================================================================\r\nvec4  SmoothCurve( vec4 x ) {  \r\n  return x * x * ( 3.0 - 2.0 * x );  \r\n}\r\n\r\nvec4 TriangleWave( vec4 x ) {  \r\n  return abs( fract( x + 0.5 ) * 2.0 - 1.0 );  \r\n}\r\n\r\nvec4 SmoothTriangleWave( vec4 x ) {  \r\n  return SmoothCurve( TriangleWave( x ) );  \r\n}  \r\n\r\nfloat SmoothTriangleWave( float x )\r\n{\r\n  return SmoothCurve( TriangleWave( vec4(x,x,x,x) ) ).x;  \r\n}  \r\n\r\nvoid Bend(inout vec3 vPos, vec2 vWind, float fBendScale)\r\n{\r\n\tfloat fLength = length(vPos);\r\n\tfloat fBF = vPos.y * fBendScale;  \r\n\tfBF += 1.0;  \r\n\tfBF *= fBF;  \r\n\tfBF = fBF * fBF - fBF;  \r\n\tvec3 vNewPos = vPos;  \r\n\tvNewPos.xz += vWind.xy * fBF;  \r\n\tvPos.xyz = normalize(vNewPos.xyz)* fLength;  \r\n}\r\n\r\n//==========================================================================================\r\n// Modified cone versions for scarf and main cloak\r\n//==========================================================================================\r\nfloat sdScarfCone( in vec3 p, in float h, in float r1, in float r2 )\r\n{\r\n    float d1 = -p.y - h;\r\n    float q = (p.y - h);\r\n    float si = 0.5*(r1-r2)/h;\r\n    p.z = mix(p.z, p.z * 0.2, q);\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\n\r\nvec2 sdCloakCone( in vec3 p, in float h, in float r1, in float r2 )\r\n{\r\n    float d1 = -p.y - h;\r\n    float q = (p.y - h);\r\n    r2 = (q * r2) + 0.08;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return vec2(length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.), q);\r\n}\r\n\r\n//==========================================================================================\r\n// Character\r\n//==========================================================================================\r\nvec3 headScarfMatUVW;\r\nfloat sdHeadScarf(vec3 pos)\r\n{\r\n\t\r\n    vec3 headScarfPos = pos - _HeadScarfPosition;\r\n    rX( headScarfPos, _HeadScarfRotation );\r\n\r\n    float distanceToTop =  min(0.0,(pos.y + 0.01));\r\n\r\n    // Put a slight twist in the middle. Gives the feel that the head scarf\r\n    // is sitting on shoulders. Very subtle, but I can see it :D\r\n    float midBend = abs( fract( distanceToTop + 0.5 ) * 2.0 - 1.0 );\r\n    headScarfPos.x += (cos( 2.0 + headScarfPos.y * 50.0 ) * 0.05 * midBend);\r\n    headScarfPos.z += (sin( 2.0 + headScarfPos.y * 50.0 ) * 0.03 * midBend);\r\n\r\n    // Apply wind to head Scarf    \r\n    headScarfPos += SmoothTriangleWave(vec4(pos.xyz * 5.0+ iTime,1.0) ).xyz * 0.05 * distanceToTop;\r\n\r\n    // Scarf shape    \r\n    float headScarf = sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z );\r\n    headScarf = max(headScarf, -sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z - 0.011));\r\n    \r\n    // Cut out the bottom of the head scarf. I have no idea what I was thinking, when I wrote this\r\n    vec3 cutOutPos = headScarfPos - vec3( 0.0, 0.08, 0.0);\r\n    vec3 r = vec3(0.12, 0.8, 0.2);\r\n    float smallestSize = min(min(r.x,r.y),r.z);\r\n\tvec3 dp = cutOutPos/r;\r\n    float h = min(1.0, abs(1.0 - abs(dp.y)) );\r\n\r\n    // Apply some crazy power until it looks like a scarf sitting on shoulders\r\n    h =  pow(h, 5.5);\r\n    \r\n    float rad = h ;\r\n    float d = length( cutOutPos/r );\r\n    \r\n    float cutOut = (d - rad) * smallestSize;\r\n    headScarf\t= max(headScarf, cutOut);\r\n\r\n    // material information\r\n    float materialVal = 1.0 - pow(d - rad, 0.02);\r\n\theadScarfMatUVW = smoothstep( -1.0, 1.0, materialVal / _HeadScarfScale);\r\n\r\n\t// Chop the top off, to make room for head\r\n    vec3 headPos = pos - vec3(0.0, 0.25, 0.0);\r\n    float head   = sdBox(headPos, vec3(0.2, 0.19, 0.2)); \r\n    headScarf = max(headScarf, -head);\r\n    \r\n    return headScarf;\r\n}\r\nvec3 mainCloakMatUVW;\r\nfloat sdMainCloak(vec3 pos)\r\n{\r\n    vec3 cloakPos = pos - _MainClothPosition;\r\n    float q =  min(0.0,(cloakPos.y + 0.05));\r\n    rX( cloakPos, _MainClothRotation );\r\n    \r\n    // Apply detailing\r\n    cloakPos += SmoothTriangleWave(vec4(pos.xyz * _MainClothDetail.x + iTime,1.0) ).xyz * _MainClothDetail.y * q;\r\n    \r\n    // Add main Wind direction\r\n    Bend(cloakPos, _WindDirection.xy, _MainClothDetail.z);\r\n    \r\n    vec2 cloak = sdCloakCone( cloakPos, _MainClothScale.y, _MainClothScale.x, _MainClothScale.z);\r\n    // Cut out the internals of the cloak\r\n    cloak.x = max( cloak.x, -sdCloakCone( cloakPos, _MainClothScale.y * 1.05, _MainClothScale.x * 0.95, _MainClothScale.z * 1.01).x);\r\n\r\n    // UV Information\r\n    mainCloakMatUVW = smoothstep( -1.0, 1.0, cloakPos / _MainClothScale);\r\n\r\n    // Cut out the top section\r\n    vec3 headPos = cloakPos - vec3(0.0, 0.69, 0.0);\r\n    float head   = sdBox(headPos, vec3(0.2, 0.67, 0.2)); \r\n\tcloak.x = max(cloak.x, -head);\r\n    \r\n    // Cut the bottom\r\n    float bottomCut   = sdPlane(cloakPos - _MainClothBotCutPos); \r\n    cloak.x = max(cloak.x, -bottomCut);\r\n    \r\n    return cloak.x;\r\n}\r\n\r\nfloat earWigs(in vec3 pos) \r\n{   \r\n\t// Symmetrical ear wigs. Is that even a word... Ear Wigs!\r\n    pos.x = abs(pos.x);\r\n\r\n    vec2  earWig = sdSegment( pos, vec3(0.02, 0.11, 0.0), vec3(0.07, 0.16, 0.05));\r\n    float ear  = earWig.x - 0.026  + (earWig.y * 0.03);\r\n    return ear;\r\n}\r\n\r\n\r\nfloat sdHead( vec3 pos )\r\n{\r\n    vec3 headPos = pos - _HeadPos;\r\n\r\n    // Slight tilt\r\n    rY(headPos, _HeadRotationY ); // 1.2\r\n    rX(headPos, _HeadRotationX );\r\n\r\n    float head = sdCylinder( headPos, vec2(0.05, 0.13) );\r\n    head = smin(earWigs(headPos), head, 0.04 );\r\n    return head;\r\n}\r\n\r\nvec3 longScarfMatUVW;\r\nfloat sdScarf(vec3 pos) \r\n{\r\n    vec3 scarfPos = pos - _LongScarfPos;\r\n    vec3 scale \t= _LongScarfScale;\r\n\r\n\r\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.04);\r\n    scarfPos.x += (sin( scarfPos.z * _LongScarfWindStrength.x + iTime ) * 0.1 * distanceToPoint);\r\n    scarfPos.y += (sin( scarfPos.z * _LongScarfWindStrength.y + iTime ) * 0.1 * distanceToPoint);\r\n\r\n    // Apply detailing\r\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _LongScarfWindStrength.z + iTime,1.0) ).xyz * _LongScarfWindStrength.w * distanceToPoint;\r\n\r\n    // Essentially a box pivoted at a specific point\r\n    vec3 scarfOffset = vec3(0.0, 0.0, -scale.y);\r\n\r\n    rX(scarfPos, _LongScarfRotX) ;\r\n    float scarf = sdBox(scarfPos - scarfOffset.xzy , scale);\r\n\r\n    longScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos - scarfOffset.xzy ) / scale);\r\n\r\n    return max(scarf, sdSphere( scarfPos, _LongScarfMaxRad ));\r\n}\r\n\r\nfloat sdLegs( in vec3 pos  )\r\n{\r\n    vec2  upperLeftLeg = sdSegment( pos, _UpperLeftLegA, _UpperLeftLegB );\r\n    float leftLeg  = upperLeftLeg.x - _UpperLeftLegParams.x;\r\n    vec2 lowerLeftLeg = sdSegment( pos, _LowerLeftLegA, _LowerLeftLegB );\r\n    leftLeg  = smin( leftLeg, lowerLeftLeg.x - _LowerLeftLegParams.x + (lowerLeftLeg.y * _LowerLeftLegParams.y), _LowerLeftLegParams.z);\r\n\r\n    // cut bottom of left leg otherwise looks nasty with harsh tip\r\n    leftLeg = max( leftLeg, -(length( pos - _LowerLeftLegB) - 0.06 ) );\r\n\r\n    vec2  upperRightLeg = sdSegment( pos, _UpperRightLegA, _UpperRightLegB );\r\n    float rightLeg  = upperRightLeg.x - _UpperRightLegParams.x;\r\n    vec2 lowerRightLeg = sdSegment( pos, _LowerRightLegA, _LowerRightLegB );\r\n    rightLeg  = smin( rightLeg, lowerRightLeg.x - _LowerRightLegParams.x + (lowerRightLeg.y * _LowerRightLegParams.y), _LowerRightLegParams.z);\r\n\r\n    return min( leftLeg, rightLeg );\r\n}\r\n\r\nvec2 sdFace( vec3 pos, vec2 currentDistance )\r\n{\r\n    vec3 headPos = pos - vec3(0.0, -0.05, 0.0);\r\n    rX( headPos, _HeadRotationX );\r\n    rY(headPos, _HeadRotationY );\r\n\r\n    // head hole - Fire in the hole!    \r\n    // OK this does not look right. Actually looks like there was \"fire in the hole\" for \r\n    // the poor travellers face. Need to come back to it one day and finish it. Maybe!\r\n    vec3 headHole = headPos - vec3(0.0, 0.1, -0.07);\r\n    float hole = sdEllipsoid( headHole,vec3(0.05, 0.03, 0.04) );\r\n    hole  = smin ( hole, sdEllipsoid( headHole - vec3(0.0, -0.03, 0.0), vec3(0.03,0.03, 0.04)), 0.05 );\r\n\r\n    // Cut it OUT!\r\n    float character =  smax( currentDistance.x, -hole, 0.001);\r\n\r\n    // face. Meh just an ellipsoid. Need to add eyes and bandana\r\n    float face = sdEllipsoid( headHole - _FacePosition.xyz, _FaceSize );\r\n    return smin_mat( vec2(face, MAT_CHARACTER_FACE), vec2(character,currentDistance.y), 0.01, 0.2 );\r\n}\r\n\r\nvec2 sdCharacter( vec3 pos )\r\n{\r\n    // Now we are in character space - Booo YA! - I never ever say Boooo YA!. Peter Pimley \r\n    // says that. Peter: have you been putting comments in my code?\r\n    pos -= _CharacterPosition;\r\n    vec3 scale = _CharacterScale;\r\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\r\n    \r\n    rY(pos, _CharacterRotation);\r\n\r\n    pos /= scale;\r\n\r\n    float mainCloak = sdMainCloak( pos );\r\n    vec2  mainCloakMat = vec2(mainCloak, MAT_CHARACTER_MAIN_CLOAK );\r\n\r\n    float headScarf = sdHeadScarf(pos);\r\n    vec2  headScarfMat = vec2(headScarf, MAT_CHARACTER_NECK_SCARF );\r\n\r\n    float longScarf = sdScarf(pos);\r\n    vec2  longScarfMat = vec2( longScarf, MAT_CHARACTER_LONG_SCARF );\r\n    headScarfMat = smin_mat( headScarfMat, longScarfMat, 0.02, 0.1 );\r\n\r\n    float head      = sdHead( pos );\r\n    vec2  headMat\t= vec2( head, MAT_CHARACTER_BASE );\r\n    headScarfMat    = smin_mat(headScarfMat, headMat, 0.05, 0.75);\r\n\r\n    vec2  characterMat = min_mat(mainCloakMat, headScarfMat); \r\n    characterMat = sdFace( pos, characterMat );\r\n\r\n    vec2 legsMat = vec2( sdLegs(pos), MAT_CHARACTER_BASE );\r\n    characterMat = min_mat( characterMat, legsMat );\r\n\r\n    // chope the bottom. This is to chop the bottom of right leg. Though\r\n    // I have positioned the character so that the right leg is hidden by terrain. \r\n    // Commenting it out for now\r\n//    characterMat.x = max( characterMat.x, -sdPlane( pos - vec3(0.0, -0.85, 0.0) ) );\r\n    characterMat.x *= scaleMul;\r\n\r\n\r\n    return characterMat;\r\n}\r\n\r\n//==========================================================================================\r\n// Clouds\r\n//==========================================================================================\r\nfloat sdCloud( in vec3 pos, vec3 cloudPos, float rad, float spread, float phaseOffset, vec3 globalParams)\r\n{ \r\n\t// Clouds are simple. A bunch of spheres with varying phase offset, size and \r\n\t// frequency values. They are also scaled along the z-Axis so more like circles\r\n\t// than spheres. With additional noise to make them look fluffy. \r\n\t// While rendering them we \"perturb\" #SpellCheck the normals to get strong specular\r\n\t// highlights\r\n\r\n\t// Add noise to the clouds\r\n\tpos += pn( pos ) * _CloudNoiseStrength;\r\n\tpos = pos - cloudPos;\r\n\r\n\t// Make us 2d-ish - My artists have confirmed me: 2D is COOL!\r\n\tpos.z /= globalParams.x;\r\n\r\n\t// Repeat the space\r\n\tfloat repitition = rad * 2.0 + spread;\r\n\tvec3  repSpace = pos - mod( pos - repitition * 0.5, repitition);\r\n\r\n\t// Create the overall shape to create clouds on\r\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.23  )  * globalParams.y ;\r\n\r\n\t// Creates clouds with offset on the main path\r\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.9 ) * globalParams.z;\r\n\r\n\t// repeated spheres\r\n\tpos.x = fract( (pos.x + repitition * 0.5) / repitition ) * repitition - repitition * 0.5;\r\n\r\n\t// return the spheres  \r\n\tfloat sphere = length(pos)- rad;\r\n\treturn sphere * globalParams.x;\r\n}\r\n\r\nvec2 sdClouds( in vec3 pos )\r\n{\r\n\t// Two layers of clouds. A layer in front of the big pyramid\r\n    float c1 = sdCloud( pos, _FrontCloudsPos, _FrontCloudParams.x, _FrontCloudParams.y, _FrontCloudParams.z, _CloudGlobalParams );\r\n    float c2 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetA, _FrontCloudParamsA.x, _FrontCloudParamsA.y, _FrontCloudParamsA.z, _CloudGlobalParams );\r\n    float c3 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetB, _FrontCloudParamsB.x, _FrontCloudParamsB.y, _FrontCloudParamsB.z, _CloudGlobalParams);\r\n    float frontClouds = min(c3, min(c1, c2));\r\n\r\n    // This plane hides the empty spaces between the front cloud spheres. Not needed\r\n    // for back spheres, they are covered by front spheres\r\n  \tfloat mainPlane = length(pos.z - _FrontCloudsPos.z) / _CloudGlobalParams.x + (pos.y - _PlaneParams.y  + sin(_PlaneParams.x + pos.x * 0.23 ) * _PlaneParams.z);// - rad;\r\n  \tfrontClouds = min(mainPlane * _CloudGlobalParams.x, frontClouds);\r\n\r\n\t// Second layer behind the big Pyramid\r\n    float c4 = sdCloud( pos, _BackCloudsPos, _BackCloudParams.x, _BackCloudParams.y, _BackCloudParams.z, _CloudBackGlobalParams );\r\n    float c5 = sdCloud( pos, _BackCloudsPos + _BackCloudsOffsetA, _BackCloudParamsA.x, _BackCloudParamsA.y, _BackCloudParamsA.z, _CloudBackGlobalParams );\r\n    float backClouds = min(c4,c5);\r\n    return min_mat(vec2(frontClouds,MAT_FRONT_CLOUDS), vec2(backClouds,MAT_BACK_CLOUDS));\r\n}\r\n\r\n//==========================================================================================\r\n// This should really be called Kites. No such thing as Flying Helplers...\r\n//==========================================================================================\r\nvec3 helperScarfMatUVW;\r\nfloat sdHelperScarf(vec3 pos, vec3 scarfOffset, vec3 originalPos ) \r\n{\r\n    vec3 scarfPos = pos - scarfOffset;\r\n\r\n    vec3 scale = _FlyingHelperScarfScale;\r\n\r\n    // How far are we from pivot of scarf\r\n    float distanceToPoint = length(scarfPos );\r\n\r\n    // Apply some motion\r\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _FlyingHelperScarfWindDetailParams.x + iTime,1.0) ).xyz * _FlyingHelperScarfWindDetailParams.y * distanceToPoint;\r\n\r\n    vec2 wave;\r\n    wave.x = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.x  );\r\n    wave.y = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.z  );\r\n\r\n    scarfPos.xy += ( wave * _FlyingHelperScarfWindParams.y * distanceToPoint);\r\n    vec3  pivotOffset = vec3(0.0, 0.0, scale.z);\r\n    float scarf = sdBox(scarfPos - pivotOffset, scale);\r\n\r\n    // Move us along the z-axis because we chop a sphere in the box. Shows borders otherwise\r\n    vec3 UVWOffset = vec3(0.0, 0.0, 1.0);\r\n    helperScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos + UVWOffset - pivotOffset.xzy ) / scale);\r\n\r\n    // Two scarf on each side of the big'un\r\n    pivotOffset.z = _FlyingHelperSideScarfScale.z;\r\n\r\n\twave.y = originalPos.x > 0.0 ? wave.y * _FlyingScarfSideWindParams.x : wave.y * _FlyingScarfSideWindParams.y;\r\n\tscarfPos.xy += scarfPos.x > 0.0 ? wave * _FlyingScarfSideWindParams.z : wave * _FlyingScarfSideWindParams.w;\r\n\r\n\t// legit mirroring!\r\n\tscarfPos.x = -abs(scarfPos.x);\r\n\tfloat sideScarfs = sdBox(scarfPos - pivotOffset + _FlyingHelperSideScarfOffset, _FlyingHelperSideScarfScale);\r\n\r\n\t// Just override the helperScarfMatUVW value for side scarfs. Too tired to create another variable and use that, not too tired\r\n\t// to write this long comment of no value\r\n    helperScarfMatUVW = scarf < sideScarfs ? helperScarfMatUVW : smoothstep(-1.0, 1.0, ( scarfPos - pivotOffset + _FlyingHelperSideScarfOffset ) / _FlyingHelperSideScarfScale);\r\n\r\n    // Combine'em\r\n    scarf = min( scarf, sideScarfs );\r\n    return scarf;\r\n}\r\n\r\nvec2 sdFlyingHelpers( vec3 pos )\r\n{\r\n\tvec3 originalPos = pos;\r\n\tfloat flyingHelper = _DrawDistance;\r\n\r\n\t// Using pos.x to determine, whether we are rendering left or right scarf.\r\n\tvec3 helperPos = _FlyingHelperPos;\r\n\thelperPos = pos.x > 0.0 ? helperPos - _FlyingHelperMovement : helperPos;\r\n\r\n\t// Rest is just mirroring\r\n\tpos.x = abs(pos.x);\r\n\tpos = pos - helperPos;\r\n\r\n\tfloat helperScarf = sdHelperScarf( pos, vec3(0.0, 0.0, 0.0), originalPos);\r\n\r\n\t// Main helper is a box with a cutout sphere at back. In-game it is more sophisticated. But\r\n\t// I am running out of time. Maybe will do a proper one, one day!\r\n\tfloat helper = sdBox( pos, _FlyingHelperScale );\r\n\thelper\t= max( helper, -sdSphere( pos - vec3(0.0, 0.0, _FlyingHelperScale.z ), _FlyingHelperScale.z) );\r\n\r\n\t// Material and combine scarf with main body\r\n\tvec2 helperMat = smin_mat( vec2(helper,MAT_FLYING_HELPERS), vec2(helperScarf,MAT_FLYING_HELPER_SCARF), 0.01, 0.1);\r\n\thelperScarfMatUVW = helper < helperScarf ? smoothstep(-1.0, 1.0, (pos + vec3(0.0,0.0,_FlyingHelperScale.z*0.5)) / _FlyingHelperScale) : helperScarfMatUVW;\r\n\r\n\treturn helperMat;\r\n}\r\n\r\n//==========================================================================================\r\n// The big mountain in the distance. Again, not a pyramid\r\n//==========================================================================================\r\nfloat sdBigMountain( in vec3 pos )\r\n{\r\n    float scaleMul = min(_PyramidScale.x, min(_PyramidScale.y, _PyramidScale.z));\r\n    vec3 posPyramid\t= pos - _PyramidPos;\r\n\r\n    // Apply noise derivative, then we can use a blocky looking texture to make the mountain\r\n    // look edgy (for lack of better word)\r\n    float derNoise\t\t= sin(noised(posPyramid.xz * _PyramidNoisePrams.x).x) * _PyramidNoisePrams.y;\r\n    posPyramid.x\t\t= posPyramid.x + derNoise;\r\n\r\n    posPyramid /= _PyramidScale;\r\n    float pyramid = sdTriPrism(  posPyramid, _PrismScale.xy ) * scaleMul;\r\n\r\n    // The piercing eye. Which is just an inverted pyrmaid on top of main pyramid.\r\n    float eyeScale = _PyramidScale.x;\r\n\r\n    vec3 posEye = pos;\r\n    posEye.y = _PrismEyeScale.z - pos.y;\r\n    posEye.x = pos.x * _PrismEyeWidth;\r\n\r\n\tfloat eye = sdTriPrism(  (posEye -_PyramidEyeOffset) / eyeScale, _PrismEyeScale.xy ) * eyeScale;\r\n\treturn max(pyramid, -eye);\r\n}\r\n\r\n//==========================================================================================\r\n// Main desert shape\r\n//==========================================================================================\r\nfloat sdLargeWaves( in vec3 pos )\r\n{\r\n\t// The main shape of terrain. Just sin waves, along X and Z axis, with a power\r\n\t// curve to make the shape more pointy \r\n\r\n    // Manipulate the height as we go in the distance\r\n    // We want terrain to be a specific way closer to character, showing a path, but the path \r\n    // gets muddier as wo go in the distance.\r\n\r\n    float distZ = abs(pos.z - _CameraPos.z);\r\n    float distX = abs(pos.x - _CameraPos.x);\r\n    float dist = (distZ ) + (distX * 0.1);\r\n    dist = dist * dist * 0.01;\r\n\r\n    float detailNoise = noised(pos.xz).x * -2.5; \r\n\tfloat largeWaves = (sin(_LargeWaveOffset.z + pos.z * _LargeWaveDetail.y + pos.z * 0.02)  \r\n\t\t\t\t\t  * sin((_LargeWaveOffset.x + dist) + (pos.x * _LargeWaveDetail.x) ) * 0.5) + 0.5;\r\n    largeWaves = -_LargeWaveOffset.y + pow( largeWaves, _LargeWavePowStre.x) *  _LargeWavePowStre.y - detailNoise * 0.1 ;// - (-pos.z*_LargeWavePowStre.z);// \r\n\r\n    // Smoothly merge with the bottom plane of terrain\r\n    largeWaves = smin(largeWaves, _LargeWavePowStre.z, 0.2);\r\n    largeWaves = (largeWaves - dist);\r\n    return largeWaves * 0.9;\r\n}\r\n\r\nfloat sdSmallWaves( in vec3 pos )\r\n{\r\n\t// The small waves are used for adding detail to the main shape of terrain\r\n\tfloat distanceToCharacter = length( pos.xz - _CharacterPosition.xz );\r\n\r\n    // movement to give feel of wind blowing\r\n    float detailNoise = noised(pos.xz).x * _SmallWaveDetail.z; \r\n\tfloat smallWaves = sin(pos.z * _SmallWaveDetail.y + detailNoise + iTime * _WindSpeed.y ) * \r\n\t\t\t\t\t   sin(pos.x * _SmallWaveDetail.x + detailNoise + iTime * _WindSpeed.x ) * _SmallDetailStrength;// * min(1.0, distanceToCharacter);\r\n\t\r\n\treturn smallWaves * 0.9;\r\n}\r\n\r\nfloat sdTerrain( in vec3 pos)\r\n{\r\n\tfloat smallWaves = sdSmallWaves( pos );\r\n\tfloat largeWaves = sdLargeWaves( pos );\r\n\r\n    return (smallWaves + largeWaves);\r\n}\r\n\r\nvec2 sdDesert( in vec3 pos, in float terrain )\r\n{\r\n    float distanceToPos = length(pos.xz - _CameraPos.xz);\r\n    if( distanceToPos > _TerrainMaxDistance)\r\n        return vec2(_DrawDistance, 0.0);\t\r\n\r\n   \tfloat mat = 9.0;//length(pos.xyz) > 9.0 ? 10.0 : 40.0;\r\n    return vec2( pos.y + terrain, MAT_TERRAIN );\r\n}\r\n\r\n//==========================================================================================\r\n// Character trail in the sand\r\n//==========================================================================================\r\nfloat sdCharacterTrail( vec3 pos, in float terrain )\r\n{\r\n\tvec3 trailOffset = (_CharacterPosition);\r\n\ttrailOffset.yz  += (_CharacterTrailOffset).yz;\r\n    trailOffset.y = -terrain + _CharacterTrailOffset.y; \r\n\r\n    vec3 trailPos = pos - trailOffset;\r\n    float distanceToPoint = length(trailPos);\r\n    trailPos.x -= _CharacterTrailOffset.x * distanceToPoint;\r\n\r\n    // Make it wavy\r\n    trailPos.x += (SmoothTriangleWave( trailPos.z * _CharacterTrailWave.x  ) * _CharacterTrailWave.z * distanceToPoint);\r\n\r\n    float trail = sdBox(trailPos - vec3(0.0, 0.0, _CharacterTrailScale.z) , _CharacterTrailScale);\r\n    return trail;\r\n}\r\n\r\n//==========================================================================================\r\n// The tombs\r\n//==========================================================================================\r\nfloat sdTombScarf(vec3 pos, vec3 scarfOffset, float t ) \r\n{ \r\n\t//  scarfs, done same as other scarfs\r\n\r\n    vec3 scarfPos = pos - scarfOffset;\r\n\r\n    scarfPos =  (mul(  _TombScarfMat, vec4(scarfPos,1.0) )).xyz;\r\n\r\n    vec3 scale = _TombScarfScale;\r\n    scale.z  += (t + 1.0 ) * 0.2;\r\n\r\n    // How far are we from pivot of scarf\r\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.1);\r\n\r\n    // Make the scarf thicker as it goes out\r\n    scale.x += distanceToPoint * 0.04;\r\n\r\n    // Apply some motion\r\n    scarfPos.x += (sin( pos.z * _TombScarfWindParams.x + iTime) * _TombScarfWindParams.z * distanceToPoint);\r\n    scarfPos.y += (sin( pos.z * _TombScarfWindParams.y + iTime) * _TombScarfWindParams.z * distanceToPoint);\r\n\r\n     vec3 pivotOffset = vec3(0.0, 0.0, scale.z);\r\n    rX(scarfPos, _TombScarfRot + ((t - 0.5)* 0.15) + SmoothTriangleWave((iTime + 1.45) * 0.1) * 0.3 );\r\n\r\n    float scarf = sdBox(scarfPos - pivotOffset , scale);\r\n    return scarf;\r\n}\r\n\r\nvec2 sdTombs( in vec3 p )\r\n{\r\n\tvec2 mainTomb = vec2(_DrawDistance, MAT_TOMB);\r\n\r\n\t// We draw two tombs, t goes -1 -> 1 so we can use negative and positive values\r\n\t// to mainpulate them both individually\r\n\tfor( float t = -1.0; t <= 1.0; t += 2.0 )\r\n\t{\r\n\t\tvec3 tombPos = (_TombPosition + vec3(-0.25 * t, t * 0.05, 0.1 * t ));\r\n\r\n\t\tvec3 pos = p - tombPos;\r\n\t\trZ( pos, 0.1 * t );\r\n\r\n\t\tfloat tombScarf = sdTombScarf( pos, _TombScarfOffset, t + 1.0);\r\n\r\n\t\tpos.x = abs(pos.x);\r\n\r\n\t\t// Taper them beyond a certain height. Rest is just a rounded box\r\n\t\tpos.x += abs( pos.y > _TombBevelParams.x  ? (pos.y - _TombBevelParams.x) * _TombBevelParams.y: 0.0 );\r\n\t\tfloat tTomb = sdRoundBox( pos, _TombScale, _TombBevelParams.z);\r\n\r\n\t\t// Cut out a sphere at top\r\n\t\ttTomb = max( tTomb, -sdSphere( pos - vec3(0.0, _TombCutOutScale.x, 0.0), _TombCutOutScale.y ) );\r\n\r\n\t\t// create scarfs at cut off points\r\n\t\tvec2 tTombMat = min_mat( vec2(tTomb, MAT_TOMB), vec2(tombScarf, MAT_TOMB_SCARF));\r\n\t\tmainTomb = min_mat( mainTomb, tTombMat);\r\n\t}\r\n\treturn mainTomb;\r\n}\r\n\r\n//==========================================================================================\r\n// The main map function\r\n//==========================================================================================\r\nvec2 map( in vec3 pos )\r\n{\r\n\tvec2 character = sdCharacter(pos);\r\n\tvec2 res = character;\r\n\r\n\t// I am assuming that since character covers a large portion of screen\r\n\t// This early out should help and same with the terrain. Assumption only, \r\n\t// need to look into it \r\n    if( res.x > 0.01 )\r\n    {\r\n    \tfloat desert = sdTerrain(pos);\r\n\t    vec2 terrain   = sdDesert( pos, desert );\r\n\t    vec2 trail\t   = vec2(-sdCharacterTrail(pos, desert), MAT_TERRAIN_TRAIL );\r\n\t    terrain.y\t\t= terrain.x > trail.x ? terrain.y : trail.y;\r\n\t\tterrain.x\t\t= smax( terrain.x, trail.x, 0.05);\r\n\r\n\t\tres\t= min_mat( res, terrain); \r\n        if( terrain.x > 0.01 )\r\n        {\r\n\t\t\tvec2 tombs\t   =  sdTombs(pos);\r\n            res = smin_mat( res, tombs, 0.2, 0.15 );\r\n\r\n            vec2 pyramid   = vec2(sdBigMountain(pos), MAT_PYRAMID);\r\n            res = min_mat( res, pyramid );\r\n\r\n            vec2 clouds\t   = sdClouds(pos);\r\n            res = min_mat( res, clouds );\r\n\r\n            vec2 flyingHelpers = sdFlyingHelpers( pos );\r\n            res = min_mat( res, flyingHelpers );\r\n        }\r\n\t}\r\n    return res;\r\n}\r\n\r\n\r\n//==========================================================================================\r\n// Used for generating normals. As it turns out that only the big mountain doesn't need\r\n// normals. Everything else does. Hey Ho!\r\n//==========================================================================================\r\nvec2 mapSimple( in vec3 pos )\r\n{\r\n\treturn map( pos );\r\n\t/*\r\n    vec2 character = sdCharacter(pos);\r\n    vec2 flyingHelpers = vec2( sdFlyingHelpers( pos ), 50.0 );\r\n    vec2 clouds\t   = sdClouds(pos);\r\n   \tfloat desert   = sdTerrain(pos);\r\n    vec2 terrain   = sdDesert( pos, desert );\r\n    terrain.x = smax( terrain.x, -sdCharacterTrail(pos, desert), 0.1 );\r\n    vec2 tombs\t   =  vec2(sdTombs(pos), 50.0);\r\n\r\n    vec2 res = character;\r\n    min_mat( res, flyingHelpers );\r\n\tres = min_mat( res, clouds );\r\n    res\t= min_mat( res, terrain); \r\n    res\t= min_mat( res, flyingHelpers); \r\n    res = smin_mat( res, tombs, 0.2, 0.15 );\r\n    return res;\r\n    */\r\n}\r\n\r\n//==========================================================================================\r\n// Raycasting: https://www.shadertoy.com/view/Xds3zN\r\n//==========================================================================================\r\nvec3 castRay(vec3 ro, vec3 rd) \r\n{\r\n    float tmin = 0.1;\r\n    float tmax = _DrawDistance;\r\n   \r\n    float t = tmin;\r\n    float m = -1.0;\r\n    float p = 0.0;\r\n    float maxSteps = _MaxSteps;\r\n    float j = 0.0;\r\n    for( float i = 0.0; i < _MaxSteps; i += 1.0 )\r\n    {\r\n        j = i;\r\n\t    float precis = 0.0005*t;\r\n\t    vec2 res = map( ro+rd*t );\r\n        if( res.x<precis || t>tmax ) \r\n        \tbreak;\r\n        t += res.x;\r\n\t    m = res.y;\r\n    }\r\n\tp = j / maxSteps;\r\n    if( t>tmax ) m=-1.0;\r\n    return vec3( t, m, p );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\r\n    return normalize( e.xyy*mapSimple( pos + e.xyy ).x + \r\n\t\t\t\t\t  e.yyx*mapSimple( pos + e.yyx ).x + \r\n\t\t\t\t\t  e.yxy*mapSimple( pos + e.yxy ).x + \r\n\t\t\t\t\t  e.xxx*mapSimple( pos + e.xxx ).x );\r\n}\r\n\r\n//==========================================================================================\r\n// Ambient Occlusion, only applied to the Traveller\r\n//==========================================================================================\r\nfloat AmbientOcclusion(vec3 p, vec3 N, float stepSize, float k)\r\n{\r\n    float r = 0.0;\r\n    float t = 0.0;\r\n  \r\n    for(int i = 0; i < 2; i++)\r\n    {\r\n        t += stepSize;\r\n        r += (1.0 / pow(2.0, t)) * (t - sdCharacter(p + (N * t)).x);\r\n    }\r\n    return max(0.0, 1.0 - (k * r));\r\n}\r\n\r\n//==========================================================================================\r\n// Simplified version of Traveller for shadow casting\r\n//==========================================================================================\r\nfloat sdCharacterShadow( vec3 pos )\r\n{\r\n    pos -= _CharacterPosition;\r\n    vec3 scale = _CharacterScale;\r\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\r\n    \r\n    rY(pos, _CharacterRotation);\r\n\r\n    pos /= scale;\r\n\r\n    float mainCloak = sdMainCloak( pos );\r\n    float longScarf = sdScarf(pos);\r\n\r\n    return min( mainCloak, longScarf) * scaleMul;\r\n}\r\n\r\n//==========================================================================================\r\n// Only character, flying helpers and tombs cast shadows. Only terrain recieves shadows\r\n//==========================================================================================\r\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\r\n{\r\n    float res = 1.0;\r\n    float t = mint;\r\n    for(int i = 0; i < 100; ++i)\r\n    {\r\n        if (t >= maxt) {\r\n            break;\r\n        }\r\n    \tfloat flyingHelpers = sdFlyingHelpers( ro + rd * t).x;\r\n    \tfloat tombs = sdTombs( ro + rd * t ).x;\r\n        float h = min( sdCharacterShadow( ro + rd*t), min(flyingHelpers, tombs) );\r\n        if( h<0.001 )\r\n            return 0.1;\r\n        res = min( res, k*h/t );\r\n        t += h;\r\n    }\r\n\treturn res;\r\n}\r\n\r\n//==========================================================================================\r\n// Hi Hussain!\r\n// Again, somebody wrote Hi Hussain here. It wasn't me, but hi back atcha!\r\n// Sky\r\n//==========================================================================================\r\nvec3 sky( vec3 ro, vec3 rd )\r\n{\r\n    // Sun calculation\r\n    float sunDistance = length( _SunPosition );\r\n\r\n    vec3 delta = _SunPosition.xyz - (ro + rd * sunDistance);\r\n    float dist \t= length(delta);\r\n\r\n    // Turn Sun into a star, because the big mountain has a star like shape\r\n    // coming from top\r\n    delta.xy *= _SunStar.xy;\r\n    float sunDist = length(delta);\r\n    float spot = 1.0 - smoothstep(0.0, _SunSize, sunDist);\r\n    vec3 sun = clamp(_SunScale * spot * spot * spot, 0.0, 1.0) * _SunColor.rgb;\r\n\t\r\n\t// Changing color on bases of distance from Sun. To get a strong halo around\r\n\t// the sun\r\n   \tfloat expDist = clamp((dist - _ExposureOffset)  * _ExposureStrength, 0.0, 1.0);\r\n   \tfloat expControl = pow(expDist,_ExposurePower);\r\n\r\n    // Sky colors\r\n    float y = rd.y;\r\n    float zen = 1.0 - pow (min (1.0, 1.0 - y), _ZenithFallOff);\r\n    vec3 zenithColor\t= _Zenith.rgb  * zen;\r\n    zenithColor = mix( _SunColor.rgb, zenithColor, expControl );\r\n\r\n    float nad = 1.0 - pow (min (1.0, 1.0 + y), _NadirFallOff);\r\n    vec3 nadirColor\t= _Nadir.rgb * nad;\r\n\r\n    float hor = 1.0 - zen - nad;\r\n    vec3 horizonColor\t= _Horizon.rgb * hor;\r\n\r\n    // Add stars for Color Scheme 3\r\nfloat stars  = 0.0;\r\n#if COLOR_SCHEME == 3\r\n    vec3 starPos = ro + ( (rd + vec3(iTime * 0.001, 0.0, 0.0) ) * sunDistance);\r\n    starPos.xyz += iTime*0.01 + noised(starPos.xy) * 3.0;\r\n\r\n    starPos      = mod( starPos, 1.5) - 0.75;\r\n    stars  \t\t = length(starPos);\r\n\r\n\tfloat starsA \t= (step( 0.9, 1.0 - stars) * 1.0 - (stars)) * 2.0;\r\n\tfloat starsB\t= (step( 0.93, 1.0 - stars) * 1.0 - (stars)) * 1.5;\r\n\tstars = starsA + starsB;\r\n\r\n    stars = stars * pow(zen * expControl, 5.0);\r\n    stars = step( 0.01, stars) * stars * 2.0;\r\n#endif\r\n    return stars + (sun * _SunStar.z + zenithColor + horizonColor + nadirColor);\r\n}\r\n\r\n//==========================================================================================\r\n// The rendering, based on: https://www.shadertoy.com/view/Xds3zN\r\n//==========================================================================================\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{ \r\n\t// res.z contains the iteration count / max iterations. This gives kind of a nice glow\r\n\t// effect around foreground objects. Looks particularly nice on sky, with clouds in\r\n\t// front and also on terrain. Gives rim kind of look!\r\n\tvec3 res\t= castRay(ro,rd);\r\n\tvec3 skyCol = sky( ro, rd );\r\n\tvec3 col\t= skyCol;\r\n\r\n\t#if defined (DEBUG_PERFORMANCE)\r\n\treturn (res.z);\r\n\t#endif\r\n\r\n\tfloat t = res.x;\r\n\tfloat m = res.y;\r\n\r\n\tvec3 pos = ro + t*rd;\r\n\r\n\t// Return sky\r\n\tif( m < 0.0 )\r\n\t{\r\n\t\t// Bloom for the background clouds. We want Big Mountain to be engulfed with fog. So just chop out\r\n\t\t// areas around right and left side of BigMountain for creating fake bloom for background clouds by\r\n\t\t// using the iteration count needed to generate the distance function\r\n\t\tfloat rightSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(45.0, -5.0, _SunPosition.z));\r\n\t\tfloat leftSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(-50.0, -5.0, _SunPosition.z));\r\n\t\tif( rightSideCloudDist < 40.0 )\r\n\t\t{\r\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, rightSideCloudDist / 40.0);\r\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\r\n\t\t}\r\n\t\telse if( leftSideCloudDist < 40.0 )\r\n\t\t{\r\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, leftSideCloudDist / 40.0);\r\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\r\n\t\t}\r\n        else\r\n\t\t\treturn col;\r\n\t}\r\n\r\n\tfloat skyFog = 1.0-exp( _FogMul * t * pow(pos.y, _FogPow) );\r\n\t#if defined (DEBUG_FOG)\r\n\treturn (skyFog);\r\n\t#endif\r\n\r\n\t// Render the big mountain. Keep track of it's color, so we can use it for transparency for clouds later\r\n\tvec3 pyramidCol = vec3(0.0, 0.0, 0.0);\r\n\tpyramidCol\t\t= mix( _PyramidCol, skyCol, skyFog * 0.5  ); \r\n\r\n\tif( TEST_MAT_LESS( m, MAT_PYRAMID) )\r\n\t{\r\n\t\t// Height fog, with strong fade to sky \r\n\t\tfloat nh = (pos.y / _PyramidHeightFog.x);\r\n\t\tnh = nh*nh*nh*nh*nh;\r\n\t\tfloat heightFog = pow(clamp(1.0 - (nh), 0.0, 1.0), _PyramidHeightFog.y);\r\n\t\theightFog\t\t= clamp( heightFog, 0.0, 1.0 );\r\n\t\tpyramidCol\t\t= mix( pyramidCol, skyCol, heightFog ); \r\n\t\treturn pyramidCol;       \r\n\t}\r\n\r\n\t// Calculate normal after calculating sky and big mountain\r\n\tvec3 nor = calcNormal(pos);\r\n\t// Terrain: https://archive.org/details/GDC2013Edwards\r\n\tif( TEST_MAT_LESS (m, MAT_TERRAIN_TRAIL ) )\r\n\t{\r\n\t\tfloat shadow = softShadow( pos - (rd * 0.01), _LightDir.xyz, _TerrainShadowParams.x, _TerrainShadowParams.y, _TerrainShadowParams.z);\r\n\t\tshadow\t\t = clamp( shadow + _TerrainShadowParams.w, 0.0, 1.0 );\r\n\r\n\t\tvec3 shadowCol = mix( shadow * _TerrainShadowColor, _TerrainDistanceShadowColor, pow(skyFog, _TerrainFogPower * _TerrainDistanceShadowPower) );\r\n\r\n\t\t// Strong rim lighting\r\n\t\tfloat rim\t= (1.0 - saturate(dot( nor , -rd ))); \r\n\t\trim\t\t\t= saturate(pow( rim, _TerrainRimPower)) *_TerrainRimStrength ; \r\n\t\tvec3 rimColor\t= rim * _TerrainRimColor;\r\n\r\n\t\t// Specular highlights\r\n\t\tvec3 ref\t\t= reflect(rd, nor);\r\n\t    vec3 halfDir\t= normalize(_LightDir + rd);\r\n\r\n\t    // The strong ocean specular highlight\r\n\t    float mainSpec = clamp( dot( ref, halfDir ), 0.0, 1.0 );\r\n\t    if ( TEST_MAT_LESS( m, MAT_TERRAIN ) )\r\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 2.0 ;\r\n\t    else\r\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 4.0;\r\n\r\n\t    float textureGlitter  = textureLod(iChannel1,pos.xz * _TerrainGlitterRep, 2.2).x * 1.15;\r\n\t    textureGlitter\t= pow(textureGlitter , _TerrainGlitterPower);\r\n\t    mainSpec \t\t*= textureGlitter;\r\n\r\n\t\t// The glitter around terrain, looks decent based on rim value\r\n\t    float rimSpec\t= (pow(rim, _TerrainRimSpecPower)) * textureGlitter;\r\n\t    vec3 specColor\t= (mainSpec + rimSpec) * _TerrainSpecColor;\r\n\t\tvec3 terrainCol\t= mix( (rimColor + specColor * shadow) + _TerrainCol, skyCol, pow(skyFog, _TerrainFogPower) ) + res.z * 0.2;  \r\n\r\n\t\t// maybe add a fake AO from player, just a sphere should do!\r\n\t\treturn mix( shadowCol, terrainCol, shadow );\r\n\t}\r\n\r\n\t// Clouds\r\n\tif( TEST_MAT_LESS (m, MAT_FRONT_CLOUDS ) )\r\n\t{\r\n\t\t// Modify the normals so that they create strong specular highlights\r\n\t\t// towards the top edge of clouds\r\n\t\tnor\t\t\t\t= normalize( nor + _CloudNormalMod);\r\n\t\tfloat dotProd\t= dot( nor, vec3(1.0,-3.5,1.0) );\r\n\r\n\t\tfloat spec\t\t=  1.0 -  clamp( pow(dotProd, _CloudSpecPower), 0.0, 1.0 );\r\n\t\tspec \t\t\t*= 2.0;\r\n\t\tvec3 cloudCol\t= spec * _CloudSpecCol + _CloudCol;\r\n\r\n\t\t// Transparency for mountain\r\n\t\tif( sdBigMountain( pos + (rd * t * _CloudPyramidDistance)) < 0.2 )\r\n\t \t{\r\n\t \t\tcloudCol = mix( pyramidCol, cloudCol, _CloudTransparencyMul ); \r\n\t\t}\r\n\r\n\t\t// Mixing for backdrop mountains. Backdrop mountains take more color from Sky. Foreground mountains\r\n\t\t// retain their own color values, so I can adjust their darkness\r\n\t\tvec3 inCloudCol = mix(cloudCol, _BackCloudCol + skyCol * 0.5 + spec * _BackCloudSpecCol, MAT_FRONT_CLOUDS - m);\r\n\t\treturn mix( inCloudCol , skyCol, skyFog * _CloudFogStrength );    \r\n\t}\r\n\r\n\t// Tombs\r\n\tif( TEST_MAT_LESS(m, MAT_TOMB_SCARF ) )\r\n\t{\r\n\t\t// Simple strong diffuse\r\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.0, 0.0, 1.0);\r\n\t\tvec3 col\t= mix( _TombMainColor, _TombScarfColor * 2.0, m - MAT_TOMB );\r\n\t\treturn mix( diff * col, skyCol, skyFog);\r\n\t}\r\n\r\n\t// Flying Helpers\r\n\tif( TEST_MAT_LESS(m, MAT_FLYING_HELPER_SCARF ) )\r\n\t{\r\n\t\tfloat fres\t= pow( clamp(1.0+dot(nor,rd) + 0.75,0.0,1.0), _FlyingHelperFrePower ) * _FlyingHelperFreScale;\r\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.5,0.0,1.0);\r\n\t\tvec3 col = _FlyingHelperYellowColor;\r\n\r\n\t\t// The main head\r\n\t\tif ( TEST_MAT_LESS( m, MAT_FLYING_HELPERS ) )\r\n\t\t{\r\n\t\t\tcol = _FlyingHelperMainColor;\r\n\r\n\t\t\t// Yellow borders\r\n\t\t\tfloat outerBorder = step( 0.95, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\r\n\t\t\tcol  = mix( col * diff, _FlyingHelperYellowColor,  outerBorder );\r\n\r\n\t\t\t// cubes in middle\r\n\t\t\tfloat rectsY = abs(helperScarfMatUVW.z * 2.0 - 1.0);\r\n\t\t\tfloat rectsX = abs(helperScarfMatUVW.x * 2.0 - 1.0);\r\n\r\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\r\n\t\t\tcircles = step( 0.5, circles );\r\n\r\n\t\t\t// Ideally want to do a separate bass for bloom. maybe one day\r\n\t\t\tfloat bloomCircle = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1); \r\n\t\t\tfloat bloom  = max( bloomCircle - 0.5, 0.0);\r\n\r\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\r\n\t\t\trectsX = 1.0 - step( 0.5, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\r\n\r\n\t\t\tfloat rects = min(rectsX, rectsY);\r\n\r\n\t\t\tfloat symbolsX = fract(rects/(helperScarfMatUVW.z * 20.0) * 20.0);\r\n\t\t\tfloat symbolsY = fract(rects/(helperScarfMatUVW.x * 2.0) * 2.0);\r\n\t\t\tfloat symbolsZ = fract(rects/((helperScarfMatUVW.z + 0.1) * 16.0) * 16.0);\r\n\t\t\tfloat symbolsW = fract(rects/((helperScarfMatUVW.x + 0.1) * 3.0) * 3.0);\r\n\r\n\t\t\tfloat symbols = symbolsY;\r\n\t\t\tsymbols = max( symbols, symbolsZ );\r\n\t\t\tsymbols = min(symbols , max(symbolsX, symbolsW));\r\n\t\t\tsymbols = step( 0.5, symbols ); \r\n\r\n\t\t\tsymbols = min( symbols, circles );\r\n\r\n\t\t\t//  float rects = min(rectsX, max(circles,rectsY));\r\n\r\n\t\t\tcol = mix( col, _FlyingHelperYellowColor, circles);\r\n\t\t\tcol = mix( col, _FlyingHelperWhiteColor * 2.0, symbols)  + bloom  * _FlyingHelperBloomScale;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// The scarfs, just have a yellow border\r\n\t\t\tfloat outerBorder = step( 0.9, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\r\n\t\t\tcol \t= mix( _FlyingHelperMainColor * diff, _FlyingHelperYellowColor,  outerBorder );\r\n\t\t}\r\n\t\treturn mix( fres * col, skyCol, skyFog * _FlyingHelperFogScale );\r\n\t}\r\n\r\n\t// Character\r\n\tif( TEST_MAT_GREATER (m, MAT_CHARACTER_BASE ) )\r\n\t{\r\n\t\tfloat diff = _CharacterDiffScale * clamp( dot( nor, _LightDir ), 0.0, 1.0 );\r\n\r\n\t\t// Why did I fudge these normals, I can't remember. It does look good though, so keep it :)\r\n\t\tnor\t\t= normalize( nor + vec3(0.3,-0.1,1.0));\r\n\t\tnor.y\t*= 0.3;\r\n\r\n\t\tfloat fres\t= pow( clamp( 1.0 + dot(nor,rd) + 0.75, 0.0, 1.0), _CharacterFrePower ) * _CharacterFreScale;\r\n\t\tvec3 col\t= _CharacterMainColor;\r\n\r\n\t\t// Just base color\r\n\t\tif( TEST_MAT_LESS( m, MAT_CHARACTER_BASE) )\r\n\t\t{\r\n\t\t\t// Add sand fade to legs. Mixing terrain color at bottom of legs\r\n\t\t\tfloat heightTerrainMix\t= pow((pos.y / _CharacterHeightTerrainMix.x), _CharacterHeightTerrainMix.y);\r\n\t\t\theightTerrainMix\t\t= clamp( heightTerrainMix, 0.0, 1.0 );\r\n\t\t\tcol\t= mix( _CharacterMainColor, _CharacterTerrainCol, heightTerrainMix );\r\n\t\t}\r\n\t\t// Main Cloak\r\n\t\telse if( TEST_MAT_LESS( m,MAT_CHARACTER_MAIN_CLOAK) )\r\n\t\t{\r\n\t\t\t// Cone kind of shapes\r\n\t\t\tfloat rectsX\t= fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 7.0) ;\r\n\t\t\trectsX\t\t\t= abs(rectsX * 2.0 - 1.0);\r\n\t\t\tfloat rects\t\t= rectsX;\r\n\t\t\trects\t\t\t= step( 0.5, rects * (1.0 - mainCloakMatUVW.y*3.5) );\r\n\t\t\tcol = mix( col, _CharacterCloakDarkColor, rects );\r\n\r\n\t\t\t// Yellow borders, two lines\r\n\t\t\tfloat outerBorder\t\t= step( 0.915, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\r\n\t\t\tfloat betweenBorders\t= step( 0.88, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\r\n\t\t\tfloat innerBorder\t\t= step( 0.87, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\r\n\r\n\t\t\tinnerBorder = min( innerBorder, 1.0 - betweenBorders );\r\n\r\n\t\t\tcol  = mix( col, _CharacterCloakDarkColor,  betweenBorders );\r\n\t\t\tcol  = mix( col, _CharacterYellowColor,  outerBorder );\r\n\t\t\tcol  = mix( col, _CharacterYellowColor,  innerBorder);\r\n\r\n\t\t\t// The verticle cubes/lines running across the bottom of cloak\r\n\t\t\tfloat cubes = abs(fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 10.0)  * 2.0 - 1.0);\r\n\t\t\tcubes\t\t= min(betweenBorders, step( 0.9, cubes) );\r\n\t\t\tcol\t\t\t= mix( col, _CharacterYellowColor,  cubes);\r\n\t\t}\r\n\t\t// headscarf\r\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_NECK_SCARF) )\r\n\t\t{\r\n\t\t\tcol = mix( col, _CharacterYellowColor, step( 0.7, headScarfMatUVW.y) );\r\n\t\t}\r\n\t\t// Long Scarf\r\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_LONG_SCARF) )\r\n\t\t{\r\n\t\t\tcol = _CharacterYellowColor;\r\n\r\n\t\t\t// Yellow borders, two lines\r\n\t\t\tfloat outerBorder = step( 0.9, abs(longScarfMatUVW.x * 2.0 - 1.0) );\r\n\t\t\tfloat innerBorder = step( 0.7, abs(longScarfMatUVW.x * 2.0 - 1.0) );\r\n\r\n\t\t\tinnerBorder = min( innerBorder, 1.0 - step( 0.8, abs(longScarfMatUVW.x * 2.0 - 1.0) ) );\r\n\r\n\t\t\t// Mix borders\r\n\t\t\tcol  = mix( col, _CharacterMainColor,  outerBorder );\r\n\t\t\tcol  = mix( col, _CharacterMainColor,  innerBorder);\r\n\r\n\t\t\t// cubes in middle\r\n\t\t\tfloat rectsY = abs(fract( longScarfMatUVW.y/ 0.10 ) * 2.0 - 1.0);// - 0.5 * 0.10;\r\n\t\t\tfloat rectsX = abs(longScarfMatUVW.x * 2.0 - 1.0);\r\n\r\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\r\n\t\t\tcircles = step( 0.5, circles );\r\n\r\n\t\t\tfloat bloomCircle\t= 1.0 - (length( vec2(rectsY, rectsX * 0.7) ) - 0.1); \r\n\t\t\tfloat bloom \t\t= max( bloomCircle - 0.45, 0.0);\r\n\r\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\r\n\t\t\trectsX = 1.0 - step( 0.5, abs(longScarfMatUVW.x * 2.0 - 1.0) );\r\n\r\n\t\t\tfloat rects = min(rectsX, rectsY);\r\n\r\n\t\t\t// There are better ways of doing symbols. Spend some time on it, buddy!\r\n\t\t\tfloat symbolsX = fract(rects/(longScarfMatUVW.y * 0.17) * 10.0);\r\n\t\t\tfloat symbolsY = fract(rects/(longScarfMatUVW.x * 18.5) * 10.0);\r\n\r\n\t\t\tfloat symbols\t= symbolsX;\r\n\t\t\tsymbols\t\t\t= max( symbols, symbolsY );\r\n\t\t\tsymbols\t\t\t= step( 0.5, symbols ); \r\n\r\n\t\t\tsymbols = min( symbols, circles );\r\n\r\n\t\t\t//        float rects = min(rectsX, max(circles,rectsY));\r\n\t\t\tcol = mix( col, _CharacterMainColor, circles);\r\n\t\t\tcol = mix( col, _CharacterWhiteColor * 2.0, symbols)  + bloom * _CharacterBloomScale;\r\n\r\n\t\t\t// White glow and disintegrating the scarf, showing depleting scarf energy. Needs bloom effect :(\r\n\t\t\tcol = mix( col, _CharacterMainColor, 1.0 - smoothstep(0.4, 0.6, longScarfMatUVW.y));\r\n\t\t\tvec3 whiteMiddle = mix( col, _CharacterWhiteColor + bloom * _CharacterBloomScale, step(0.48, longScarfMatUVW.y));\r\n\t\t\tcol = mix( whiteMiddle, col, step(0.5, longScarfMatUVW.y));\r\n\t\t}\r\n\t\t// Face\r\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_FACE)  )\r\n\t\t{\r\n\t\t\tcol = vec3(0,0,0);\r\n\t\t}\r\n\t\tfloat ao = AmbientOcclusion(pos - (rd * 0.01), nor, _CharacterAOParams.x, _CharacterAOParams.y); \r\n\t\treturn ao * mix( (fres + diff) * col, skyCol, skyFog * _CharacterFogScale );\r\n\t}\r\n\treturn vec3( clamp(col * 0.0,0.0,1.0) );\r\n}\r\n\r\n\r\nfloat rand(float n)\r\n{\r\n\treturn fract(sin(n) * 43758.5453123);\r\n}\r\n\r\nfloat noise(float p)\r\n{\r\n\tfloat fl = floor(p);\r\n\tfloat fc = fract(p);\r\n    fc = fc*fc*(3.0-2.0*fc);\r\n    return mix(rand(fl), rand(fl + 1.0), fc);\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// Move camera using noise. This is probably quite expensive way of doing it :(\r\n\tfloat unitNoiseX = (noise(iTime * _CameraMovement.w ) * 2.0)  - 1.0;\r\n\tfloat unitNoiseY = (noise((iTime * _CameraMovement.w ) + 32.0) * 2.0)  -1.0;\r\n\tfloat unitNoiseZ = (noise((iTime * _CameraMovement.w ) + 48.0) * 2.0)  -1.0;\r\n\tvec3 ro = _CameraPos + vec3(unitNoiseX, unitNoiseY, unitNoiseZ) * _CameraMovement.xyz;\r\n\r\n\r\n\tvec3 screenRay\t\t= vec3(fragCoord / iResolution.xy, 1.0);\r\n\tvec2 screenCoord\t= screenRay.xy * 2.0 - 1.0;\r\n\r\n\t// Screen ray frustum aligned\r\n\tscreenRay.xy = screenCoord * _CameraFOV.xy;\r\n    screenRay.x\t\t\t*= 1.35;\r\n\tscreenRay.z  = -_CameraFOV.z;\r\n\tscreenRay /= abs( _CameraFOV.z); \r\n\r\n    // In camera space\r\n\tvec3 rd = normalize(mul( _CameraInvViewMatrix, vec4(screenRay,0.0))).xyz;\r\n\r\n\t// Do the render\r\n\tvec4 col = vec4(render(ro, rd), 0.0);\r\n\r\n\t// No it does not need gamma correct or tone mapping or any other effect that you heard about\r\n\t// and thought was cool. This is not realistic lighting\r\n\r\n\t// vignette\r\n\tfloat vig = pow(1.0 - 0.4 * dot(screenCoord, screenCoord), 0.6) * 1.25;\r\n\tvig = min( vig, 1.0);\r\n\tcol *= vig;\r\n\r\n\t// Final color\r\n\tfragColor =  col;\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\none.png","type":"texture","channel":0,"sampler":null,"published":0}],"Info":{"Name":"Tribute - Journey!","id":null,"date":null,"viewed":0,"name":"Tribute - Journey!","description":"This is just a tribute, to the greatest game in the world, ah,\r\nguh fli-goo ga goo buh dee\r\nOoh guh goo bee, ooh guh guh bee guh guh bee\r\nFli-goo gee goo, a-fli-guh woo wa mama Lucifer!","likes":0,"published":null,"tags":["clouds"," sky"," character"," tribute"," desert"," journey"," scarf"," sphericalclouds"," traveller"," tomb"]},"ver":null,"info":{"Name":"Tribute - Journey!","id":null,"date":null,"viewed":0,"name":"Tribute - Journey!","description":"This is just a tribute, to the greatest game in the world, ah,\r\nguh fli-goo ga goo buh dee\r\nOoh guh goo bee, ooh guh guh bee guh guh bee\r\nFli-goo gee goo, a-fli-guh woo wa mama Lucifer!","likes":0,"published":null,"tags":["clouds"," sky"," character"," tribute"," desert"," journey"," scarf"," sphericalclouds"," traveller"," tomb"]},"renderpass":[{"Code":"/*\r\n\tBefore you continue reading, feast your eyes on these beautiful Color Schemes (0,1,2)\r\n*/\r\n\r\n// Modify the number to 0,1,2 or 3 and press play button at bottom for different schemes.\r\n#define COLOR_SCHEME 1\r\n\r\n/*\r\n\tThis shader is just a tribute to \"Journey\" game by That Game Company. Some answers:\r\n\t1) No, I do not have any affiliation with That Game Company.\r\n\t2) Yes, Journey is one of the best games ever made\r\n\t3) It has taken me around 3-4 months from start to finish, evenings and weekends\r\n\t4) Most of the time was spent getting the details right\r\n\t5) Yes, the character needs more work. One day I will finish it\r\n\t6) Yes, if anybody comes up with something cool to add, I would love to improve :)\r\n\t7) There is nothing mathemagically amazing in this shader. I hope you do find it pretty though!\r\n\t8) Yes, the code is fairly ugly. But look at the colors - PRETTY!\r\n\t9) If you have any other questions, I will be happy to answer\r\n\r\n\tThis shader started as a learning playground, but around January, I finished my second round of Journey\r\n\tand thought, well why the hell not, and so here we are.\r\n\r\n\tSpecial thanks to Thibault Girard and Jack Hamilton for their artistic input. Also bigs up to Peter Pimley\r\n\tfor his constant optimism.\r\n\r\n\tYou are hereby granted your wish to follow me on twitter: @shakemayster\r\n\r\n\tOther authors (With BIG thanks !!!) \r\n\tDave_Hoskins\r\n\tDila\r\n\tMaurogik\r\n\tFabriceNeyret2\r\n*/\r\n\r\n#define RGB vec3\r\n#define mul(a,b) b*a\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n\r\n\r\n#if COLOR_SCHEME == 0\r\nconst float _FogMul = -0.00100 ;\r\nconst float _FogPow = 1.82000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.22632, 0.88099, -0.4155) ;\r\nconst float _Brightness = 1.00000 ;\r\nconst float _Contrast = 1.00000 ;\r\nconst float _Saturation = 1.00000 ;\r\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\r\nconst float _SunSize = 26.00000 ;\r\nconst float _SunScale = 15.00000 ;\r\nconst float _ExposureOffset = 11.10000 ;\r\nconst float _ExposurePower = 0.52000 ;\r\nconst float _ExposureStrength = 0.09000 ;\r\nconst RGB _SunColor = RGB(1, 0.73741, 0.63971) ;\r\nconst RGB _Zenith = RGB(0.67128, 0.94118, 0.69204) ;\r\nconst float _ZenithFallOff = 1.42000 ;\r\nconst RGB _Nadir = RGB(0, 0, 0) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.80147, 0.80147, 0.80147) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.57353, 0.1488, 0.067474) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.375, 0.21885, 0.15993) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.38971, 0.10735, 0.054444) ;\r\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.35588, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\r\nconst float _CharacterBloomScale = 0.87000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 3.84000 ;\r\nconst float _CharacterFogScale = 20.00000 ;\r\nconst float _CloudTransparencyMul = 0.90000 ;\r\nconst RGB _CloudCol = RGB(1, 0.96957, 0.88235) ;\r\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\r\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.47735, 0.59559, 0.49705) ;\r\nconst RGB _TombScarfColor = RGB(0.45588, 0.093858, 0.093858) ;\r\nconst RGB _PyramidCol = RGB(0.30147, 0.28329, 0.21059) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.05) ;\r\nconst RGB _TerrainCol = RGB(0.76863, 0.55294, 0.47059) ;\r\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 1.56000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 1.94000 ;\r\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 2.00000 ;\r\nconst float _TerrainRimSpecPower = 1.46000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.40441, 0.34106, 0.31818) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.81471, 0.74265) ;\r\nconst float _TerrainDistanceShadowPower = 0.11000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.80882, 0.11671, 0.017842) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.56187, 0.0073529) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 1.91000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 4.00000 ;\r\n#endif\r\n\r\n#if COLOR_SCHEME == 1\r\nconst float _FogMul = -0.00800 ;\r\nconst float _FogPow = 1.00000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\r\nconst float _Brightness = 0.40000 ;\r\nconst float _Contrast = 0.83000 ;\r\nconst float _Saturation = 1.21000 ;\r\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\r\nconst float _SunSize = 26.00000 ;\r\nconst float _SunScale = 15.00000 ;\r\nconst float _ExposureOffset = 11.10000 ;\r\nconst float _ExposurePower = 0.52000 ;\r\nconst float _ExposureStrength = 0.09000 ;\r\nconst RGB _SunColor = RGB(1, 0.95441, 0.77206) ;\r\nconst RGB _Zenith = RGB(0.77941, 0.5898, 0.41263) ;\r\nconst float _ZenithFallOff = 2.36000 ;\r\nconst RGB _Nadir = RGB(1, 0.93103, 0) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.96324, 0.80163, 0.38954) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.35294, 0.16016, 0.12197) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.25735, 0.028557, 0.0056769) ;\r\nconst RGB _CharacterYellowColor = RGB(0.88971, 0.34975, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(0.9928, 1, 0.47794) ;\r\nconst float _CharacterBloomScale = 0.70000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 3.84000 ;\r\nconst float _CharacterFogScale = 4.55000 ;\r\nconst float _CloudTransparencyMul = 0.90000 ;\r\nconst RGB _CloudCol = RGB(1, 0.84926, 0.69853) ;\r\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\r\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.64706, 0.38039, 0.27451) ;\r\nconst RGB _TombScarfColor = RGB(0.38971, 0.10029, 0.10029) ;\r\nconst RGB _PyramidCol = RGB(0.69853, 0.40389, 0.22086) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.3) ;\r\nconst RGB _TerrainCol = RGB(0.56618, 0.29249, 0.1915) ;\r\nconst RGB _TerrainSpecColor = RGB(1, 0.77637, 0.53676) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 1.56000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 3.20000 ;\r\nconst RGB _TerrainRimColor = RGB(0.16176, 0.13131, 0.098724) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 1.61000 ;\r\nconst float _TerrainRimSpecPower = 2.88000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.48529, 0.13282, 0) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(0.70588, 0.4644, 0.36851) ;\r\nconst float _TerrainDistanceShadowPower = 0.11000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.85294, 0.11759, 0.012543) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.3931, 0) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 2.61000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 1.75000 ;\r\n#endif\r\n\r\n#if COLOR_SCHEME == 2\r\nconst float _FogMul = -0.00100 ;\r\nconst float _FogPow = 1.68000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\r\nconst float _Brightness = 0.40000 ;\r\nconst float _Contrast = 0.82000 ;\r\nconst float _Saturation = 1.21000 ;\r\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\r\nconst float _SunSize = 26.00000 ;\r\nconst float _SunScale = 15.00000 ;\r\nconst float _ExposureOffset = 11.10000 ;\r\nconst float _ExposurePower = 0.52000 ;\r\nconst float _ExposureStrength = 0.09000 ;\r\nconst RGB _SunColor = RGB(0.97059, 0.97059, 0.97059) ;\r\nconst RGB _Zenith = RGB(0.98039, 0.83137, 0.53725) ;\r\nconst float _ZenithFallOff = 2.36000 ;\r\nconst RGB _Nadir = RGB(0, 0, 0) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.84559, 0.77688, 0.6031) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.5, 0.3404, 0.12868) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.31618, 0.14042, 0.039522) ;\r\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.30233, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\r\nconst float _CharacterBloomScale = 0.87000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 3.84000 ;\r\nconst float _CharacterFogScale = 12.47000 ;\r\nconst float _CloudTransparencyMul = 0.80000 ;\r\nconst RGB _CloudCol = RGB(0.99216, 0.9451, 0.76471) ;\r\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\r\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.94118, 0.82759, 0.45675) ;\r\nconst RGB _TombScarfColor = RGB(0.44118, 0.19989, 0.14922) ;\r\nconst RGB _PyramidCol = RGB(0.92647, 0.73579, 0.3338) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 4.65) ;\r\nconst RGB _TerrainCol = RGB(0.71324, 0.5076, 0.236) ;\r\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 0.03000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 3.20000 ;\r\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 1.61000 ;\r\nconst float _TerrainRimSpecPower = 0.38000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.66912, 0.52969, 0.369) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.75466, 0.43382) ;\r\nconst float _TerrainDistanceShadowPower = 0.11000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.91912, 0.30412, 0.21626) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(0.98529, 0.60477, 0.12316) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 1.91000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 4.00000 ;\r\n#endif\r\n\r\n#if COLOR_SCHEME == 3\r\nconst float _FogMul = -0.00100 ;\r\nconst float _FogPow = 1.82000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.29644, 0.6859, -0.66458) ;\r\nconst float _Brightness = 1.00000 ;\r\nconst float _Contrast = 1.00000 ;\r\nconst float _Saturation = 1.00000 ;\r\nconst vec3 _SunStar = vec3(20.45, 1.49, 0.5) ;\r\nconst float _SunSize = 26.09000 ;\r\nconst float _SunScale = 15.04000 ;\r\nconst float _ExposureOffset = 13.72000 ;\r\nconst float _ExposurePower = 0.60000 ;\r\nconst float _ExposureStrength = 0.02000 ;\r\nconst RGB _SunColor = RGB(0.51471, 0.79919, 1) ;\r\nconst RGB _Zenith = RGB(0, 0.053922, 0.16176) ;\r\nconst float _ZenithFallOff = 1.42000 ;\r\nconst RGB _Nadir = RGB(0.21569, 0.2549, 0.36078) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.35191, 0.30223, 0.47794) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.36765, 0.097656, 0.045956) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.083261, 0.11379, 0.16176) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.073529, 0.011604, 0) ;\r\nconst RGB _CharacterYellowColor = RGB(0.60294, 0.33162, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\r\nconst float _CharacterBloomScale = 0.87000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 19.83000 ;\r\nconst float _CharacterFogScale = 60.00000 ;\r\nconst float _CloudTransparencyMul = 0.90000 ;\r\nconst RGB _CloudCol = RGB(0.0069204, 0.15969, 0.23529) ;\r\nconst RGB _BackCloudCol = RGB(0, 0.10969, 0.15441) ;\r\nconst RGB _CloudSpecCol = RGB(0.11765, 0.11765, 0.11765) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.080882, 0.080882, 0.080882) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.23789, 0.27707, 0.40441) ;\r\nconst RGB _TombScarfColor = RGB(0.066176, 0, 0.034229) ;\r\nconst RGB _PyramidCol = RGB(0, 0, 0) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.92) ;\r\nconst RGB _TerrainCol = RGB(0, 0.058832, 0.10294) ;\r\nconst RGB _TerrainSpecColor = RGB(0.24622, 0.29188, 0.33824) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 1.56000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 1.94000 ;\r\nconst RGB _TerrainRimColor = RGB(0.091021, 0.057093, 0.16176) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 2.00000 ;\r\nconst float _TerrainRimSpecPower = 1.46000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.37) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.11029, 0.11029, 0.11029) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(0.0034061, 0.073181, 0.15441) ;\r\nconst float _TerrainDistanceShadowPower = 0.06000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.12661, 0.004109, 0.13971) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(0.48529, 0.2711, 0) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 1.91000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 5.51000 ;\r\n#endif\r\n\r\n//==========================================================================================\r\n// Play with these at your own risk. Expect, unexpected results!\r\n//==========================================================================================\r\n\r\nconst mat4 _CameraInvViewMatrix = mat4( 1, 0, 0, 1.04, \r\n0, 0.9684963, 0.2490279, 2.2, \r\n0, 0.2490279, -0.9684963, 18.6, \r\n0, 0, 0, 1 ) ;\r\nconst vec3 _CameraFOV = vec3(1.038, 0.78984, -1) ;\r\nconst vec3 _CameraPos = vec3(1.0, 2.2, 18.6) ;\r\nconst vec4 _CameraMovement = vec4(0.15, 0.1, 0.2, 0.25) ;\r\n\r\nconst vec3 _WindDirection = vec3(-0.27, -0.12, 0) ;\r\n\r\nconst float _DrawDistance = 70.00000 ;\r\nconst float _MaxSteps = 64.00000 ;\r\n\r\nconst vec3 _SunPosition = vec3(0.2, 56, -40.1) ;\r\nconst float _CharacterRotation = 0.17000 ;\r\nconst vec3 _CharacterPosition = vec3(0.52, 2.35, 17.6) ;\r\nconst vec3 _CharacterScale = vec3(0.4, 0.53, 0.38) ;\r\nconst float _MainClothRotation = 0.30000 ;\r\nconst vec3 _MainClothScale = vec3(0.3, 0.68, 0.31) ;\r\nconst vec3 _MainClothPosition = vec3(0, -0.12, 0) ;\r\nconst vec3 _MainClothBotCutPos = vec3(0, -0.52, 0) ;\r\nconst vec3 _MainClothDetail = vec3(6, 0.04, 1.3) ;\r\nconst float _HeadScarfRotation = -0.19000 ;\r\nconst vec3 _HeadScarfPosition = vec3(-0.005, -0.16, -0.01) ;\r\nconst vec3 _HeadScarfScale = vec3(0.18, 0.2, 0.03) ;\r\nconst float _HeadRotationX = -0.30000 ;\r\nconst float _HeadRotationY = 0.29000 ;\r\nconst float _HeadRotationZ = 0.00000 ;\r\nconst vec3 _HeadPos = vec3(0, -0.04, 0.01) ;\r\nconst vec3 _LongScarfPos = vec3(0.01, -0.15, 0.09) ;\r\nconst vec3 _LongScarfScale = vec3(0.05, 1.25, 0.001) ;\r\nconst vec4 _LongScarfWindStrength = vec4(0.3, 4.52, 5.2, 0.02) ;\r\nconst float _LongScarfRotX = 1.43000 ;\r\nconst float _LongScarfMaxRad = 1.99000 ;\r\nconst vec3 _FacePosition = vec3(0, -0.01, 0.05) ;\r\nconst vec3 _FaceSize = vec3(0.038, 0.05, 0.03) ;\r\nconst vec3 _UpperLeftLegA = vec3(-0.02, -0.37, 0.01) ;\r\nconst vec3 _UpperLeftLegB = vec3(-0.02, -0.67, -0.059999) ;\r\nconst vec3 _UpperLeftLegParams = vec3(0.026, 1, 1) ;\r\nconst vec3 _LowerLeftLegA = vec3(-0.02, -0.67, -0.059999) ;\r\nconst vec3 _LowerLeftLegB = vec3(-0.02, -0.77, 0.12) ;\r\nconst vec3 _LowerLeftLegParams = vec3(0.028, 0.03, 0.01) ;\r\nconst vec3 _UpperRightLegA = vec3(0.07, -0.5, 0.02) ;\r\nconst vec3 _UpperRightLegB = vec3(0.07, -0.61, 0.09) ;\r\nconst vec3 _UpperRightLegParams = vec3(0.026, 1, 1) ;\r\nconst vec3 _LowerRightLegA = vec3(0.07, -0.61, 0.09) ;\r\nconst vec3 _LowerRightLegB = vec3(0.07, -0.91, 0.22) ;\r\nconst vec3 _LowerRightLegParams = vec3(0.028, 0.03, 0.01) ;\r\nconst vec3 _BodyPos = vec3(0, -0.45, -0.03) ;\r\nconst vec3 _CharacterTrailOffset = vec3(0.72, 0.01, 0.06) ;\r\nconst vec3 _CharacterTrailScale = vec3(0.001, 0, 0.5) ;\r\nconst vec3 _CharacterTrailWave = vec3(1.97, 0, 0.34) ;\r\nconst vec2 _CharacterHeightTerrainMix = vec2(1.95, -30) ;\r\nconst vec3 _CloudNoiseStrength = vec3(0.2, 0.16, 0.1) ;\r\nconst vec3 _FrontCloudsPos = vec3(9.91, 8.6, -12.88) ;\r\nconst vec3 _FrontCloudsOffsetA = vec3(-9.1, 3.04, 0) ;\r\nconst vec3 _FrontCloudsOffsetB = vec3(-2.97, 3.72, -0.05) ;\r\nconst vec3 _FrontCloudParams = vec3(5.02, 3.79, 5) ;\r\nconst vec3 _FrontCloudParamsA = vec3(3.04, 0.16, 2) ;\r\nconst vec3 _FrontCloudParamsB = vec3(1.34, 0.3, 3.15) ;\r\nconst vec3 _BackCloudsPos = vec3(29.99, 13.61, -18.8) ;\r\nconst vec3 _BackCloudsOffsetA = vec3(24.87, -1.49, 0) ;\r\nconst vec3 _BackCloudParams = vec3(7.12, 4.26, 1.68) ;\r\nconst vec3 _BackCloudParamsA = vec3(6.37, 2.23, 2.07) ;\r\nconst vec3 _PlaneParams = vec3(7.64, 10.85, 3.76) ;\r\nconst vec3 _CloudGlobalParams = vec3(0.123, 2.1, 0.5) ;\r\nconst vec3 _CloudBackGlobalParams = vec3(0.16, 1.4, -0.01) ;\r\nconst vec3 _CloudNormalMod = vec3(0.26, -0.13, 1.22) ;\r\nconst float _CloudSpecPower = 24.04000 ;\r\nconst float _CloudPyramidDistance = 0.14500 ;\r\nconst vec3 _TombPosition = vec3(5, 5, 9.28) ;\r\nconst vec3 _TombScale = vec3(0.07, 0.5, 0.006) ;\r\nconst vec3 _TombBevelParams = vec3(0.44, 0.66, 0.01) ;\r\nconst float _TombRepScale = 0.79000 ;\r\nconst vec3 _TombCutOutScale = vec3(0.39, 0.06, -14.92) ;\r\nconst vec3 _TombScarfOffset = vec3(0, 0.46, 0) ;\r\nconst vec3 _TombScarfWindParams = vec3(-1.61, 6, 0.05) ;\r\nconst vec3 _TombScarfScale = vec3(0.03, 0.002, 0.5) ;\r\nconst float _TombScarfRot = -0.88000 ;\r\nconst mat4 _TombScarfMat = mat4( 0.9362437, 0, -0.3513514, 0, \r\n0, 1, 0, 0, \r\n0.3513514, 0, 0.9362437, 0, \r\n0, 0, 0, 1 ) ;\r\nconst vec3 _PyramidPos = vec3(0, 10.9, -50) ;\r\nconst vec3 _PyramidScale = vec3(34.1, 24.9, 18) ;\r\nconst vec3 _PrismScale = vec3(1, 1.9, 1) ;\r\nconst vec3 _PyramidNoisePrams = vec3(1.5, 1, 1) ;\r\nconst vec3 _PrismEyeScale = vec3(0.7, 1.9, 51.5) ;\r\nconst vec3 _PyramidEyeOffset = vec3(2.0, -4.9, 0) ;\r\nconst float _PrismEyeWidth = 5.86000 ;\r\nconst float _TerrainMaxDistance = 30.04000 ;\r\nconst float _SmallDetailStrength = 0.00600 ;\r\nconst vec3 _SmallWaveDetail = vec3(3.19, 16, 6.05) ;\r\nconst vec2 _WindSpeed = vec2(2, 0.6) ;\r\nconst float _MediumDetailStrength = 0.05000 ;\r\nconst vec2 _MediumWaveDetail = vec2(2, 50) ;\r\nconst vec3 _MediumWaveOffset = vec3(0.3, -2, 0.1) ;\r\nconst vec2 _LargeWaveDetail = vec2(0.25, 0.73) ;\r\nconst vec3 _LargeWavePowStre = vec3(0.6, 2.96, -2.08) ;\r\nconst vec3 _LargeWaveOffset = vec3(-3.65, 4.41, -11.64) ;\r\nconst vec3 _FlyingHelperPos = vec3(2.15, 4.68, 14.4) ;\r\nconst vec3 _FlyingHelperScale = vec3(0.25, 0.001, 0.3) ;\r\nconst vec3 _FlyingHelperMovement = vec3(0.44, 1.44, -2.98) ;\r\nconst vec3 _FlyingHelperScarfScale = vec3(0.1, 0.001, 1.5) ;\r\nconst vec3 _FlyingHelperScarfWindParams = vec3(-0.06, 0.31, 0.47) ;\r\nconst vec3 _FlyingHelperScarfWindDetailParams = vec3(3.93, 0.005, -45.32) ;\r\nconst vec3 _FlyingHelperSideScarfOffset = vec3(0.16, -0.01, 0) ;\r\nconst vec3 _FlyingHelperSideScarfScale = vec3(0.06, 0.001, 0.8) ;\r\nconst vec4 _FlyingScarfSideWindParams = vec4(2.46, -1.59, -0.05, 0.21) ;\r\n\r\n// Material ID definitions\r\n#define MAT_PYRAMID 1.0\r\n\r\n#define MAT_TERRAIN 10.0\r\n#define MAT_TERRAIN_TRAIL 11.0\r\n\r\n#define MAT_BACK_CLOUDS 20.0\r\n#define MAT_FRONT_CLOUDS 21.0\r\n\r\n#define MAT_TOMB 30.0\r\n#define MAT_TOMB_SCARF 31.0\r\n\r\n#define MAT_FLYING_HELPERS 40.0\r\n#define MAT_FLYING_HELPER_SCARF 41.0\r\n\r\n#define MAT_CHARACTER_BASE 50.0\r\n#define MAT_CHARACTER_MAIN_CLOAK 51.0\r\n#define MAT_CHARACTER_NECK_SCARF 52.0\r\n#define MAT_CHARACTER_LONG_SCARF 53.0\r\n#define MAT_CHARACTER_FACE 54.0\r\n\r\n#define TEST_MAT_LESS( a, b ) a < (b + 0.1)\r\n#define TEST_MAT_GREATER( a, b ) a > (b - 0.1)\r\n\r\n//==========================================================================================\r\n// Primitive functions by IQ\r\n//==========================================================================================\r\nfloat sdRoundBox(vec3 p, vec3 b, float r)\r\n{\r\n\treturn length( max( abs(p) - b, 0.0) ) - r;\r\n}\r\n\r\nfloat sdSphere(vec3 p, float s)\r\n{\r\n\treturn length(p) - s;\r\n}\r\n\r\nfloat sdPlane( vec3 p )\r\n{\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b)\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) +\r\n\t\tlength(max(d, 0.0));\r\n}\r\n\r\nfloat sdCylinder(vec3 p, vec2 h)\r\n{\r\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\r\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nfloat sdPlane(vec3 p, vec4 n)\r\n{\r\n\t// n must be normalized\r\n\treturn dot(p, n.xyz) + n.w;\r\n}\r\n\r\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\r\n{\r\n\tvec3 pa = p - a, ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn vec2( length( pa - ba*h ), h );\r\n}\r\n\r\nfloat sdEllipsoid(in vec3 p, in vec3 r)\r\n{\r\n\treturn (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\r\n}\r\n\r\nfloat sdTriPrism( vec3 p, vec2 h )\r\n{\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\n\r\n//==========================================================================================\r\n// distance field operations\r\n//==========================================================================================\r\nvec2 min_mat( vec2 d1, vec2 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\r\n    return mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\nvec2 smin_mat( vec2 a, vec2 b, float k, float c )\r\n{\r\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\r\n    float x = mix( b.x, a.x, h ) - k*h*(1.0-h);\r\n    return vec2( x, ( h < c ) ? b.y : a.y);\r\n}\r\n\r\nfloat smax( float a, float b, float k )\r\n{\r\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\r\n\treturn mix( a, b, h ) + k*h*(1.0-h);\r\n}\r\n\r\n//==========================================================================================\r\n// Rotations\r\n//==========================================================================================\r\nvoid rX(inout vec3 p, float a) {\r\n    vec3 q = p;\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    p.y = c * q.y - s * q.z;\r\n    p.z = s * q.y + c * q.z;\r\n}\r\n\r\nvoid rY(inout vec3 p, float a) {\r\n    vec3 q = p;\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    p.x = c * q.x + s * q.z;\r\n    p.z = -s * q.x + c * q.z;\r\n}\r\n\r\nvoid rZ(inout vec3 p, float a) {\r\n    vec3 q = p;\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    p.x = c * q.x + s * q.y;\r\n    p.y = -s * q.x + c * q.y;\r\n}\r\n\r\n//==========================================================================================\r\n// Value noise and its derivatives: https://www.shadertoy.com/view/MdX3Rr\r\n//==========================================================================================\r\nvec3 noised( in vec2 x )\r\n{\r\n    vec2 f = fract(x);\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\r\n#if 0\r\n    // texel fetch version\r\n    ivec2 p = ivec2(floor(x));\r\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\r\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\r\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\r\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\r\n#else    \r\n    // texture version    \r\n    vec2 p = floor(x);\r\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n#endif\r\n    \r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\r\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\n\r\n//==========================================================================================\r\n// Noise function: https://www.shadertoy.com/view/4sfGRH \r\n//==========================================================================================\r\nfloat pn(vec3 p) {\r\n    vec3 i = floor(p); \r\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\r\n    vec3 f = cos((p-i)*3.141592653589793)*(-.5) + .5;  \r\n\ta = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\r\n    a.xy = mix(a.xz, a.yw, f.y);   \r\n\treturn mix(a.x, a.y, f.z);\r\n}\r\n\r\n//==========================================================================================\r\n// Sin Wave approximation http://http.developer.nvidia.com/GPUGems3/gpugems3_ch16.html\r\n//==========================================================================================\r\nvec4  SmoothCurve( vec4 x ) {  \r\n  return x * x * ( 3.0 - 2.0 * x );  \r\n}\r\n\r\nvec4 TriangleWave( vec4 x ) {  \r\n  return abs( fract( x + 0.5 ) * 2.0 - 1.0 );  \r\n}\r\n\r\nvec4 SmoothTriangleWave( vec4 x ) {  \r\n  return SmoothCurve( TriangleWave( x ) );  \r\n}  \r\n\r\nfloat SmoothTriangleWave( float x )\r\n{\r\n  return SmoothCurve( TriangleWave( vec4(x,x,x,x) ) ).x;  \r\n}  \r\n\r\nvoid Bend(inout vec3 vPos, vec2 vWind, float fBendScale)\r\n{\r\n\tfloat fLength = length(vPos);\r\n\tfloat fBF = vPos.y * fBendScale;  \r\n\tfBF += 1.0;  \r\n\tfBF *= fBF;  \r\n\tfBF = fBF * fBF - fBF;  \r\n\tvec3 vNewPos = vPos;  \r\n\tvNewPos.xz += vWind.xy * fBF;  \r\n\tvPos.xyz = normalize(vNewPos.xyz)* fLength;  \r\n}\r\n\r\n//==========================================================================================\r\n// Modified cone versions for scarf and main cloak\r\n//==========================================================================================\r\nfloat sdScarfCone( in vec3 p, in float h, in float r1, in float r2 )\r\n{\r\n    float d1 = -p.y - h;\r\n    float q = (p.y - h);\r\n    float si = 0.5*(r1-r2)/h;\r\n    p.z = mix(p.z, p.z * 0.2, q);\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\n\r\nvec2 sdCloakCone( in vec3 p, in float h, in float r1, in float r2 )\r\n{\r\n    float d1 = -p.y - h;\r\n    float q = (p.y - h);\r\n    r2 = (q * r2) + 0.08;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return vec2(length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.), q);\r\n}\r\n\r\n//==========================================================================================\r\n// Character\r\n//==========================================================================================\r\nvec3 headScarfMatUVW;\r\nfloat sdHeadScarf(vec3 pos)\r\n{\r\n\t\r\n    vec3 headScarfPos = pos - _HeadScarfPosition;\r\n    rX( headScarfPos, _HeadScarfRotation );\r\n\r\n    float distanceToTop =  min(0.0,(pos.y + 0.01));\r\n\r\n    // Put a slight twist in the middle. Gives the feel that the head scarf\r\n    // is sitting on shoulders. Very subtle, but I can see it :D\r\n    float midBend = abs( fract( distanceToTop + 0.5 ) * 2.0 - 1.0 );\r\n    headScarfPos.x += (cos( 2.0 + headScarfPos.y * 50.0 ) * 0.05 * midBend);\r\n    headScarfPos.z += (sin( 2.0 + headScarfPos.y * 50.0 ) * 0.03 * midBend);\r\n\r\n    // Apply wind to head Scarf    \r\n    headScarfPos += SmoothTriangleWave(vec4(pos.xyz * 5.0+ iTime,1.0) ).xyz * 0.05 * distanceToTop;\r\n\r\n    // Scarf shape    \r\n    float headScarf = sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z );\r\n    headScarf = max(headScarf, -sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z - 0.011));\r\n    \r\n    // Cut out the bottom of the head scarf. I have no idea what I was thinking, when I wrote this\r\n    vec3 cutOutPos = headScarfPos - vec3( 0.0, 0.08, 0.0);\r\n    vec3 r = vec3(0.12, 0.8, 0.2);\r\n    float smallestSize = min(min(r.x,r.y),r.z);\r\n\tvec3 dp = cutOutPos/r;\r\n    float h = min(1.0, abs(1.0 - abs(dp.y)) );\r\n\r\n    // Apply some crazy power until it looks like a scarf sitting on shoulders\r\n    h =  pow(h, 5.5);\r\n    \r\n    float rad = h ;\r\n    float d = length( cutOutPos/r );\r\n    \r\n    float cutOut = (d - rad) * smallestSize;\r\n    headScarf\t= max(headScarf, cutOut);\r\n\r\n    // material information\r\n    float materialVal = 1.0 - pow(d - rad, 0.02);\r\n\theadScarfMatUVW = smoothstep( -1.0, 1.0, materialVal / _HeadScarfScale);\r\n\r\n\t// Chop the top off, to make room for head\r\n    vec3 headPos = pos - vec3(0.0, 0.25, 0.0);\r\n    float head   = sdBox(headPos, vec3(0.2, 0.19, 0.2)); \r\n    headScarf = max(headScarf, -head);\r\n    \r\n    return headScarf;\r\n}\r\nvec3 mainCloakMatUVW;\r\nfloat sdMainCloak(vec3 pos)\r\n{\r\n    vec3 cloakPos = pos - _MainClothPosition;\r\n    float q =  min(0.0,(cloakPos.y + 0.05));\r\n    rX( cloakPos, _MainClothRotation );\r\n    \r\n    // Apply detailing\r\n    cloakPos += SmoothTriangleWave(vec4(pos.xyz * _MainClothDetail.x + iTime,1.0) ).xyz * _MainClothDetail.y * q;\r\n    \r\n    // Add main Wind direction\r\n    Bend(cloakPos, _WindDirection.xy, _MainClothDetail.z);\r\n    \r\n    vec2 cloak = sdCloakCone( cloakPos, _MainClothScale.y, _MainClothScale.x, _MainClothScale.z);\r\n    // Cut out the internals of the cloak\r\n    cloak.x = max( cloak.x, -sdCloakCone( cloakPos, _MainClothScale.y * 1.05, _MainClothScale.x * 0.95, _MainClothScale.z * 1.01).x);\r\n\r\n    // UV Information\r\n    mainCloakMatUVW = smoothstep( -1.0, 1.0, cloakPos / _MainClothScale);\r\n\r\n    // Cut out the top section\r\n    vec3 headPos = cloakPos - vec3(0.0, 0.69, 0.0);\r\n    float head   = sdBox(headPos, vec3(0.2, 0.67, 0.2)); \r\n\tcloak.x = max(cloak.x, -head);\r\n    \r\n    // Cut the bottom\r\n    float bottomCut   = sdPlane(cloakPos - _MainClothBotCutPos); \r\n    cloak.x = max(cloak.x, -bottomCut);\r\n    \r\n    return cloak.x;\r\n}\r\n\r\nfloat earWigs(in vec3 pos) \r\n{   \r\n\t// Symmetrical ear wigs. Is that even a word... Ear Wigs!\r\n    pos.x = abs(pos.x);\r\n\r\n    vec2  earWig = sdSegment( pos, vec3(0.02, 0.11, 0.0), vec3(0.07, 0.16, 0.05));\r\n    float ear  = earWig.x - 0.026  + (earWig.y * 0.03);\r\n    return ear;\r\n}\r\n\r\n\r\nfloat sdHead( vec3 pos )\r\n{\r\n    vec3 headPos = pos - _HeadPos;\r\n\r\n    // Slight tilt\r\n    rY(headPos, _HeadRotationY ); // 1.2\r\n    rX(headPos, _HeadRotationX );\r\n\r\n    float head = sdCylinder( headPos, vec2(0.05, 0.13) );\r\n    head = smin(earWigs(headPos), head, 0.04 );\r\n    return head;\r\n}\r\n\r\nvec3 longScarfMatUVW;\r\nfloat sdScarf(vec3 pos) \r\n{\r\n    vec3 scarfPos = pos - _LongScarfPos;\r\n    vec3 scale \t= _LongScarfScale;\r\n\r\n\r\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.04);\r\n    scarfPos.x += (sin( scarfPos.z * _LongScarfWindStrength.x + iTime ) * 0.1 * distanceToPoint);\r\n    scarfPos.y += (sin( scarfPos.z * _LongScarfWindStrength.y + iTime ) * 0.1 * distanceToPoint);\r\n\r\n    // Apply detailing\r\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _LongScarfWindStrength.z + iTime,1.0) ).xyz * _LongScarfWindStrength.w * distanceToPoint;\r\n\r\n    // Essentially a box pivoted at a specific point\r\n    vec3 scarfOffset = vec3(0.0, 0.0, -scale.y);\r\n\r\n    rX(scarfPos, _LongScarfRotX) ;\r\n    float scarf = sdBox(scarfPos - scarfOffset.xzy , scale);\r\n\r\n    longScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos - scarfOffset.xzy ) / scale);\r\n\r\n    return max(scarf, sdSphere( scarfPos, _LongScarfMaxRad ));\r\n}\r\n\r\nfloat sdLegs( in vec3 pos  )\r\n{\r\n    vec2  upperLeftLeg = sdSegment( pos, _UpperLeftLegA, _UpperLeftLegB );\r\n    float leftLeg  = upperLeftLeg.x - _UpperLeftLegParams.x;\r\n    vec2 lowerLeftLeg = sdSegment( pos, _LowerLeftLegA, _LowerLeftLegB );\r\n    leftLeg  = smin( leftLeg, lowerLeftLeg.x - _LowerLeftLegParams.x + (lowerLeftLeg.y * _LowerLeftLegParams.y), _LowerLeftLegParams.z);\r\n\r\n    // cut bottom of left leg otherwise looks nasty with harsh tip\r\n    leftLeg = max( leftLeg, -(length( pos - _LowerLeftLegB) - 0.06 ) );\r\n\r\n    vec2  upperRightLeg = sdSegment( pos, _UpperRightLegA, _UpperRightLegB );\r\n    float rightLeg  = upperRightLeg.x - _UpperRightLegParams.x;\r\n    vec2 lowerRightLeg = sdSegment( pos, _LowerRightLegA, _LowerRightLegB );\r\n    rightLeg  = smin( rightLeg, lowerRightLeg.x - _LowerRightLegParams.x + (lowerRightLeg.y * _LowerRightLegParams.y), _LowerRightLegParams.z);\r\n\r\n    return min( leftLeg, rightLeg );\r\n}\r\n\r\nvec2 sdFace( vec3 pos, vec2 currentDistance )\r\n{\r\n    vec3 headPos = pos - vec3(0.0, -0.05, 0.0);\r\n    rX( headPos, _HeadRotationX );\r\n    rY(headPos, _HeadRotationY );\r\n\r\n    // head hole - Fire in the hole!    \r\n    // OK this does not look right. Actually looks like there was \"fire in the hole\" for \r\n    // the poor travellers face. Need to come back to it one day and finish it. Maybe!\r\n    vec3 headHole = headPos - vec3(0.0, 0.1, -0.07);\r\n    float hole = sdEllipsoid( headHole,vec3(0.05, 0.03, 0.04) );\r\n    hole  = smin ( hole, sdEllipsoid( headHole - vec3(0.0, -0.03, 0.0), vec3(0.03,0.03, 0.04)), 0.05 );\r\n\r\n    // Cut it OUT!\r\n    float character =  smax( currentDistance.x, -hole, 0.001);\r\n\r\n    // face. Meh just an ellipsoid. Need to add eyes and bandana\r\n    float face = sdEllipsoid( headHole - _FacePosition.xyz, _FaceSize );\r\n    return smin_mat( vec2(face, MAT_CHARACTER_FACE), vec2(character,currentDistance.y), 0.01, 0.2 );\r\n}\r\n\r\nvec2 sdCharacter( vec3 pos )\r\n{\r\n    // Now we are in character space - Booo YA! - I never ever say Boooo YA!. Peter Pimley \r\n    // says that. Peter: have you been putting comments in my code?\r\n    pos -= _CharacterPosition;\r\n    vec3 scale = _CharacterScale;\r\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\r\n    \r\n    rY(pos, _CharacterRotation);\r\n\r\n    pos /= scale;\r\n\r\n    float mainCloak = sdMainCloak( pos );\r\n    vec2  mainCloakMat = vec2(mainCloak, MAT_CHARACTER_MAIN_CLOAK );\r\n\r\n    float headScarf = sdHeadScarf(pos);\r\n    vec2  headScarfMat = vec2(headScarf, MAT_CHARACTER_NECK_SCARF );\r\n\r\n    float longScarf = sdScarf(pos);\r\n    vec2  longScarfMat = vec2( longScarf, MAT_CHARACTER_LONG_SCARF );\r\n    headScarfMat = smin_mat( headScarfMat, longScarfMat, 0.02, 0.1 );\r\n\r\n    float head      = sdHead( pos );\r\n    vec2  headMat\t= vec2( head, MAT_CHARACTER_BASE );\r\n    headScarfMat    = smin_mat(headScarfMat, headMat, 0.05, 0.75);\r\n\r\n    vec2  characterMat = min_mat(mainCloakMat, headScarfMat); \r\n    characterMat = sdFace( pos, characterMat );\r\n\r\n    vec2 legsMat = vec2( sdLegs(pos), MAT_CHARACTER_BASE );\r\n    characterMat = min_mat( characterMat, legsMat );\r\n\r\n    // chope the bottom. This is to chop the bottom of right leg. Though\r\n    // I have positioned the character so that the right leg is hidden by terrain. \r\n    // Commenting it out for now\r\n//    characterMat.x = max( characterMat.x, -sdPlane( pos - vec3(0.0, -0.85, 0.0) ) );\r\n    characterMat.x *= scaleMul;\r\n\r\n\r\n    return characterMat;\r\n}\r\n\r\n//==========================================================================================\r\n// Clouds\r\n//==========================================================================================\r\nfloat sdCloud( in vec3 pos, vec3 cloudPos, float rad, float spread, float phaseOffset, vec3 globalParams)\r\n{ \r\n\t// Clouds are simple. A bunch of spheres with varying phase offset, size and \r\n\t// frequency values. They are also scaled along the z-Axis so more like circles\r\n\t// than spheres. With additional noise to make them look fluffy. \r\n\t// While rendering them we \"perturb\" #SpellCheck the normals to get strong specular\r\n\t// highlights\r\n\r\n\t// Add noise to the clouds\r\n\tpos += pn( pos ) * _CloudNoiseStrength;\r\n\tpos = pos - cloudPos;\r\n\r\n\t// Make us 2d-ish - My artists have confirmed me: 2D is COOL!\r\n\tpos.z /= globalParams.x;\r\n\r\n\t// Repeat the space\r\n\tfloat repitition = rad * 2.0 + spread;\r\n\tvec3  repSpace = pos - mod( pos - repitition * 0.5, repitition);\r\n\r\n\t// Create the overall shape to create clouds on\r\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.23  )  * globalParams.y ;\r\n\r\n\t// Creates clouds with offset on the main path\r\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.9 ) * globalParams.z;\r\n\r\n\t// repeated spheres\r\n\tpos.x = fract( (pos.x + repitition * 0.5) / repitition ) * repitition - repitition * 0.5;\r\n\r\n\t// return the spheres  \r\n\tfloat sphere = length(pos)- rad;\r\n\treturn sphere * globalParams.x;\r\n}\r\n\r\nvec2 sdClouds( in vec3 pos )\r\n{\r\n\t// Two layers of clouds. A layer in front of the big pyramid\r\n    float c1 = sdCloud( pos, _FrontCloudsPos, _FrontCloudParams.x, _FrontCloudParams.y, _FrontCloudParams.z, _CloudGlobalParams );\r\n    float c2 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetA, _FrontCloudParamsA.x, _FrontCloudParamsA.y, _FrontCloudParamsA.z, _CloudGlobalParams );\r\n    float c3 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetB, _FrontCloudParamsB.x, _FrontCloudParamsB.y, _FrontCloudParamsB.z, _CloudGlobalParams);\r\n    float frontClouds = min(c3, min(c1, c2));\r\n\r\n    // This plane hides the empty spaces between the front cloud spheres. Not needed\r\n    // for back spheres, they are covered by front spheres\r\n  \tfloat mainPlane = length(pos.z - _FrontCloudsPos.z) / _CloudGlobalParams.x + (pos.y - _PlaneParams.y  + sin(_PlaneParams.x + pos.x * 0.23 ) * _PlaneParams.z);// - rad;\r\n  \tfrontClouds = min(mainPlane * _CloudGlobalParams.x, frontClouds);\r\n\r\n\t// Second layer behind the big Pyramid\r\n    float c4 = sdCloud( pos, _BackCloudsPos, _BackCloudParams.x, _BackCloudParams.y, _BackCloudParams.z, _CloudBackGlobalParams );\r\n    float c5 = sdCloud( pos, _BackCloudsPos + _BackCloudsOffsetA, _BackCloudParamsA.x, _BackCloudParamsA.y, _BackCloudParamsA.z, _CloudBackGlobalParams );\r\n    float backClouds = min(c4,c5);\r\n    return min_mat(vec2(frontClouds,MAT_FRONT_CLOUDS), vec2(backClouds,MAT_BACK_CLOUDS));\r\n}\r\n\r\n//==========================================================================================\r\n// This should really be called Kites. No such thing as Flying Helplers...\r\n//==========================================================================================\r\nvec3 helperScarfMatUVW;\r\nfloat sdHelperScarf(vec3 pos, vec3 scarfOffset, vec3 originalPos ) \r\n{\r\n    vec3 scarfPos = pos - scarfOffset;\r\n\r\n    vec3 scale = _FlyingHelperScarfScale;\r\n\r\n    // How far are we from pivot of scarf\r\n    float distanceToPoint = length(scarfPos );\r\n\r\n    // Apply some motion\r\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _FlyingHelperScarfWindDetailParams.x + iTime,1.0) ).xyz * _FlyingHelperScarfWindDetailParams.y * distanceToPoint;\r\n\r\n    vec2 wave;\r\n    wave.x = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.x  );\r\n    wave.y = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.z  );\r\n\r\n    scarfPos.xy += ( wave * _FlyingHelperScarfWindParams.y * distanceToPoint);\r\n    vec3  pivotOffset = vec3(0.0, 0.0, scale.z);\r\n    float scarf = sdBox(scarfPos - pivotOffset, scale);\r\n\r\n    // Move us along the z-axis because we chop a sphere in the box. Shows borders otherwise\r\n    vec3 UVWOffset = vec3(0.0, 0.0, 1.0);\r\n    helperScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos + UVWOffset - pivotOffset.xzy ) / scale);\r\n\r\n    // Two scarf on each side of the big'un\r\n    pivotOffset.z = _FlyingHelperSideScarfScale.z;\r\n\r\n\twave.y = originalPos.x > 0.0 ? wave.y * _FlyingScarfSideWindParams.x : wave.y * _FlyingScarfSideWindParams.y;\r\n\tscarfPos.xy += scarfPos.x > 0.0 ? wave * _FlyingScarfSideWindParams.z : wave * _FlyingScarfSideWindParams.w;\r\n\r\n\t// legit mirroring!\r\n\tscarfPos.x = -abs(scarfPos.x);\r\n\tfloat sideScarfs = sdBox(scarfPos - pivotOffset + _FlyingHelperSideScarfOffset, _FlyingHelperSideScarfScale);\r\n\r\n\t// Just override the helperScarfMatUVW value for side scarfs. Too tired to create another variable and use that, not too tired\r\n\t// to write this long comment of no value\r\n    helperScarfMatUVW = scarf < sideScarfs ? helperScarfMatUVW : smoothstep(-1.0, 1.0, ( scarfPos - pivotOffset + _FlyingHelperSideScarfOffset ) / _FlyingHelperSideScarfScale);\r\n\r\n    // Combine'em\r\n    scarf = min( scarf, sideScarfs );\r\n    return scarf;\r\n}\r\n\r\nvec2 sdFlyingHelpers( vec3 pos )\r\n{\r\n\tvec3 originalPos = pos;\r\n\tfloat flyingHelper = _DrawDistance;\r\n\r\n\t// Using pos.x to determine, whether we are rendering left or right scarf.\r\n\tvec3 helperPos = _FlyingHelperPos;\r\n\thelperPos = pos.x > 0.0 ? helperPos - _FlyingHelperMovement : helperPos;\r\n\r\n\t// Rest is just mirroring\r\n\tpos.x = abs(pos.x);\r\n\tpos = pos - helperPos;\r\n\r\n\tfloat helperScarf = sdHelperScarf( pos, vec3(0.0, 0.0, 0.0), originalPos);\r\n\r\n\t// Main helper is a box with a cutout sphere at back. In-game it is more sophisticated. But\r\n\t// I am running out of time. Maybe will do a proper one, one day!\r\n\tfloat helper = sdBox( pos, _FlyingHelperScale );\r\n\thelper\t= max( helper, -sdSphere( pos - vec3(0.0, 0.0, _FlyingHelperScale.z ), _FlyingHelperScale.z) );\r\n\r\n\t// Material and combine scarf with main body\r\n\tvec2 helperMat = smin_mat( vec2(helper,MAT_FLYING_HELPERS), vec2(helperScarf,MAT_FLYING_HELPER_SCARF), 0.01, 0.1);\r\n\thelperScarfMatUVW = helper < helperScarf ? smoothstep(-1.0, 1.0, (pos + vec3(0.0,0.0,_FlyingHelperScale.z*0.5)) / _FlyingHelperScale) : helperScarfMatUVW;\r\n\r\n\treturn helperMat;\r\n}\r\n\r\n//==========================================================================================\r\n// The big mountain in the distance. Again, not a pyramid\r\n//==========================================================================================\r\nfloat sdBigMountain( in vec3 pos )\r\n{\r\n    float scaleMul = min(_PyramidScale.x, min(_PyramidScale.y, _PyramidScale.z));\r\n    vec3 posPyramid\t= pos - _PyramidPos;\r\n\r\n    // Apply noise derivative, then we can use a blocky looking texture to make the mountain\r\n    // look edgy (for lack of better word)\r\n    float derNoise\t\t= sin(noised(posPyramid.xz * _PyramidNoisePrams.x).x) * _PyramidNoisePrams.y;\r\n    posPyramid.x\t\t= posPyramid.x + derNoise;\r\n\r\n    posPyramid /= _PyramidScale;\r\n    float pyramid = sdTriPrism(  posPyramid, _PrismScale.xy ) * scaleMul;\r\n\r\n    // The piercing eye. Which is just an inverted pyrmaid on top of main pyramid.\r\n    float eyeScale = _PyramidScale.x;\r\n\r\n    vec3 posEye = pos;\r\n    posEye.y = _PrismEyeScale.z - pos.y;\r\n    posEye.x = pos.x * _PrismEyeWidth;\r\n\r\n\tfloat eye = sdTriPrism(  (posEye -_PyramidEyeOffset) / eyeScale, _PrismEyeScale.xy ) * eyeScale;\r\n\treturn max(pyramid, -eye);\r\n}\r\n\r\n//==========================================================================================\r\n// Main desert shape\r\n//==========================================================================================\r\nfloat sdLargeWaves( in vec3 pos )\r\n{\r\n\t// The main shape of terrain. Just sin waves, along X and Z axis, with a power\r\n\t// curve to make the shape more pointy \r\n\r\n    // Manipulate the height as we go in the distance\r\n    // We want terrain to be a specific way closer to character, showing a path, but the path \r\n    // gets muddier as wo go in the distance.\r\n\r\n    float distZ = abs(pos.z - _CameraPos.z);\r\n    float distX = abs(pos.x - _CameraPos.x);\r\n    float dist = (distZ ) + (distX * 0.1);\r\n    dist = dist * dist * 0.01;\r\n\r\n    float detailNoise = noised(pos.xz).x * -2.5; \r\n\tfloat largeWaves = (sin(_LargeWaveOffset.z + pos.z * _LargeWaveDetail.y + pos.z * 0.02)  \r\n\t\t\t\t\t  * sin((_LargeWaveOffset.x + dist) + (pos.x * _LargeWaveDetail.x) ) * 0.5) + 0.5;\r\n    largeWaves = -_LargeWaveOffset.y + pow( largeWaves, _LargeWavePowStre.x) *  _LargeWavePowStre.y - detailNoise * 0.1 ;// - (-pos.z*_LargeWavePowStre.z);// \r\n\r\n    // Smoothly merge with the bottom plane of terrain\r\n    largeWaves = smin(largeWaves, _LargeWavePowStre.z, 0.2);\r\n    largeWaves = (largeWaves - dist);\r\n    return largeWaves * 0.9;\r\n}\r\n\r\nfloat sdSmallWaves( in vec3 pos )\r\n{\r\n\t// The small waves are used for adding detail to the main shape of terrain\r\n\tfloat distanceToCharacter = length( pos.xz - _CharacterPosition.xz );\r\n\r\n    // movement to give feel of wind blowing\r\n    float detailNoise = noised(pos.xz).x * _SmallWaveDetail.z; \r\n\tfloat smallWaves = sin(pos.z * _SmallWaveDetail.y + detailNoise + iTime * _WindSpeed.y ) * \r\n\t\t\t\t\t   sin(pos.x * _SmallWaveDetail.x + detailNoise + iTime * _WindSpeed.x ) * _SmallDetailStrength;// * min(1.0, distanceToCharacter);\r\n\t\r\n\treturn smallWaves * 0.9;\r\n}\r\n\r\nfloat sdTerrain( in vec3 pos)\r\n{\r\n\tfloat smallWaves = sdSmallWaves( pos );\r\n\tfloat largeWaves = sdLargeWaves( pos );\r\n\r\n    return (smallWaves + largeWaves);\r\n}\r\n\r\nvec2 sdDesert( in vec3 pos, in float terrain )\r\n{\r\n    float distanceToPos = length(pos.xz - _CameraPos.xz);\r\n    if( distanceToPos > _TerrainMaxDistance)\r\n        return vec2(_DrawDistance, 0.0);\t\r\n\r\n   \tfloat mat = 9.0;//length(pos.xyz) > 9.0 ? 10.0 : 40.0;\r\n    return vec2( pos.y + terrain, MAT_TERRAIN );\r\n}\r\n\r\n//==========================================================================================\r\n// Character trail in the sand\r\n//==========================================================================================\r\nfloat sdCharacterTrail( vec3 pos, in float terrain )\r\n{\r\n\tvec3 trailOffset = (_CharacterPosition);\r\n\ttrailOffset.yz  += (_CharacterTrailOffset).yz;\r\n    trailOffset.y = -terrain + _CharacterTrailOffset.y; \r\n\r\n    vec3 trailPos = pos - trailOffset;\r\n    float distanceToPoint = length(trailPos);\r\n    trailPos.x -= _CharacterTrailOffset.x * distanceToPoint;\r\n\r\n    // Make it wavy\r\n    trailPos.x += (SmoothTriangleWave( trailPos.z * _CharacterTrailWave.x  ) * _CharacterTrailWave.z * distanceToPoint);\r\n\r\n    float trail = sdBox(trailPos - vec3(0.0, 0.0, _CharacterTrailScale.z) , _CharacterTrailScale);\r\n    return trail;\r\n}\r\n\r\n//==========================================================================================\r\n// The tombs\r\n//==========================================================================================\r\nfloat sdTombScarf(vec3 pos, vec3 scarfOffset, float t ) \r\n{ \r\n\t//  scarfs, done same as other scarfs\r\n\r\n    vec3 scarfPos = pos - scarfOffset;\r\n\r\n    scarfPos =  (mul(  _TombScarfMat, vec4(scarfPos,1.0) )).xyz;\r\n\r\n    vec3 scale = _TombScarfScale;\r\n    scale.z  += (t + 1.0 ) * 0.2;\r\n\r\n    // How far are we from pivot of scarf\r\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.1);\r\n\r\n    // Make the scarf thicker as it goes out\r\n    scale.x += distanceToPoint * 0.04;\r\n\r\n    // Apply some motion\r\n    scarfPos.x += (sin( pos.z * _TombScarfWindParams.x + iTime) * _TombScarfWindParams.z * distanceToPoint);\r\n    scarfPos.y += (sin( pos.z * _TombScarfWindParams.y + iTime) * _TombScarfWindParams.z * distanceToPoint);\r\n\r\n     vec3 pivotOffset = vec3(0.0, 0.0, scale.z);\r\n    rX(scarfPos, _TombScarfRot + ((t - 0.5)* 0.15) + SmoothTriangleWave((iTime + 1.45) * 0.1) * 0.3 );\r\n\r\n    float scarf = sdBox(scarfPos - pivotOffset , scale);\r\n    return scarf;\r\n}\r\n\r\nvec2 sdTombs( in vec3 p )\r\n{\r\n\tvec2 mainTomb = vec2(_DrawDistance, MAT_TOMB);\r\n\r\n\t// We draw two tombs, t goes -1 -> 1 so we can use negative and positive values\r\n\t// to mainpulate them both individually\r\n\tfor( float t = -1.0; t <= 1.0; t += 2.0 )\r\n\t{\r\n\t\tvec3 tombPos = (_TombPosition + vec3(-0.25 * t, t * 0.05, 0.1 * t ));\r\n\r\n\t\tvec3 pos = p - tombPos;\r\n\t\trZ( pos, 0.1 * t );\r\n\r\n\t\tfloat tombScarf = sdTombScarf( pos, _TombScarfOffset, t + 1.0);\r\n\r\n\t\tpos.x = abs(pos.x);\r\n\r\n\t\t// Taper them beyond a certain height. Rest is just a rounded box\r\n\t\tpos.x += abs( pos.y > _TombBevelParams.x  ? (pos.y - _TombBevelParams.x) * _TombBevelParams.y: 0.0 );\r\n\t\tfloat tTomb = sdRoundBox( pos, _TombScale, _TombBevelParams.z);\r\n\r\n\t\t// Cut out a sphere at top\r\n\t\ttTomb = max( tTomb, -sdSphere( pos - vec3(0.0, _TombCutOutScale.x, 0.0), _TombCutOutScale.y ) );\r\n\r\n\t\t// create scarfs at cut off points\r\n\t\tvec2 tTombMat = min_mat( vec2(tTomb, MAT_TOMB), vec2(tombScarf, MAT_TOMB_SCARF));\r\n\t\tmainTomb = min_mat( mainTomb, tTombMat);\r\n\t}\r\n\treturn mainTomb;\r\n}\r\n\r\n//==========================================================================================\r\n// The main map function\r\n//==========================================================================================\r\nvec2 map( in vec3 pos )\r\n{\r\n\tvec2 character = sdCharacter(pos);\r\n\tvec2 res = character;\r\n\r\n\t// I am assuming that since character covers a large portion of screen\r\n\t// This early out should help and same with the terrain. Assumption only, \r\n\t// need to look into it \r\n    if( res.x > 0.01 )\r\n    {\r\n    \tfloat desert = sdTerrain(pos);\r\n\t    vec2 terrain   = sdDesert( pos, desert );\r\n\t    vec2 trail\t   = vec2(-sdCharacterTrail(pos, desert), MAT_TERRAIN_TRAIL );\r\n\t    terrain.y\t\t= terrain.x > trail.x ? terrain.y : trail.y;\r\n\t\tterrain.x\t\t= smax( terrain.x, trail.x, 0.05);\r\n\r\n\t\tres\t= min_mat( res, terrain); \r\n        if( terrain.x > 0.01 )\r\n        {\r\n\t\t\tvec2 tombs\t   =  sdTombs(pos);\r\n            res = smin_mat( res, tombs, 0.2, 0.15 );\r\n\r\n            vec2 pyramid   = vec2(sdBigMountain(pos), MAT_PYRAMID);\r\n            res = min_mat( res, pyramid );\r\n\r\n            vec2 clouds\t   = sdClouds(pos);\r\n            res = min_mat( res, clouds );\r\n\r\n            vec2 flyingHelpers = sdFlyingHelpers( pos );\r\n            res = min_mat( res, flyingHelpers );\r\n        }\r\n\t}\r\n    return res;\r\n}\r\n\r\n\r\n//==========================================================================================\r\n// Used for generating normals. As it turns out that only the big mountain doesn't need\r\n// normals. Everything else does. Hey Ho!\r\n//==========================================================================================\r\nvec2 mapSimple( in vec3 pos )\r\n{\r\n\treturn map( pos );\r\n\t/*\r\n    vec2 character = sdCharacter(pos);\r\n    vec2 flyingHelpers = vec2( sdFlyingHelpers( pos ), 50.0 );\r\n    vec2 clouds\t   = sdClouds(pos);\r\n   \tfloat desert   = sdTerrain(pos);\r\n    vec2 terrain   = sdDesert( pos, desert );\r\n    terrain.x = smax( terrain.x, -sdCharacterTrail(pos, desert), 0.1 );\r\n    vec2 tombs\t   =  vec2(sdTombs(pos), 50.0);\r\n\r\n    vec2 res = character;\r\n    min_mat( res, flyingHelpers );\r\n\tres = min_mat( res, clouds );\r\n    res\t= min_mat( res, terrain); \r\n    res\t= min_mat( res, flyingHelpers); \r\n    res = smin_mat( res, tombs, 0.2, 0.15 );\r\n    return res;\r\n    */\r\n}\r\n\r\n//==========================================================================================\r\n// Raycasting: https://www.shadertoy.com/view/Xds3zN\r\n//==========================================================================================\r\nvec3 castRay(vec3 ro, vec3 rd) \r\n{\r\n    float tmin = 0.1;\r\n    float tmax = _DrawDistance;\r\n   \r\n    float t = tmin;\r\n    float m = -1.0;\r\n    float p = 0.0;\r\n    float maxSteps = _MaxSteps;\r\n    float j = 0.0;\r\n    for( float i = 0.0; i < _MaxSteps; i += 1.0 )\r\n    {\r\n        j = i;\r\n\t    float precis = 0.0005*t;\r\n\t    vec2 res = map( ro+rd*t );\r\n        if( res.x<precis || t>tmax ) \r\n        \tbreak;\r\n        t += res.x;\r\n\t    m = res.y;\r\n    }\r\n\tp = j / maxSteps;\r\n    if( t>tmax ) m=-1.0;\r\n    return vec3( t, m, p );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\r\n    return normalize( e.xyy*mapSimple( pos + e.xyy ).x + \r\n\t\t\t\t\t  e.yyx*mapSimple( pos + e.yyx ).x + \r\n\t\t\t\t\t  e.yxy*mapSimple( pos + e.yxy ).x + \r\n\t\t\t\t\t  e.xxx*mapSimple( pos + e.xxx ).x );\r\n}\r\n\r\n//==========================================================================================\r\n// Ambient Occlusion, only applied to the Traveller\r\n//==========================================================================================\r\nfloat AmbientOcclusion(vec3 p, vec3 N, float stepSize, float k)\r\n{\r\n    float r = 0.0;\r\n    float t = 0.0;\r\n  \r\n    for(int i = 0; i < 2; i++)\r\n    {\r\n        t += stepSize;\r\n        r += (1.0 / pow(2.0, t)) * (t - sdCharacter(p + (N * t)).x);\r\n    }\r\n    return max(0.0, 1.0 - (k * r));\r\n}\r\n\r\n//==========================================================================================\r\n// Simplified version of Traveller for shadow casting\r\n//==========================================================================================\r\nfloat sdCharacterShadow( vec3 pos )\r\n{\r\n    pos -= _CharacterPosition;\r\n    vec3 scale = _CharacterScale;\r\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\r\n    \r\n    rY(pos, _CharacterRotation);\r\n\r\n    pos /= scale;\r\n\r\n    float mainCloak = sdMainCloak( pos );\r\n    float longScarf = sdScarf(pos);\r\n\r\n    return min( mainCloak, longScarf) * scaleMul;\r\n}\r\n\r\n//==========================================================================================\r\n// Only character, flying helpers and tombs cast shadows. Only terrain recieves shadows\r\n//==========================================================================================\r\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\r\n{\r\n    float res = 1.0;\r\n    float t = mint;\r\n    for(int i = 0; i < 100; ++i)\r\n    {\r\n        if (t >= maxt) {\r\n            break;\r\n        }\r\n    \tfloat flyingHelpers = sdFlyingHelpers( ro + rd * t).x;\r\n    \tfloat tombs = sdTombs( ro + rd * t ).x;\r\n        float h = min( sdCharacterShadow( ro + rd*t), min(flyingHelpers, tombs) );\r\n        if( h<0.001 )\r\n            return 0.1;\r\n        res = min( res, k*h/t );\r\n        t += h;\r\n    }\r\n\treturn res;\r\n}\r\n\r\n//==========================================================================================\r\n// Hi Hussain!\r\n// Again, somebody wrote Hi Hussain here. It wasn't me, but hi back atcha!\r\n// Sky\r\n//==========================================================================================\r\nvec3 sky( vec3 ro, vec3 rd )\r\n{\r\n    // Sun calculation\r\n    float sunDistance = length( _SunPosition );\r\n\r\n    vec3 delta = _SunPosition.xyz - (ro + rd * sunDistance);\r\n    float dist \t= length(delta);\r\n\r\n    // Turn Sun into a star, because the big mountain has a star like shape\r\n    // coming from top\r\n    delta.xy *= _SunStar.xy;\r\n    float sunDist = length(delta);\r\n    float spot = 1.0 - smoothstep(0.0, _SunSize, sunDist);\r\n    vec3 sun = clamp(_SunScale * spot * spot * spot, 0.0, 1.0) * _SunColor.rgb;\r\n\t\r\n\t// Changing color on bases of distance from Sun. To get a strong halo around\r\n\t// the sun\r\n   \tfloat expDist = clamp((dist - _ExposureOffset)  * _ExposureStrength, 0.0, 1.0);\r\n   \tfloat expControl = pow(expDist,_ExposurePower);\r\n\r\n    // Sky colors\r\n    float y = rd.y;\r\n    float zen = 1.0 - pow (min (1.0, 1.0 - y), _ZenithFallOff);\r\n    vec3 zenithColor\t= _Zenith.rgb  * zen;\r\n    zenithColor = mix( _SunColor.rgb, zenithColor, expControl );\r\n\r\n    float nad = 1.0 - pow (min (1.0, 1.0 + y), _NadirFallOff);\r\n    vec3 nadirColor\t= _Nadir.rgb * nad;\r\n\r\n    float hor = 1.0 - zen - nad;\r\n    vec3 horizonColor\t= _Horizon.rgb * hor;\r\n\r\n    // Add stars for Color Scheme 3\r\nfloat stars  = 0.0;\r\n#if COLOR_SCHEME == 3\r\n    vec3 starPos = ro + ( (rd + vec3(iTime * 0.001, 0.0, 0.0) ) * sunDistance);\r\n    starPos.xyz += iTime*0.01 + noised(starPos.xy) * 3.0;\r\n\r\n    starPos      = mod( starPos, 1.5) - 0.75;\r\n    stars  \t\t = length(starPos);\r\n\r\n\tfloat starsA \t= (step( 0.9, 1.0 - stars) * 1.0 - (stars)) * 2.0;\r\n\tfloat starsB\t= (step( 0.93, 1.0 - stars) * 1.0 - (stars)) * 1.5;\r\n\tstars = starsA + starsB;\r\n\r\n    stars = stars * pow(zen * expControl, 5.0);\r\n    stars = step( 0.01, stars) * stars * 2.0;\r\n#endif\r\n    return stars + (sun * _SunStar.z + zenithColor + horizonColor + nadirColor);\r\n}\r\n\r\n//==========================================================================================\r\n// The rendering, based on: https://www.shadertoy.com/view/Xds3zN\r\n//==========================================================================================\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{ \r\n\t// res.z contains the iteration count / max iterations. This gives kind of a nice glow\r\n\t// effect around foreground objects. Looks particularly nice on sky, with clouds in\r\n\t// front and also on terrain. Gives rim kind of look!\r\n\tvec3 res\t= castRay(ro,rd);\r\n\tvec3 skyCol = sky( ro, rd );\r\n\tvec3 col\t= skyCol;\r\n\r\n\t#if defined (DEBUG_PERFORMANCE)\r\n\treturn (res.z);\r\n\t#endif\r\n\r\n\tfloat t = res.x;\r\n\tfloat m = res.y;\r\n\r\n\tvec3 pos = ro + t*rd;\r\n\r\n\t// Return sky\r\n\tif( m < 0.0 )\r\n\t{\r\n\t\t// Bloom for the background clouds. We want Big Mountain to be engulfed with fog. So just chop out\r\n\t\t// areas around right and left side of BigMountain for creating fake bloom for background clouds by\r\n\t\t// using the iteration count needed to generate the distance function\r\n\t\tfloat rightSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(45.0, -5.0, _SunPosition.z));\r\n\t\tfloat leftSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(-50.0, -5.0, _SunPosition.z));\r\n\t\tif( rightSideCloudDist < 40.0 )\r\n\t\t{\r\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, rightSideCloudDist / 40.0);\r\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\r\n\t\t}\r\n\t\telse if( leftSideCloudDist < 40.0 )\r\n\t\t{\r\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, leftSideCloudDist / 40.0);\r\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\r\n\t\t}\r\n        else\r\n\t\t\treturn col;\r\n\t}\r\n\r\n\tfloat skyFog = 1.0-exp( _FogMul * t * pow(pos.y, _FogPow) );\r\n\t#if defined (DEBUG_FOG)\r\n\treturn (skyFog);\r\n\t#endif\r\n\r\n\t// Render the big mountain. Keep track of it's color, so we can use it for transparency for clouds later\r\n\tvec3 pyramidCol = vec3(0.0, 0.0, 0.0);\r\n\tpyramidCol\t\t= mix( _PyramidCol, skyCol, skyFog * 0.5  ); \r\n\r\n\tif( TEST_MAT_LESS( m, MAT_PYRAMID) )\r\n\t{\r\n\t\t// Height fog, with strong fade to sky \r\n\t\tfloat nh = (pos.y / _PyramidHeightFog.x);\r\n\t\tnh = nh*nh*nh*nh*nh;\r\n\t\tfloat heightFog = pow(clamp(1.0 - (nh), 0.0, 1.0), _PyramidHeightFog.y);\r\n\t\theightFog\t\t= clamp( heightFog, 0.0, 1.0 );\r\n\t\tpyramidCol\t\t= mix( pyramidCol, skyCol, heightFog ); \r\n\t\treturn pyramidCol;       \r\n\t}\r\n\r\n\t// Calculate normal after calculating sky and big mountain\r\n\tvec3 nor = calcNormal(pos);\r\n\t// Terrain: https://archive.org/details/GDC2013Edwards\r\n\tif( TEST_MAT_LESS (m, MAT_TERRAIN_TRAIL ) )\r\n\t{\r\n\t\tfloat shadow = softShadow( pos - (rd * 0.01), _LightDir.xyz, _TerrainShadowParams.x, _TerrainShadowParams.y, _TerrainShadowParams.z);\r\n\t\tshadow\t\t = clamp( shadow + _TerrainShadowParams.w, 0.0, 1.0 );\r\n\r\n\t\tvec3 shadowCol = mix( shadow * _TerrainShadowColor, _TerrainDistanceShadowColor, pow(skyFog, _TerrainFogPower * _TerrainDistanceShadowPower) );\r\n\r\n\t\t// Strong rim lighting\r\n\t\tfloat rim\t= (1.0 - saturate(dot( nor , -rd ))); \r\n\t\trim\t\t\t= saturate(pow( rim, _TerrainRimPower)) *_TerrainRimStrength ; \r\n\t\tvec3 rimColor\t= rim * _TerrainRimColor;\r\n\r\n\t\t// Specular highlights\r\n\t\tvec3 ref\t\t= reflect(rd, nor);\r\n\t    vec3 halfDir\t= normalize(_LightDir + rd);\r\n\r\n\t    // The strong ocean specular highlight\r\n\t    float mainSpec = clamp( dot( ref, halfDir ), 0.0, 1.0 );\r\n\t    if ( TEST_MAT_LESS( m, MAT_TERRAIN ) )\r\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 2.0 ;\r\n\t    else\r\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 4.0;\r\n\r\n\t    float textureGlitter  = textureLod(iChannel1,pos.xz * _TerrainGlitterRep, 2.2).x * 1.15;\r\n\t    textureGlitter\t= pow(textureGlitter , _TerrainGlitterPower);\r\n\t    mainSpec \t\t*= textureGlitter;\r\n\r\n\t\t// The glitter around terrain, looks decent based on rim value\r\n\t    float rimSpec\t= (pow(rim, _TerrainRimSpecPower)) * textureGlitter;\r\n\t    vec3 specColor\t= (mainSpec + rimSpec) * _TerrainSpecColor;\r\n\t\tvec3 terrainCol\t= mix( (rimColor + specColor * shadow) + _TerrainCol, skyCol, pow(skyFog, _TerrainFogPower) ) + res.z * 0.2;  \r\n\r\n\t\t// maybe add a fake AO from player, just a sphere should do!\r\n\t\treturn mix( shadowCol, terrainCol, shadow );\r\n\t}\r\n\r\n\t// Clouds\r\n\tif( TEST_MAT_LESS (m, MAT_FRONT_CLOUDS ) )\r\n\t{\r\n\t\t// Modify the normals so that they create strong specular highlights\r\n\t\t// towards the top edge of clouds\r\n\t\tnor\t\t\t\t= normalize( nor + _CloudNormalMod);\r\n\t\tfloat dotProd\t= dot( nor, vec3(1.0,-3.5,1.0) );\r\n\r\n\t\tfloat spec\t\t=  1.0 -  clamp( pow(dotProd, _CloudSpecPower), 0.0, 1.0 );\r\n\t\tspec \t\t\t*= 2.0;\r\n\t\tvec3 cloudCol\t= spec * _CloudSpecCol + _CloudCol;\r\n\r\n\t\t// Transparency for mountain\r\n\t\tif( sdBigMountain( pos + (rd * t * _CloudPyramidDistance)) < 0.2 )\r\n\t \t{\r\n\t \t\tcloudCol = mix( pyramidCol, cloudCol, _CloudTransparencyMul ); \r\n\t\t}\r\n\r\n\t\t// Mixing for backdrop mountains. Backdrop mountains take more color from Sky. Foreground mountains\r\n\t\t// retain their own color values, so I can adjust their darkness\r\n\t\tvec3 inCloudCol = mix(cloudCol, _BackCloudCol + skyCol * 0.5 + spec * _BackCloudSpecCol, MAT_FRONT_CLOUDS - m);\r\n\t\treturn mix( inCloudCol , skyCol, skyFog * _CloudFogStrength );    \r\n\t}\r\n\r\n\t// Tombs\r\n\tif( TEST_MAT_LESS(m, MAT_TOMB_SCARF ) )\r\n\t{\r\n\t\t// Simple strong diffuse\r\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.0, 0.0, 1.0);\r\n\t\tvec3 col\t= mix( _TombMainColor, _TombScarfColor * 2.0, m - MAT_TOMB );\r\n\t\treturn mix( diff * col, skyCol, skyFog);\r\n\t}\r\n\r\n\t// Flying Helpers\r\n\tif( TEST_MAT_LESS(m, MAT_FLYING_HELPER_SCARF ) )\r\n\t{\r\n\t\tfloat fres\t= pow( clamp(1.0+dot(nor,rd) + 0.75,0.0,1.0), _FlyingHelperFrePower ) * _FlyingHelperFreScale;\r\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.5,0.0,1.0);\r\n\t\tvec3 col = _FlyingHelperYellowColor;\r\n\r\n\t\t// The main head\r\n\t\tif ( TEST_MAT_LESS( m, MAT_FLYING_HELPERS ) )\r\n\t\t{\r\n\t\t\tcol = _FlyingHelperMainColor;\r\n\r\n\t\t\t// Yellow borders\r\n\t\t\tfloat outerBorder = step( 0.95, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\r\n\t\t\tcol  = mix( col * diff, _FlyingHelperYellowColor,  outerBorder );\r\n\r\n\t\t\t// cubes in middle\r\n\t\t\tfloat rectsY = abs(helperScarfMatUVW.z * 2.0 - 1.0);\r\n\t\t\tfloat rectsX = abs(helperScarfMatUVW.x * 2.0 - 1.0);\r\n\r\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\r\n\t\t\tcircles = step( 0.5, circles );\r\n\r\n\t\t\t// Ideally want to do a separate bass for bloom. maybe one day\r\n\t\t\tfloat bloomCircle = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1); \r\n\t\t\tfloat bloom  = max( bloomCircle - 0.5, 0.0);\r\n\r\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\r\n\t\t\trectsX = 1.0 - step( 0.5, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\r\n\r\n\t\t\tfloat rects = min(rectsX, rectsY);\r\n\r\n\t\t\tfloat symbolsX = fract(rects/(helperScarfMatUVW.z * 20.0) * 20.0);\r\n\t\t\tfloat symbolsY = fract(rects/(helperScarfMatUVW.x * 2.0) * 2.0);\r\n\t\t\tfloat symbolsZ = fract(rects/((helperScarfMatUVW.z + 0.1) * 16.0) * 16.0);\r\n\t\t\tfloat symbolsW = fract(rects/((helperScarfMatUVW.x + 0.1) * 3.0) * 3.0);\r\n\r\n\t\t\tfloat symbols = symbolsY;\r\n\t\t\tsymbols = max( symbols, symbolsZ );\r\n\t\t\tsymbols = min(symbols , max(symbolsX, symbolsW));\r\n\t\t\tsymbols = step( 0.5, symbols ); \r\n\r\n\t\t\tsymbols = min( symbols, circles );\r\n\r\n\t\t\t//  float rects = min(rectsX, max(circles,rectsY));\r\n\r\n\t\t\tcol = mix( col, _FlyingHelperYellowColor, circles);\r\n\t\t\tcol = mix( col, _FlyingHelperWhiteColor * 2.0, symbols)  + bloom  * _FlyingHelperBloomScale;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// The scarfs, just have a yellow border\r\n\t\t\tfloat outerBorder = step( 0.9, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\r\n\t\t\tcol \t= mix( _FlyingHelperMainColor * diff, _FlyingHelperYellowColor,  outerBorder );\r\n\t\t}\r\n\t\treturn mix( fres * col, skyCol, skyFog * _FlyingHelperFogScale );\r\n\t}\r\n\r\n\t// Character\r\n\tif( TEST_MAT_GREATER (m, MAT_CHARACTER_BASE ) )\r\n\t{\r\n\t\tfloat diff = _CharacterDiffScale * clamp( dot( nor, _LightDir ), 0.0, 1.0 );\r\n\r\n\t\t// Why did I fudge these normals, I can't remember. It does look good though, so keep it :)\r\n\t\tnor\t\t= normalize( nor + vec3(0.3,-0.1,1.0));\r\n\t\tnor.y\t*= 0.3;\r\n\r\n\t\tfloat fres\t= pow( clamp( 1.0 + dot(nor,rd) + 0.75, 0.0, 1.0), _CharacterFrePower ) * _CharacterFreScale;\r\n\t\tvec3 col\t= _CharacterMainColor;\r\n\r\n\t\t// Just base color\r\n\t\tif( TEST_MAT_LESS( m, MAT_CHARACTER_BASE) )\r\n\t\t{\r\n\t\t\t// Add sand fade to legs. Mixing terrain color at bottom of legs\r\n\t\t\tfloat heightTerrainMix\t= pow((pos.y / _CharacterHeightTerrainMix.x), _CharacterHeightTerrainMix.y);\r\n\t\t\theightTerrainMix\t\t= clamp( heightTerrainMix, 0.0, 1.0 );\r\n\t\t\tcol\t= mix( _CharacterMainColor, _CharacterTerrainCol, heightTerrainMix );\r\n\t\t}\r\n\t\t// Main Cloak\r\n\t\telse if( TEST_MAT_LESS( m,MAT_CHARACTER_MAIN_CLOAK) )\r\n\t\t{\r\n\t\t\t// Cone kind of shapes\r\n\t\t\tfloat rectsX\t= fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 7.0) ;\r\n\t\t\trectsX\t\t\t= abs(rectsX * 2.0 - 1.0);\r\n\t\t\tfloat rects\t\t= rectsX;\r\n\t\t\trects\t\t\t= step( 0.5, rects * (1.0 - mainCloakMatUVW.y*3.5) );\r\n\t\t\tcol = mix( col, _CharacterCloakDarkColor, rects );\r\n\r\n\t\t\t// Yellow borders, two lines\r\n\t\t\tfloat outerBorder\t\t= step( 0.915, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\r\n\t\t\tfloat betweenBorders\t= step( 0.88, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\r\n\t\t\tfloat innerBorder\t\t= step( 0.87, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\r\n\r\n\t\t\tinnerBorder = min( innerBorder, 1.0 - betweenBorders );\r\n\r\n\t\t\tcol  = mix( col, _CharacterCloakDarkColor,  betweenBorders );\r\n\t\t\tcol  = mix( col, _CharacterYellowColor,  outerBorder );\r\n\t\t\tcol  = mix( col, _CharacterYellowColor,  innerBorder);\r\n\r\n\t\t\t// The verticle cubes/lines running across the bottom of cloak\r\n\t\t\tfloat cubes = abs(fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 10.0)  * 2.0 - 1.0);\r\n\t\t\tcubes\t\t= min(betweenBorders, step( 0.9, cubes) );\r\n\t\t\tcol\t\t\t= mix( col, _CharacterYellowColor,  cubes);\r\n\t\t}\r\n\t\t// headscarf\r\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_NECK_SCARF) )\r\n\t\t{\r\n\t\t\tcol = mix( col, _CharacterYellowColor, step( 0.7, headScarfMatUVW.y) );\r\n\t\t}\r\n\t\t// Long Scarf\r\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_LONG_SCARF) )\r\n\t\t{\r\n\t\t\tcol = _CharacterYellowColor;\r\n\r\n\t\t\t// Yellow borders, two lines\r\n\t\t\tfloat outerBorder = step( 0.9, abs(longScarfMatUVW.x * 2.0 - 1.0) );\r\n\t\t\tfloat innerBorder = step( 0.7, abs(longScarfMatUVW.x * 2.0 - 1.0) );\r\n\r\n\t\t\tinnerBorder = min( innerBorder, 1.0 - step( 0.8, abs(longScarfMatUVW.x * 2.0 - 1.0) ) );\r\n\r\n\t\t\t// Mix borders\r\n\t\t\tcol  = mix( col, _CharacterMainColor,  outerBorder );\r\n\t\t\tcol  = mix( col, _CharacterMainColor,  innerBorder);\r\n\r\n\t\t\t// cubes in middle\r\n\t\t\tfloat rectsY = abs(fract( longScarfMatUVW.y/ 0.10 ) * 2.0 - 1.0);// - 0.5 * 0.10;\r\n\t\t\tfloat rectsX = abs(longScarfMatUVW.x * 2.0 - 1.0);\r\n\r\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\r\n\t\t\tcircles = step( 0.5, circles );\r\n\r\n\t\t\tfloat bloomCircle\t= 1.0 - (length( vec2(rectsY, rectsX * 0.7) ) - 0.1); \r\n\t\t\tfloat bloom \t\t= max( bloomCircle - 0.45, 0.0);\r\n\r\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\r\n\t\t\trectsX = 1.0 - step( 0.5, abs(longScarfMatUVW.x * 2.0 - 1.0) );\r\n\r\n\t\t\tfloat rects = min(rectsX, rectsY);\r\n\r\n\t\t\t// There are better ways of doing symbols. Spend some time on it, buddy!\r\n\t\t\tfloat symbolsX = fract(rects/(longScarfMatUVW.y * 0.17) * 10.0);\r\n\t\t\tfloat symbolsY = fract(rects/(longScarfMatUVW.x * 18.5) * 10.0);\r\n\r\n\t\t\tfloat symbols\t= symbolsX;\r\n\t\t\tsymbols\t\t\t= max( symbols, symbolsY );\r\n\t\t\tsymbols\t\t\t= step( 0.5, symbols ); \r\n\r\n\t\t\tsymbols = min( symbols, circles );\r\n\r\n\t\t\t//        float rects = min(rectsX, max(circles,rectsY));\r\n\t\t\tcol = mix( col, _CharacterMainColor, circles);\r\n\t\t\tcol = mix( col, _CharacterWhiteColor * 2.0, symbols)  + bloom * _CharacterBloomScale;\r\n\r\n\t\t\t// White glow and disintegrating the scarf, showing depleting scarf energy. Needs bloom effect :(\r\n\t\t\tcol = mix( col, _CharacterMainColor, 1.0 - smoothstep(0.4, 0.6, longScarfMatUVW.y));\r\n\t\t\tvec3 whiteMiddle = mix( col, _CharacterWhiteColor + bloom * _CharacterBloomScale, step(0.48, longScarfMatUVW.y));\r\n\t\t\tcol = mix( whiteMiddle, col, step(0.5, longScarfMatUVW.y));\r\n\t\t}\r\n\t\t// Face\r\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_FACE)  )\r\n\t\t{\r\n\t\t\tcol = vec3(0,0,0);\r\n\t\t}\r\n\t\tfloat ao = AmbientOcclusion(pos - (rd * 0.01), nor, _CharacterAOParams.x, _CharacterAOParams.y); \r\n\t\treturn ao * mix( (fres + diff) * col, skyCol, skyFog * _CharacterFogScale );\r\n\t}\r\n\treturn vec3( clamp(col * 0.0,0.0,1.0) );\r\n}\r\n\r\n\r\nfloat rand(float n)\r\n{\r\n\treturn fract(sin(n) * 43758.5453123);\r\n}\r\n\r\nfloat noise(float p)\r\n{\r\n\tfloat fl = floor(p);\r\n\tfloat fc = fract(p);\r\n    fc = fc*fc*(3.0-2.0*fc);\r\n    return mix(rand(fl), rand(fl + 1.0), fc);\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// Move camera using noise. This is probably quite expensive way of doing it :(\r\n\tfloat unitNoiseX = (noise(iTime * _CameraMovement.w ) * 2.0)  - 1.0;\r\n\tfloat unitNoiseY = (noise((iTime * _CameraMovement.w ) + 32.0) * 2.0)  -1.0;\r\n\tfloat unitNoiseZ = (noise((iTime * _CameraMovement.w ) + 48.0) * 2.0)  -1.0;\r\n\tvec3 ro = _CameraPos + vec3(unitNoiseX, unitNoiseY, unitNoiseZ) * _CameraMovement.xyz;\r\n\r\n\r\n\tvec3 screenRay\t\t= vec3(fragCoord / iResolution.xy, 1.0);\r\n\tvec2 screenCoord\t= screenRay.xy * 2.0 - 1.0;\r\n\r\n\t// Screen ray frustum aligned\r\n\tscreenRay.xy = screenCoord * _CameraFOV.xy;\r\n    screenRay.x\t\t\t*= 1.35;\r\n\tscreenRay.z  = -_CameraFOV.z;\r\n\tscreenRay /= abs( _CameraFOV.z); \r\n\r\n    // In camera space\r\n\tvec3 rd = normalize(mul( _CameraInvViewMatrix, vec4(screenRay,0.0))).xyz;\r\n\r\n\t// Do the render\r\n\tvec4 col = vec4(render(ro, rd), 0.0);\r\n\r\n\t// No it does not need gamma correct or tone mapping or any other effect that you heard about\r\n\t// and thought was cool. This is not realistic lighting\r\n\r\n\t// vignette\r\n\tfloat vig = pow(1.0 - 0.4 * dot(screenCoord, screenCoord), 0.6) * 1.25;\r\n\tvig = min( vig, 1.0);\r\n\tcol *= vig;\r\n\r\n\t// Final color\r\n\tfragColor =  col;\r\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\none.png","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"/*\r\n\tBefore you continue reading, feast your eyes on these beautiful Color Schemes (0,1,2)\r\n*/\r\n\r\n// Modify the number to 0,1,2 or 3 and press play button at bottom for different schemes.\r\n#define COLOR_SCHEME 1\r\n\r\n/*\r\n\tThis shader is just a tribute to \"Journey\" game by That Game Company. Some answers:\r\n\t1) No, I do not have any affiliation with That Game Company.\r\n\t2) Yes, Journey is one of the best games ever made\r\n\t3) It has taken me around 3-4 months from start to finish, evenings and weekends\r\n\t4) Most of the time was spent getting the details right\r\n\t5) Yes, the character needs more work. One day I will finish it\r\n\t6) Yes, if anybody comes up with something cool to add, I would love to improve :)\r\n\t7) There is nothing mathemagically amazing in this shader. I hope you do find it pretty though!\r\n\t8) Yes, the code is fairly ugly. But look at the colors - PRETTY!\r\n\t9) If you have any other questions, I will be happy to answer\r\n\r\n\tThis shader started as a learning playground, but around January, I finished my second round of Journey\r\n\tand thought, well why the hell not, and so here we are.\r\n\r\n\tSpecial thanks to Thibault Girard and Jack Hamilton for their artistic input. Also bigs up to Peter Pimley\r\n\tfor his constant optimism.\r\n\r\n\tYou are hereby granted your wish to follow me on twitter: @shakemayster\r\n\r\n\tOther authors (With BIG thanks !!!) \r\n\tDave_Hoskins\r\n\tDila\r\n\tMaurogik\r\n\tFabriceNeyret2\r\n*/\r\n\r\n#define RGB vec3\r\n#define mul(a,b) b*a\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n\r\n\r\n#if COLOR_SCHEME == 0\r\nconst float _FogMul = -0.00100 ;\r\nconst float _FogPow = 1.82000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.22632, 0.88099, -0.4155) ;\r\nconst float _Brightness = 1.00000 ;\r\nconst float _Contrast = 1.00000 ;\r\nconst float _Saturation = 1.00000 ;\r\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\r\nconst float _SunSize = 26.00000 ;\r\nconst float _SunScale = 15.00000 ;\r\nconst float _ExposureOffset = 11.10000 ;\r\nconst float _ExposurePower = 0.52000 ;\r\nconst float _ExposureStrength = 0.09000 ;\r\nconst RGB _SunColor = RGB(1, 0.73741, 0.63971) ;\r\nconst RGB _Zenith = RGB(0.67128, 0.94118, 0.69204) ;\r\nconst float _ZenithFallOff = 1.42000 ;\r\nconst RGB _Nadir = RGB(0, 0, 0) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.80147, 0.80147, 0.80147) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.57353, 0.1488, 0.067474) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.375, 0.21885, 0.15993) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.38971, 0.10735, 0.054444) ;\r\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.35588, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\r\nconst float _CharacterBloomScale = 0.87000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 3.84000 ;\r\nconst float _CharacterFogScale = 20.00000 ;\r\nconst float _CloudTransparencyMul = 0.90000 ;\r\nconst RGB _CloudCol = RGB(1, 0.96957, 0.88235) ;\r\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\r\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.47735, 0.59559, 0.49705) ;\r\nconst RGB _TombScarfColor = RGB(0.45588, 0.093858, 0.093858) ;\r\nconst RGB _PyramidCol = RGB(0.30147, 0.28329, 0.21059) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.05) ;\r\nconst RGB _TerrainCol = RGB(0.76863, 0.55294, 0.47059) ;\r\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 1.56000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 1.94000 ;\r\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 2.00000 ;\r\nconst float _TerrainRimSpecPower = 1.46000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.40441, 0.34106, 0.31818) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.81471, 0.74265) ;\r\nconst float _TerrainDistanceShadowPower = 0.11000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.80882, 0.11671, 0.017842) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.56187, 0.0073529) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 1.91000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 4.00000 ;\r\n#endif\r\n\r\n#if COLOR_SCHEME == 1\r\nconst float _FogMul = -0.00800 ;\r\nconst float _FogPow = 1.00000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\r\nconst float _Brightness = 0.40000 ;\r\nconst float _Contrast = 0.83000 ;\r\nconst float _Saturation = 1.21000 ;\r\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\r\nconst float _SunSize = 26.00000 ;\r\nconst float _SunScale = 15.00000 ;\r\nconst float _ExposureOffset = 11.10000 ;\r\nconst float _ExposurePower = 0.52000 ;\r\nconst float _ExposureStrength = 0.09000 ;\r\nconst RGB _SunColor = RGB(1, 0.95441, 0.77206) ;\r\nconst RGB _Zenith = RGB(0.77941, 0.5898, 0.41263) ;\r\nconst float _ZenithFallOff = 2.36000 ;\r\nconst RGB _Nadir = RGB(1, 0.93103, 0) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.96324, 0.80163, 0.38954) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.35294, 0.16016, 0.12197) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.25735, 0.028557, 0.0056769) ;\r\nconst RGB _CharacterYellowColor = RGB(0.88971, 0.34975, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(0.9928, 1, 0.47794) ;\r\nconst float _CharacterBloomScale = 0.70000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 3.84000 ;\r\nconst float _CharacterFogScale = 4.55000 ;\r\nconst float _CloudTransparencyMul = 0.90000 ;\r\nconst RGB _CloudCol = RGB(1, 0.84926, 0.69853) ;\r\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\r\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.64706, 0.38039, 0.27451) ;\r\nconst RGB _TombScarfColor = RGB(0.38971, 0.10029, 0.10029) ;\r\nconst RGB _PyramidCol = RGB(0.69853, 0.40389, 0.22086) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.3) ;\r\nconst RGB _TerrainCol = RGB(0.56618, 0.29249, 0.1915) ;\r\nconst RGB _TerrainSpecColor = RGB(1, 0.77637, 0.53676) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 1.56000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 3.20000 ;\r\nconst RGB _TerrainRimColor = RGB(0.16176, 0.13131, 0.098724) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 1.61000 ;\r\nconst float _TerrainRimSpecPower = 2.88000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.48529, 0.13282, 0) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(0.70588, 0.4644, 0.36851) ;\r\nconst float _TerrainDistanceShadowPower = 0.11000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.85294, 0.11759, 0.012543) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.3931, 0) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 2.61000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 1.75000 ;\r\n#endif\r\n\r\n#if COLOR_SCHEME == 2\r\nconst float _FogMul = -0.00100 ;\r\nconst float _FogPow = 1.68000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\r\nconst float _Brightness = 0.40000 ;\r\nconst float _Contrast = 0.82000 ;\r\nconst float _Saturation = 1.21000 ;\r\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\r\nconst float _SunSize = 26.00000 ;\r\nconst float _SunScale = 15.00000 ;\r\nconst float _ExposureOffset = 11.10000 ;\r\nconst float _ExposurePower = 0.52000 ;\r\nconst float _ExposureStrength = 0.09000 ;\r\nconst RGB _SunColor = RGB(0.97059, 0.97059, 0.97059) ;\r\nconst RGB _Zenith = RGB(0.98039, 0.83137, 0.53725) ;\r\nconst float _ZenithFallOff = 2.36000 ;\r\nconst RGB _Nadir = RGB(0, 0, 0) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.84559, 0.77688, 0.6031) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.5, 0.3404, 0.12868) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.31618, 0.14042, 0.039522) ;\r\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.30233, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\r\nconst float _CharacterBloomScale = 0.87000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 3.84000 ;\r\nconst float _CharacterFogScale = 12.47000 ;\r\nconst float _CloudTransparencyMul = 0.80000 ;\r\nconst RGB _CloudCol = RGB(0.99216, 0.9451, 0.76471) ;\r\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\r\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.94118, 0.82759, 0.45675) ;\r\nconst RGB _TombScarfColor = RGB(0.44118, 0.19989, 0.14922) ;\r\nconst RGB _PyramidCol = RGB(0.92647, 0.73579, 0.3338) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 4.65) ;\r\nconst RGB _TerrainCol = RGB(0.71324, 0.5076, 0.236) ;\r\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 0.03000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 3.20000 ;\r\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 1.61000 ;\r\nconst float _TerrainRimSpecPower = 0.38000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.66912, 0.52969, 0.369) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.75466, 0.43382) ;\r\nconst float _TerrainDistanceShadowPower = 0.11000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.91912, 0.30412, 0.21626) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(0.98529, 0.60477, 0.12316) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 1.91000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 4.00000 ;\r\n#endif\r\n\r\n#if COLOR_SCHEME == 3\r\nconst float _FogMul = -0.00100 ;\r\nconst float _FogPow = 1.82000 ;\r\nconst float _IncorrectGammaCorrect = 1.00000 ;\r\nconst vec3 _LightDir = vec3(-0.29644, 0.6859, -0.66458) ;\r\nconst float _Brightness = 1.00000 ;\r\nconst float _Contrast = 1.00000 ;\r\nconst float _Saturation = 1.00000 ;\r\nconst vec3 _SunStar = vec3(20.45, 1.49, 0.5) ;\r\nconst float _SunSize = 26.09000 ;\r\nconst float _SunScale = 15.04000 ;\r\nconst float _ExposureOffset = 13.72000 ;\r\nconst float _ExposurePower = 0.60000 ;\r\nconst float _ExposureStrength = 0.02000 ;\r\nconst RGB _SunColor = RGB(0.51471, 0.79919, 1) ;\r\nconst RGB _Zenith = RGB(0, 0.053922, 0.16176) ;\r\nconst float _ZenithFallOff = 1.42000 ;\r\nconst RGB _Nadir = RGB(0.21569, 0.2549, 0.36078) ;\r\nconst float _NadirFallOff = 1.91000 ;\r\nconst RGB _Horizon = RGB(0.35191, 0.30223, 0.47794) ;\r\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\r\nconst RGB _CharacterMainColor = RGB(0.36765, 0.097656, 0.045956) ;\r\nconst RGB _CharacterTerrainCol = RGB(0.083261, 0.11379, 0.16176) ;\r\nconst RGB _CharacterCloakDarkColor = RGB(0.073529, 0.011604, 0) ;\r\nconst RGB _CharacterYellowColor = RGB(0.60294, 0.33162, 0) ;\r\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\r\nconst float _CharacterBloomScale = 0.87000 ;\r\nconst float _CharacterDiffScale = 1.50000 ;\r\nconst float _CharacterFreScale = 1.77000 ;\r\nconst float _CharacterFrePower = 19.83000 ;\r\nconst float _CharacterFogScale = 60.00000 ;\r\nconst float _CloudTransparencyMul = 0.90000 ;\r\nconst RGB _CloudCol = RGB(0.0069204, 0.15969, 0.23529) ;\r\nconst RGB _BackCloudCol = RGB(0, 0.10969, 0.15441) ;\r\nconst RGB _CloudSpecCol = RGB(0.11765, 0.11765, 0.11765) ;\r\nconst RGB _BackCloudSpecCol = RGB(0.080882, 0.080882, 0.080882) ;\r\nconst float _CloudFogStrength = 0.50000 ;\r\nconst RGB _TombMainColor = RGB(0.23789, 0.27707, 0.40441) ;\r\nconst RGB _TombScarfColor = RGB(0.066176, 0, 0.034229) ;\r\nconst RGB _PyramidCol = RGB(0, 0, 0) ;\r\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.92) ;\r\nconst RGB _TerrainCol = RGB(0, 0.058832, 0.10294) ;\r\nconst RGB _TerrainSpecColor = RGB(0.24622, 0.29188, 0.33824) ;\r\nconst float _TerrainSpecPower = 55.35000 ;\r\nconst float _TerrainSpecStrength = 1.56000 ;\r\nconst float _TerrainGlitterRep = 7.00000 ;\r\nconst float _TerrainGlitterPower = 1.94000 ;\r\nconst RGB _TerrainRimColor = RGB(0.091021, 0.057093, 0.16176) ;\r\nconst float _TerrainRimPower = 5.59000 ;\r\nconst float _TerrainRimStrength = 2.00000 ;\r\nconst float _TerrainRimSpecPower = 1.46000 ;\r\nconst float _TerrainFogPower = 2.11000 ;\r\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.37) ;\r\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\r\nconst RGB _TerrainShadowColor = RGB(0.11029, 0.11029, 0.11029) ;\r\nconst RGB _TerrainDistanceShadowColor = RGB(0.0034061, 0.073181, 0.15441) ;\r\nconst float _TerrainDistanceShadowPower = 0.06000 ;\r\nconst RGB _FlyingHelperMainColor = RGB(0.12661, 0.004109, 0.13971) ;\r\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\r\nconst RGB _FlyingHelperYellowColor = RGB(0.48529, 0.2711, 0) ;\r\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\r\nconst float _FlyingHelperBloomScale = 1.91000 ;\r\nconst float _FlyingHelperFrePower = 1.00000 ;\r\nconst float _FlyingHelperFreScale = 0.85000 ;\r\nconst float _FlyingHelperFogScale = 5.51000 ;\r\n#endif\r\n\r\n//==========================================================================================\r\n// Play with these at your own risk. Expect, unexpected results!\r\n//==========================================================================================\r\n\r\nconst mat4 _CameraInvViewMatrix = mat4( 1, 0, 0, 1.04, \r\n0, 0.9684963, 0.2490279, 2.2, \r\n0, 0.2490279, -0.9684963, 18.6, \r\n0, 0, 0, 1 ) ;\r\nconst vec3 _CameraFOV = vec3(1.038, 0.78984, -1) ;\r\nconst vec3 _CameraPos = vec3(1.0, 2.2, 18.6) ;\r\nconst vec4 _CameraMovement = vec4(0.15, 0.1, 0.2, 0.25) ;\r\n\r\nconst vec3 _WindDirection = vec3(-0.27, -0.12, 0) ;\r\n\r\nconst float _DrawDistance = 70.00000 ;\r\nconst float _MaxSteps = 64.00000 ;\r\n\r\nconst vec3 _SunPosition = vec3(0.2, 56, -40.1) ;\r\nconst float _CharacterRotation = 0.17000 ;\r\nconst vec3 _CharacterPosition = vec3(0.52, 2.35, 17.6) ;\r\nconst vec3 _CharacterScale = vec3(0.4, 0.53, 0.38) ;\r\nconst float _MainClothRotation = 0.30000 ;\r\nconst vec3 _MainClothScale = vec3(0.3, 0.68, 0.31) ;\r\nconst vec3 _MainClothPosition = vec3(0, -0.12, 0) ;\r\nconst vec3 _MainClothBotCutPos = vec3(0, -0.52, 0) ;\r\nconst vec3 _MainClothDetail = vec3(6, 0.04, 1.3) ;\r\nconst float _HeadScarfRotation = -0.19000 ;\r\nconst vec3 _HeadScarfPosition = vec3(-0.005, -0.16, -0.01) ;\r\nconst vec3 _HeadScarfScale = vec3(0.18, 0.2, 0.03) ;\r\nconst float _HeadRotationX = -0.30000 ;\r\nconst float _HeadRotationY = 0.29000 ;\r\nconst float _HeadRotationZ = 0.00000 ;\r\nconst vec3 _HeadPos = vec3(0, -0.04, 0.01) ;\r\nconst vec3 _LongScarfPos = vec3(0.01, -0.15, 0.09) ;\r\nconst vec3 _LongScarfScale = vec3(0.05, 1.25, 0.001) ;\r\nconst vec4 _LongScarfWindStrength = vec4(0.3, 4.52, 5.2, 0.02) ;\r\nconst float _LongScarfRotX = 1.43000 ;\r\nconst float _LongScarfMaxRad = 1.99000 ;\r\nconst vec3 _FacePosition = vec3(0, -0.01, 0.05) ;\r\nconst vec3 _FaceSize = vec3(0.038, 0.05, 0.03) ;\r\nconst vec3 _UpperLeftLegA = vec3(-0.02, -0.37, 0.01) ;\r\nconst vec3 _UpperLeftLegB = vec3(-0.02, -0.67, -0.059999) ;\r\nconst vec3 _UpperLeftLegParams = vec3(0.026, 1, 1) ;\r\nconst vec3 _LowerLeftLegA = vec3(-0.02, -0.67, -0.059999) ;\r\nconst vec3 _LowerLeftLegB = vec3(-0.02, -0.77, 0.12) ;\r\nconst vec3 _LowerLeftLegParams = vec3(0.028, 0.03, 0.01) ;\r\nconst vec3 _UpperRightLegA = vec3(0.07, -0.5, 0.02) ;\r\nconst vec3 _UpperRightLegB = vec3(0.07, -0.61, 0.09) ;\r\nconst vec3 _UpperRightLegParams = vec3(0.026, 1, 1) ;\r\nconst vec3 _LowerRightLegA = vec3(0.07, -0.61, 0.09) ;\r\nconst vec3 _LowerRightLegB = vec3(0.07, -0.91, 0.22) ;\r\nconst vec3 _LowerRightLegParams = vec3(0.028, 0.03, 0.01) ;\r\nconst vec3 _BodyPos = vec3(0, -0.45, -0.03) ;\r\nconst vec3 _CharacterTrailOffset = vec3(0.72, 0.01, 0.06) ;\r\nconst vec3 _CharacterTrailScale = vec3(0.001, 0, 0.5) ;\r\nconst vec3 _CharacterTrailWave = vec3(1.97, 0, 0.34) ;\r\nconst vec2 _CharacterHeightTerrainMix = vec2(1.95, -30) ;\r\nconst vec3 _CloudNoiseStrength = vec3(0.2, 0.16, 0.1) ;\r\nconst vec3 _FrontCloudsPos = vec3(9.91, 8.6, -12.88) ;\r\nconst vec3 _FrontCloudsOffsetA = vec3(-9.1, 3.04, 0) ;\r\nconst vec3 _FrontCloudsOffsetB = vec3(-2.97, 3.72, -0.05) ;\r\nconst vec3 _FrontCloudParams = vec3(5.02, 3.79, 5) ;\r\nconst vec3 _FrontCloudParamsA = vec3(3.04, 0.16, 2) ;\r\nconst vec3 _FrontCloudParamsB = vec3(1.34, 0.3, 3.15) ;\r\nconst vec3 _BackCloudsPos = vec3(29.99, 13.61, -18.8) ;\r\nconst vec3 _BackCloudsOffsetA = vec3(24.87, -1.49, 0) ;\r\nconst vec3 _BackCloudParams = vec3(7.12, 4.26, 1.68) ;\r\nconst vec3 _BackCloudParamsA = vec3(6.37, 2.23, 2.07) ;\r\nconst vec3 _PlaneParams = vec3(7.64, 10.85, 3.76) ;\r\nconst vec3 _CloudGlobalParams = vec3(0.123, 2.1, 0.5) ;\r\nconst vec3 _CloudBackGlobalParams = vec3(0.16, 1.4, -0.01) ;\r\nconst vec3 _CloudNormalMod = vec3(0.26, -0.13, 1.22) ;\r\nconst float _CloudSpecPower = 24.04000 ;\r\nconst float _CloudPyramidDistance = 0.14500 ;\r\nconst vec3 _TombPosition = vec3(5, 5, 9.28) ;\r\nconst vec3 _TombScale = vec3(0.07, 0.5, 0.006) ;\r\nconst vec3 _TombBevelParams = vec3(0.44, 0.66, 0.01) ;\r\nconst float _TombRepScale = 0.79000 ;\r\nconst vec3 _TombCutOutScale = vec3(0.39, 0.06, -14.92) ;\r\nconst vec3 _TombScarfOffset = vec3(0, 0.46, 0) ;\r\nconst vec3 _TombScarfWindParams = vec3(-1.61, 6, 0.05) ;\r\nconst vec3 _TombScarfScale = vec3(0.03, 0.002, 0.5) ;\r\nconst float _TombScarfRot = -0.88000 ;\r\nconst mat4 _TombScarfMat = mat4( 0.9362437, 0, -0.3513514, 0, \r\n0, 1, 0, 0, \r\n0.3513514, 0, 0.9362437, 0, \r\n0, 0, 0, 1 ) ;\r\nconst vec3 _PyramidPos = vec3(0, 10.9, -50) ;\r\nconst vec3 _PyramidScale = vec3(34.1, 24.9, 18) ;\r\nconst vec3 _PrismScale = vec3(1, 1.9, 1) ;\r\nconst vec3 _PyramidNoisePrams = vec3(1.5, 1, 1) ;\r\nconst vec3 _PrismEyeScale = vec3(0.7, 1.9, 51.5) ;\r\nconst vec3 _PyramidEyeOffset = vec3(2.0, -4.9, 0) ;\r\nconst float _PrismEyeWidth = 5.86000 ;\r\nconst float _TerrainMaxDistance = 30.04000 ;\r\nconst float _SmallDetailStrength = 0.00600 ;\r\nconst vec3 _SmallWaveDetail = vec3(3.19, 16, 6.05) ;\r\nconst vec2 _WindSpeed = vec2(2, 0.6) ;\r\nconst float _MediumDetailStrength = 0.05000 ;\r\nconst vec2 _MediumWaveDetail = vec2(2, 50) ;\r\nconst vec3 _MediumWaveOffset = vec3(0.3, -2, 0.1) ;\r\nconst vec2 _LargeWaveDetail = vec2(0.25, 0.73) ;\r\nconst vec3 _LargeWavePowStre = vec3(0.6, 2.96, -2.08) ;\r\nconst vec3 _LargeWaveOffset = vec3(-3.65, 4.41, -11.64) ;\r\nconst vec3 _FlyingHelperPos = vec3(2.15, 4.68, 14.4) ;\r\nconst vec3 _FlyingHelperScale = vec3(0.25, 0.001, 0.3) ;\r\nconst vec3 _FlyingHelperMovement = vec3(0.44, 1.44, -2.98) ;\r\nconst vec3 _FlyingHelperScarfScale = vec3(0.1, 0.001, 1.5) ;\r\nconst vec3 _FlyingHelperScarfWindParams = vec3(-0.06, 0.31, 0.47) ;\r\nconst vec3 _FlyingHelperScarfWindDetailParams = vec3(3.93, 0.005, -45.32) ;\r\nconst vec3 _FlyingHelperSideScarfOffset = vec3(0.16, -0.01, 0) ;\r\nconst vec3 _FlyingHelperSideScarfScale = vec3(0.06, 0.001, 0.8) ;\r\nconst vec4 _FlyingScarfSideWindParams = vec4(2.46, -1.59, -0.05, 0.21) ;\r\n\r\n// Material ID definitions\r\n#define MAT_PYRAMID 1.0\r\n\r\n#define MAT_TERRAIN 10.0\r\n#define MAT_TERRAIN_TRAIL 11.0\r\n\r\n#define MAT_BACK_CLOUDS 20.0\r\n#define MAT_FRONT_CLOUDS 21.0\r\n\r\n#define MAT_TOMB 30.0\r\n#define MAT_TOMB_SCARF 31.0\r\n\r\n#define MAT_FLYING_HELPERS 40.0\r\n#define MAT_FLYING_HELPER_SCARF 41.0\r\n\r\n#define MAT_CHARACTER_BASE 50.0\r\n#define MAT_CHARACTER_MAIN_CLOAK 51.0\r\n#define MAT_CHARACTER_NECK_SCARF 52.0\r\n#define MAT_CHARACTER_LONG_SCARF 53.0\r\n#define MAT_CHARACTER_FACE 54.0\r\n\r\n#define TEST_MAT_LESS( a, b ) a < (b + 0.1)\r\n#define TEST_MAT_GREATER( a, b ) a > (b - 0.1)\r\n\r\n//==========================================================================================\r\n// Primitive functions by IQ\r\n//==========================================================================================\r\nfloat sdRoundBox(vec3 p, vec3 b, float r)\r\n{\r\n\treturn length( max( abs(p) - b, 0.0) ) - r;\r\n}\r\n\r\nfloat sdSphere(vec3 p, float s)\r\n{\r\n\treturn length(p) - s;\r\n}\r\n\r\nfloat sdPlane( vec3 p )\r\n{\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b)\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) +\r\n\t\tlength(max(d, 0.0));\r\n}\r\n\r\nfloat sdCylinder(vec3 p, vec2 h)\r\n{\r\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\r\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nfloat sdPlane(vec3 p, vec4 n)\r\n{\r\n\t// n must be normalized\r\n\treturn dot(p, n.xyz) + n.w;\r\n}\r\n\r\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\r\n{\r\n\tvec3 pa = p - a, ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn vec2( length( pa - ba*h ), h );\r\n}\r\n\r\nfloat sdEllipsoid(in vec3 p, in vec3 r)\r\n{\r\n\treturn (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\r\n}\r\n\r\nfloat sdTriPrism( vec3 p, vec2 h )\r\n{\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\n\r\n//==========================================================================================\r\n// distance field operations\r\n//==========================================================================================\r\nvec2 min_mat( vec2 d1, vec2 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\r\n    return mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\nvec2 smin_mat( vec2 a, vec2 b, float k, float c )\r\n{\r\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\r\n    float x = mix( b.x, a.x, h ) - k*h*(1.0-h);\r\n    return vec2( x, ( h < c ) ? b.y : a.y);\r\n}\r\n\r\nfloat smax( float a, float b, float k )\r\n{\r\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\r\n\treturn mix( a, b, h ) + k*h*(1.0-h);\r\n}\r\n\r\n//==========================================================================================\r\n// Rotations\r\n//==========================================================================================\r\nvoid rX(inout vec3 p, float a) {\r\n    vec3 q = p;\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    p.y = c * q.y - s * q.z;\r\n    p.z = s * q.y + c * q.z;\r\n}\r\n\r\nvoid rY(inout vec3 p, float a) {\r\n    vec3 q = p;\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    p.x = c * q.x + s * q.z;\r\n    p.z = -s * q.x + c * q.z;\r\n}\r\n\r\nvoid rZ(inout vec3 p, float a) {\r\n    vec3 q = p;\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    p.x = c * q.x + s * q.y;\r\n    p.y = -s * q.x + c * q.y;\r\n}\r\n\r\n//==========================================================================================\r\n// Value noise and its derivatives: https://www.shadertoy.com/view/MdX3Rr\r\n//==========================================================================================\r\nvec3 noised( in vec2 x )\r\n{\r\n    vec2 f = fract(x);\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\r\n#if 0\r\n    // texel fetch version\r\n    ivec2 p = ivec2(floor(x));\r\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\r\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\r\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\r\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\r\n#else    \r\n    // texture version    \r\n    vec2 p = floor(x);\r\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n#endif\r\n    \r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\r\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\n\r\n//==========================================================================================\r\n// Noise function: https://www.shadertoy.com/view/4sfGRH \r\n//==========================================================================================\r\nfloat pn(vec3 p) {\r\n    vec3 i = floor(p); \r\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\r\n    vec3 f = cos((p-i)*3.141592653589793)*(-.5) + .5;  \r\n\ta = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\r\n    a.xy = mix(a.xz, a.yw, f.y);   \r\n\treturn mix(a.x, a.y, f.z);\r\n}\r\n\r\n//==========================================================================================\r\n// Sin Wave approximation http://http.developer.nvidia.com/GPUGems3/gpugems3_ch16.html\r\n//==========================================================================================\r\nvec4  SmoothCurve( vec4 x ) {  \r\n  return x * x * ( 3.0 - 2.0 * x );  \r\n}\r\n\r\nvec4 TriangleWave( vec4 x ) {  \r\n  return abs( fract( x + 0.5 ) * 2.0 - 1.0 );  \r\n}\r\n\r\nvec4 SmoothTriangleWave( vec4 x ) {  \r\n  return SmoothCurve( TriangleWave( x ) );  \r\n}  \r\n\r\nfloat SmoothTriangleWave( float x )\r\n{\r\n  return SmoothCurve( TriangleWave( vec4(x,x,x,x) ) ).x;  \r\n}  \r\n\r\nvoid Bend(inout vec3 vPos, vec2 vWind, float fBendScale)\r\n{\r\n\tfloat fLength = length(vPos);\r\n\tfloat fBF = vPos.y * fBendScale;  \r\n\tfBF += 1.0;  \r\n\tfBF *= fBF;  \r\n\tfBF = fBF * fBF - fBF;  \r\n\tvec3 vNewPos = vPos;  \r\n\tvNewPos.xz += vWind.xy * fBF;  \r\n\tvPos.xyz = normalize(vNewPos.xyz)* fLength;  \r\n}\r\n\r\n//==========================================================================================\r\n// Modified cone versions for scarf and main cloak\r\n//==========================================================================================\r\nfloat sdScarfCone( in vec3 p, in float h, in float r1, in float r2 )\r\n{\r\n    float d1 = -p.y - h;\r\n    float q = (p.y - h);\r\n    float si = 0.5*(r1-r2)/h;\r\n    p.z = mix(p.z, p.z * 0.2, q);\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\n\r\nvec2 sdCloakCone( in vec3 p, in float h, in float r1, in float r2 )\r\n{\r\n    float d1 = -p.y - h;\r\n    float q = (p.y - h);\r\n    r2 = (q * r2) + 0.08;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return vec2(length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.), q);\r\n}\r\n\r\n//==========================================================================================\r\n// Character\r\n//==========================================================================================\r\nvec3 headScarfMatUVW;\r\nfloat sdHeadScarf(vec3 pos)\r\n{\r\n\t\r\n    vec3 headScarfPos = pos - _HeadScarfPosition;\r\n    rX( headScarfPos, _HeadScarfRotation );\r\n\r\n    float distanceToTop =  min(0.0,(pos.y + 0.01));\r\n\r\n    // Put a slight twist in the middle. Gives the feel that the head scarf\r\n    // is sitting on shoulders. Very subtle, but I can see it :D\r\n    float midBend = abs( fract( distanceToTop + 0.5 ) * 2.0 - 1.0 );\r\n    headScarfPos.x += (cos( 2.0 + headScarfPos.y * 50.0 ) * 0.05 * midBend);\r\n    headScarfPos.z += (sin( 2.0 + headScarfPos.y * 50.0 ) * 0.03 * midBend);\r\n\r\n    // Apply wind to head Scarf    \r\n    headScarfPos += SmoothTriangleWave(vec4(pos.xyz * 5.0+ iTime,1.0) ).xyz * 0.05 * distanceToTop;\r\n\r\n    // Scarf shape    \r\n    float headScarf = sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z );\r\n    headScarf = max(headScarf, -sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z - 0.011));\r\n    \r\n    // Cut out the bottom of the head scarf. I have no idea what I was thinking, when I wrote this\r\n    vec3 cutOutPos = headScarfPos - vec3( 0.0, 0.08, 0.0);\r\n    vec3 r = vec3(0.12, 0.8, 0.2);\r\n    float smallestSize = min(min(r.x,r.y),r.z);\r\n\tvec3 dp = cutOutPos/r;\r\n    float h = min(1.0, abs(1.0 - abs(dp.y)) );\r\n\r\n    // Apply some crazy power until it looks like a scarf sitting on shoulders\r\n    h =  pow(h, 5.5);\r\n    \r\n    float rad = h ;\r\n    float d = length( cutOutPos/r );\r\n    \r\n    float cutOut = (d - rad) * smallestSize;\r\n    headScarf\t= max(headScarf, cutOut);\r\n\r\n    // material information\r\n    float materialVal = 1.0 - pow(d - rad, 0.02);\r\n\theadScarfMatUVW = smoothstep( -1.0, 1.0, materialVal / _HeadScarfScale);\r\n\r\n\t// Chop the top off, to make room for head\r\n    vec3 headPos = pos - vec3(0.0, 0.25, 0.0);\r\n    float head   = sdBox(headPos, vec3(0.2, 0.19, 0.2)); \r\n    headScarf = max(headScarf, -head);\r\n    \r\n    return headScarf;\r\n}\r\nvec3 mainCloakMatUVW;\r\nfloat sdMainCloak(vec3 pos)\r\n{\r\n    vec3 cloakPos = pos - _MainClothPosition;\r\n    float q =  min(0.0,(cloakPos.y + 0.05));\r\n    rX( cloakPos, _MainClothRotation );\r\n    \r\n    // Apply detailing\r\n    cloakPos += SmoothTriangleWave(vec4(pos.xyz * _MainClothDetail.x + iTime,1.0) ).xyz * _MainClothDetail.y * q;\r\n    \r\n    // Add main Wind direction\r\n    Bend(cloakPos, _WindDirection.xy, _MainClothDetail.z);\r\n    \r\n    vec2 cloak = sdCloakCone( cloakPos, _MainClothScale.y, _MainClothScale.x, _MainClothScale.z);\r\n    // Cut out the internals of the cloak\r\n    cloak.x = max( cloak.x, -sdCloakCone( cloakPos, _MainClothScale.y * 1.05, _MainClothScale.x * 0.95, _MainClothScale.z * 1.01).x);\r\n\r\n    // UV Information\r\n    mainCloakMatUVW = smoothstep( -1.0, 1.0, cloakPos / _MainClothScale);\r\n\r\n    // Cut out the top section\r\n    vec3 headPos = cloakPos - vec3(0.0, 0.69, 0.0);\r\n    float head   = sdBox(headPos, vec3(0.2, 0.67, 0.2)); \r\n\tcloak.x = max(cloak.x, -head);\r\n    \r\n    // Cut the bottom\r\n    float bottomCut   = sdPlane(cloakPos - _MainClothBotCutPos); \r\n    cloak.x = max(cloak.x, -bottomCut);\r\n    \r\n    return cloak.x;\r\n}\r\n\r\nfloat earWigs(in vec3 pos) \r\n{   \r\n\t// Symmetrical ear wigs. Is that even a word... Ear Wigs!\r\n    pos.x = abs(pos.x);\r\n\r\n    vec2  earWig = sdSegment( pos, vec3(0.02, 0.11, 0.0), vec3(0.07, 0.16, 0.05));\r\n    float ear  = earWig.x - 0.026  + (earWig.y * 0.03);\r\n    return ear;\r\n}\r\n\r\n\r\nfloat sdHead( vec3 pos )\r\n{\r\n    vec3 headPos = pos - _HeadPos;\r\n\r\n    // Slight tilt\r\n    rY(headPos, _HeadRotationY ); // 1.2\r\n    rX(headPos, _HeadRotationX );\r\n\r\n    float head = sdCylinder( headPos, vec2(0.05, 0.13) );\r\n    head = smin(earWigs(headPos), head, 0.04 );\r\n    return head;\r\n}\r\n\r\nvec3 longScarfMatUVW;\r\nfloat sdScarf(vec3 pos) \r\n{\r\n    vec3 scarfPos = pos - _LongScarfPos;\r\n    vec3 scale \t= _LongScarfScale;\r\n\r\n\r\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.04);\r\n    scarfPos.x += (sin( scarfPos.z * _LongScarfWindStrength.x + iTime ) * 0.1 * distanceToPoint);\r\n    scarfPos.y += (sin( scarfPos.z * _LongScarfWindStrength.y + iTime ) * 0.1 * distanceToPoint);\r\n\r\n    // Apply detailing\r\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _LongScarfWindStrength.z + iTime,1.0) ).xyz * _LongScarfWindStrength.w * distanceToPoint;\r\n\r\n    // Essentially a box pivoted at a specific point\r\n    vec3 scarfOffset = vec3(0.0, 0.0, -scale.y);\r\n\r\n    rX(scarfPos, _LongScarfRotX) ;\r\n    float scarf = sdBox(scarfPos - scarfOffset.xzy , scale);\r\n\r\n    longScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos - scarfOffset.xzy ) / scale);\r\n\r\n    return max(scarf, sdSphere( scarfPos, _LongScarfMaxRad ));\r\n}\r\n\r\nfloat sdLegs( in vec3 pos  )\r\n{\r\n    vec2  upperLeftLeg = sdSegment( pos, _UpperLeftLegA, _UpperLeftLegB );\r\n    float leftLeg  = upperLeftLeg.x - _UpperLeftLegParams.x;\r\n    vec2 lowerLeftLeg = sdSegment( pos, _LowerLeftLegA, _LowerLeftLegB );\r\n    leftLeg  = smin( leftLeg, lowerLeftLeg.x - _LowerLeftLegParams.x + (lowerLeftLeg.y * _LowerLeftLegParams.y), _LowerLeftLegParams.z);\r\n\r\n    // cut bottom of left leg otherwise looks nasty with harsh tip\r\n    leftLeg = max( leftLeg, -(length( pos - _LowerLeftLegB) - 0.06 ) );\r\n\r\n    vec2  upperRightLeg = sdSegment( pos, _UpperRightLegA, _UpperRightLegB );\r\n    float rightLeg  = upperRightLeg.x - _UpperRightLegParams.x;\r\n    vec2 lowerRightLeg = sdSegment( pos, _LowerRightLegA, _LowerRightLegB );\r\n    rightLeg  = smin( rightLeg, lowerRightLeg.x - _LowerRightLegParams.x + (lowerRightLeg.y * _LowerRightLegParams.y), _LowerRightLegParams.z);\r\n\r\n    return min( leftLeg, rightLeg );\r\n}\r\n\r\nvec2 sdFace( vec3 pos, vec2 currentDistance )\r\n{\r\n    vec3 headPos = pos - vec3(0.0, -0.05, 0.0);\r\n    rX( headPos, _HeadRotationX );\r\n    rY(headPos, _HeadRotationY );\r\n\r\n    // head hole - Fire in the hole!    \r\n    // OK this does not look right. Actually looks like there was \"fire in the hole\" for \r\n    // the poor travellers face. Need to come back to it one day and finish it. Maybe!\r\n    vec3 headHole = headPos - vec3(0.0, 0.1, -0.07);\r\n    float hole = sdEllipsoid( headHole,vec3(0.05, 0.03, 0.04) );\r\n    hole  = smin ( hole, sdEllipsoid( headHole - vec3(0.0, -0.03, 0.0), vec3(0.03,0.03, 0.04)), 0.05 );\r\n\r\n    // Cut it OUT!\r\n    float character =  smax( currentDistance.x, -hole, 0.001);\r\n\r\n    // face. Meh just an ellipsoid. Need to add eyes and bandana\r\n    float face = sdEllipsoid( headHole - _FacePosition.xyz, _FaceSize );\r\n    return smin_mat( vec2(face, MAT_CHARACTER_FACE), vec2(character,currentDistance.y), 0.01, 0.2 );\r\n}\r\n\r\nvec2 sdCharacter( vec3 pos )\r\n{\r\n    // Now we are in character space - Booo YA! - I never ever say Boooo YA!. Peter Pimley \r\n    // says that. Peter: have you been putting comments in my code?\r\n    pos -= _CharacterPosition;\r\n    vec3 scale = _CharacterScale;\r\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\r\n    \r\n    rY(pos, _CharacterRotation);\r\n\r\n    pos /= scale;\r\n\r\n    float mainCloak = sdMainCloak( pos );\r\n    vec2  mainCloakMat = vec2(mainCloak, MAT_CHARACTER_MAIN_CLOAK );\r\n\r\n    float headScarf = sdHeadScarf(pos);\r\n    vec2  headScarfMat = vec2(headScarf, MAT_CHARACTER_NECK_SCARF );\r\n\r\n    float longScarf = sdScarf(pos);\r\n    vec2  longScarfMat = vec2( longScarf, MAT_CHARACTER_LONG_SCARF );\r\n    headScarfMat = smin_mat( headScarfMat, longScarfMat, 0.02, 0.1 );\r\n\r\n    float head      = sdHead( pos );\r\n    vec2  headMat\t= vec2( head, MAT_CHARACTER_BASE );\r\n    headScarfMat    = smin_mat(headScarfMat, headMat, 0.05, 0.75);\r\n\r\n    vec2  characterMat = min_mat(mainCloakMat, headScarfMat); \r\n    characterMat = sdFace( pos, characterMat );\r\n\r\n    vec2 legsMat = vec2( sdLegs(pos), MAT_CHARACTER_BASE );\r\n    characterMat = min_mat( characterMat, legsMat );\r\n\r\n    // chope the bottom. This is to chop the bottom of right leg. Though\r\n    // I have positioned the character so that the right leg is hidden by terrain. \r\n    // Commenting it out for now\r\n//    characterMat.x = max( characterMat.x, -sdPlane( pos - vec3(0.0, -0.85, 0.0) ) );\r\n    characterMat.x *= scaleMul;\r\n\r\n\r\n    return characterMat;\r\n}\r\n\r\n//==========================================================================================\r\n// Clouds\r\n//==========================================================================================\r\nfloat sdCloud( in vec3 pos, vec3 cloudPos, float rad, float spread, float phaseOffset, vec3 globalParams)\r\n{ \r\n\t// Clouds are simple. A bunch of spheres with varying phase offset, size and \r\n\t// frequency values. They are also scaled along the z-Axis so more like circles\r\n\t// than spheres. With additional noise to make them look fluffy. \r\n\t// While rendering them we \"perturb\" #SpellCheck the normals to get strong specular\r\n\t// highlights\r\n\r\n\t// Add noise to the clouds\r\n\tpos += pn( pos ) * _CloudNoiseStrength;\r\n\tpos = pos - cloudPos;\r\n\r\n\t// Make us 2d-ish - My artists have confirmed me: 2D is COOL!\r\n\tpos.z /= globalParams.x;\r\n\r\n\t// Repeat the space\r\n\tfloat repitition = rad * 2.0 + spread;\r\n\tvec3  repSpace = pos - mod( pos - repitition * 0.5, repitition);\r\n\r\n\t// Create the overall shape to create clouds on\r\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.23  )  * globalParams.y ;\r\n\r\n\t// Creates clouds with offset on the main path\r\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.9 ) * globalParams.z;\r\n\r\n\t// repeated spheres\r\n\tpos.x = fract( (pos.x + repitition * 0.5) / repitition ) * repitition - repitition * 0.5;\r\n\r\n\t// return the spheres  \r\n\tfloat sphere = length(pos)- rad;\r\n\treturn sphere * globalParams.x;\r\n}\r\n\r\nvec2 sdClouds( in vec3 pos )\r\n{\r\n\t// Two layers of clouds. A layer in front of the big pyramid\r\n    float c1 = sdCloud( pos, _FrontCloudsPos, _FrontCloudParams.x, _FrontCloudParams.y, _FrontCloudParams.z, _CloudGlobalParams );\r\n    float c2 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetA, _FrontCloudParamsA.x, _FrontCloudParamsA.y, _FrontCloudParamsA.z, _CloudGlobalParams );\r\n    float c3 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetB, _FrontCloudParamsB.x, _FrontCloudParamsB.y, _FrontCloudParamsB.z, _CloudGlobalParams);\r\n    float frontClouds = min(c3, min(c1, c2));\r\n\r\n    // This plane hides the empty spaces between the front cloud spheres. Not needed\r\n    // for back spheres, they are covered by front spheres\r\n  \tfloat mainPlane = length(pos.z - _FrontCloudsPos.z) / _CloudGlobalParams.x + (pos.y - _PlaneParams.y  + sin(_PlaneParams.x + pos.x * 0.23 ) * _PlaneParams.z);// - rad;\r\n  \tfrontClouds = min(mainPlane * _CloudGlobalParams.x, frontClouds);\r\n\r\n\t// Second layer behind the big Pyramid\r\n    float c4 = sdCloud( pos, _BackCloudsPos, _BackCloudParams.x, _BackCloudParams.y, _BackCloudParams.z, _CloudBackGlobalParams );\r\n    float c5 = sdCloud( pos, _BackCloudsPos + _BackCloudsOffsetA, _BackCloudParamsA.x, _BackCloudParamsA.y, _BackCloudParamsA.z, _CloudBackGlobalParams );\r\n    float backClouds = min(c4,c5);\r\n    return min_mat(vec2(frontClouds,MAT_FRONT_CLOUDS), vec2(backClouds,MAT_BACK_CLOUDS));\r\n}\r\n\r\n//==========================================================================================\r\n// This should really be called Kites. No such thing as Flying Helplers...\r\n//==========================================================================================\r\nvec3 helperScarfMatUVW;\r\nfloat sdHelperScarf(vec3 pos, vec3 scarfOffset, vec3 originalPos ) \r\n{\r\n    vec3 scarfPos = pos - scarfOffset;\r\n\r\n    vec3 scale = _FlyingHelperScarfScale;\r\n\r\n    // How far are we from pivot of scarf\r\n    float distanceToPoint = length(scarfPos );\r\n\r\n    // Apply some motion\r\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _FlyingHelperScarfWindDetailParams.x + iTime,1.0) ).xyz * _FlyingHelperScarfWindDetailParams.y * distanceToPoint;\r\n\r\n    vec2 wave;\r\n    wave.x = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.x  );\r\n    wave.y = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.z  );\r\n\r\n    scarfPos.xy += ( wave * _FlyingHelperScarfWindParams.y * distanceToPoint);\r\n    vec3  pivotOffset = vec3(0.0, 0.0, scale.z);\r\n    float scarf = sdBox(scarfPos - pivotOffset, scale);\r\n\r\n    // Move us along the z-axis because we chop a sphere in the box. Shows borders otherwise\r\n    vec3 UVWOffset = vec3(0.0, 0.0, 1.0);\r\n    helperScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos + UVWOffset - pivotOffset.xzy ) / scale);\r\n\r\n    // Two scarf on each side of the big'un\r\n    pivotOffset.z = _FlyingHelperSideScarfScale.z;\r\n\r\n\twave.y = originalPos.x > 0.0 ? wave.y * _FlyingScarfSideWindParams.x : wave.y * _FlyingScarfSideWindParams.y;\r\n\tscarfPos.xy += scarfPos.x > 0.0 ? wave * _FlyingScarfSideWindParams.z : wave * _FlyingScarfSideWindParams.w;\r\n\r\n\t// legit mirroring!\r\n\tscarfPos.x = -abs(scarfPos.x);\r\n\tfloat sideScarfs = sdBox(scarfPos - pivotOffset + _FlyingHelperSideScarfOffset, _FlyingHelperSideScarfScale);\r\n\r\n\t// Just override the helperScarfMatUVW value for side scarfs. Too tired to create another variable and use that, not too tired\r\n\t// to write this long comment of no value\r\n    helperScarfMatUVW = scarf < sideScarfs ? helperScarfMatUVW : smoothstep(-1.0, 1.0, ( scarfPos - pivotOffset + _FlyingHelperSideScarfOffset ) / _FlyingHelperSideScarfScale);\r\n\r\n    // Combine'em\r\n    scarf = min( scarf, sideScarfs );\r\n    return scarf;\r\n}\r\n\r\nvec2 sdFlyingHelpers( vec3 pos )\r\n{\r\n\tvec3 originalPos = pos;\r\n\tfloat flyingHelper = _DrawDistance;\r\n\r\n\t// Using pos.x to determine, whether we are rendering left or right scarf.\r\n\tvec3 helperPos = _FlyingHelperPos;\r\n\thelperPos = pos.x > 0.0 ? helperPos - _FlyingHelperMovement : helperPos;\r\n\r\n\t// Rest is just mirroring\r\n\tpos.x = abs(pos.x);\r\n\tpos = pos - helperPos;\r\n\r\n\tfloat helperScarf = sdHelperScarf( pos, vec3(0.0, 0.0, 0.0), originalPos);\r\n\r\n\t// Main helper is a box with a cutout sphere at back. In-game it is more sophisticated. But\r\n\t// I am running out of time. Maybe will do a proper one, one day!\r\n\tfloat helper = sdBox( pos, _FlyingHelperScale );\r\n\thelper\t= max( helper, -sdSphere( pos - vec3(0.0, 0.0, _FlyingHelperScale.z ), _FlyingHelperScale.z) );\r\n\r\n\t// Material and combine scarf with main body\r\n\tvec2 helperMat = smin_mat( vec2(helper,MAT_FLYING_HELPERS), vec2(helperScarf,MAT_FLYING_HELPER_SCARF), 0.01, 0.1);\r\n\thelperScarfMatUVW = helper < helperScarf ? smoothstep(-1.0, 1.0, (pos + vec3(0.0,0.0,_FlyingHelperScale.z*0.5)) / _FlyingHelperScale) : helperScarfMatUVW;\r\n\r\n\treturn helperMat;\r\n}\r\n\r\n//==========================================================================================\r\n// The big mountain in the distance. Again, not a pyramid\r\n//==========================================================================================\r\nfloat sdBigMountain( in vec3 pos )\r\n{\r\n    float scaleMul = min(_PyramidScale.x, min(_PyramidScale.y, _PyramidScale.z));\r\n    vec3 posPyramid\t= pos - _PyramidPos;\r\n\r\n    // Apply noise derivative, then we can use a blocky looking texture to make the mountain\r\n    // look edgy (for lack of better word)\r\n    float derNoise\t\t= sin(noised(posPyramid.xz * _PyramidNoisePrams.x).x) * _PyramidNoisePrams.y;\r\n    posPyramid.x\t\t= posPyramid.x + derNoise;\r\n\r\n    posPyramid /= _PyramidScale;\r\n    float pyramid = sdTriPrism(  posPyramid, _PrismScale.xy ) * scaleMul;\r\n\r\n    // The piercing eye. Which is just an inverted pyrmaid on top of main pyramid.\r\n    float eyeScale = _PyramidScale.x;\r\n\r\n    vec3 posEye = pos;\r\n    posEye.y = _PrismEyeScale.z - pos.y;\r\n    posEye.x = pos.x * _PrismEyeWidth;\r\n\r\n\tfloat eye = sdTriPrism(  (posEye -_PyramidEyeOffset) / eyeScale, _PrismEyeScale.xy ) * eyeScale;\r\n\treturn max(pyramid, -eye);\r\n}\r\n\r\n//==========================================================================================\r\n// Main desert shape\r\n//==========================================================================================\r\nfloat sdLargeWaves( in vec3 pos )\r\n{\r\n\t// The main shape of terrain. Just sin waves, along X and Z axis, with a power\r\n\t// curve to make the shape more pointy \r\n\r\n    // Manipulate the height as we go in the distance\r\n    // We want terrain to be a specific way closer to character, showing a path, but the path \r\n    // gets muddier as wo go in the distance.\r\n\r\n    float distZ = abs(pos.z - _CameraPos.z);\r\n    float distX = abs(pos.x - _CameraPos.x);\r\n    float dist = (distZ ) + (distX * 0.1);\r\n    dist = dist * dist * 0.01;\r\n\r\n    float detailNoise = noised(pos.xz).x * -2.5; \r\n\tfloat largeWaves = (sin(_LargeWaveOffset.z + pos.z * _LargeWaveDetail.y + pos.z * 0.02)  \r\n\t\t\t\t\t  * sin((_LargeWaveOffset.x + dist) + (pos.x * _LargeWaveDetail.x) ) * 0.5) + 0.5;\r\n    largeWaves = -_LargeWaveOffset.y + pow( largeWaves, _LargeWavePowStre.x) *  _LargeWavePowStre.y - detailNoise * 0.1 ;// - (-pos.z*_LargeWavePowStre.z);// \r\n\r\n    // Smoothly merge with the bottom plane of terrain\r\n    largeWaves = smin(largeWaves, _LargeWavePowStre.z, 0.2);\r\n    largeWaves = (largeWaves - dist);\r\n    return largeWaves * 0.9;\r\n}\r\n\r\nfloat sdSmallWaves( in vec3 pos )\r\n{\r\n\t// The small waves are used for adding detail to the main shape of terrain\r\n\tfloat distanceToCharacter = length( pos.xz - _CharacterPosition.xz );\r\n\r\n    // movement to give feel of wind blowing\r\n    float detailNoise = noised(pos.xz).x * _SmallWaveDetail.z; \r\n\tfloat smallWaves = sin(pos.z * _SmallWaveDetail.y + detailNoise + iTime * _WindSpeed.y ) * \r\n\t\t\t\t\t   sin(pos.x * _SmallWaveDetail.x + detailNoise + iTime * _WindSpeed.x ) * _SmallDetailStrength;// * min(1.0, distanceToCharacter);\r\n\t\r\n\treturn smallWaves * 0.9;\r\n}\r\n\r\nfloat sdTerrain( in vec3 pos)\r\n{\r\n\tfloat smallWaves = sdSmallWaves( pos );\r\n\tfloat largeWaves = sdLargeWaves( pos );\r\n\r\n    return (smallWaves + largeWaves);\r\n}\r\n\r\nvec2 sdDesert( in vec3 pos, in float terrain )\r\n{\r\n    float distanceToPos = length(pos.xz - _CameraPos.xz);\r\n    if( distanceToPos > _TerrainMaxDistance)\r\n        return vec2(_DrawDistance, 0.0);\t\r\n\r\n   \tfloat mat = 9.0;//length(pos.xyz) > 9.0 ? 10.0 : 40.0;\r\n    return vec2( pos.y + terrain, MAT_TERRAIN );\r\n}\r\n\r\n//==========================================================================================\r\n// Character trail in the sand\r\n//==========================================================================================\r\nfloat sdCharacterTrail( vec3 pos, in float terrain )\r\n{\r\n\tvec3 trailOffset = (_CharacterPosition);\r\n\ttrailOffset.yz  += (_CharacterTrailOffset).yz;\r\n    trailOffset.y = -terrain + _CharacterTrailOffset.y; \r\n\r\n    vec3 trailPos = pos - trailOffset;\r\n    float distanceToPoint = length(trailPos);\r\n    trailPos.x -= _CharacterTrailOffset.x * distanceToPoint;\r\n\r\n    // Make it wavy\r\n    trailPos.x += (SmoothTriangleWave( trailPos.z * _CharacterTrailWave.x  ) * _CharacterTrailWave.z * distanceToPoint);\r\n\r\n    float trail = sdBox(trailPos - vec3(0.0, 0.0, _CharacterTrailScale.z) , _CharacterTrailScale);\r\n    return trail;\r\n}\r\n\r\n//==========================================================================================\r\n// The tombs\r\n//==========================================================================================\r\nfloat sdTombScarf(vec3 pos, vec3 scarfOffset, float t ) \r\n{ \r\n\t//  scarfs, done same as other scarfs\r\n\r\n    vec3 scarfPos = pos - scarfOffset;\r\n\r\n    scarfPos =  (mul(  _TombScarfMat, vec4(scarfPos,1.0) )).xyz;\r\n\r\n    vec3 scale = _TombScarfScale;\r\n    scale.z  += (t + 1.0 ) * 0.2;\r\n\r\n    // How far are we from pivot of scarf\r\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.1);\r\n\r\n    // Make the scarf thicker as it goes out\r\n    scale.x += distanceToPoint * 0.04;\r\n\r\n    // Apply some motion\r\n    scarfPos.x += (sin( pos.z * _TombScarfWindParams.x + iTime) * _TombScarfWindParams.z * distanceToPoint);\r\n    scarfPos.y += (sin( pos.z * _TombScarfWindParams.y + iTime) * _TombScarfWindParams.z * distanceToPoint);\r\n\r\n     vec3 pivotOffset = vec3(0.0, 0.0, scale.z);\r\n    rX(scarfPos, _TombScarfRot + ((t - 0.5)* 0.15) + SmoothTriangleWave((iTime + 1.45) * 0.1) * 0.3 );\r\n\r\n    float scarf = sdBox(scarfPos - pivotOffset , scale);\r\n    return scarf;\r\n}\r\n\r\nvec2 sdTombs( in vec3 p )\r\n{\r\n\tvec2 mainTomb = vec2(_DrawDistance, MAT_TOMB);\r\n\r\n\t// We draw two tombs, t goes -1 -> 1 so we can use negative and positive values\r\n\t// to mainpulate them both individually\r\n\tfor( float t = -1.0; t <= 1.0; t += 2.0 )\r\n\t{\r\n\t\tvec3 tombPos = (_TombPosition + vec3(-0.25 * t, t * 0.05, 0.1 * t ));\r\n\r\n\t\tvec3 pos = p - tombPos;\r\n\t\trZ( pos, 0.1 * t );\r\n\r\n\t\tfloat tombScarf = sdTombScarf( pos, _TombScarfOffset, t + 1.0);\r\n\r\n\t\tpos.x = abs(pos.x);\r\n\r\n\t\t// Taper them beyond a certain height. Rest is just a rounded box\r\n\t\tpos.x += abs( pos.y > _TombBevelParams.x  ? (pos.y - _TombBevelParams.x) * _TombBevelParams.y: 0.0 );\r\n\t\tfloat tTomb = sdRoundBox( pos, _TombScale, _TombBevelParams.z);\r\n\r\n\t\t// Cut out a sphere at top\r\n\t\ttTomb = max( tTomb, -sdSphere( pos - vec3(0.0, _TombCutOutScale.x, 0.0), _TombCutOutScale.y ) );\r\n\r\n\t\t// create scarfs at cut off points\r\n\t\tvec2 tTombMat = min_mat( vec2(tTomb, MAT_TOMB), vec2(tombScarf, MAT_TOMB_SCARF));\r\n\t\tmainTomb = min_mat( mainTomb, tTombMat);\r\n\t}\r\n\treturn mainTomb;\r\n}\r\n\r\n//==========================================================================================\r\n// The main map function\r\n//==========================================================================================\r\nvec2 map( in vec3 pos )\r\n{\r\n\tvec2 character = sdCharacter(pos);\r\n\tvec2 res = character;\r\n\r\n\t// I am assuming that since character covers a large portion of screen\r\n\t// This early out should help and same with the terrain. Assumption only, \r\n\t// need to look into it \r\n    if( res.x > 0.01 )\r\n    {\r\n    \tfloat desert = sdTerrain(pos);\r\n\t    vec2 terrain   = sdDesert( pos, desert );\r\n\t    vec2 trail\t   = vec2(-sdCharacterTrail(pos, desert), MAT_TERRAIN_TRAIL );\r\n\t    terrain.y\t\t= terrain.x > trail.x ? terrain.y : trail.y;\r\n\t\tterrain.x\t\t= smax( terrain.x, trail.x, 0.05);\r\n\r\n\t\tres\t= min_mat( res, terrain); \r\n        if( terrain.x > 0.01 )\r\n        {\r\n\t\t\tvec2 tombs\t   =  sdTombs(pos);\r\n            res = smin_mat( res, tombs, 0.2, 0.15 );\r\n\r\n            vec2 pyramid   = vec2(sdBigMountain(pos), MAT_PYRAMID);\r\n            res = min_mat( res, pyramid );\r\n\r\n            vec2 clouds\t   = sdClouds(pos);\r\n            res = min_mat( res, clouds );\r\n\r\n            vec2 flyingHelpers = sdFlyingHelpers( pos );\r\n            res = min_mat( res, flyingHelpers );\r\n        }\r\n\t}\r\n    return res;\r\n}\r\n\r\n\r\n//==========================================================================================\r\n// Used for generating normals. As it turns out that only the big mountain doesn't need\r\n// normals. Everything else does. Hey Ho!\r\n//==========================================================================================\r\nvec2 mapSimple( in vec3 pos )\r\n{\r\n\treturn map( pos );\r\n\t/*\r\n    vec2 character = sdCharacter(pos);\r\n    vec2 flyingHelpers = vec2( sdFlyingHelpers( pos ), 50.0 );\r\n    vec2 clouds\t   = sdClouds(pos);\r\n   \tfloat desert   = sdTerrain(pos);\r\n    vec2 terrain   = sdDesert( pos, desert );\r\n    terrain.x = smax( terrain.x, -sdCharacterTrail(pos, desert), 0.1 );\r\n    vec2 tombs\t   =  vec2(sdTombs(pos), 50.0);\r\n\r\n    vec2 res = character;\r\n    min_mat( res, flyingHelpers );\r\n\tres = min_mat( res, clouds );\r\n    res\t= min_mat( res, terrain); \r\n    res\t= min_mat( res, flyingHelpers); \r\n    res = smin_mat( res, tombs, 0.2, 0.15 );\r\n    return res;\r\n    */\r\n}\r\n\r\n//==========================================================================================\r\n// Raycasting: https://www.shadertoy.com/view/Xds3zN\r\n//==========================================================================================\r\nvec3 castRay(vec3 ro, vec3 rd) \r\n{\r\n    float tmin = 0.1;\r\n    float tmax = _DrawDistance;\r\n   \r\n    float t = tmin;\r\n    float m = -1.0;\r\n    float p = 0.0;\r\n    float maxSteps = _MaxSteps;\r\n    float j = 0.0;\r\n    for( float i = 0.0; i < _MaxSteps; i += 1.0 )\r\n    {\r\n        j = i;\r\n\t    float precis = 0.0005*t;\r\n\t    vec2 res = map( ro+rd*t );\r\n        if( res.x<precis || t>tmax ) \r\n        \tbreak;\r\n        t += res.x;\r\n\t    m = res.y;\r\n    }\r\n\tp = j / maxSteps;\r\n    if( t>tmax ) m=-1.0;\r\n    return vec3( t, m, p );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\r\n    return normalize( e.xyy*mapSimple( pos + e.xyy ).x + \r\n\t\t\t\t\t  e.yyx*mapSimple( pos + e.yyx ).x + \r\n\t\t\t\t\t  e.yxy*mapSimple( pos + e.yxy ).x + \r\n\t\t\t\t\t  e.xxx*mapSimple( pos + e.xxx ).x );\r\n}\r\n\r\n//==========================================================================================\r\n// Ambient Occlusion, only applied to the Traveller\r\n//==========================================================================================\r\nfloat AmbientOcclusion(vec3 p, vec3 N, float stepSize, float k)\r\n{\r\n    float r = 0.0;\r\n    float t = 0.0;\r\n  \r\n    for(int i = 0; i < 2; i++)\r\n    {\r\n        t += stepSize;\r\n        r += (1.0 / pow(2.0, t)) * (t - sdCharacter(p + (N * t)).x);\r\n    }\r\n    return max(0.0, 1.0 - (k * r));\r\n}\r\n\r\n//==========================================================================================\r\n// Simplified version of Traveller for shadow casting\r\n//==========================================================================================\r\nfloat sdCharacterShadow( vec3 pos )\r\n{\r\n    pos -= _CharacterPosition;\r\n    vec3 scale = _CharacterScale;\r\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\r\n    \r\n    rY(pos, _CharacterRotation);\r\n\r\n    pos /= scale;\r\n\r\n    float mainCloak = sdMainCloak( pos );\r\n    float longScarf = sdScarf(pos);\r\n\r\n    return min( mainCloak, longScarf) * scaleMul;\r\n}\r\n\r\n//==========================================================================================\r\n// Only character, flying helpers and tombs cast shadows. Only terrain recieves shadows\r\n//==========================================================================================\r\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\r\n{\r\n    float res = 1.0;\r\n    float t = mint;\r\n    for(int i = 0; i < 100; ++i)\r\n    {\r\n        if (t >= maxt) {\r\n            break;\r\n        }\r\n    \tfloat flyingHelpers = sdFlyingHelpers( ro + rd * t).x;\r\n    \tfloat tombs = sdTombs( ro + rd * t ).x;\r\n        float h = min( sdCharacterShadow( ro + rd*t), min(flyingHelpers, tombs) );\r\n        if( h<0.001 )\r\n            return 0.1;\r\n        res = min( res, k*h/t );\r\n        t += h;\r\n    }\r\n\treturn res;\r\n}\r\n\r\n//==========================================================================================\r\n// Hi Hussain!\r\n// Again, somebody wrote Hi Hussain here. It wasn't me, but hi back atcha!\r\n// Sky\r\n//==========================================================================================\r\nvec3 sky( vec3 ro, vec3 rd )\r\n{\r\n    // Sun calculation\r\n    float sunDistance = length( _SunPosition );\r\n\r\n    vec3 delta = _SunPosition.xyz - (ro + rd * sunDistance);\r\n    float dist \t= length(delta);\r\n\r\n    // Turn Sun into a star, because the big mountain has a star like shape\r\n    // coming from top\r\n    delta.xy *= _SunStar.xy;\r\n    float sunDist = length(delta);\r\n    float spot = 1.0 - smoothstep(0.0, _SunSize, sunDist);\r\n    vec3 sun = clamp(_SunScale * spot * spot * spot, 0.0, 1.0) * _SunColor.rgb;\r\n\t\r\n\t// Changing color on bases of distance from Sun. To get a strong halo around\r\n\t// the sun\r\n   \tfloat expDist = clamp((dist - _ExposureOffset)  * _ExposureStrength, 0.0, 1.0);\r\n   \tfloat expControl = pow(expDist,_ExposurePower);\r\n\r\n    // Sky colors\r\n    float y = rd.y;\r\n    float zen = 1.0 - pow (min (1.0, 1.0 - y), _ZenithFallOff);\r\n    vec3 zenithColor\t= _Zenith.rgb  * zen;\r\n    zenithColor = mix( _SunColor.rgb, zenithColor, expControl );\r\n\r\n    float nad = 1.0 - pow (min (1.0, 1.0 + y), _NadirFallOff);\r\n    vec3 nadirColor\t= _Nadir.rgb * nad;\r\n\r\n    float hor = 1.0 - zen - nad;\r\n    vec3 horizonColor\t= _Horizon.rgb * hor;\r\n\r\n    // Add stars for Color Scheme 3\r\nfloat stars  = 0.0;\r\n#if COLOR_SCHEME == 3\r\n    vec3 starPos = ro + ( (rd + vec3(iTime * 0.001, 0.0, 0.0) ) * sunDistance);\r\n    starPos.xyz += iTime*0.01 + noised(starPos.xy) * 3.0;\r\n\r\n    starPos      = mod( starPos, 1.5) - 0.75;\r\n    stars  \t\t = length(starPos);\r\n\r\n\tfloat starsA \t= (step( 0.9, 1.0 - stars) * 1.0 - (stars)) * 2.0;\r\n\tfloat starsB\t= (step( 0.93, 1.0 - stars) * 1.0 - (stars)) * 1.5;\r\n\tstars = starsA + starsB;\r\n\r\n    stars = stars * pow(zen * expControl, 5.0);\r\n    stars = step( 0.01, stars) * stars * 2.0;\r\n#endif\r\n    return stars + (sun * _SunStar.z + zenithColor + horizonColor + nadirColor);\r\n}\r\n\r\n//==========================================================================================\r\n// The rendering, based on: https://www.shadertoy.com/view/Xds3zN\r\n//==========================================================================================\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{ \r\n\t// res.z contains the iteration count / max iterations. This gives kind of a nice glow\r\n\t// effect around foreground objects. Looks particularly nice on sky, with clouds in\r\n\t// front and also on terrain. Gives rim kind of look!\r\n\tvec3 res\t= castRay(ro,rd);\r\n\tvec3 skyCol = sky( ro, rd );\r\n\tvec3 col\t= skyCol;\r\n\r\n\t#if defined (DEBUG_PERFORMANCE)\r\n\treturn (res.z);\r\n\t#endif\r\n\r\n\tfloat t = res.x;\r\n\tfloat m = res.y;\r\n\r\n\tvec3 pos = ro + t*rd;\r\n\r\n\t// Return sky\r\n\tif( m < 0.0 )\r\n\t{\r\n\t\t// Bloom for the background clouds. We want Big Mountain to be engulfed with fog. So just chop out\r\n\t\t// areas around right and left side of BigMountain for creating fake bloom for background clouds by\r\n\t\t// using the iteration count needed to generate the distance function\r\n\t\tfloat rightSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(45.0, -5.0, _SunPosition.z));\r\n\t\tfloat leftSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(-50.0, -5.0, _SunPosition.z));\r\n\t\tif( rightSideCloudDist < 40.0 )\r\n\t\t{\r\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, rightSideCloudDist / 40.0);\r\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\r\n\t\t}\r\n\t\telse if( leftSideCloudDist < 40.0 )\r\n\t\t{\r\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, leftSideCloudDist / 40.0);\r\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\r\n\t\t}\r\n        else\r\n\t\t\treturn col;\r\n\t}\r\n\r\n\tfloat skyFog = 1.0-exp( _FogMul * t * pow(pos.y, _FogPow) );\r\n\t#if defined (DEBUG_FOG)\r\n\treturn (skyFog);\r\n\t#endif\r\n\r\n\t// Render the big mountain. Keep track of it's color, so we can use it for transparency for clouds later\r\n\tvec3 pyramidCol = vec3(0.0, 0.0, 0.0);\r\n\tpyramidCol\t\t= mix( _PyramidCol, skyCol, skyFog * 0.5  ); \r\n\r\n\tif( TEST_MAT_LESS( m, MAT_PYRAMID) )\r\n\t{\r\n\t\t// Height fog, with strong fade to sky \r\n\t\tfloat nh = (pos.y / _PyramidHeightFog.x);\r\n\t\tnh = nh*nh*nh*nh*nh;\r\n\t\tfloat heightFog = pow(clamp(1.0 - (nh), 0.0, 1.0), _PyramidHeightFog.y);\r\n\t\theightFog\t\t= clamp( heightFog, 0.0, 1.0 );\r\n\t\tpyramidCol\t\t= mix( pyramidCol, skyCol, heightFog ); \r\n\t\treturn pyramidCol;       \r\n\t}\r\n\r\n\t// Calculate normal after calculating sky and big mountain\r\n\tvec3 nor = calcNormal(pos);\r\n\t// Terrain: https://archive.org/details/GDC2013Edwards\r\n\tif( TEST_MAT_LESS (m, MAT_TERRAIN_TRAIL ) )\r\n\t{\r\n\t\tfloat shadow = softShadow( pos - (rd * 0.01), _LightDir.xyz, _TerrainShadowParams.x, _TerrainShadowParams.y, _TerrainShadowParams.z);\r\n\t\tshadow\t\t = clamp( shadow + _TerrainShadowParams.w, 0.0, 1.0 );\r\n\r\n\t\tvec3 shadowCol = mix( shadow * _TerrainShadowColor, _TerrainDistanceShadowColor, pow(skyFog, _TerrainFogPower * _TerrainDistanceShadowPower) );\r\n\r\n\t\t// Strong rim lighting\r\n\t\tfloat rim\t= (1.0 - saturate(dot( nor , -rd ))); \r\n\t\trim\t\t\t= saturate(pow( rim, _TerrainRimPower)) *_TerrainRimStrength ; \r\n\t\tvec3 rimColor\t= rim * _TerrainRimColor;\r\n\r\n\t\t// Specular highlights\r\n\t\tvec3 ref\t\t= reflect(rd, nor);\r\n\t    vec3 halfDir\t= normalize(_LightDir + rd);\r\n\r\n\t    // The strong ocean specular highlight\r\n\t    float mainSpec = clamp( dot( ref, halfDir ), 0.0, 1.0 );\r\n\t    if ( TEST_MAT_LESS( m, MAT_TERRAIN ) )\r\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 2.0 ;\r\n\t    else\r\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 4.0;\r\n\r\n\t    float textureGlitter  = textureLod(iChannel1,pos.xz * _TerrainGlitterRep, 2.2).x * 1.15;\r\n\t    textureGlitter\t= pow(textureGlitter , _TerrainGlitterPower);\r\n\t    mainSpec \t\t*= textureGlitter;\r\n\r\n\t\t// The glitter around terrain, looks decent based on rim value\r\n\t    float rimSpec\t= (pow(rim, _TerrainRimSpecPower)) * textureGlitter;\r\n\t    vec3 specColor\t= (mainSpec + rimSpec) * _TerrainSpecColor;\r\n\t\tvec3 terrainCol\t= mix( (rimColor + specColor * shadow) + _TerrainCol, skyCol, pow(skyFog, _TerrainFogPower) ) + res.z * 0.2;  \r\n\r\n\t\t// maybe add a fake AO from player, just a sphere should do!\r\n\t\treturn mix( shadowCol, terrainCol, shadow );\r\n\t}\r\n\r\n\t// Clouds\r\n\tif( TEST_MAT_LESS (m, MAT_FRONT_CLOUDS ) )\r\n\t{\r\n\t\t// Modify the normals so that they create strong specular highlights\r\n\t\t// towards the top edge of clouds\r\n\t\tnor\t\t\t\t= normalize( nor + _CloudNormalMod);\r\n\t\tfloat dotProd\t= dot( nor, vec3(1.0,-3.5,1.0) );\r\n\r\n\t\tfloat spec\t\t=  1.0 -  clamp( pow(dotProd, _CloudSpecPower), 0.0, 1.0 );\r\n\t\tspec \t\t\t*= 2.0;\r\n\t\tvec3 cloudCol\t= spec * _CloudSpecCol + _CloudCol;\r\n\r\n\t\t// Transparency for mountain\r\n\t\tif( sdBigMountain( pos + (rd * t * _CloudPyramidDistance)) < 0.2 )\r\n\t \t{\r\n\t \t\tcloudCol = mix( pyramidCol, cloudCol, _CloudTransparencyMul ); \r\n\t\t}\r\n\r\n\t\t// Mixing for backdrop mountains. Backdrop mountains take more color from Sky. Foreground mountains\r\n\t\t// retain their own color values, so I can adjust their darkness\r\n\t\tvec3 inCloudCol = mix(cloudCol, _BackCloudCol + skyCol * 0.5 + spec * _BackCloudSpecCol, MAT_FRONT_CLOUDS - m);\r\n\t\treturn mix( inCloudCol , skyCol, skyFog * _CloudFogStrength );    \r\n\t}\r\n\r\n\t// Tombs\r\n\tif( TEST_MAT_LESS(m, MAT_TOMB_SCARF ) )\r\n\t{\r\n\t\t// Simple strong diffuse\r\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.0, 0.0, 1.0);\r\n\t\tvec3 col\t= mix( _TombMainColor, _TombScarfColor * 2.0, m - MAT_TOMB );\r\n\t\treturn mix( diff * col, skyCol, skyFog);\r\n\t}\r\n\r\n\t// Flying Helpers\r\n\tif( TEST_MAT_LESS(m, MAT_FLYING_HELPER_SCARF ) )\r\n\t{\r\n\t\tfloat fres\t= pow( clamp(1.0+dot(nor,rd) + 0.75,0.0,1.0), _FlyingHelperFrePower ) * _FlyingHelperFreScale;\r\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.5,0.0,1.0);\r\n\t\tvec3 col = _FlyingHelperYellowColor;\r\n\r\n\t\t// The main head\r\n\t\tif ( TEST_MAT_LESS( m, MAT_FLYING_HELPERS ) )\r\n\t\t{\r\n\t\t\tcol = _FlyingHelperMainColor;\r\n\r\n\t\t\t// Yellow borders\r\n\t\t\tfloat outerBorder = step( 0.95, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\r\n\t\t\tcol  = mix( col * diff, _FlyingHelperYellowColor,  outerBorder );\r\n\r\n\t\t\t// cubes in middle\r\n\t\t\tfloat rectsY = abs(helperScarfMatUVW.z * 2.0 - 1.0);\r\n\t\t\tfloat rectsX = abs(helperScarfMatUVW.x * 2.0 - 1.0);\r\n\r\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\r\n\t\t\tcircles = step( 0.5, circles );\r\n\r\n\t\t\t// Ideally want to do a separate bass for bloom. maybe one day\r\n\t\t\tfloat bloomCircle = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1); \r\n\t\t\tfloat bloom  = max( bloomCircle - 0.5, 0.0);\r\n\r\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\r\n\t\t\trectsX = 1.0 - step( 0.5, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\r\n\r\n\t\t\tfloat rects = min(rectsX, rectsY);\r\n\r\n\t\t\tfloat symbolsX = fract(rects/(helperScarfMatUVW.z * 20.0) * 20.0);\r\n\t\t\tfloat symbolsY = fract(rects/(helperScarfMatUVW.x * 2.0) * 2.0);\r\n\t\t\tfloat symbolsZ = fract(rects/((helperScarfMatUVW.z + 0.1) * 16.0) * 16.0);\r\n\t\t\tfloat symbolsW = fract(rects/((helperScarfMatUVW.x + 0.1) * 3.0) * 3.0);\r\n\r\n\t\t\tfloat symbols = symbolsY;\r\n\t\t\tsymbols = max( symbols, symbolsZ );\r\n\t\t\tsymbols = min(symbols , max(symbolsX, symbolsW));\r\n\t\t\tsymbols = step( 0.5, symbols ); \r\n\r\n\t\t\tsymbols = min( symbols, circles );\r\n\r\n\t\t\t//  float rects = min(rectsX, max(circles,rectsY));\r\n\r\n\t\t\tcol = mix( col, _FlyingHelperYellowColor, circles);\r\n\t\t\tcol = mix( col, _FlyingHelperWhiteColor * 2.0, symbols)  + bloom  * _FlyingHelperBloomScale;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// The scarfs, just have a yellow border\r\n\t\t\tfloat outerBorder = step( 0.9, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\r\n\t\t\tcol \t= mix( _FlyingHelperMainColor * diff, _FlyingHelperYellowColor,  outerBorder );\r\n\t\t}\r\n\t\treturn mix( fres * col, skyCol, skyFog * _FlyingHelperFogScale );\r\n\t}\r\n\r\n\t// Character\r\n\tif( TEST_MAT_GREATER (m, MAT_CHARACTER_BASE ) )\r\n\t{\r\n\t\tfloat diff = _CharacterDiffScale * clamp( dot( nor, _LightDir ), 0.0, 1.0 );\r\n\r\n\t\t// Why did I fudge these normals, I can't remember. It does look good though, so keep it :)\r\n\t\tnor\t\t= normalize( nor + vec3(0.3,-0.1,1.0));\r\n\t\tnor.y\t*= 0.3;\r\n\r\n\t\tfloat fres\t= pow( clamp( 1.0 + dot(nor,rd) + 0.75, 0.0, 1.0), _CharacterFrePower ) * _CharacterFreScale;\r\n\t\tvec3 col\t= _CharacterMainColor;\r\n\r\n\t\t// Just base color\r\n\t\tif( TEST_MAT_LESS( m, MAT_CHARACTER_BASE) )\r\n\t\t{\r\n\t\t\t// Add sand fade to legs. Mixing terrain color at bottom of legs\r\n\t\t\tfloat heightTerrainMix\t= pow((pos.y / _CharacterHeightTerrainMix.x), _CharacterHeightTerrainMix.y);\r\n\t\t\theightTerrainMix\t\t= clamp( heightTerrainMix, 0.0, 1.0 );\r\n\t\t\tcol\t= mix( _CharacterMainColor, _CharacterTerrainCol, heightTerrainMix );\r\n\t\t}\r\n\t\t// Main Cloak\r\n\t\telse if( TEST_MAT_LESS( m,MAT_CHARACTER_MAIN_CLOAK) )\r\n\t\t{\r\n\t\t\t// Cone kind of shapes\r\n\t\t\tfloat rectsX\t= fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 7.0) ;\r\n\t\t\trectsX\t\t\t= abs(rectsX * 2.0 - 1.0);\r\n\t\t\tfloat rects\t\t= rectsX;\r\n\t\t\trects\t\t\t= step( 0.5, rects * (1.0 - mainCloakMatUVW.y*3.5) );\r\n\t\t\tcol = mix( col, _CharacterCloakDarkColor, rects );\r\n\r\n\t\t\t// Yellow borders, two lines\r\n\t\t\tfloat outerBorder\t\t= step( 0.915, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\r\n\t\t\tfloat betweenBorders\t= step( 0.88, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\r\n\t\t\tfloat innerBorder\t\t= step( 0.87, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\r\n\r\n\t\t\tinnerBorder = min( innerBorder, 1.0 - betweenBorders );\r\n\r\n\t\t\tcol  = mix( col, _CharacterCloakDarkColor,  betweenBorders );\r\n\t\t\tcol  = mix( col, _CharacterYellowColor,  outerBorder );\r\n\t\t\tcol  = mix( col, _CharacterYellowColor,  innerBorder);\r\n\r\n\t\t\t// The verticle cubes/lines running across the bottom of cloak\r\n\t\t\tfloat cubes = abs(fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 10.0)  * 2.0 - 1.0);\r\n\t\t\tcubes\t\t= min(betweenBorders, step( 0.9, cubes) );\r\n\t\t\tcol\t\t\t= mix( col, _CharacterYellowColor,  cubes);\r\n\t\t}\r\n\t\t// headscarf\r\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_NECK_SCARF) )\r\n\t\t{\r\n\t\t\tcol = mix( col, _CharacterYellowColor, step( 0.7, headScarfMatUVW.y) );\r\n\t\t}\r\n\t\t// Long Scarf\r\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_LONG_SCARF) )\r\n\t\t{\r\n\t\t\tcol = _CharacterYellowColor;\r\n\r\n\t\t\t// Yellow borders, two lines\r\n\t\t\tfloat outerBorder = step( 0.9, abs(longScarfMatUVW.x * 2.0 - 1.0) );\r\n\t\t\tfloat innerBorder = step( 0.7, abs(longScarfMatUVW.x * 2.0 - 1.0) );\r\n\r\n\t\t\tinnerBorder = min( innerBorder, 1.0 - step( 0.8, abs(longScarfMatUVW.x * 2.0 - 1.0) ) );\r\n\r\n\t\t\t// Mix borders\r\n\t\t\tcol  = mix( col, _CharacterMainColor,  outerBorder );\r\n\t\t\tcol  = mix( col, _CharacterMainColor,  innerBorder);\r\n\r\n\t\t\t// cubes in middle\r\n\t\t\tfloat rectsY = abs(fract( longScarfMatUVW.y/ 0.10 ) * 2.0 - 1.0);// - 0.5 * 0.10;\r\n\t\t\tfloat rectsX = abs(longScarfMatUVW.x * 2.0 - 1.0);\r\n\r\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\r\n\t\t\tcircles = step( 0.5, circles );\r\n\r\n\t\t\tfloat bloomCircle\t= 1.0 - (length( vec2(rectsY, rectsX * 0.7) ) - 0.1); \r\n\t\t\tfloat bloom \t\t= max( bloomCircle - 0.45, 0.0);\r\n\r\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\r\n\t\t\trectsX = 1.0 - step( 0.5, abs(longScarfMatUVW.x * 2.0 - 1.0) );\r\n\r\n\t\t\tfloat rects = min(rectsX, rectsY);\r\n\r\n\t\t\t// There are better ways of doing symbols. Spend some time on it, buddy!\r\n\t\t\tfloat symbolsX = fract(rects/(longScarfMatUVW.y * 0.17) * 10.0);\r\n\t\t\tfloat symbolsY = fract(rects/(longScarfMatUVW.x * 18.5) * 10.0);\r\n\r\n\t\t\tfloat symbols\t= symbolsX;\r\n\t\t\tsymbols\t\t\t= max( symbols, symbolsY );\r\n\t\t\tsymbols\t\t\t= step( 0.5, symbols ); \r\n\r\n\t\t\tsymbols = min( symbols, circles );\r\n\r\n\t\t\t//        float rects = min(rectsX, max(circles,rectsY));\r\n\t\t\tcol = mix( col, _CharacterMainColor, circles);\r\n\t\t\tcol = mix( col, _CharacterWhiteColor * 2.0, symbols)  + bloom * _CharacterBloomScale;\r\n\r\n\t\t\t// White glow and disintegrating the scarf, showing depleting scarf energy. Needs bloom effect :(\r\n\t\t\tcol = mix( col, _CharacterMainColor, 1.0 - smoothstep(0.4, 0.6, longScarfMatUVW.y));\r\n\t\t\tvec3 whiteMiddle = mix( col, _CharacterWhiteColor + bloom * _CharacterBloomScale, step(0.48, longScarfMatUVW.y));\r\n\t\t\tcol = mix( whiteMiddle, col, step(0.5, longScarfMatUVW.y));\r\n\t\t}\r\n\t\t// Face\r\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_FACE)  )\r\n\t\t{\r\n\t\t\tcol = vec3(0,0,0);\r\n\t\t}\r\n\t\tfloat ao = AmbientOcclusion(pos - (rd * 0.01), nor, _CharacterAOParams.x, _CharacterAOParams.y); \r\n\t\treturn ao * mix( (fres + diff) * col, skyCol, skyFog * _CharacterFogScale );\r\n\t}\r\n\treturn vec3( clamp(col * 0.0,0.0,1.0) );\r\n}\r\n\r\n\r\nfloat rand(float n)\r\n{\r\n\treturn fract(sin(n) * 43758.5453123);\r\n}\r\n\r\nfloat noise(float p)\r\n{\r\n\tfloat fl = floor(p);\r\n\tfloat fc = fract(p);\r\n    fc = fc*fc*(3.0-2.0*fc);\r\n    return mix(rand(fl), rand(fl + 1.0), fc);\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// Move camera using noise. This is probably quite expensive way of doing it :(\r\n\tfloat unitNoiseX = (noise(iTime * _CameraMovement.w ) * 2.0)  - 1.0;\r\n\tfloat unitNoiseY = (noise((iTime * _CameraMovement.w ) + 32.0) * 2.0)  -1.0;\r\n\tfloat unitNoiseZ = (noise((iTime * _CameraMovement.w ) + 48.0) * 2.0)  -1.0;\r\n\tvec3 ro = _CameraPos + vec3(unitNoiseX, unitNoiseY, unitNoiseZ) * _CameraMovement.xyz;\r\n\r\n\r\n\tvec3 screenRay\t\t= vec3(fragCoord / iResolution.xy, 1.0);\r\n\tvec2 screenCoord\t= screenRay.xy * 2.0 - 1.0;\r\n\r\n\t// Screen ray frustum aligned\r\n\tscreenRay.xy = screenCoord * _CameraFOV.xy;\r\n    screenRay.x\t\t\t*= 1.35;\r\n\tscreenRay.z  = -_CameraFOV.z;\r\n\tscreenRay /= abs( _CameraFOV.z); \r\n\r\n    // In camera space\r\n\tvec3 rd = normalize(mul( _CameraInvViewMatrix, vec4(screenRay,0.0))).xyz;\r\n\r\n\t// Do the render\r\n\tvec4 col = vec4(render(ro, rd), 0.0);\r\n\r\n\t// No it does not need gamma correct or tone mapping or any other effect that you heard about\r\n\t// and thought was cool. This is not realistic lighting\r\n\r\n\t// vignette\r\n\tfloat vig = pow(1.0 - 0.4 * dot(screenCoord, screenCoord), 0.6) * 1.25;\r\n\tvig = min( vig, 1.0);\r\n\tcol *= vig;\r\n\r\n\t// Final color\r\n\tfragColor =  col;\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"float noise(vec3 p) //Thx to Las^Mercury\r\n{\r\n\tvec3 i = floor(p);\r\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\r\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\r\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\r\n\ta.xy = mix(a.xz, a.yw, f.y);\r\n\treturn mix(a.x, a.y, f.z);\r\n}\r\n\r\nfloat sphere(vec3 p, vec4 spr)\r\n{\r\n\treturn length(spr.xyz-p) - spr.w;\r\n}\r\n\r\nfloat flame(vec3 p)\r\n{\r\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\r\n\treturn d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\r\n}\r\n\r\nfloat scene(vec3 p)\r\n{\r\n\treturn min(100.-length(p) , abs(flame(p)) );\r\n}\r\n\r\nvec4 raymarch(vec3 org, vec3 dir)\r\n{\r\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\r\n\tvec3  p = org;\r\n\tbool glowed = false;\r\n\t\r\n\tfor(int i=0; i<64; i++)\r\n\t{\r\n\t\td = scene(p) + eps;\r\n\t\tp += d * dir;\r\n\t\tif( d>eps )\r\n\t\t{\r\n\t\t\tif(flame(p) < .0)\r\n\t\t\t\tglowed=true;\r\n\t\t\tif(glowed)\r\n       \t\t\tglow = float(i)/64.;\r\n\t\t}\r\n\t}\r\n\treturn vec4(p,glow);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\r\n\tv.x *= iResolution.x/iResolution.y;\r\n\t\r\n\tvec3 org = vec3(0., -2., 4.);\r\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\r\n\t\r\n\tvec4 p = raymarch(org, dir);\r\n\tfloat glow = p.w;\r\n\t\r\n\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\r\n\t\r\n\tfragColor = mix(vec4(0.), col, pow(glow*2.,4.));\r\n\t//fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\r\n\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"float noise(vec3 p) //Thx to Las^Mercury\r\n{\r\n\tvec3 i = floor(p);\r\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\r\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\r\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\r\n\ta.xy = mix(a.xz, a.yw, f.y);\r\n\treturn mix(a.x, a.y, f.z);\r\n}\r\n\r\nfloat sphere(vec3 p, vec4 spr)\r\n{\r\n\treturn length(spr.xyz-p) - spr.w;\r\n}\r\n\r\nfloat flame(vec3 p)\r\n{\r\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\r\n\treturn d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\r\n}\r\n\r\nfloat scene(vec3 p)\r\n{\r\n\treturn min(100.-length(p) , abs(flame(p)) );\r\n}\r\n\r\nvec4 raymarch(vec3 org, vec3 dir)\r\n{\r\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\r\n\tvec3  p = org;\r\n\tbool glowed = false;\r\n\t\r\n\tfor(int i=0; i<64; i++)\r\n\t{\r\n\t\td = scene(p) + eps;\r\n\t\tp += d * dir;\r\n\t\tif( d>eps )\r\n\t\t{\r\n\t\t\tif(flame(p) < .0)\r\n\t\t\t\tglowed=true;\r\n\t\t\tif(glowed)\r\n       \t\t\tglow = float(i)/64.;\r\n\t\t}\r\n\t}\r\n\treturn vec4(p,glow);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\r\n\tv.x *= iResolution.x/iResolution.y;\r\n\t\r\n\tvec3 org = vec3(0., -2., 4.);\r\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\r\n\t\r\n\tvec4 p = raymarch(org, dir);\r\n\tfloat glow = p.w;\r\n\t\r\n\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\r\n\t\r\n\tfragColor = mix(vec4(0.), col, pow(glow*2.,4.));\r\n\t//fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\r\n\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Flame","id":null,"date":null,"viewed":0,"name":"Flame","description":"Simple flame in distance field.","likes":0,"published":null,"tags":["3d"," distancefield"," transparency"]},"ver":null,"info":{"Name":"Flame","id":null,"date":null,"viewed":0,"name":"Flame","description":"Simple flame in distance field.","likes":0,"published":null,"tags":["3d"," distancefield"," transparency"]},"renderpass":[{"Code":"float noise(vec3 p) //Thx to Las^Mercury\r\n{\r\n\tvec3 i = floor(p);\r\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\r\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\r\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\r\n\ta.xy = mix(a.xz, a.yw, f.y);\r\n\treturn mix(a.x, a.y, f.z);\r\n}\r\n\r\nfloat sphere(vec3 p, vec4 spr)\r\n{\r\n\treturn length(spr.xyz-p) - spr.w;\r\n}\r\n\r\nfloat flame(vec3 p)\r\n{\r\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\r\n\treturn d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\r\n}\r\n\r\nfloat scene(vec3 p)\r\n{\r\n\treturn min(100.-length(p) , abs(flame(p)) );\r\n}\r\n\r\nvec4 raymarch(vec3 org, vec3 dir)\r\n{\r\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\r\n\tvec3  p = org;\r\n\tbool glowed = false;\r\n\t\r\n\tfor(int i=0; i<64; i++)\r\n\t{\r\n\t\td = scene(p) + eps;\r\n\t\tp += d * dir;\r\n\t\tif( d>eps )\r\n\t\t{\r\n\t\t\tif(flame(p) < .0)\r\n\t\t\t\tglowed=true;\r\n\t\t\tif(glowed)\r\n       \t\t\tglow = float(i)/64.;\r\n\t\t}\r\n\t}\r\n\treturn vec4(p,glow);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\r\n\tv.x *= iResolution.x/iResolution.y;\r\n\t\r\n\tvec3 org = vec3(0., -2., 4.);\r\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\r\n\t\r\n\tvec4 p = raymarch(org, dir);\r\n\tfloat glow = p.w;\r\n\t\r\n\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\r\n\t\r\n\tfragColor = mix(vec4(0.), col, pow(glow*2.,4.));\r\n\t//fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\r\n\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"float noise(vec3 p) //Thx to Las^Mercury\r\n{\r\n\tvec3 i = floor(p);\r\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\r\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\r\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\r\n\ta.xy = mix(a.xz, a.yw, f.y);\r\n\treturn mix(a.x, a.y, f.z);\r\n}\r\n\r\nfloat sphere(vec3 p, vec4 spr)\r\n{\r\n\treturn length(spr.xyz-p) - spr.w;\r\n}\r\n\r\nfloat flame(vec3 p)\r\n{\r\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\r\n\treturn d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\r\n}\r\n\r\nfloat scene(vec3 p)\r\n{\r\n\treturn min(100.-length(p) , abs(flame(p)) );\r\n}\r\n\r\nvec4 raymarch(vec3 org, vec3 dir)\r\n{\r\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\r\n\tvec3  p = org;\r\n\tbool glowed = false;\r\n\t\r\n\tfor(int i=0; i<64; i++)\r\n\t{\r\n\t\td = scene(p) + eps;\r\n\t\tp += d * dir;\r\n\t\tif( d>eps )\r\n\t\t{\r\n\t\t\tif(flame(p) < .0)\r\n\t\t\t\tglowed=true;\r\n\t\t\tif(glowed)\r\n       \t\t\tglow = float(i)/64.;\r\n\t\t}\r\n\t}\r\n\treturn vec4(p,glow);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\r\n\tv.x *= iResolution.x/iResolution.y;\r\n\t\r\n\tvec3 org = vec3(0., -2., 4.);\r\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\r\n\t\r\n\tvec4 p = raymarch(org, dir);\r\n\tfloat glow = p.w;\r\n\t\r\n\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\r\n\t\r\n\tfragColor = mix(vec4(0.), col, pow(glow*2.,4.));\r\n\t//fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\r\n\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//afl_ext 2017-2019\r\n\r\n#define DRAG_MULT 0.048\r\n#define ITERATIONS_RAYMARCH 13\r\n#define ITERATIONS_NORMAL 48\r\n\r\n#define Mouse (iMouse.xy / iResolution.xy)\r\n#define Resolution (iResolution.xy)\r\n#define Time (iTime)\r\n\r\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\r\n    float x = dot(direction, position) * frequency + timeshift * speed;\r\n    float wave = exp(sin(x) - 1.0);\r\n    float dx = wave * cos(x);\r\n    return vec2(wave, -dx);\r\n}\r\n\r\nfloat getwaves(vec2 position, int iterations){\r\n\tfloat iter = 0.0;\r\n    float phase = 6.0;\r\n    float speed = 2.0;\r\n    float weight = 1.0;\r\n    float w = 0.0;\r\n    float ws = 0.0;\r\n    for(int i=0;i<iterations;i++){\r\n        vec2 p = vec2(sin(iter), cos(iter));\r\n        vec2 res = wavedx(position, p, speed, phase, Time);\r\n        position += normalize(p) * res.y * weight * DRAG_MULT;\r\n        w += res.x * weight;\r\n        iter += 12.0;\r\n        ws += weight;\r\n        weight = mix(weight, 0.0, 0.2);\r\n        phase *= 1.18;\r\n        speed *= 1.07;\r\n    }\r\n    return w / ws;\r\n}\r\n\r\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\r\n    vec3 pos = start;\r\n    float h = 0.0;\r\n    float hupper = depth;\r\n    float hlower = 0.0;\r\n    vec2 zer = vec2(0.0);\r\n    vec3 dir = normalize(end - start);\r\n    for(int i=0;i<318;i++){\r\n        h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH) * depth - depth;\r\n        if(h + 0.01 > pos.y) {\r\n            return distance(pos, camera);\r\n        }\r\n        pos += dir * (pos.y - h);\r\n    }\r\n    return -1.0;\r\n}\r\n\r\nfloat H = 0.0;\r\nvec3 normal(vec2 pos, float e, float depth){\r\n    vec2 ex = vec2(e, 0);\r\n    H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;\r\n    vec3 a = vec3(pos.x, H, pos.y);\r\n    return normalize(cross(normalize(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, ITERATIONS_NORMAL) * depth, pos.y)), \r\n                           normalize(a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));\r\n}\r\nmat3 rotmat(vec3 axis, float angle)\r\n{\r\n\taxis = normalize(axis);\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\tfloat oc = 1.0 - c;\r\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \r\n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \r\n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\r\n}\r\n\r\nvec3 getRay(vec2 uv){\r\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\r\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\r\n    if(Resolution.x < 400.0) return proj;\r\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;\r\n    return ray;\r\n}\r\n\r\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\r\n{ \r\n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \r\n}\r\n\r\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\r\n\tsundir.y = max(sundir.y, -0.07);\r\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\r\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\r\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\r\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\r\n\tfloat mymie = sundt * special_trick * 0.2;\r\n\tvec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\r\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\r\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\r\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\r\n\treturn bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;\r\n} \r\nvec3 getatm(vec3 ray){\r\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\r\n    \r\n}\r\n\r\nfloat sun(vec3 ray){\r\n \tvec3 sd = normalize(vec3(1.0));   \r\n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\r\n}\r\nvec3 aces_tonemap(vec3 color){\t\r\n\tmat3 m1 = mat3(\r\n        0.59719, 0.07600, 0.02840,\r\n        0.35458, 0.90834, 0.13383,\r\n        0.04823, 0.01566, 0.83777\r\n\t);\r\n\tmat3 m2 = mat3(\r\n        1.60475, -0.10208, -0.00327,\r\n        -0.53108,  1.10813, -0.07276,\r\n        -0.07367, -0.00605,  1.07602\r\n\t);\r\n\tvec3 v = m1 * color;    \r\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\r\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\r\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n \t\r\n\tfloat waterdepth = 2.1;\r\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\r\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\r\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\r\n\tvec3 ray = getRay(uv);\r\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\r\n    if(ray.y >= -0.01){\r\n        vec3 C = getatm(ray) * 2.0 + sun(ray);\r\n        //tonemapping\r\n    \tC = aces_tonemap(C);\r\n     \tfragColor = vec4( C,1.0);   \r\n        return;\r\n    }\r\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\r\n    vec3 hipos = orig + ray * hihit;\r\n    vec3 lopos = orig + ray * lohit;\r\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\r\n    vec3 pos = orig + ray * dist;\r\n\r\n\tvec3 N = normal(pos.xz, 0.001, waterdepth);\r\n    vec2 velocity = N.xz * (1.0 - N.y);\r\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\r\n    vec3 R = reflect(ray, N);\r\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\r\n\t\r\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R);\r\n    //tonemapping\r\n    C = aces_tonemap(C);\r\n    \r\n\tfragColor = vec4(C,1.0);\r\n}","inputs":[],"outputs":[],"code":"//afl_ext 2017-2019\r\n\r\n#define DRAG_MULT 0.048\r\n#define ITERATIONS_RAYMARCH 13\r\n#define ITERATIONS_NORMAL 48\r\n\r\n#define Mouse (iMouse.xy / iResolution.xy)\r\n#define Resolution (iResolution.xy)\r\n#define Time (iTime)\r\n\r\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\r\n    float x = dot(direction, position) * frequency + timeshift * speed;\r\n    float wave = exp(sin(x) - 1.0);\r\n    float dx = wave * cos(x);\r\n    return vec2(wave, -dx);\r\n}\r\n\r\nfloat getwaves(vec2 position, int iterations){\r\n\tfloat iter = 0.0;\r\n    float phase = 6.0;\r\n    float speed = 2.0;\r\n    float weight = 1.0;\r\n    float w = 0.0;\r\n    float ws = 0.0;\r\n    for(int i=0;i<iterations;i++){\r\n        vec2 p = vec2(sin(iter), cos(iter));\r\n        vec2 res = wavedx(position, p, speed, phase, Time);\r\n        position += normalize(p) * res.y * weight * DRAG_MULT;\r\n        w += res.x * weight;\r\n        iter += 12.0;\r\n        ws += weight;\r\n        weight = mix(weight, 0.0, 0.2);\r\n        phase *= 1.18;\r\n        speed *= 1.07;\r\n    }\r\n    return w / ws;\r\n}\r\n\r\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\r\n    vec3 pos = start;\r\n    float h = 0.0;\r\n    float hupper = depth;\r\n    float hlower = 0.0;\r\n    vec2 zer = vec2(0.0);\r\n    vec3 dir = normalize(end - start);\r\n    for(int i=0;i<318;i++){\r\n        h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH) * depth - depth;\r\n        if(h + 0.01 > pos.y) {\r\n            return distance(pos, camera);\r\n        }\r\n        pos += dir * (pos.y - h);\r\n    }\r\n    return -1.0;\r\n}\r\n\r\nfloat H = 0.0;\r\nvec3 normal(vec2 pos, float e, float depth){\r\n    vec2 ex = vec2(e, 0);\r\n    H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;\r\n    vec3 a = vec3(pos.x, H, pos.y);\r\n    return normalize(cross(normalize(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, ITERATIONS_NORMAL) * depth, pos.y)), \r\n                           normalize(a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));\r\n}\r\nmat3 rotmat(vec3 axis, float angle)\r\n{\r\n\taxis = normalize(axis);\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\tfloat oc = 1.0 - c;\r\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \r\n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \r\n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\r\n}\r\n\r\nvec3 getRay(vec2 uv){\r\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\r\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\r\n    if(Resolution.x < 400.0) return proj;\r\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;\r\n    return ray;\r\n}\r\n\r\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\r\n{ \r\n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \r\n}\r\n\r\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\r\n\tsundir.y = max(sundir.y, -0.07);\r\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\r\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\r\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\r\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\r\n\tfloat mymie = sundt * special_trick * 0.2;\r\n\tvec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\r\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\r\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\r\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\r\n\treturn bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;\r\n} \r\nvec3 getatm(vec3 ray){\r\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\r\n    \r\n}\r\n\r\nfloat sun(vec3 ray){\r\n \tvec3 sd = normalize(vec3(1.0));   \r\n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\r\n}\r\nvec3 aces_tonemap(vec3 color){\t\r\n\tmat3 m1 = mat3(\r\n        0.59719, 0.07600, 0.02840,\r\n        0.35458, 0.90834, 0.13383,\r\n        0.04823, 0.01566, 0.83777\r\n\t);\r\n\tmat3 m2 = mat3(\r\n        1.60475, -0.10208, -0.00327,\r\n        -0.53108,  1.10813, -0.07276,\r\n        -0.07367, -0.00605,  1.07602\r\n\t);\r\n\tvec3 v = m1 * color;    \r\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\r\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\r\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n \t\r\n\tfloat waterdepth = 2.1;\r\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\r\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\r\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\r\n\tvec3 ray = getRay(uv);\r\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\r\n    if(ray.y >= -0.01){\r\n        vec3 C = getatm(ray) * 2.0 + sun(ray);\r\n        //tonemapping\r\n    \tC = aces_tonemap(C);\r\n     \tfragColor = vec4( C,1.0);   \r\n        return;\r\n    }\r\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\r\n    vec3 hipos = orig + ray * hihit;\r\n    vec3 lopos = orig + ray * lohit;\r\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\r\n    vec3 pos = orig + ray * dist;\r\n\r\n\tvec3 N = normal(pos.xz, 0.001, waterdepth);\r\n    vec2 velocity = N.xz * (1.0 - N.y);\r\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\r\n    vec3 R = reflect(ray, N);\r\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\r\n\t\r\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R);\r\n    //tonemapping\r\n    C = aces_tonemap(C);\r\n    \r\n\tfragColor = vec4(C,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Very fast procedural ocean ","id":null,"date":null,"viewed":0,"name":"Very fast procedural ocean ","description":"It's fast because it doesn't use noise but rather sin waves","likes":0,"published":null,"tags":["waves"," sea"," water"," ocean"," seascape"," scape"]},"ver":null,"info":{"Name":"Very fast procedural ocean ","id":null,"date":null,"viewed":0,"name":"Very fast procedural ocean ","description":"It's fast because it doesn't use noise but rather sin waves","likes":0,"published":null,"tags":["waves"," sea"," water"," ocean"," seascape"," scape"]},"renderpass":[{"Code":"//afl_ext 2017-2019\r\n\r\n#define DRAG_MULT 0.048\r\n#define ITERATIONS_RAYMARCH 13\r\n#define ITERATIONS_NORMAL 48\r\n\r\n#define Mouse (iMouse.xy / iResolution.xy)\r\n#define Resolution (iResolution.xy)\r\n#define Time (iTime)\r\n\r\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\r\n    float x = dot(direction, position) * frequency + timeshift * speed;\r\n    float wave = exp(sin(x) - 1.0);\r\n    float dx = wave * cos(x);\r\n    return vec2(wave, -dx);\r\n}\r\n\r\nfloat getwaves(vec2 position, int iterations){\r\n\tfloat iter = 0.0;\r\n    float phase = 6.0;\r\n    float speed = 2.0;\r\n    float weight = 1.0;\r\n    float w = 0.0;\r\n    float ws = 0.0;\r\n    for(int i=0;i<iterations;i++){\r\n        vec2 p = vec2(sin(iter), cos(iter));\r\n        vec2 res = wavedx(position, p, speed, phase, Time);\r\n        position += normalize(p) * res.y * weight * DRAG_MULT;\r\n        w += res.x * weight;\r\n        iter += 12.0;\r\n        ws += weight;\r\n        weight = mix(weight, 0.0, 0.2);\r\n        phase *= 1.18;\r\n        speed *= 1.07;\r\n    }\r\n    return w / ws;\r\n}\r\n\r\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\r\n    vec3 pos = start;\r\n    float h = 0.0;\r\n    float hupper = depth;\r\n    float hlower = 0.0;\r\n    vec2 zer = vec2(0.0);\r\n    vec3 dir = normalize(end - start);\r\n    for(int i=0;i<318;i++){\r\n        h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH) * depth - depth;\r\n        if(h + 0.01 > pos.y) {\r\n            return distance(pos, camera);\r\n        }\r\n        pos += dir * (pos.y - h);\r\n    }\r\n    return -1.0;\r\n}\r\n\r\nfloat H = 0.0;\r\nvec3 normal(vec2 pos, float e, float depth){\r\n    vec2 ex = vec2(e, 0);\r\n    H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;\r\n    vec3 a = vec3(pos.x, H, pos.y);\r\n    return normalize(cross(normalize(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, ITERATIONS_NORMAL) * depth, pos.y)), \r\n                           normalize(a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));\r\n}\r\nmat3 rotmat(vec3 axis, float angle)\r\n{\r\n\taxis = normalize(axis);\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\tfloat oc = 1.0 - c;\r\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \r\n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \r\n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\r\n}\r\n\r\nvec3 getRay(vec2 uv){\r\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\r\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\r\n    if(Resolution.x < 400.0) return proj;\r\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;\r\n    return ray;\r\n}\r\n\r\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\r\n{ \r\n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \r\n}\r\n\r\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\r\n\tsundir.y = max(sundir.y, -0.07);\r\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\r\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\r\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\r\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\r\n\tfloat mymie = sundt * special_trick * 0.2;\r\n\tvec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\r\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\r\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\r\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\r\n\treturn bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;\r\n} \r\nvec3 getatm(vec3 ray){\r\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\r\n    \r\n}\r\n\r\nfloat sun(vec3 ray){\r\n \tvec3 sd = normalize(vec3(1.0));   \r\n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\r\n}\r\nvec3 aces_tonemap(vec3 color){\t\r\n\tmat3 m1 = mat3(\r\n        0.59719, 0.07600, 0.02840,\r\n        0.35458, 0.90834, 0.13383,\r\n        0.04823, 0.01566, 0.83777\r\n\t);\r\n\tmat3 m2 = mat3(\r\n        1.60475, -0.10208, -0.00327,\r\n        -0.53108,  1.10813, -0.07276,\r\n        -0.07367, -0.00605,  1.07602\r\n\t);\r\n\tvec3 v = m1 * color;    \r\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\r\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\r\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n \t\r\n\tfloat waterdepth = 2.1;\r\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\r\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\r\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\r\n\tvec3 ray = getRay(uv);\r\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\r\n    if(ray.y >= -0.01){\r\n        vec3 C = getatm(ray) * 2.0 + sun(ray);\r\n        //tonemapping\r\n    \tC = aces_tonemap(C);\r\n     \tfragColor = vec4( C,1.0);   \r\n        return;\r\n    }\r\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\r\n    vec3 hipos = orig + ray * hihit;\r\n    vec3 lopos = orig + ray * lohit;\r\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\r\n    vec3 pos = orig + ray * dist;\r\n\r\n\tvec3 N = normal(pos.xz, 0.001, waterdepth);\r\n    vec2 velocity = N.xz * (1.0 - N.y);\r\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\r\n    vec3 R = reflect(ray, N);\r\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\r\n\t\r\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R);\r\n    //tonemapping\r\n    C = aces_tonemap(C);\r\n    \r\n\tfragColor = vec4(C,1.0);\r\n}","inputs":[],"outputs":[],"code":"//afl_ext 2017-2019\r\n\r\n#define DRAG_MULT 0.048\r\n#define ITERATIONS_RAYMARCH 13\r\n#define ITERATIONS_NORMAL 48\r\n\r\n#define Mouse (iMouse.xy / iResolution.xy)\r\n#define Resolution (iResolution.xy)\r\n#define Time (iTime)\r\n\r\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\r\n    float x = dot(direction, position) * frequency + timeshift * speed;\r\n    float wave = exp(sin(x) - 1.0);\r\n    float dx = wave * cos(x);\r\n    return vec2(wave, -dx);\r\n}\r\n\r\nfloat getwaves(vec2 position, int iterations){\r\n\tfloat iter = 0.0;\r\n    float phase = 6.0;\r\n    float speed = 2.0;\r\n    float weight = 1.0;\r\n    float w = 0.0;\r\n    float ws = 0.0;\r\n    for(int i=0;i<iterations;i++){\r\n        vec2 p = vec2(sin(iter), cos(iter));\r\n        vec2 res = wavedx(position, p, speed, phase, Time);\r\n        position += normalize(p) * res.y * weight * DRAG_MULT;\r\n        w += res.x * weight;\r\n        iter += 12.0;\r\n        ws += weight;\r\n        weight = mix(weight, 0.0, 0.2);\r\n        phase *= 1.18;\r\n        speed *= 1.07;\r\n    }\r\n    return w / ws;\r\n}\r\n\r\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\r\n    vec3 pos = start;\r\n    float h = 0.0;\r\n    float hupper = depth;\r\n    float hlower = 0.0;\r\n    vec2 zer = vec2(0.0);\r\n    vec3 dir = normalize(end - start);\r\n    for(int i=0;i<318;i++){\r\n        h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH) * depth - depth;\r\n        if(h + 0.01 > pos.y) {\r\n            return distance(pos, camera);\r\n        }\r\n        pos += dir * (pos.y - h);\r\n    }\r\n    return -1.0;\r\n}\r\n\r\nfloat H = 0.0;\r\nvec3 normal(vec2 pos, float e, float depth){\r\n    vec2 ex = vec2(e, 0);\r\n    H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;\r\n    vec3 a = vec3(pos.x, H, pos.y);\r\n    return normalize(cross(normalize(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, ITERATIONS_NORMAL) * depth, pos.y)), \r\n                           normalize(a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));\r\n}\r\nmat3 rotmat(vec3 axis, float angle)\r\n{\r\n\taxis = normalize(axis);\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\tfloat oc = 1.0 - c;\r\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \r\n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \r\n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\r\n}\r\n\r\nvec3 getRay(vec2 uv){\r\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\r\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\r\n    if(Resolution.x < 400.0) return proj;\r\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;\r\n    return ray;\r\n}\r\n\r\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\r\n{ \r\n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \r\n}\r\n\r\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\r\n\tsundir.y = max(sundir.y, -0.07);\r\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\r\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\r\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\r\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\r\n\tfloat mymie = sundt * special_trick * 0.2;\r\n\tvec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\r\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\r\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\r\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\r\n\treturn bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;\r\n} \r\nvec3 getatm(vec3 ray){\r\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\r\n    \r\n}\r\n\r\nfloat sun(vec3 ray){\r\n \tvec3 sd = normalize(vec3(1.0));   \r\n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\r\n}\r\nvec3 aces_tonemap(vec3 color){\t\r\n\tmat3 m1 = mat3(\r\n        0.59719, 0.07600, 0.02840,\r\n        0.35458, 0.90834, 0.13383,\r\n        0.04823, 0.01566, 0.83777\r\n\t);\r\n\tmat3 m2 = mat3(\r\n        1.60475, -0.10208, -0.00327,\r\n        -0.53108,  1.10813, -0.07276,\r\n        -0.07367, -0.00605,  1.07602\r\n\t);\r\n\tvec3 v = m1 * color;    \r\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\r\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\r\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n \t\r\n\tfloat waterdepth = 2.1;\r\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\r\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\r\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\r\n\tvec3 ray = getRay(uv);\r\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\r\n    if(ray.y >= -0.01){\r\n        vec3 C = getatm(ray) * 2.0 + sun(ray);\r\n        //tonemapping\r\n    \tC = aces_tonemap(C);\r\n     \tfragColor = vec4( C,1.0);   \r\n        return;\r\n    }\r\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\r\n    vec3 hipos = orig + ray * hihit;\r\n    vec3 lopos = orig + ray * lohit;\r\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\r\n    vec3 pos = orig + ray * dist;\r\n\r\n\tvec3 N = normal(pos.xz, 0.001, waterdepth);\r\n    vec2 velocity = N.xz * (1.0 - N.y);\r\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\r\n    vec3 R = reflect(ray, N);\r\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\r\n\t\r\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R);\r\n    //tonemapping\r\n    C = aces_tonemap(C);\r\n    \r\n\tfragColor = vec4(C,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define E1_COUNT 200\r\n#define E1_RADIUS 0.01f\r\n#define E1_RADIUS2 0.2f\r\n#define E1_RANGE 0.4f\r\n\r\n#define E2_COUNT 5\r\n#define E2_RADIUS 0.1f\r\n    \r\n#define E3_COUNT 20\r\n#define E3_RADIUS 0.1f\r\n#define E3_RADIUS2 2.0f\r\n\r\n#define E4_COUNT 10\r\n#define E4_RADIUS 0.2f\r\n#define E4_RADIUS2 0.1f\r\n\r\n#define E6_COUNT 5\r\n\r\nmat3 rotateX(float a)\r\n{\r\n    float sx = sin(a), cx = cos(a);\r\n    return mat3(vec3(1.0,0.0,0.0),vec3(0.0,cx,sx),vec3(0.0,-sx,cx));\r\n}\r\n\r\nmat3 rotateY(float a)\r\n{\r\n    float sy = sin(a), cy = cos(a);\r\n    return mat3(vec3(cy,0.0,-sy),vec3(0.0,1.0,0.0),vec3(sy,0.0,cy));\r\n}\r\n\r\nfloat hash(float a)\r\n{\r\n    return fract(5147.4235*sin(a*0.012345f));\r\n}\r\n\r\nvec3 hash3(vec3 a)\r\n{\r\n    return fract(5147.4235*sin(vec3(55.123,43.45,16.123) + dot(a,vec3(1.0f,14.554,145.34f))*0.012345f));\r\n}\r\n\r\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\r\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\r\nvec4 hash4( vec4 n ) { return fract(sin(n)*753.5453123); }\r\nfloat noise3( vec3 x, float seed )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + dot(p.yz,vec2(157.0,113.0)) + seed;\r\n    vec4 s1=mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),vec4(f.x));\r\n    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\r\n}\r\n\r\nvec3 noisepos(int seed)\r\n{\r\n    return vec3(fract(5147.4235*sin(vec3(55.123,43.45,16.123) + vec3(float(seed)*0.012345f)))) - 0.5f;\r\n}\r\n\r\n/*vec3 lnoiseadd(vec3 p)\r\n{\r\n    return vec3(noise3(p,0.0f),noise3(p,10.0f),noise3(p,4.0f)) - vec3(0.5f);\r\n}*/\r\n\r\nvec3 lnoiseadd(vec3 p)\r\n{\r\n    return texture(iChannel0,p.xy*0.1f).xyz - vec3(0.5f);\r\n}\r\n\r\n// particles\r\nvec4 effect1( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0;\r\n    float sr = 6.283f / float(E1_COUNT);\r\n\r\n    for (int i=0; i<E1_COUNT;i++)\r\n    {\r\n        float t = fract(time*0.5 - hash(float(i+seed))*0.3f*E1_RANGE);\r\n        t = sqrt(t);\r\n        float r = t*2.0f;\r\n        vec3 p = vec3(sin(float(i)*sr),0,cos(float(i)*sr));\r\n        p = normalize(p + lnoiseadd(p*20.0f+p*r*0.3f)*vec3(0.1f,1.0f,0.1f)*E1_RANGE);\r\n        p = p * r;\r\n        p += (lnoiseadd(p*1.0f))*0.3f*(r*0.4f+0.2f);\r\n        p -= pos;\r\n        float rl = 1.0f/dot(ray,normalize(p));\r\n        float finout = clamp(r,0.0f,1.0f) * clamp(2.0-r,0.0f,1.0f);\r\n        a += (1.0f - clamp(sqrt(rl*rl - 1.0) * length(p) / mix(E1_RADIUS,E1_RADIUS2,t),0.0,1.0)) * finout*0.5f;\r\n    }\r\n\r\n    return vec4(0.5,0.5,0.5,1)*a;\r\n}\r\n\r\n// rays\r\nvec4 effect2( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    for (int i=0; i<E2_COUNT; i++)\r\n    {\r\n        float tm = time*4.0f - hash(float(i+seed));\r\n    \tint s=int(floor(tm));\r\n        float io = fract(tm)* (1.0-fract(tm))*2.0f;\r\n    \r\n    \tvec3 nr = normalize(noisepos(seed+s*E2_COUNT+i));\r\n    \r\n    \tvec3 n = cross(nr,ray);\r\n    \tfloat ln = length(n);\r\n    \tn = normalize(n);\r\n    \tfloat rl = abs(dot(n, pos))/E2_RADIUS;\r\n    \r\n    \tfloat t = dot(cross(pos,nr),n) / ln;\r\n    \tt = dot(ray*t + pos,nr);\r\n    \tt=(1.0-abs(dot(nr,ray)))*t;\r\n    \r\n    \ta += ((1.0f - clamp(rl,0.0,1.0)) * clamp(t,0.0,1.0))*io;\r\n    }\r\n    \r\n    return mix(vec4(1.0f)*a,vec4(a*0.2f+0.5f,a*0.2f+0.5f,1,1)*a,a);\r\n}\r\n\r\n// dot particles\r\nvec4 effect3( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    vec3 npp = normalize(pos);\r\n    \r\n    for (int i=0; i<E3_COUNT;i++)\r\n    {\r\n        float tm = time*1.0f - hash(float(i+seed));\r\n    \tint s=int(floor(tm));\r\n        float io = fract(tm);\r\n        vec3 np = normalize(noisepos(i + seed + s*E3_COUNT));\r\n        vec3 p = np * sqrt(1.0f-io)*E3_RADIUS2 - pos;\r\n        \r\n        float ad=0.0;\r\n        for (int k=0;k<11;k++)\r\n        {\r\n            p += np*0.03f;\r\n        \tfloat rl = 1.0f/dot(ray,normalize(p));\r\n        \trl = (sqrt(rl*rl - 1.0));\r\n        \tad += (1.0f - clamp(rl * length(p) / E3_RADIUS,0.0,1.0))*abs(6.0f-float(5-k))*0.03f * io;\r\n        }\r\n        a += ad*ad;\r\n    }\r\n    \r\n    return vec4(a*a,a*a,a,1);\r\n}\r\n\r\n// core particles\r\nvec4 effect4( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    vec3 npp = normalize(pos);\r\n    \r\n    for (int i=0; i<E4_COUNT; i++)\r\n    {\r\n        float tm = time*1.0f - hash(float(i+seed)+floor(time));\r\n    \tint s=int(floor(tm));\r\n        float io = fract(tm) * (1.0-fract(tm));\r\n        vec3 np = normalize(noisepos(i + seed + s*E4_COUNT));\r\n        vec3 p = np * E4_RADIUS2 - pos;\r\n        float rl = 1.0f/dot(ray,normalize(p));\r\n        rl = (sqrt(rl*rl - 1.0));\r\n        a+= (1.0f - clamp(rl / E4_RADIUS,0.0,1.0)) * io;\r\n    }\r\n    \r\n    return vec4(a*a,a*a,a,1);\r\n}\r\n\r\nfloat perlin(vec3 p)\r\n{\r\n    //return texture(iChannel0,p*0.2f).x*0.4 + texture(iChannel0,p*0.4f).x*0.4 + texture(iChannel0,p*0.8f).x*0.2;\r\n    return texture(iChannel0,p.xy*0.2f).x;\r\n}\r\n\r\nvec3 marh(vec3 pos, vec3 ray, float time, int seed)\r\n{\r\n    vec3 p = pos;\r\n    \r\n    for (int i=0; i<20; i++)\r\n    {\r\n        float n = (perlin(p + vec3(time*0.2f,0,0)) + perlin(p - vec3(time*0.2f,0.5f,0.5f))) * 0.5;\r\n        float h = mix(n*0.5f, 0.5f, clamp(length(p)*0.5f,0.0,1.0));\r\n        p += ray*clamp(h - 0.1f,0.0f,1.0f);\r\n    }\r\n    return p;\r\n}\r\n\r\nvec3 ofx;\r\nvec3 ofy;\r\n\r\nvec4 effect5( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    vec3 p = marh(pos,ray,0.0,seed);\r\n    vec3 p1 = marh(pos,normalize(ray+ofx),0.0,seed);\r\n    vec3 p2 = marh(pos,normalize(ray+ofy),0.0,seed);\r\n    vec3 n = normalize(cross(p1-p,p2-p));\r\n       \r\n    //a = (0.8-clamp(length(p-pos)*0.1f,0.0,1.0))*2.0f;\r\n    a = clamp(dot(n,normalize(vec3(0,0.0,1.0))),0.0,1.0);\r\n    \r\n    return vec4(1,1,1,1)*a;\r\n}\r\n\r\nfloat circle( vec2 uv, vec2 pos, float r, float w, float a)\r\n{\r\n    float c = abs(length(uv - pos) - r) - w;\r\n    return 1.0-clamp(c/a,0.0,1.0);\r\n}\r\n\r\nfloat fillcircle( vec2 uv, vec2 pos, float r, float a)\r\n{\r\n    float c = (length(uv - pos) - r);\r\n    return 1.0-clamp(c/a,0.0,1.0);\r\n}\r\n\r\nfloat noise(vec2 uv)\r\n{\r\n    return texture(iChannel0,uv*0.04f).x;\r\n}\r\n\r\nfloat noise(vec3 uv)\r\n{\r\n    return texture(iChannel0,uv.xy*0.04f).x;\r\n}\r\n\r\nfloat perlin(vec2 uv)\r\n{\r\n    return noise(uv) * noise(uv*2.0f)*0.9f + noise(uv*6.0f)*0.1f;\r\n}    \r\n\r\nvec2 repeat(vec2 uv, int count)\r\n{\r\n    float seg = 6.283185307179586476925286766559f/float(count);\r\n    float v = fract(atan(uv.x,uv.y)/seg) * seg - seg*0.5f;\r\n    return vec2(sin(v),cos(v)) * length(uv);\r\n}\r\n\r\nvec2 rotate(vec2 uv, float a)\r\n{\r\n    float v = atan(uv.x,uv.y)+a;\r\n    return vec2(sin(v),cos(v)) * length(uv);\r\n}\r\n\r\n// magic rings map\r\nfloat rings(vec2 uv, float t)\r\n{\r\n\tfloat a = 0.0;\r\n    float tr = length(uv);\r\n    tr = tr>3.4f ? t*0.1f : tr>2.4f ? -t*0.1f : 0.0;\r\n    float g = clamp((perlin(rotate(uv,tr)*15.0f)-0.23f)*10.0f,0.0f,1.0f);\r\n    float gb = clamp((perlin(uv*5.0f)-0.2f)*100.0f,0.0f,1.0f);\r\n    gb *= clamp((perlin(uv*5.0f + vec2(100.0f))-0.25f)*100.0f,0.0f,1.0f);\r\n    \r\n    float r2 = clamp((t-1.0f)*2.0f + sin(t*20.0f)*0.03f,0.0,1.0f);\r\n    a += circle(uv,vec2(0.0,0.0),2.1f,0.01f,0.02f)*r2;\r\n    a += circle(uv,vec2(0.0,0.0),2.2f,0.02f,0.02f)*r2;\r\n    a += circle(uv,vec2(0.0,0.0),2.35f,0.05f,0.02f)*g*r2;\r\n    float r1 = clamp((t-1.6f)*8.0f + sin(t*40.0f) * 0.4f,0.0,1.0f);\r\n    a += circle(uv,vec2(0.0,0.0),2.8f,0.02f,0.02f)*r1;\r\n    a += circle(uv,vec2(0.0,0.0),3.1f,0.02f,0.02f)*r1;\r\n    a += circle(uv,vec2(0.0,0.0),2.95f,0.05f,0.02f)*g*r1;\r\n    a += circle(uv,vec2(0.0,0.0),3.2f,0.01f,0.02f)*r1;\r\n    float r0 = clamp((t-2.3f)*5.0f + sin(t*50.0f),0.0,1.0f);\r\n    a += circle(uv,vec2(0.0,0.0),3.8f,0.01f,0.02f) * 0.5f * r0;\r\n    a += circle(uv,vec2(0.0,0.0),3.95f,0.05f,0.02f)*g * 0.5f * r0;\r\n    \r\n    float c2 = clamp((t-0.5f)*2.0f + sin(t*20.0f)*0.03f,0.0,1.0f);\r\n    float p2 = clamp((t-0.5f)*2.0f,0.0,1.0f);\r\n    vec2 uvs = repeat(uv, E6_COUNT);\r\n    a = max(a - fillcircle(uvs,vec2(0.0,3.0-p2),0.64f,0.02f)*c2,0.0);\r\n    a += circle(uvs,vec2(0.0,3.0-p2),0.5f,0.03f,0.03f)*c2;\r\n    a += circle(uvs,vec2(0.0,3.0-p2),0.63f,0.01f,0.02f)*c2;\r\n    a += fillcircle(uvs,vec2(0.0,3.0-p2),0.3f,0.02f)*gb*c2 * r2;\r\n    \r\n    float p3 = sin(clamp(t,0.0,1.0f)*1.57);\r\n    uvs *= 5.0;\r\n    a += circle(uvs,vec2(-10.3 + p3*6.0f,2.2),5.0f,0.1f,0.2f);\r\n    a += circle(uvs,vec2(10.3 - p3*6.0f,2.2),5.0f,0.1f,0.2f);\r\n\r\n    a += circle(uvs,vec2(-10.3 + p3*6.0f,2.2),4.2f,0.02f,0.2f);\r\n    a += circle(uvs,vec2(10.3 - p3*6.0f,2.2),4.2f,0.02f,0.2f);\r\n    \r\n    a = max(a - fillcircle(uv,vec2(0.0,0.0),0.71f * p3,0.02f)*0.9f,0.0);\r\n    a += circle(uv,vec2(0.0,0.0),0.6f*p3,0.02f,0.02f);\r\n    a += circle(uv,vec2(0.0,0.0),0.7f*p3,0.01f,0.02f);\r\n    return clamp(a,0.0,1.0);\r\n}\r\n\r\n// magic rings\r\nvec4 effect6(vec3 pos, vec3 ray, float t)\r\n{\r\n    vec3 fn = vec3(0.0,1.0,0.0);\r\n    vec3 fp = vec3(0.0,0.0,0.0);\r\n    vec2 pe6 = (ray *dot(pos+fp,fn)/dot(ray,fn)-pos).xz * 4.0f;\r\n\r\n    vec4 en = vec4(0.5,1.0,0.5,1.0) * perlin(vec2(length(pe6)*0.5f-t*3.0f,atan(pe6.x,pe6.y)*10.0f)) * clamp(1.0-length(pe6)*0.2f,0.0,1.0);\r\n    \r\n\treturn vec4(1.0) * rings(pe6,t) + vec4(1.0,0.0,1.0,1.0) * rings(pe6*0.96f,t)*0.5f\r\n        + en * clamp(t*0.4,0.0,1.0);\r\n}\r\n\r\n// cylinder vec3(forward, back, radius)\r\nvec3 cyl(vec3 pos, vec3 ray, vec3 p, vec3 ax, float r)\r\n{\r\n    vec3 n = cross(ray,ax);\r\n    float ln = length(n);\r\n    n = normalize(n);\r\n    float rl = abs(dot(n, pos - p));\r\n    if (rl>=r)\r\n        return vec3(0.0,0.0,1.0);\r\n    float d = dot(pos-p,n);\r\n\r\n    float t = dot(cross(pos-p,ax),n)/ln;\r\n    float it = 1.0/dot(ray,normalize(cross(n,ax)));\r\n    float s = abs (sqrt(r*r - d*d) *it);\r\n    return vec3(t+s,t-s,rl/r);\r\n}\r\n\r\nvec2 clampcyl(float ry,float py,vec2 cyl, float f, float t)\r\n{\r\n    return (vec2(1.0)-clamp(ry*cyl.xy-vec2(py)+vec2(f),vec2(0.0),vec2(1.0)))*clamp(ry*cyl.xy-vec2(py)+vec2(t),vec2(0.0),vec2(1.0));\r\n}\r\n\r\nfloat lc(vec3 pos)\r\n{\r\n    pos.y*=0.25f;\r\n    float a=noise(pos*2.0f)*0.4f + noise(pos*4.0f)*0.3f + noise(pos*10.0f)*0.2f+ noise(pos*20.0f)*0.1f;\r\n    return clamp((0.5f-abs(0.5f-a))*20.0f-8.0f,0.0,1.0);\r\n}\r\n\r\n// force column\r\nvec4 effect7( vec3 pos, vec3 ray, float time)\r\n{\r\n    float a = 0.0f;\r\n        \r\n    //vec3 c1 = cyl(pos-vec3(0.7,0,0),ray, vec3(0.0),vec3(0.0,1.0,0.0),0.25f);\r\n    //vec3 c2 = cyl(pos-vec3(0.7,0,0),ray, vec3(0.0),vec3(0.0,1.0,0.0),0.20f);\r\n    vec3 c1 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),0.25f);\r\n    vec3 c2 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),0.20f);\r\n    vec3 c3 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),clamp(4.25-time,0.0,1.0f)*100.0f);\r\n    \r\n    vec2 l1 = clampcyl(ray.y,pos.y,c1.xy,0.0,1000.0);\r\n    vec2 l2 = clampcyl(ray.y,pos.y,c2.xy,0.0,1000.0);\r\n    \r\n    a += (1.0-c2.z)*clamp(l2.x+l2.y,0.0,1.0);\r\n    float v = lc((ray*c1.x-pos)+vec3(0,time*10.0f,0))*2.0f*l1.x;\r\n        ;\r\n    a += abs(c1.x-c1.y)>0.0f ? (mix(a+l1.y*lc((ray*c1.y-pos)+vec3(0,time*10.0f,0))*0.5f, v*0.5f, v))*(1.0-c1.z) : 0.0;\r\n    a = a*clamp((time-4.2)*10.0f,0.0,1.0);\r\n    return vec4(1,1,0.5,1)*a + vec4(1.0f)*(1.0-c3.z)*clamp((time-4.1)*10.0f,0.0,1.0);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\r\n\r\n    float time=iTime*1.0;\r\n    \r\n    // Ray, position and rotation\r\n    float mx = iMouse.z>0.0?iMouse.y/iResolution.y*1.5 - 1.5:-0.6;\r\n    //float mx = iMouse.z>0.0?iMouse.y/iResolution.y*4.0 - 2.0:-0.6;\r\n\tfloat my = iMouse.z>0.0?iMouse.x/iResolution.x*10.0:time*0.025;\r\n    mat3 imr = rotateX(mx) * rotateY(-my);\r\n    vec3 ray = normalize(vec3(p,2.0))*imr;\r\n    ofx = vec3(0.1,0.0,0.0)*imr;\r\n    ofy = vec3(0.0,0.1,0.0)*imr;\r\n    vec3 pos = vec3(0.0,0.2,-3.0)*imr;\r\n\r\n    // Output to screen\r\n    float a = 0.0;\r\n    \r\n    fragColor = iTime > 4.2f && iTime < 6.0f ? effect1(pos,ray,iTime,0) : vec4(0);\r\n    fragColor += mix(effect6(pos,ray,iTime-1.6f)*clamp(time-1.6,0.0,1.0)\r\n        + effect7(pos,ray,time)\r\n        + effect3(pos,ray,iTime,0)*clamp(time*0.25,0.0,1.0)\r\n                     + effect2(pos,ray,iTime,0)*clamp((time-1.5f)*3.0f,0.0,1.0)\r\n                     + effect4(pos,ray,iTime,0)*clamp(time-0.5f,0.0,1.0),vec4(1.0f),a);\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"#define E1_COUNT 200\r\n#define E1_RADIUS 0.01f\r\n#define E1_RADIUS2 0.2f\r\n#define E1_RANGE 0.4f\r\n\r\n#define E2_COUNT 5\r\n#define E2_RADIUS 0.1f\r\n    \r\n#define E3_COUNT 20\r\n#define E3_RADIUS 0.1f\r\n#define E3_RADIUS2 2.0f\r\n\r\n#define E4_COUNT 10\r\n#define E4_RADIUS 0.2f\r\n#define E4_RADIUS2 0.1f\r\n\r\n#define E6_COUNT 5\r\n\r\nmat3 rotateX(float a)\r\n{\r\n    float sx = sin(a), cx = cos(a);\r\n    return mat3(vec3(1.0,0.0,0.0),vec3(0.0,cx,sx),vec3(0.0,-sx,cx));\r\n}\r\n\r\nmat3 rotateY(float a)\r\n{\r\n    float sy = sin(a), cy = cos(a);\r\n    return mat3(vec3(cy,0.0,-sy),vec3(0.0,1.0,0.0),vec3(sy,0.0,cy));\r\n}\r\n\r\nfloat hash(float a)\r\n{\r\n    return fract(5147.4235*sin(a*0.012345f));\r\n}\r\n\r\nvec3 hash3(vec3 a)\r\n{\r\n    return fract(5147.4235*sin(vec3(55.123,43.45,16.123) + dot(a,vec3(1.0f,14.554,145.34f))*0.012345f));\r\n}\r\n\r\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\r\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\r\nvec4 hash4( vec4 n ) { return fract(sin(n)*753.5453123); }\r\nfloat noise3( vec3 x, float seed )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + dot(p.yz,vec2(157.0,113.0)) + seed;\r\n    vec4 s1=mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),vec4(f.x));\r\n    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\r\n}\r\n\r\nvec3 noisepos(int seed)\r\n{\r\n    return vec3(fract(5147.4235*sin(vec3(55.123,43.45,16.123) + vec3(float(seed)*0.012345f)))) - 0.5f;\r\n}\r\n\r\n/*vec3 lnoiseadd(vec3 p)\r\n{\r\n    return vec3(noise3(p,0.0f),noise3(p,10.0f),noise3(p,4.0f)) - vec3(0.5f);\r\n}*/\r\n\r\nvec3 lnoiseadd(vec3 p)\r\n{\r\n    return texture(iChannel0,p.xy*0.1f).xyz - vec3(0.5f);\r\n}\r\n\r\n// particles\r\nvec4 effect1( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0;\r\n    float sr = 6.283f / float(E1_COUNT);\r\n\r\n    for (int i=0; i<E1_COUNT;i++)\r\n    {\r\n        float t = fract(time*0.5 - hash(float(i+seed))*0.3f*E1_RANGE);\r\n        t = sqrt(t);\r\n        float r = t*2.0f;\r\n        vec3 p = vec3(sin(float(i)*sr),0,cos(float(i)*sr));\r\n        p = normalize(p + lnoiseadd(p*20.0f+p*r*0.3f)*vec3(0.1f,1.0f,0.1f)*E1_RANGE);\r\n        p = p * r;\r\n        p += (lnoiseadd(p*1.0f))*0.3f*(r*0.4f+0.2f);\r\n        p -= pos;\r\n        float rl = 1.0f/dot(ray,normalize(p));\r\n        float finout = clamp(r,0.0f,1.0f) * clamp(2.0-r,0.0f,1.0f);\r\n        a += (1.0f - clamp(sqrt(rl*rl - 1.0) * length(p) / mix(E1_RADIUS,E1_RADIUS2,t),0.0,1.0)) * finout*0.5f;\r\n    }\r\n\r\n    return vec4(0.5,0.5,0.5,1)*a;\r\n}\r\n\r\n// rays\r\nvec4 effect2( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    for (int i=0; i<E2_COUNT; i++)\r\n    {\r\n        float tm = time*4.0f - hash(float(i+seed));\r\n    \tint s=int(floor(tm));\r\n        float io = fract(tm)* (1.0-fract(tm))*2.0f;\r\n    \r\n    \tvec3 nr = normalize(noisepos(seed+s*E2_COUNT+i));\r\n    \r\n    \tvec3 n = cross(nr,ray);\r\n    \tfloat ln = length(n);\r\n    \tn = normalize(n);\r\n    \tfloat rl = abs(dot(n, pos))/E2_RADIUS;\r\n    \r\n    \tfloat t = dot(cross(pos,nr),n) / ln;\r\n    \tt = dot(ray*t + pos,nr);\r\n    \tt=(1.0-abs(dot(nr,ray)))*t;\r\n    \r\n    \ta += ((1.0f - clamp(rl,0.0,1.0)) * clamp(t,0.0,1.0))*io;\r\n    }\r\n    \r\n    return mix(vec4(1.0f)*a,vec4(a*0.2f+0.5f,a*0.2f+0.5f,1,1)*a,a);\r\n}\r\n\r\n// dot particles\r\nvec4 effect3( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    vec3 npp = normalize(pos);\r\n    \r\n    for (int i=0; i<E3_COUNT;i++)\r\n    {\r\n        float tm = time*1.0f - hash(float(i+seed));\r\n    \tint s=int(floor(tm));\r\n        float io = fract(tm);\r\n        vec3 np = normalize(noisepos(i + seed + s*E3_COUNT));\r\n        vec3 p = np * sqrt(1.0f-io)*E3_RADIUS2 - pos;\r\n        \r\n        float ad=0.0;\r\n        for (int k=0;k<11;k++)\r\n        {\r\n            p += np*0.03f;\r\n        \tfloat rl = 1.0f/dot(ray,normalize(p));\r\n        \trl = (sqrt(rl*rl - 1.0));\r\n        \tad += (1.0f - clamp(rl * length(p) / E3_RADIUS,0.0,1.0))*abs(6.0f-float(5-k))*0.03f * io;\r\n        }\r\n        a += ad*ad;\r\n    }\r\n    \r\n    return vec4(a*a,a*a,a,1);\r\n}\r\n\r\n// core particles\r\nvec4 effect4( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    vec3 npp = normalize(pos);\r\n    \r\n    for (int i=0; i<E4_COUNT; i++)\r\n    {\r\n        float tm = time*1.0f - hash(float(i+seed)+floor(time));\r\n    \tint s=int(floor(tm));\r\n        float io = fract(tm) * (1.0-fract(tm));\r\n        vec3 np = normalize(noisepos(i + seed + s*E4_COUNT));\r\n        vec3 p = np * E4_RADIUS2 - pos;\r\n        float rl = 1.0f/dot(ray,normalize(p));\r\n        rl = (sqrt(rl*rl - 1.0));\r\n        a+= (1.0f - clamp(rl / E4_RADIUS,0.0,1.0)) * io;\r\n    }\r\n    \r\n    return vec4(a*a,a*a,a,1);\r\n}\r\n\r\nfloat perlin(vec3 p)\r\n{\r\n    //return texture(iChannel0,p*0.2f).x*0.4 + texture(iChannel0,p*0.4f).x*0.4 + texture(iChannel0,p*0.8f).x*0.2;\r\n    return texture(iChannel0,p.xy*0.2f).x;\r\n}\r\n\r\nvec3 marh(vec3 pos, vec3 ray, float time, int seed)\r\n{\r\n    vec3 p = pos;\r\n    \r\n    for (int i=0; i<20; i++)\r\n    {\r\n        float n = (perlin(p + vec3(time*0.2f,0,0)) + perlin(p - vec3(time*0.2f,0.5f,0.5f))) * 0.5;\r\n        float h = mix(n*0.5f, 0.5f, clamp(length(p)*0.5f,0.0,1.0));\r\n        p += ray*clamp(h - 0.1f,0.0f,1.0f);\r\n    }\r\n    return p;\r\n}\r\n\r\nvec3 ofx;\r\nvec3 ofy;\r\n\r\nvec4 effect5( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    vec3 p = marh(pos,ray,0.0,seed);\r\n    vec3 p1 = marh(pos,normalize(ray+ofx),0.0,seed);\r\n    vec3 p2 = marh(pos,normalize(ray+ofy),0.0,seed);\r\n    vec3 n = normalize(cross(p1-p,p2-p));\r\n       \r\n    //a = (0.8-clamp(length(p-pos)*0.1f,0.0,1.0))*2.0f;\r\n    a = clamp(dot(n,normalize(vec3(0,0.0,1.0))),0.0,1.0);\r\n    \r\n    return vec4(1,1,1,1)*a;\r\n}\r\n\r\nfloat circle( vec2 uv, vec2 pos, float r, float w, float a)\r\n{\r\n    float c = abs(length(uv - pos) - r) - w;\r\n    return 1.0-clamp(c/a,0.0,1.0);\r\n}\r\n\r\nfloat fillcircle( vec2 uv, vec2 pos, float r, float a)\r\n{\r\n    float c = (length(uv - pos) - r);\r\n    return 1.0-clamp(c/a,0.0,1.0);\r\n}\r\n\r\nfloat noise(vec2 uv)\r\n{\r\n    return texture(iChannel0,uv*0.04f).x;\r\n}\r\n\r\nfloat noise(vec3 uv)\r\n{\r\n    return texture(iChannel0,uv.xy*0.04f).x;\r\n}\r\n\r\nfloat perlin(vec2 uv)\r\n{\r\n    return noise(uv) * noise(uv*2.0f)*0.9f + noise(uv*6.0f)*0.1f;\r\n}    \r\n\r\nvec2 repeat(vec2 uv, int count)\r\n{\r\n    float seg = 6.283185307179586476925286766559f/float(count);\r\n    float v = fract(atan(uv.x,uv.y)/seg) * seg - seg*0.5f;\r\n    return vec2(sin(v),cos(v)) * length(uv);\r\n}\r\n\r\nvec2 rotate(vec2 uv, float a)\r\n{\r\n    float v = atan(uv.x,uv.y)+a;\r\n    return vec2(sin(v),cos(v)) * length(uv);\r\n}\r\n\r\n// magic rings map\r\nfloat rings(vec2 uv, float t)\r\n{\r\n\tfloat a = 0.0;\r\n    float tr = length(uv);\r\n    tr = tr>3.4f ? t*0.1f : tr>2.4f ? -t*0.1f : 0.0;\r\n    float g = clamp((perlin(rotate(uv,tr)*15.0f)-0.23f)*10.0f,0.0f,1.0f);\r\n    float gb = clamp((perlin(uv*5.0f)-0.2f)*100.0f,0.0f,1.0f);\r\n    gb *= clamp((perlin(uv*5.0f + vec2(100.0f))-0.25f)*100.0f,0.0f,1.0f);\r\n    \r\n    float r2 = clamp((t-1.0f)*2.0f + sin(t*20.0f)*0.03f,0.0,1.0f);\r\n    a += circle(uv,vec2(0.0,0.0),2.1f,0.01f,0.02f)*r2;\r\n    a += circle(uv,vec2(0.0,0.0),2.2f,0.02f,0.02f)*r2;\r\n    a += circle(uv,vec2(0.0,0.0),2.35f,0.05f,0.02f)*g*r2;\r\n    float r1 = clamp((t-1.6f)*8.0f + sin(t*40.0f) * 0.4f,0.0,1.0f);\r\n    a += circle(uv,vec2(0.0,0.0),2.8f,0.02f,0.02f)*r1;\r\n    a += circle(uv,vec2(0.0,0.0),3.1f,0.02f,0.02f)*r1;\r\n    a += circle(uv,vec2(0.0,0.0),2.95f,0.05f,0.02f)*g*r1;\r\n    a += circle(uv,vec2(0.0,0.0),3.2f,0.01f,0.02f)*r1;\r\n    float r0 = clamp((t-2.3f)*5.0f + sin(t*50.0f),0.0,1.0f);\r\n    a += circle(uv,vec2(0.0,0.0),3.8f,0.01f,0.02f) * 0.5f * r0;\r\n    a += circle(uv,vec2(0.0,0.0),3.95f,0.05f,0.02f)*g * 0.5f * r0;\r\n    \r\n    float c2 = clamp((t-0.5f)*2.0f + sin(t*20.0f)*0.03f,0.0,1.0f);\r\n    float p2 = clamp((t-0.5f)*2.0f,0.0,1.0f);\r\n    vec2 uvs = repeat(uv, E6_COUNT);\r\n    a = max(a - fillcircle(uvs,vec2(0.0,3.0-p2),0.64f,0.02f)*c2,0.0);\r\n    a += circle(uvs,vec2(0.0,3.0-p2),0.5f,0.03f,0.03f)*c2;\r\n    a += circle(uvs,vec2(0.0,3.0-p2),0.63f,0.01f,0.02f)*c2;\r\n    a += fillcircle(uvs,vec2(0.0,3.0-p2),0.3f,0.02f)*gb*c2 * r2;\r\n    \r\n    float p3 = sin(clamp(t,0.0,1.0f)*1.57);\r\n    uvs *= 5.0;\r\n    a += circle(uvs,vec2(-10.3 + p3*6.0f,2.2),5.0f,0.1f,0.2f);\r\n    a += circle(uvs,vec2(10.3 - p3*6.0f,2.2),5.0f,0.1f,0.2f);\r\n\r\n    a += circle(uvs,vec2(-10.3 + p3*6.0f,2.2),4.2f,0.02f,0.2f);\r\n    a += circle(uvs,vec2(10.3 - p3*6.0f,2.2),4.2f,0.02f,0.2f);\r\n    \r\n    a = max(a - fillcircle(uv,vec2(0.0,0.0),0.71f * p3,0.02f)*0.9f,0.0);\r\n    a += circle(uv,vec2(0.0,0.0),0.6f*p3,0.02f,0.02f);\r\n    a += circle(uv,vec2(0.0,0.0),0.7f*p3,0.01f,0.02f);\r\n    return clamp(a,0.0,1.0);\r\n}\r\n\r\n// magic rings\r\nvec4 effect6(vec3 pos, vec3 ray, float t)\r\n{\r\n    vec3 fn = vec3(0.0,1.0,0.0);\r\n    vec3 fp = vec3(0.0,0.0,0.0);\r\n    vec2 pe6 = (ray *dot(pos+fp,fn)/dot(ray,fn)-pos).xz * 4.0f;\r\n\r\n    vec4 en = vec4(0.5,1.0,0.5,1.0) * perlin(vec2(length(pe6)*0.5f-t*3.0f,atan(pe6.x,pe6.y)*10.0f)) * clamp(1.0-length(pe6)*0.2f,0.0,1.0);\r\n    \r\n\treturn vec4(1.0) * rings(pe6,t) + vec4(1.0,0.0,1.0,1.0) * rings(pe6*0.96f,t)*0.5f\r\n        + en * clamp(t*0.4,0.0,1.0);\r\n}\r\n\r\n// cylinder vec3(forward, back, radius)\r\nvec3 cyl(vec3 pos, vec3 ray, vec3 p, vec3 ax, float r)\r\n{\r\n    vec3 n = cross(ray,ax);\r\n    float ln = length(n);\r\n    n = normalize(n);\r\n    float rl = abs(dot(n, pos - p));\r\n    if (rl>=r)\r\n        return vec3(0.0,0.0,1.0);\r\n    float d = dot(pos-p,n);\r\n\r\n    float t = dot(cross(pos-p,ax),n)/ln;\r\n    float it = 1.0/dot(ray,normalize(cross(n,ax)));\r\n    float s = abs (sqrt(r*r - d*d) *it);\r\n    return vec3(t+s,t-s,rl/r);\r\n}\r\n\r\nvec2 clampcyl(float ry,float py,vec2 cyl, float f, float t)\r\n{\r\n    return (vec2(1.0)-clamp(ry*cyl.xy-vec2(py)+vec2(f),vec2(0.0),vec2(1.0)))*clamp(ry*cyl.xy-vec2(py)+vec2(t),vec2(0.0),vec2(1.0));\r\n}\r\n\r\nfloat lc(vec3 pos)\r\n{\r\n    pos.y*=0.25f;\r\n    float a=noise(pos*2.0f)*0.4f + noise(pos*4.0f)*0.3f + noise(pos*10.0f)*0.2f+ noise(pos*20.0f)*0.1f;\r\n    return clamp((0.5f-abs(0.5f-a))*20.0f-8.0f,0.0,1.0);\r\n}\r\n\r\n// force column\r\nvec4 effect7( vec3 pos, vec3 ray, float time)\r\n{\r\n    float a = 0.0f;\r\n        \r\n    //vec3 c1 = cyl(pos-vec3(0.7,0,0),ray, vec3(0.0),vec3(0.0,1.0,0.0),0.25f);\r\n    //vec3 c2 = cyl(pos-vec3(0.7,0,0),ray, vec3(0.0),vec3(0.0,1.0,0.0),0.20f);\r\n    vec3 c1 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),0.25f);\r\n    vec3 c2 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),0.20f);\r\n    vec3 c3 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),clamp(4.25-time,0.0,1.0f)*100.0f);\r\n    \r\n    vec2 l1 = clampcyl(ray.y,pos.y,c1.xy,0.0,1000.0);\r\n    vec2 l2 = clampcyl(ray.y,pos.y,c2.xy,0.0,1000.0);\r\n    \r\n    a += (1.0-c2.z)*clamp(l2.x+l2.y,0.0,1.0);\r\n    float v = lc((ray*c1.x-pos)+vec3(0,time*10.0f,0))*2.0f*l1.x;\r\n        ;\r\n    a += abs(c1.x-c1.y)>0.0f ? (mix(a+l1.y*lc((ray*c1.y-pos)+vec3(0,time*10.0f,0))*0.5f, v*0.5f, v))*(1.0-c1.z) : 0.0;\r\n    a = a*clamp((time-4.2)*10.0f,0.0,1.0);\r\n    return vec4(1,1,0.5,1)*a + vec4(1.0f)*(1.0-c3.z)*clamp((time-4.1)*10.0f,0.0,1.0);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\r\n\r\n    float time=iTime*1.0;\r\n    \r\n    // Ray, position and rotation\r\n    float mx = iMouse.z>0.0?iMouse.y/iResolution.y*1.5 - 1.5:-0.6;\r\n    //float mx = iMouse.z>0.0?iMouse.y/iResolution.y*4.0 - 2.0:-0.6;\r\n\tfloat my = iMouse.z>0.0?iMouse.x/iResolution.x*10.0:time*0.025;\r\n    mat3 imr = rotateX(mx) * rotateY(-my);\r\n    vec3 ray = normalize(vec3(p,2.0))*imr;\r\n    ofx = vec3(0.1,0.0,0.0)*imr;\r\n    ofy = vec3(0.0,0.1,0.0)*imr;\r\n    vec3 pos = vec3(0.0,0.2,-3.0)*imr;\r\n\r\n    // Output to screen\r\n    float a = 0.0;\r\n    \r\n    fragColor = iTime > 4.2f && iTime < 6.0f ? effect1(pos,ray,iTime,0) : vec4(0);\r\n    fragColor += mix(effect6(pos,ray,iTime-1.6f)*clamp(time-1.6,0.0,1.0)\r\n        + effect7(pos,ray,time)\r\n        + effect3(pos,ray,iTime,0)*clamp(time*0.25,0.0,1.0)\r\n                     + effect2(pos,ray,iTime,0)*clamp((time-1.5f)*3.0f,0.0,1.0)\r\n                     + effect4(pos,ray,iTime,0)*clamp(time-0.5f,0.0,1.0),vec4(1.0f),a);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":null,"published":0}],"Info":{"Name":"Special effect ","id":null,"date":null,"viewed":0,"name":"Special effect ","description":"A small effect that combines several mechanics used in the creation of special effects.","likes":0,"published":null,"tags":["noise"," particles"," effect"," primitives"," geometry"]},"ver":null,"info":{"Name":"Special effect ","id":null,"date":null,"viewed":0,"name":"Special effect ","description":"A small effect that combines several mechanics used in the creation of special effects.","likes":0,"published":null,"tags":["noise"," particles"," effect"," primitives"," geometry"]},"renderpass":[{"Code":"#define E1_COUNT 200\r\n#define E1_RADIUS 0.01f\r\n#define E1_RADIUS2 0.2f\r\n#define E1_RANGE 0.4f\r\n\r\n#define E2_COUNT 5\r\n#define E2_RADIUS 0.1f\r\n    \r\n#define E3_COUNT 20\r\n#define E3_RADIUS 0.1f\r\n#define E3_RADIUS2 2.0f\r\n\r\n#define E4_COUNT 10\r\n#define E4_RADIUS 0.2f\r\n#define E4_RADIUS2 0.1f\r\n\r\n#define E6_COUNT 5\r\n\r\nmat3 rotateX(float a)\r\n{\r\n    float sx = sin(a), cx = cos(a);\r\n    return mat3(vec3(1.0,0.0,0.0),vec3(0.0,cx,sx),vec3(0.0,-sx,cx));\r\n}\r\n\r\nmat3 rotateY(float a)\r\n{\r\n    float sy = sin(a), cy = cos(a);\r\n    return mat3(vec3(cy,0.0,-sy),vec3(0.0,1.0,0.0),vec3(sy,0.0,cy));\r\n}\r\n\r\nfloat hash(float a)\r\n{\r\n    return fract(5147.4235*sin(a*0.012345f));\r\n}\r\n\r\nvec3 hash3(vec3 a)\r\n{\r\n    return fract(5147.4235*sin(vec3(55.123,43.45,16.123) + dot(a,vec3(1.0f,14.554,145.34f))*0.012345f));\r\n}\r\n\r\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\r\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\r\nvec4 hash4( vec4 n ) { return fract(sin(n)*753.5453123); }\r\nfloat noise3( vec3 x, float seed )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + dot(p.yz,vec2(157.0,113.0)) + seed;\r\n    vec4 s1=mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),vec4(f.x));\r\n    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\r\n}\r\n\r\nvec3 noisepos(int seed)\r\n{\r\n    return vec3(fract(5147.4235*sin(vec3(55.123,43.45,16.123) + vec3(float(seed)*0.012345f)))) - 0.5f;\r\n}\r\n\r\n/*vec3 lnoiseadd(vec3 p)\r\n{\r\n    return vec3(noise3(p,0.0f),noise3(p,10.0f),noise3(p,4.0f)) - vec3(0.5f);\r\n}*/\r\n\r\nvec3 lnoiseadd(vec3 p)\r\n{\r\n    return texture(iChannel0,p.xy*0.1f).xyz - vec3(0.5f);\r\n}\r\n\r\n// particles\r\nvec4 effect1( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0;\r\n    float sr = 6.283f / float(E1_COUNT);\r\n\r\n    for (int i=0; i<E1_COUNT;i++)\r\n    {\r\n        float t = fract(time*0.5 - hash(float(i+seed))*0.3f*E1_RANGE);\r\n        t = sqrt(t);\r\n        float r = t*2.0f;\r\n        vec3 p = vec3(sin(float(i)*sr),0,cos(float(i)*sr));\r\n        p = normalize(p + lnoiseadd(p*20.0f+p*r*0.3f)*vec3(0.1f,1.0f,0.1f)*E1_RANGE);\r\n        p = p * r;\r\n        p += (lnoiseadd(p*1.0f))*0.3f*(r*0.4f+0.2f);\r\n        p -= pos;\r\n        float rl = 1.0f/dot(ray,normalize(p));\r\n        float finout = clamp(r,0.0f,1.0f) * clamp(2.0-r,0.0f,1.0f);\r\n        a += (1.0f - clamp(sqrt(rl*rl - 1.0) * length(p) / mix(E1_RADIUS,E1_RADIUS2,t),0.0,1.0)) * finout*0.5f;\r\n    }\r\n\r\n    return vec4(0.5,0.5,0.5,1)*a;\r\n}\r\n\r\n// rays\r\nvec4 effect2( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    for (int i=0; i<E2_COUNT; i++)\r\n    {\r\n        float tm = time*4.0f - hash(float(i+seed));\r\n    \tint s=int(floor(tm));\r\n        float io = fract(tm)* (1.0-fract(tm))*2.0f;\r\n    \r\n    \tvec3 nr = normalize(noisepos(seed+s*E2_COUNT+i));\r\n    \r\n    \tvec3 n = cross(nr,ray);\r\n    \tfloat ln = length(n);\r\n    \tn = normalize(n);\r\n    \tfloat rl = abs(dot(n, pos))/E2_RADIUS;\r\n    \r\n    \tfloat t = dot(cross(pos,nr),n) / ln;\r\n    \tt = dot(ray*t + pos,nr);\r\n    \tt=(1.0-abs(dot(nr,ray)))*t;\r\n    \r\n    \ta += ((1.0f - clamp(rl,0.0,1.0)) * clamp(t,0.0,1.0))*io;\r\n    }\r\n    \r\n    return mix(vec4(1.0f)*a,vec4(a*0.2f+0.5f,a*0.2f+0.5f,1,1)*a,a);\r\n}\r\n\r\n// dot particles\r\nvec4 effect3( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    vec3 npp = normalize(pos);\r\n    \r\n    for (int i=0; i<E3_COUNT;i++)\r\n    {\r\n        float tm = time*1.0f - hash(float(i+seed));\r\n    \tint s=int(floor(tm));\r\n        float io = fract(tm);\r\n        vec3 np = normalize(noisepos(i + seed + s*E3_COUNT));\r\n        vec3 p = np * sqrt(1.0f-io)*E3_RADIUS2 - pos;\r\n        \r\n        float ad=0.0;\r\n        for (int k=0;k<11;k++)\r\n        {\r\n            p += np*0.03f;\r\n        \tfloat rl = 1.0f/dot(ray,normalize(p));\r\n        \trl = (sqrt(rl*rl - 1.0));\r\n        \tad += (1.0f - clamp(rl * length(p) / E3_RADIUS,0.0,1.0))*abs(6.0f-float(5-k))*0.03f * io;\r\n        }\r\n        a += ad*ad;\r\n    }\r\n    \r\n    return vec4(a*a,a*a,a,1);\r\n}\r\n\r\n// core particles\r\nvec4 effect4( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    vec3 npp = normalize(pos);\r\n    \r\n    for (int i=0; i<E4_COUNT; i++)\r\n    {\r\n        float tm = time*1.0f - hash(float(i+seed)+floor(time));\r\n    \tint s=int(floor(tm));\r\n        float io = fract(tm) * (1.0-fract(tm));\r\n        vec3 np = normalize(noisepos(i + seed + s*E4_COUNT));\r\n        vec3 p = np * E4_RADIUS2 - pos;\r\n        float rl = 1.0f/dot(ray,normalize(p));\r\n        rl = (sqrt(rl*rl - 1.0));\r\n        a+= (1.0f - clamp(rl / E4_RADIUS,0.0,1.0)) * io;\r\n    }\r\n    \r\n    return vec4(a*a,a*a,a,1);\r\n}\r\n\r\nfloat perlin(vec3 p)\r\n{\r\n    //return texture(iChannel0,p*0.2f).x*0.4 + texture(iChannel0,p*0.4f).x*0.4 + texture(iChannel0,p*0.8f).x*0.2;\r\n    return texture(iChannel0,p.xy*0.2f).x;\r\n}\r\n\r\nvec3 marh(vec3 pos, vec3 ray, float time, int seed)\r\n{\r\n    vec3 p = pos;\r\n    \r\n    for (int i=0; i<20; i++)\r\n    {\r\n        float n = (perlin(p + vec3(time*0.2f,0,0)) + perlin(p - vec3(time*0.2f,0.5f,0.5f))) * 0.5;\r\n        float h = mix(n*0.5f, 0.5f, clamp(length(p)*0.5f,0.0,1.0));\r\n        p += ray*clamp(h - 0.1f,0.0f,1.0f);\r\n    }\r\n    return p;\r\n}\r\n\r\nvec3 ofx;\r\nvec3 ofy;\r\n\r\nvec4 effect5( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    vec3 p = marh(pos,ray,0.0,seed);\r\n    vec3 p1 = marh(pos,normalize(ray+ofx),0.0,seed);\r\n    vec3 p2 = marh(pos,normalize(ray+ofy),0.0,seed);\r\n    vec3 n = normalize(cross(p1-p,p2-p));\r\n       \r\n    //a = (0.8-clamp(length(p-pos)*0.1f,0.0,1.0))*2.0f;\r\n    a = clamp(dot(n,normalize(vec3(0,0.0,1.0))),0.0,1.0);\r\n    \r\n    return vec4(1,1,1,1)*a;\r\n}\r\n\r\nfloat circle( vec2 uv, vec2 pos, float r, float w, float a)\r\n{\r\n    float c = abs(length(uv - pos) - r) - w;\r\n    return 1.0-clamp(c/a,0.0,1.0);\r\n}\r\n\r\nfloat fillcircle( vec2 uv, vec2 pos, float r, float a)\r\n{\r\n    float c = (length(uv - pos) - r);\r\n    return 1.0-clamp(c/a,0.0,1.0);\r\n}\r\n\r\nfloat noise(vec2 uv)\r\n{\r\n    return texture(iChannel0,uv*0.04f).x;\r\n}\r\n\r\nfloat noise(vec3 uv)\r\n{\r\n    return texture(iChannel0,uv.xy*0.04f).x;\r\n}\r\n\r\nfloat perlin(vec2 uv)\r\n{\r\n    return noise(uv) * noise(uv*2.0f)*0.9f + noise(uv*6.0f)*0.1f;\r\n}    \r\n\r\nvec2 repeat(vec2 uv, int count)\r\n{\r\n    float seg = 6.283185307179586476925286766559f/float(count);\r\n    float v = fract(atan(uv.x,uv.y)/seg) * seg - seg*0.5f;\r\n    return vec2(sin(v),cos(v)) * length(uv);\r\n}\r\n\r\nvec2 rotate(vec2 uv, float a)\r\n{\r\n    float v = atan(uv.x,uv.y)+a;\r\n    return vec2(sin(v),cos(v)) * length(uv);\r\n}\r\n\r\n// magic rings map\r\nfloat rings(vec2 uv, float t)\r\n{\r\n\tfloat a = 0.0;\r\n    float tr = length(uv);\r\n    tr = tr>3.4f ? t*0.1f : tr>2.4f ? -t*0.1f : 0.0;\r\n    float g = clamp((perlin(rotate(uv,tr)*15.0f)-0.23f)*10.0f,0.0f,1.0f);\r\n    float gb = clamp((perlin(uv*5.0f)-0.2f)*100.0f,0.0f,1.0f);\r\n    gb *= clamp((perlin(uv*5.0f + vec2(100.0f))-0.25f)*100.0f,0.0f,1.0f);\r\n    \r\n    float r2 = clamp((t-1.0f)*2.0f + sin(t*20.0f)*0.03f,0.0,1.0f);\r\n    a += circle(uv,vec2(0.0,0.0),2.1f,0.01f,0.02f)*r2;\r\n    a += circle(uv,vec2(0.0,0.0),2.2f,0.02f,0.02f)*r2;\r\n    a += circle(uv,vec2(0.0,0.0),2.35f,0.05f,0.02f)*g*r2;\r\n    float r1 = clamp((t-1.6f)*8.0f + sin(t*40.0f) * 0.4f,0.0,1.0f);\r\n    a += circle(uv,vec2(0.0,0.0),2.8f,0.02f,0.02f)*r1;\r\n    a += circle(uv,vec2(0.0,0.0),3.1f,0.02f,0.02f)*r1;\r\n    a += circle(uv,vec2(0.0,0.0),2.95f,0.05f,0.02f)*g*r1;\r\n    a += circle(uv,vec2(0.0,0.0),3.2f,0.01f,0.02f)*r1;\r\n    float r0 = clamp((t-2.3f)*5.0f + sin(t*50.0f),0.0,1.0f);\r\n    a += circle(uv,vec2(0.0,0.0),3.8f,0.01f,0.02f) * 0.5f * r0;\r\n    a += circle(uv,vec2(0.0,0.0),3.95f,0.05f,0.02f)*g * 0.5f * r0;\r\n    \r\n    float c2 = clamp((t-0.5f)*2.0f + sin(t*20.0f)*0.03f,0.0,1.0f);\r\n    float p2 = clamp((t-0.5f)*2.0f,0.0,1.0f);\r\n    vec2 uvs = repeat(uv, E6_COUNT);\r\n    a = max(a - fillcircle(uvs,vec2(0.0,3.0-p2),0.64f,0.02f)*c2,0.0);\r\n    a += circle(uvs,vec2(0.0,3.0-p2),0.5f,0.03f,0.03f)*c2;\r\n    a += circle(uvs,vec2(0.0,3.0-p2),0.63f,0.01f,0.02f)*c2;\r\n    a += fillcircle(uvs,vec2(0.0,3.0-p2),0.3f,0.02f)*gb*c2 * r2;\r\n    \r\n    float p3 = sin(clamp(t,0.0,1.0f)*1.57);\r\n    uvs *= 5.0;\r\n    a += circle(uvs,vec2(-10.3 + p3*6.0f,2.2),5.0f,0.1f,0.2f);\r\n    a += circle(uvs,vec2(10.3 - p3*6.0f,2.2),5.0f,0.1f,0.2f);\r\n\r\n    a += circle(uvs,vec2(-10.3 + p3*6.0f,2.2),4.2f,0.02f,0.2f);\r\n    a += circle(uvs,vec2(10.3 - p3*6.0f,2.2),4.2f,0.02f,0.2f);\r\n    \r\n    a = max(a - fillcircle(uv,vec2(0.0,0.0),0.71f * p3,0.02f)*0.9f,0.0);\r\n    a += circle(uv,vec2(0.0,0.0),0.6f*p3,0.02f,0.02f);\r\n    a += circle(uv,vec2(0.0,0.0),0.7f*p3,0.01f,0.02f);\r\n    return clamp(a,0.0,1.0);\r\n}\r\n\r\n// magic rings\r\nvec4 effect6(vec3 pos, vec3 ray, float t)\r\n{\r\n    vec3 fn = vec3(0.0,1.0,0.0);\r\n    vec3 fp = vec3(0.0,0.0,0.0);\r\n    vec2 pe6 = (ray *dot(pos+fp,fn)/dot(ray,fn)-pos).xz * 4.0f;\r\n\r\n    vec4 en = vec4(0.5,1.0,0.5,1.0) * perlin(vec2(length(pe6)*0.5f-t*3.0f,atan(pe6.x,pe6.y)*10.0f)) * clamp(1.0-length(pe6)*0.2f,0.0,1.0);\r\n    \r\n\treturn vec4(1.0) * rings(pe6,t) + vec4(1.0,0.0,1.0,1.0) * rings(pe6*0.96f,t)*0.5f\r\n        + en * clamp(t*0.4,0.0,1.0);\r\n}\r\n\r\n// cylinder vec3(forward, back, radius)\r\nvec3 cyl(vec3 pos, vec3 ray, vec3 p, vec3 ax, float r)\r\n{\r\n    vec3 n = cross(ray,ax);\r\n    float ln = length(n);\r\n    n = normalize(n);\r\n    float rl = abs(dot(n, pos - p));\r\n    if (rl>=r)\r\n        return vec3(0.0,0.0,1.0);\r\n    float d = dot(pos-p,n);\r\n\r\n    float t = dot(cross(pos-p,ax),n)/ln;\r\n    float it = 1.0/dot(ray,normalize(cross(n,ax)));\r\n    float s = abs (sqrt(r*r - d*d) *it);\r\n    return vec3(t+s,t-s,rl/r);\r\n}\r\n\r\nvec2 clampcyl(float ry,float py,vec2 cyl, float f, float t)\r\n{\r\n    return (vec2(1.0)-clamp(ry*cyl.xy-vec2(py)+vec2(f),vec2(0.0),vec2(1.0)))*clamp(ry*cyl.xy-vec2(py)+vec2(t),vec2(0.0),vec2(1.0));\r\n}\r\n\r\nfloat lc(vec3 pos)\r\n{\r\n    pos.y*=0.25f;\r\n    float a=noise(pos*2.0f)*0.4f + noise(pos*4.0f)*0.3f + noise(pos*10.0f)*0.2f+ noise(pos*20.0f)*0.1f;\r\n    return clamp((0.5f-abs(0.5f-a))*20.0f-8.0f,0.0,1.0);\r\n}\r\n\r\n// force column\r\nvec4 effect7( vec3 pos, vec3 ray, float time)\r\n{\r\n    float a = 0.0f;\r\n        \r\n    //vec3 c1 = cyl(pos-vec3(0.7,0,0),ray, vec3(0.0),vec3(0.0,1.0,0.0),0.25f);\r\n    //vec3 c2 = cyl(pos-vec3(0.7,0,0),ray, vec3(0.0),vec3(0.0,1.0,0.0),0.20f);\r\n    vec3 c1 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),0.25f);\r\n    vec3 c2 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),0.20f);\r\n    vec3 c3 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),clamp(4.25-time,0.0,1.0f)*100.0f);\r\n    \r\n    vec2 l1 = clampcyl(ray.y,pos.y,c1.xy,0.0,1000.0);\r\n    vec2 l2 = clampcyl(ray.y,pos.y,c2.xy,0.0,1000.0);\r\n    \r\n    a += (1.0-c2.z)*clamp(l2.x+l2.y,0.0,1.0);\r\n    float v = lc((ray*c1.x-pos)+vec3(0,time*10.0f,0))*2.0f*l1.x;\r\n        ;\r\n    a += abs(c1.x-c1.y)>0.0f ? (mix(a+l1.y*lc((ray*c1.y-pos)+vec3(0,time*10.0f,0))*0.5f, v*0.5f, v))*(1.0-c1.z) : 0.0;\r\n    a = a*clamp((time-4.2)*10.0f,0.0,1.0);\r\n    return vec4(1,1,0.5,1)*a + vec4(1.0f)*(1.0-c3.z)*clamp((time-4.1)*10.0f,0.0,1.0);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\r\n\r\n    float time=iTime*1.0;\r\n    \r\n    // Ray, position and rotation\r\n    float mx = iMouse.z>0.0?iMouse.y/iResolution.y*1.5 - 1.5:-0.6;\r\n    //float mx = iMouse.z>0.0?iMouse.y/iResolution.y*4.0 - 2.0:-0.6;\r\n\tfloat my = iMouse.z>0.0?iMouse.x/iResolution.x*10.0:time*0.025;\r\n    mat3 imr = rotateX(mx) * rotateY(-my);\r\n    vec3 ray = normalize(vec3(p,2.0))*imr;\r\n    ofx = vec3(0.1,0.0,0.0)*imr;\r\n    ofy = vec3(0.0,0.1,0.0)*imr;\r\n    vec3 pos = vec3(0.0,0.2,-3.0)*imr;\r\n\r\n    // Output to screen\r\n    float a = 0.0;\r\n    \r\n    fragColor = iTime > 4.2f && iTime < 6.0f ? effect1(pos,ray,iTime,0) : vec4(0);\r\n    fragColor += mix(effect6(pos,ray,iTime-1.6f)*clamp(time-1.6,0.0,1.0)\r\n        + effect7(pos,ray,time)\r\n        + effect3(pos,ray,iTime,0)*clamp(time*0.25,0.0,1.0)\r\n                     + effect2(pos,ray,iTime,0)*clamp((time-1.5f)*3.0f,0.0,1.0)\r\n                     + effect4(pos,ray,iTime,0)*clamp(time-0.5f,0.0,1.0),vec4(1.0f),a);\r\n}\r\n","inputs":[{"id":null,"filepath":"\\media\\texture\\3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[],"code":"#define E1_COUNT 200\r\n#define E1_RADIUS 0.01f\r\n#define E1_RADIUS2 0.2f\r\n#define E1_RANGE 0.4f\r\n\r\n#define E2_COUNT 5\r\n#define E2_RADIUS 0.1f\r\n    \r\n#define E3_COUNT 20\r\n#define E3_RADIUS 0.1f\r\n#define E3_RADIUS2 2.0f\r\n\r\n#define E4_COUNT 10\r\n#define E4_RADIUS 0.2f\r\n#define E4_RADIUS2 0.1f\r\n\r\n#define E6_COUNT 5\r\n\r\nmat3 rotateX(float a)\r\n{\r\n    float sx = sin(a), cx = cos(a);\r\n    return mat3(vec3(1.0,0.0,0.0),vec3(0.0,cx,sx),vec3(0.0,-sx,cx));\r\n}\r\n\r\nmat3 rotateY(float a)\r\n{\r\n    float sy = sin(a), cy = cos(a);\r\n    return mat3(vec3(cy,0.0,-sy),vec3(0.0,1.0,0.0),vec3(sy,0.0,cy));\r\n}\r\n\r\nfloat hash(float a)\r\n{\r\n    return fract(5147.4235*sin(a*0.012345f));\r\n}\r\n\r\nvec3 hash3(vec3 a)\r\n{\r\n    return fract(5147.4235*sin(vec3(55.123,43.45,16.123) + dot(a,vec3(1.0f,14.554,145.34f))*0.012345f));\r\n}\r\n\r\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\r\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\r\nvec4 hash4( vec4 n ) { return fract(sin(n)*753.5453123); }\r\nfloat noise3( vec3 x, float seed )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + dot(p.yz,vec2(157.0,113.0)) + seed;\r\n    vec4 s1=mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),vec4(f.x));\r\n    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\r\n}\r\n\r\nvec3 noisepos(int seed)\r\n{\r\n    return vec3(fract(5147.4235*sin(vec3(55.123,43.45,16.123) + vec3(float(seed)*0.012345f)))) - 0.5f;\r\n}\r\n\r\n/*vec3 lnoiseadd(vec3 p)\r\n{\r\n    return vec3(noise3(p,0.0f),noise3(p,10.0f),noise3(p,4.0f)) - vec3(0.5f);\r\n}*/\r\n\r\nvec3 lnoiseadd(vec3 p)\r\n{\r\n    return texture(iChannel0,p.xy*0.1f).xyz - vec3(0.5f);\r\n}\r\n\r\n// particles\r\nvec4 effect1( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0;\r\n    float sr = 6.283f / float(E1_COUNT);\r\n\r\n    for (int i=0; i<E1_COUNT;i++)\r\n    {\r\n        float t = fract(time*0.5 - hash(float(i+seed))*0.3f*E1_RANGE);\r\n        t = sqrt(t);\r\n        float r = t*2.0f;\r\n        vec3 p = vec3(sin(float(i)*sr),0,cos(float(i)*sr));\r\n        p = normalize(p + lnoiseadd(p*20.0f+p*r*0.3f)*vec3(0.1f,1.0f,0.1f)*E1_RANGE);\r\n        p = p * r;\r\n        p += (lnoiseadd(p*1.0f))*0.3f*(r*0.4f+0.2f);\r\n        p -= pos;\r\n        float rl = 1.0f/dot(ray,normalize(p));\r\n        float finout = clamp(r,0.0f,1.0f) * clamp(2.0-r,0.0f,1.0f);\r\n        a += (1.0f - clamp(sqrt(rl*rl - 1.0) * length(p) / mix(E1_RADIUS,E1_RADIUS2,t),0.0,1.0)) * finout*0.5f;\r\n    }\r\n\r\n    return vec4(0.5,0.5,0.5,1)*a;\r\n}\r\n\r\n// rays\r\nvec4 effect2( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    for (int i=0; i<E2_COUNT; i++)\r\n    {\r\n        float tm = time*4.0f - hash(float(i+seed));\r\n    \tint s=int(floor(tm));\r\n        float io = fract(tm)* (1.0-fract(tm))*2.0f;\r\n    \r\n    \tvec3 nr = normalize(noisepos(seed+s*E2_COUNT+i));\r\n    \r\n    \tvec3 n = cross(nr,ray);\r\n    \tfloat ln = length(n);\r\n    \tn = normalize(n);\r\n    \tfloat rl = abs(dot(n, pos))/E2_RADIUS;\r\n    \r\n    \tfloat t = dot(cross(pos,nr),n) / ln;\r\n    \tt = dot(ray*t + pos,nr);\r\n    \tt=(1.0-abs(dot(nr,ray)))*t;\r\n    \r\n    \ta += ((1.0f - clamp(rl,0.0,1.0)) * clamp(t,0.0,1.0))*io;\r\n    }\r\n    \r\n    return mix(vec4(1.0f)*a,vec4(a*0.2f+0.5f,a*0.2f+0.5f,1,1)*a,a);\r\n}\r\n\r\n// dot particles\r\nvec4 effect3( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    vec3 npp = normalize(pos);\r\n    \r\n    for (int i=0; i<E3_COUNT;i++)\r\n    {\r\n        float tm = time*1.0f - hash(float(i+seed));\r\n    \tint s=int(floor(tm));\r\n        float io = fract(tm);\r\n        vec3 np = normalize(noisepos(i + seed + s*E3_COUNT));\r\n        vec3 p = np * sqrt(1.0f-io)*E3_RADIUS2 - pos;\r\n        \r\n        float ad=0.0;\r\n        for (int k=0;k<11;k++)\r\n        {\r\n            p += np*0.03f;\r\n        \tfloat rl = 1.0f/dot(ray,normalize(p));\r\n        \trl = (sqrt(rl*rl - 1.0));\r\n        \tad += (1.0f - clamp(rl * length(p) / E3_RADIUS,0.0,1.0))*abs(6.0f-float(5-k))*0.03f * io;\r\n        }\r\n        a += ad*ad;\r\n    }\r\n    \r\n    return vec4(a*a,a*a,a,1);\r\n}\r\n\r\n// core particles\r\nvec4 effect4( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    vec3 npp = normalize(pos);\r\n    \r\n    for (int i=0; i<E4_COUNT; i++)\r\n    {\r\n        float tm = time*1.0f - hash(float(i+seed)+floor(time));\r\n    \tint s=int(floor(tm));\r\n        float io = fract(tm) * (1.0-fract(tm));\r\n        vec3 np = normalize(noisepos(i + seed + s*E4_COUNT));\r\n        vec3 p = np * E4_RADIUS2 - pos;\r\n        float rl = 1.0f/dot(ray,normalize(p));\r\n        rl = (sqrt(rl*rl - 1.0));\r\n        a+= (1.0f - clamp(rl / E4_RADIUS,0.0,1.0)) * io;\r\n    }\r\n    \r\n    return vec4(a*a,a*a,a,1);\r\n}\r\n\r\nfloat perlin(vec3 p)\r\n{\r\n    //return texture(iChannel0,p*0.2f).x*0.4 + texture(iChannel0,p*0.4f).x*0.4 + texture(iChannel0,p*0.8f).x*0.2;\r\n    return texture(iChannel0,p.xy*0.2f).x;\r\n}\r\n\r\nvec3 marh(vec3 pos, vec3 ray, float time, int seed)\r\n{\r\n    vec3 p = pos;\r\n    \r\n    for (int i=0; i<20; i++)\r\n    {\r\n        float n = (perlin(p + vec3(time*0.2f,0,0)) + perlin(p - vec3(time*0.2f,0.5f,0.5f))) * 0.5;\r\n        float h = mix(n*0.5f, 0.5f, clamp(length(p)*0.5f,0.0,1.0));\r\n        p += ray*clamp(h - 0.1f,0.0f,1.0f);\r\n    }\r\n    return p;\r\n}\r\n\r\nvec3 ofx;\r\nvec3 ofy;\r\n\r\nvec4 effect5( vec3 pos, vec3 ray, float time, int seed )\r\n{\r\n    float a = 0.0f;\r\n    \r\n    vec3 p = marh(pos,ray,0.0,seed);\r\n    vec3 p1 = marh(pos,normalize(ray+ofx),0.0,seed);\r\n    vec3 p2 = marh(pos,normalize(ray+ofy),0.0,seed);\r\n    vec3 n = normalize(cross(p1-p,p2-p));\r\n       \r\n    //a = (0.8-clamp(length(p-pos)*0.1f,0.0,1.0))*2.0f;\r\n    a = clamp(dot(n,normalize(vec3(0,0.0,1.0))),0.0,1.0);\r\n    \r\n    return vec4(1,1,1,1)*a;\r\n}\r\n\r\nfloat circle( vec2 uv, vec2 pos, float r, float w, float a)\r\n{\r\n    float c = abs(length(uv - pos) - r) - w;\r\n    return 1.0-clamp(c/a,0.0,1.0);\r\n}\r\n\r\nfloat fillcircle( vec2 uv, vec2 pos, float r, float a)\r\n{\r\n    float c = (length(uv - pos) - r);\r\n    return 1.0-clamp(c/a,0.0,1.0);\r\n}\r\n\r\nfloat noise(vec2 uv)\r\n{\r\n    return texture(iChannel0,uv*0.04f).x;\r\n}\r\n\r\nfloat noise(vec3 uv)\r\n{\r\n    return texture(iChannel0,uv.xy*0.04f).x;\r\n}\r\n\r\nfloat perlin(vec2 uv)\r\n{\r\n    return noise(uv) * noise(uv*2.0f)*0.9f + noise(uv*6.0f)*0.1f;\r\n}    \r\n\r\nvec2 repeat(vec2 uv, int count)\r\n{\r\n    float seg = 6.283185307179586476925286766559f/float(count);\r\n    float v = fract(atan(uv.x,uv.y)/seg) * seg - seg*0.5f;\r\n    return vec2(sin(v),cos(v)) * length(uv);\r\n}\r\n\r\nvec2 rotate(vec2 uv, float a)\r\n{\r\n    float v = atan(uv.x,uv.y)+a;\r\n    return vec2(sin(v),cos(v)) * length(uv);\r\n}\r\n\r\n// magic rings map\r\nfloat rings(vec2 uv, float t)\r\n{\r\n\tfloat a = 0.0;\r\n    float tr = length(uv);\r\n    tr = tr>3.4f ? t*0.1f : tr>2.4f ? -t*0.1f : 0.0;\r\n    float g = clamp((perlin(rotate(uv,tr)*15.0f)-0.23f)*10.0f,0.0f,1.0f);\r\n    float gb = clamp((perlin(uv*5.0f)-0.2f)*100.0f,0.0f,1.0f);\r\n    gb *= clamp((perlin(uv*5.0f + vec2(100.0f))-0.25f)*100.0f,0.0f,1.0f);\r\n    \r\n    float r2 = clamp((t-1.0f)*2.0f + sin(t*20.0f)*0.03f,0.0,1.0f);\r\n    a += circle(uv,vec2(0.0,0.0),2.1f,0.01f,0.02f)*r2;\r\n    a += circle(uv,vec2(0.0,0.0),2.2f,0.02f,0.02f)*r2;\r\n    a += circle(uv,vec2(0.0,0.0),2.35f,0.05f,0.02f)*g*r2;\r\n    float r1 = clamp((t-1.6f)*8.0f + sin(t*40.0f) * 0.4f,0.0,1.0f);\r\n    a += circle(uv,vec2(0.0,0.0),2.8f,0.02f,0.02f)*r1;\r\n    a += circle(uv,vec2(0.0,0.0),3.1f,0.02f,0.02f)*r1;\r\n    a += circle(uv,vec2(0.0,0.0),2.95f,0.05f,0.02f)*g*r1;\r\n    a += circle(uv,vec2(0.0,0.0),3.2f,0.01f,0.02f)*r1;\r\n    float r0 = clamp((t-2.3f)*5.0f + sin(t*50.0f),0.0,1.0f);\r\n    a += circle(uv,vec2(0.0,0.0),3.8f,0.01f,0.02f) * 0.5f * r0;\r\n    a += circle(uv,vec2(0.0,0.0),3.95f,0.05f,0.02f)*g * 0.5f * r0;\r\n    \r\n    float c2 = clamp((t-0.5f)*2.0f + sin(t*20.0f)*0.03f,0.0,1.0f);\r\n    float p2 = clamp((t-0.5f)*2.0f,0.0,1.0f);\r\n    vec2 uvs = repeat(uv, E6_COUNT);\r\n    a = max(a - fillcircle(uvs,vec2(0.0,3.0-p2),0.64f,0.02f)*c2,0.0);\r\n    a += circle(uvs,vec2(0.0,3.0-p2),0.5f,0.03f,0.03f)*c2;\r\n    a += circle(uvs,vec2(0.0,3.0-p2),0.63f,0.01f,0.02f)*c2;\r\n    a += fillcircle(uvs,vec2(0.0,3.0-p2),0.3f,0.02f)*gb*c2 * r2;\r\n    \r\n    float p3 = sin(clamp(t,0.0,1.0f)*1.57);\r\n    uvs *= 5.0;\r\n    a += circle(uvs,vec2(-10.3 + p3*6.0f,2.2),5.0f,0.1f,0.2f);\r\n    a += circle(uvs,vec2(10.3 - p3*6.0f,2.2),5.0f,0.1f,0.2f);\r\n\r\n    a += circle(uvs,vec2(-10.3 + p3*6.0f,2.2),4.2f,0.02f,0.2f);\r\n    a += circle(uvs,vec2(10.3 - p3*6.0f,2.2),4.2f,0.02f,0.2f);\r\n    \r\n    a = max(a - fillcircle(uv,vec2(0.0,0.0),0.71f * p3,0.02f)*0.9f,0.0);\r\n    a += circle(uv,vec2(0.0,0.0),0.6f*p3,0.02f,0.02f);\r\n    a += circle(uv,vec2(0.0,0.0),0.7f*p3,0.01f,0.02f);\r\n    return clamp(a,0.0,1.0);\r\n}\r\n\r\n// magic rings\r\nvec4 effect6(vec3 pos, vec3 ray, float t)\r\n{\r\n    vec3 fn = vec3(0.0,1.0,0.0);\r\n    vec3 fp = vec3(0.0,0.0,0.0);\r\n    vec2 pe6 = (ray *dot(pos+fp,fn)/dot(ray,fn)-pos).xz * 4.0f;\r\n\r\n    vec4 en = vec4(0.5,1.0,0.5,1.0) * perlin(vec2(length(pe6)*0.5f-t*3.0f,atan(pe6.x,pe6.y)*10.0f)) * clamp(1.0-length(pe6)*0.2f,0.0,1.0);\r\n    \r\n\treturn vec4(1.0) * rings(pe6,t) + vec4(1.0,0.0,1.0,1.0) * rings(pe6*0.96f,t)*0.5f\r\n        + en * clamp(t*0.4,0.0,1.0);\r\n}\r\n\r\n// cylinder vec3(forward, back, radius)\r\nvec3 cyl(vec3 pos, vec3 ray, vec3 p, vec3 ax, float r)\r\n{\r\n    vec3 n = cross(ray,ax);\r\n    float ln = length(n);\r\n    n = normalize(n);\r\n    float rl = abs(dot(n, pos - p));\r\n    if (rl>=r)\r\n        return vec3(0.0,0.0,1.0);\r\n    float d = dot(pos-p,n);\r\n\r\n    float t = dot(cross(pos-p,ax),n)/ln;\r\n    float it = 1.0/dot(ray,normalize(cross(n,ax)));\r\n    float s = abs (sqrt(r*r - d*d) *it);\r\n    return vec3(t+s,t-s,rl/r);\r\n}\r\n\r\nvec2 clampcyl(float ry,float py,vec2 cyl, float f, float t)\r\n{\r\n    return (vec2(1.0)-clamp(ry*cyl.xy-vec2(py)+vec2(f),vec2(0.0),vec2(1.0)))*clamp(ry*cyl.xy-vec2(py)+vec2(t),vec2(0.0),vec2(1.0));\r\n}\r\n\r\nfloat lc(vec3 pos)\r\n{\r\n    pos.y*=0.25f;\r\n    float a=noise(pos*2.0f)*0.4f + noise(pos*4.0f)*0.3f + noise(pos*10.0f)*0.2f+ noise(pos*20.0f)*0.1f;\r\n    return clamp((0.5f-abs(0.5f-a))*20.0f-8.0f,0.0,1.0);\r\n}\r\n\r\n// force column\r\nvec4 effect7( vec3 pos, vec3 ray, float time)\r\n{\r\n    float a = 0.0f;\r\n        \r\n    //vec3 c1 = cyl(pos-vec3(0.7,0,0),ray, vec3(0.0),vec3(0.0,1.0,0.0),0.25f);\r\n    //vec3 c2 = cyl(pos-vec3(0.7,0,0),ray, vec3(0.0),vec3(0.0,1.0,0.0),0.20f);\r\n    vec3 c1 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),0.25f);\r\n    vec3 c2 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),0.20f);\r\n    vec3 c3 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),clamp(4.25-time,0.0,1.0f)*100.0f);\r\n    \r\n    vec2 l1 = clampcyl(ray.y,pos.y,c1.xy,0.0,1000.0);\r\n    vec2 l2 = clampcyl(ray.y,pos.y,c2.xy,0.0,1000.0);\r\n    \r\n    a += (1.0-c2.z)*clamp(l2.x+l2.y,0.0,1.0);\r\n    float v = lc((ray*c1.x-pos)+vec3(0,time*10.0f,0))*2.0f*l1.x;\r\n        ;\r\n    a += abs(c1.x-c1.y)>0.0f ? (mix(a+l1.y*lc((ray*c1.y-pos)+vec3(0,time*10.0f,0))*0.5f, v*0.5f, v))*(1.0-c1.z) : 0.0;\r\n    a = a*clamp((time-4.2)*10.0f,0.0,1.0);\r\n    return vec4(1,1,0.5,1)*a + vec4(1.0f)*(1.0-c3.z)*clamp((time-4.1)*10.0f,0.0,1.0);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\r\n\r\n    float time=iTime*1.0;\r\n    \r\n    // Ray, position and rotation\r\n    float mx = iMouse.z>0.0?iMouse.y/iResolution.y*1.5 - 1.5:-0.6;\r\n    //float mx = iMouse.z>0.0?iMouse.y/iResolution.y*4.0 - 2.0:-0.6;\r\n\tfloat my = iMouse.z>0.0?iMouse.x/iResolution.x*10.0:time*0.025;\r\n    mat3 imr = rotateX(mx) * rotateY(-my);\r\n    vec3 ray = normalize(vec3(p,2.0))*imr;\r\n    ofx = vec3(0.1,0.0,0.0)*imr;\r\n    ofy = vec3(0.0,0.1,0.0)*imr;\r\n    vec3 pos = vec3(0.0,0.2,-3.0)*imr;\r\n\r\n    // Output to screen\r\n    float a = 0.0;\r\n    \r\n    fragColor = iTime > 4.2f && iTime < 6.0f ? effect1(pos,ray,iTime,0) : vec4(0);\r\n    fragColor += mix(effect6(pos,ray,iTime-1.6f)*clamp(time-1.6,0.0,1.0)\r\n        + effect7(pos,ray,time)\r\n        + effect3(pos,ray,iTime,0)*clamp(time*0.25,0.0,1.0)\r\n                     + effect2(pos,ray,iTime,0)*clamp((time-1.5f)*3.0f,0.0,1.0)\r\n                     + effect4(pos,ray,iTime,0)*clamp(time-0.5f,0.0,1.0),vec4(1.0f),a);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Old watch (IBL). Created by Reinder Nijhoff 2018\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/lscBW4\r\n//\r\n// I have moved all ray-march code to this tab, in order to keep the IBL-code in the \r\n// 'Image tab' more readable. The physically-based properties of the materials are also \r\n// defined here.\r\n//\r\n// All (signed) distance field (SDF) code is copy-paste from the excellent framework by \r\n// Inigo Quilez:\r\n//\r\n// https://www.shadertoy.com/view/Xds3zN\r\n//\r\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n//\r\n\r\n#define MAT_TABLE    1.\r\n#define MAT_PENCIL_0 2.\r\n#define MAT_PENCIL_1 3.\r\n#define MAT_PENCIL_2 4.\r\n#define MAT_DIAL     5.\r\n#define MAT_HAND     6.\r\n#define MAT_METAL_0  7.\r\n#define MAT_METAL_1  8.\r\n\r\n#define CLOCK_ROT_X -0.26\r\n#define CLOCK_ROT_Y 0.2\r\n#define CLOCK_OFFSET_Y 0.42\r\n#define PENCIL_POS vec3(-0.31,-0.2, -.725)\r\n\r\nfloat MAX_T = 10.;\r\n\r\n//\r\n// SDF functions (by Inigo Quilez).\r\n//\r\n\r\nfloat sdPlane( const vec3 p ) {\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdTorus( const vec3 p, const vec2 t ) {\r\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\r\n  return length(q)-t.y;\r\n}\r\n\r\nfloat sdTorusYZ( const vec3 p, const vec2 t ) {\r\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\r\n  return length(q)-t.y;\r\n}\r\n\r\nfloat sdTorusYX( const vec3 p, const vec2 t ) {\r\n  vec2 q = vec2(length(p.yx)-t.x,p.z);\r\n  return length(q)-t.y;\r\n}\r\n\r\nfloat sdCylinder( const vec3 p, const vec2 h ) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat sdCylinderZY( const vec3 p, const vec2 h ) {\r\n  vec2 d = abs(vec2(length(p.zy),p.x)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat sdCylinderXY( const vec3 p, const vec2 h ) {\r\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\n\r\nfloat sdHexPrism( const vec3 p, const vec2 h ) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.x-h.y,max((q.z*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.x-h.y;\r\n    float d2 = max((q.z*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\n\r\nfloat sdEllipsoid( const vec3 p, const vec3 r ) {\r\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\r\n}\r\n\r\nfloat sdCapsule( const vec3 p, const vec3 a, const vec3 b, const float r ) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\n\r\nfloat sdSphere( const vec3 p, const float r ) {\r\n    return length(p) - r;\r\n}\r\n\r\nfloat sdCone( const vec3 p, const vec2 c ) {\r\n    float q = length(p.yz);\r\n    return dot(c,vec2(q,p.x));\r\n}\r\n\r\nfloat sdSegment2D( const vec2 p, const vec2 a, const vec2 b, const float w ) {\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - w;\r\n}\r\n\r\nfloat opS( const float d1, const float d2 ) {\r\n    return max(-d1,d2);\r\n}\r\n\r\nfloat opU( const float d1, const float d2 ) {\r\n    return min(d1,d2);\r\n}\r\n\r\nvec3 rotateX( in vec3 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.yz = mat2(co,-si,si,co)*p.yz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateY( in vec3 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xz = mat2(co,-si,si,co)*p.xz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateZ( in vec3 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xy = mat2(co,-si,si,co)*p.xy;\r\n    return p;\r\n}\r\n\r\nvec2 rotate( in vec2 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p = mat2(co,-si,si,co) * p;\r\n    return p;\r\n}\r\n\r\n//\r\n// Hash without Sine by Dave Hoskins.\r\n//\r\n\r\nfloat hash11(float p) {\r\n\tvec3 p3  = fract(vec3(p) * .1031);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\n//\r\n// SDF of the scene.\r\n//\r\n\r\nfloat mapHand( const vec3 pos, const float w, const float l, const float r ) {\r\n    float d = sdSegment2D(pos.xz, vec2(0,-w*10.), vec2(0,l), w);\r\n    d = min(d, length(pos.xz) - (.03+r));\r\n    return max(d, abs(pos.y)-.005);\r\n}\r\n\r\nvec2 map( in vec3 pos, in vec3 p1, in vec3 ps, in vec3 pm, in vec3 ph, \r\n         const bool watchIntersect, const bool pencilIntersect ) {\r\n    //--- table\r\n    vec2 res = vec2(sdPlane(pos), MAT_TABLE);\r\n    \r\n    // chain\r\n    if (pos.z > 1.1) {\r\n        float h = smoothstep(3., -.4, pos.z)*.74 + .045;\r\n        float dChain0 = length(pos.xy+vec2(.3*sin(pos.z), -h))-.1;\r\n        if (dChain0 < 0.1) {\r\n            dChain0 = 10.;\r\n            float pth1z = floor(pos.z*5.);\r\n            if (pth1z > 5.) {\r\n\t            float pth1 = hash11(floor(pos.z*5.));\r\n    \t        vec3 pt1 = vec3(pos.x + .3*sin(pos.z)- pth1 *.02 + 0.02, pos.y-h - pth1 *.03, mod(pos.z, .2) - .1);\r\n        \t    pt1 = rotateZ(pt1, .6 * smoothstep(2.,3., pos.z));\r\n            \tdChain0 = sdTorus(pt1, vec2(.071, .02)); \r\n            }\r\n            \r\n            float pth2z = floor(pos.z*5. + .5);\r\n            float pth2 = hash11(pth2z); \r\n            vec3 pt2 = vec3(pos.x + .3*sin(pos.z)- pth2 *.02 + 0.02, pos.y-h - pth2 *.03, mod(pos.z + .1, .2) - .1);\r\n            pt2 = rotateZ(pt2, 1.1 * smoothstep(2.,3., pos.z));\r\n            dChain0 = opU(dChain0, sdTorusYZ(pt2, vec2(.071, .02)));          \r\n        }\r\n        if (dChain0 < res.x) res = vec2(dChain0, MAT_METAL_1);\r\n    }\r\n    //--- pencil\r\n    if (pencilIntersect) {\r\n        float dPencil0 = sdHexPrism(pos + PENCIL_POS, vec2(.2, 2.));\r\n        dPencil0 = opS(-sdCone(pos + (PENCIL_POS + vec3(-2.05,0,0)), vec2(.95,0.3122)),dPencil0);\r\n        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.4,-2.82,-1.03)), 3.), dPencil0);\r\n        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.5,-0.82,2.86)), 3.), dPencil0);\r\n        if (dPencil0 < res.x) res = vec2(dPencil0, MAT_PENCIL_0);\r\n\r\n        float dPencil1 = sdCapsule(pos, -PENCIL_POS - vec3(2.2,0.,0.), -PENCIL_POS-vec3(2.55, 0., 0.), .21);\r\n        if (dPencil1 < res.x) res = vec2(dPencil1, MAT_PENCIL_1);\r\n        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);\r\n        float r = .02*abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\r\n\r\n        float dPencil2 = sdCylinderZY(pos + PENCIL_POS + vec3(2.25,-0.0125,0), vec2(.22 - r,.25));\r\n        if (dPencil2 < res.x) res = vec2(dPencil2, MAT_PENCIL_2);\r\n    }\r\n    \r\n    //--- watch\r\n    if (watchIntersect) {\r\n        float dDial = sdCylinder(p1, vec2(1.05,.13));\r\n        if (dDial < res.x) res = vec2(dDial, MAT_DIAL);\r\n\r\n        float dC = sdTorusYX(vec3(max(abs(p1.x)-.5*p1.y-0.19,0.),p1.y+0.12,p1.z-1.18), vec2(0.11,0.02));\r\n        if (dC < res.x) res = vec2(dC, MAT_METAL_1);\r\n        \r\n        float dM = sdTorus(p1 + vec3(0,-.165,0), vec2(1.005,.026));   \r\n        float bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15,0.04));\r\n        if(bb < 0.5) {\r\n            float a = atan(p1.y, p1.x);\r\n            float c = abs(fract(a*3.1415)-.5);\r\n            float d = min(abs(p1.z-1.3), .02);\r\n            bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15 - 40.*d*d - .1*c*c,0.04));\r\n        } \r\n        dM = opU(dM, bb);\r\n         \r\n        dM = opU(dM, sdCylinderZY(p1+vec3(0,0,-1.18), vec2(0.06,0.2)));\r\n        float rr = min(abs(p1.z-1.26), .2);\r\n        dM = opU(dM, sdCylinderXY(p1+vec3(0,0,-1.2), vec2(0.025 + 0.35*rr,0.1)));\r\n       \r\n        p1.y = abs(p1.y);\r\n        dM = opU(dM, sdTorus(p1 + vec3(0,-.1,0), vec2(1.025,.075)));\r\n        dM = opU(dM, sdCylinder(p1, vec2(1.1,.1)));\r\n        dM = opS(sdTorus(p1 + vec3(0,-.1,0), vec2(1.11,.015)), dM);\r\n        dM = opU(dM, sdCylinder(p1, vec2(0.01,0.175)));\r\n        dM = opU(dM, sdCylinder(p1+vec3(0,0,.6), vec2(0.01,0.155)));\r\n        if (dM < res.x) res = vec2(dM, MAT_METAL_0);\r\n\r\n        // minutes hand\r\n        float dMin = mapHand(pm + vec3(0,-.16,0), .02, 0.7, 0.015);\r\n        if (dMin < res.x) res = vec2(dMin, MAT_HAND);\r\n        // hours hand\r\n        float dHour = mapHand(ph + vec3(0,-.15,0), .02, 0.4, 0.03);\r\n        if (dHour < res.x) res = vec2(dHour, MAT_HAND);\r\n        // seconds hand\r\n        float dSeconds = mapHand(ps + vec3(0,-.14,0), .01, 0.17, 0.006);\r\n        if (dSeconds < res.x) res = vec2(dSeconds, MAT_HAND);\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\nvec2 map( in vec3 pos ) {\r\n    vec3 p1 = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    \r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\r\n    \r\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\r\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\r\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\r\n    \r\n    return map( pos, p1, ps, pm, ph, true, true );\r\n}\r\n\r\nfloat mapGlass( in vec3 pos ) {\r\n    return sdEllipsoid( pos - vec3(0,.10,0), vec3(1.,.2,1.) );\r\n}\r\n\r\n//\r\n// Ray march code.\r\n//\r\n\r\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float r ) {\r\n\tvec3 oc = ro;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - r * r;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n    h = sqrt( h );\r\n\treturn vec2(-b - h, -b + h);\r\n}\r\n\r\nbool boxIntserct( in vec3 ro, in vec3 rd, in vec3 rad ) {\r\n    vec3 m = 1.0/rd;\r\n    vec3 n = m*ro;\r\n    vec3 k = abs(m)*rad;\r\n\t\r\n    vec3 t1 = -n - k;\r\n    vec3 t2 = -n + k;\r\n\r\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\r\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\r\n\t\r\n\tif( tN > tF || tF < 0.0) return false;\r\n\r\n\treturn true;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos ) {\r\n    const vec2 e = vec2(1.0,-1.0)*0.0075;\r\n    return normalize( e.xyy*map( pos + e.xyy ).x + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\r\n}\r\n\r\nvec2 castRay( in vec3 ro, in vec3 rd ) {\r\n    float tmin = 0.5;\r\n    float tmax = MAX_T;\r\n    \r\n    // bounding volume\r\n    const float top = 0.95;\r\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\r\n    float tp2 = (top-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>top ) tmin = max( tmin, tp2 );\r\n                                                 else           tmax = min( tmax, tp2 ); }\r\n    \r\n    float t = tmin;\r\n    float mat = -1.;\r\n    \r\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\r\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\r\n    \r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\r\n    \r\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\r\n    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );\r\n    \r\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\r\n    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );\r\n    \r\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\r\n    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );\r\n    \r\n    bool watchIntersect = boxIntserct(p1, rd1, vec3(1.1,.2,1.4));\r\n    bool pencilIntersect = boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));\r\n    \r\n    for( int i=0; i<48; i++ ) {\r\n\t    float precis = 0.00025*t;\r\n\t    vec2 res = map( ro+rd*t, p1+rd1*t, ps+rds*t, pm+rdm*t, ph+rdh*t, \r\n                       watchIntersect, pencilIntersect );\r\n        if( res.x<precis || t>tmax ) break; //return vec2(t, mat);\r\n        t += res.x;\r\n        mat = res.y;\r\n    }\r\n\r\n    if( t>tmax ) t=-1.0;\r\n    return vec2(t, mat);\r\n}\r\n\r\nvec3 calcNormalGlass( in vec3 pos ) {\r\n    const vec2 e = vec2(1.0,-1.0)*0.005;\r\n    return normalize( e.xyy*mapGlass( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*mapGlass( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*mapGlass( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*mapGlass( pos + e.xxx ) );\r\n}\r\n\r\nfloat castRayGlass( in vec3 ro, in vec3 rd ) {\r\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\r\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\r\n\r\n    float t = -1.;\r\n    vec2 bb = sphIntersect( p1- vec3(0,.10,0), rd1, 1.);\r\n    if (bb.y > 0.) {\r\n        t = max(bb.x, 0.);\r\n        float tmax = bb.y;\r\n        for( int i=0; i<24; i++ ) {\r\n            float precis = 0.00025*t;\r\n            float res = mapGlass( p1+rd1*t );\r\n            if( res<precis || t>tmax ) break; \r\n            t += res;\r\n        }\r\n\r\n        if( t>tmax ) t=-1.0;\r\n    }\r\n    return t;\r\n}\r\n\r\n\r\nfloat calcAO( in vec3 ro, in vec3 rd ) {\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    \r\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\r\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\r\n    \r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\r\n    \r\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\r\n    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );\r\n    \r\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\r\n    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );\r\n    \r\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\r\n    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );\r\n    \r\n    bool watchIntersect = true; //boxIntserct(p1, rd1, vec3(1.1,.2,1.4));\r\n    bool pencilIntersect = true; //boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));\r\n    \r\n    \r\n    for( int i=0; i<6; i++ ) {\r\n        float h = 0.001 + 0.25*float(i)/5.0;\r\n        float d = map( ro+rd*h, p1+rd1*h, ps+rds*h, pm+rdm*h, ph+rdh*h, \r\n                       watchIntersect, pencilIntersect ).x;\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n    }\r\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \r\n}\r\n\r\n//\r\n// Material properties.\r\n//\r\n\r\nvec4 texNoise( sampler2D sam, in vec3 p, in vec3 n ) {\r\n\tvec4 x = texture( sam, p.yz );\r\n\tvec4 y = texture( sam, p.zx );\r\n\tvec4 z = texture( sam, p.xy );\r\n\r\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\r\n}\r\n\r\nvoid getMaterialProperties(\r\n    in vec3 pos, in float mat,\r\n    inout vec3 normal, inout vec3 albedo, inout float ao, inout float roughness, inout float metallic,\r\n\tsampler2D tex1, sampler2D tex2, sampler2D tex3) {\r\n    \r\n    vec3 pinv = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    pinv = rotateY( pinv, CLOCK_ROT_Y );\r\n    \r\n    normal = calcNormal( pos );\r\n    ao = calcAO(pos, normal);\r\n    metallic = 0.;\r\n    \r\n    vec4 noise = texNoise(tex1, pinv * .5, normal);\r\n    float metalnoise = 1.- noise.r;\r\n    metalnoise*=metalnoise;\r\n\r\n    mat -= .5;\r\n    if (mat < MAT_TABLE) {\r\n        albedo = .7 * pow(texture(tex1, rotate(pos.xz * .4 + .25, -.3)).rgb, 2.2*vec3(0.45,0.5,0.5));\r\n        roughness = 0.95 - albedo.r * .6;\r\n    }\r\n    else if( mat < MAT_PENCIL_0 ) {\r\n        vec2 npos = pos.yz + PENCIL_POS.yz;\r\n        if (length(npos) < 0.055) {\r\n        \talbedo = vec3(0.02);\r\n        \troughness = .9;\r\n        } else if(sdHexPrism(pos + PENCIL_POS, vec2(.195, 3.)) < 0.) {\r\n        \talbedo = .8* texture(tex1, pos.xz).rgb;\r\n        \troughness = 0.99;\r\n        } else {\r\n        \talbedo = .5*pow(vec3(1.,.8,.15), vec3(2.2));\r\n        \troughness = .75 - noise.b * .4;\r\n        }\r\n        albedo *= noise.g * .75 + .7;\r\n    }\r\n    else if( mat < MAT_PENCIL_1 ) {\r\n       \talbedo = .4*pow(vec3(.85,.75,.55), vec3(2.2));\r\n       \troughness = 1.;\r\n    }\r\n    else if( mat < MAT_PENCIL_2 ) {\r\n        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);\r\n        float r = 1. - abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\r\n\r\n        r -= 4. * metalnoise;  \r\n        ao *= .5 + .5 * r;\r\n\t    albedo = mix(vec3(0.5, 0.3, 0.2),vec3(0.560, 0.570, 0.580), ao * ao); // Iron\r\n   \t\troughness = 1.-.25*r;\r\n   \t\tmetallic = 1.; \r\n    }\r\n    else if( mat < MAT_DIAL ) {\r\n        float dial = texture(tex2, vec2(-.5 * pinv.x + .5, +.5 * pinv.z + .5)).r;\r\n        albedo = vec3(dial);\r\n        roughness = dial + .95;\r\n    }\r\n    else if( mat < MAT_HAND ) {\r\n        albedo = vec3(0.02);\r\n        roughness = .65;\r\n    }\r\n    else if( mat < MAT_METAL_0 ) {\r\n\t    albedo = vec3(1.000, 0.766, 0.336); // Gold\r\n   \t\troughness = .6;\r\n   \t\tmetallic = 1.; \r\n    } \r\n    else if( mat < MAT_METAL_1 ) {\r\n\t    albedo = vec3(0.972, 0.960, 0.915); // Silver\r\n   \t\troughness = .7 + max(.15 * length(pos.xz)-.3, 0.); // prevent aliasing\r\n   \t\tmetallic = 1.; \r\n    }\r\n    \r\n    if (mat < MAT_PENCIL_2) {\r\n        ao = min(ao, smoothstep(.95, 1.5, length(pos.xz)));\r\n    }\r\n    \r\n    if (metallic > .5) {   \r\n        albedo *= 1.-metalnoise;\r\n        roughness += metalnoise*4.;\r\n    }\r\n    \r\n    ao = clamp(.1+.9*ao, 0., 1.);\r\n    roughness = clamp(roughness, 0., 1.);\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta ) {\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(0.0, 1.0,0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n\r\n// Old watch (IBL). Created by Reinder Nijhoff 2018\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/lscBW4\r\n//\r\n// This shader uses Image Based Lighting (IBL) to render an old watch. The\r\n// materials of the objects have physically-based properties.\r\n//\r\n// A material is defined by its albedo and roughness value and it can be a \r\n// metal or a non-metal.\r\n//\r\n// I have used the IBL technique as explained in the article 'Real Shading in\r\n// Unreal Engine 4' by Brian Karis of Epic Games.[1] According to this article,\r\n// the lighting of a material is the sum of two components:\r\n// \r\n// 1. Diffuse: a look-up (using the normal vector) in a pre-computed environment map.\r\n// 2. Specular: a look-up (based on the reflection vector and the roughness of the\r\n//       material) in a pre-computed environment map, combined with a look-up in a\r\n//       pre-calculated BRDF integration map (Buf B).  \r\n// \r\n// Note that I do NOT (pre)compute the environment maps needed in this shader. Instead,\r\n// I use (the lod levels of) a Shadertoy cubemap that I have remapped using a random \r\n// function to get something HDR-ish. This is not correct and not how it is described\r\n// in the article, but I think that for this scene the result is good enough.\r\n//\r\n// I made a shader that renders this same scene using a simple path tracer. You can\r\n// compare the result here:\r\n//\r\n// https://www.shadertoy.com/view/MlyyzW\r\n//\r\n// [1] http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\r\n//\r\n\r\n#define MAX_LOD 8.\r\n#define DIFFUSE_LOD 6.75\r\n#define AA 2\r\n// #define P_MALIN_AO \r\n\r\nvec3 getSpecularLightColor( vec3 N, float roughness ) {\r\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\r\n    return pow(textureLod(iChannel0, N.xy, roughness * MAX_LOD).rgb, vec3(4.5)) * 6.5;\r\n}\r\n\r\nvec3 getDiffuseLightColor( vec3 N ) {\r\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\r\n    return .25 +pow(textureLod(iChannel0, N.xy, DIFFUSE_LOD).rgb, vec3(3.)) * 1.;\r\n}\r\n\r\n//\r\n// Modified FrenelSchlick: https://seblagarde.wordpress.com/2011/08/17/hello-world/\r\n//\r\nvec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\r\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\n\r\n//\r\n// Image based lighting\r\n//\r\n\r\nvec3 lighting(in vec3 ro, in vec3 pos, in vec3 N, in vec3 albedo, in float ao, in float roughness, in float metallic ) {\r\n    vec3 V = normalize(ro - pos); \r\n    vec3 R = reflect(-V, N);\r\n    float NdotV = max(0.0, dot(N, V));\r\n\r\n    vec3 F0 = vec3(0.04); \r\n    F0 = mix(F0, albedo, metallic);\r\n\r\n    vec3 F = FresnelSchlickRoughness(NdotV, F0, roughness);\r\n\r\n    vec3 kS = F;\r\n\r\n    vec3 prefilteredColor = getSpecularLightColor(R, roughness);\r\n    vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\r\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\r\n\r\n    vec3 kD = vec3(1.0) - kS;\r\n\r\n    kD *= 1.0 - metallic;\r\n\r\n    vec3 irradiance = getDiffuseLightColor(N);\r\n\r\n    vec3 diffuse  = albedo * irradiance;\r\n\r\n#ifdef P_MALIN_AO\r\n    vec3 color = kD * diffuse * ao + specular * calcAO(pos, R);\r\n#else\r\n    vec3 color = (kD * diffuse + specular) * ao;\r\n#endif\r\n\r\n    return color;\r\n}\r\n\r\n//\r\n// main \r\n//\r\n\r\nvec3 render( const in vec3 ro, const in vec3 rd ) {\r\n    vec3 col = vec3(0); \r\n    vec2 res = castRay( ro, rd );\r\n\r\n    if (res.x > 0.) {\r\n        vec3 pos = ro + rd * res.x;\r\n        vec3 N, albedo;\r\n        float roughness, metallic, ao;\r\n\r\n        getMaterialProperties(pos, res.y, N, albedo, ao, roughness, metallic, iChannel1, iChannel2, iChannel3);\r\n\r\n        col = lighting(ro, pos, N, albedo, ao, roughness, metallic);\r\n        col *= max(0.0, min(1.1, 10./dot(pos,pos)) - .15);\r\n    }\r\n\r\n    // Glass. \r\n    float glass = castRayGlass( ro, rd );\r\n    if (glass > 0. && (glass < res.x || res.x < 0.)) {\r\n        vec3 N = calcNormalGlass(ro+rd*glass);\r\n        vec3 pos = ro + rd * glass;\r\n\r\n        vec3 V = normalize(ro - pos); \r\n        vec3 R = reflect(-V, N);\r\n        float NdotV = max(0.0, dot(N, V));\r\n\r\n        float roughness = texture(iChannel2, pos.xz*.5 + .5).g;\r\n\r\n        vec3 F = FresnelSchlickRoughness(NdotV, vec3(.08), roughness);\r\n        vec3 prefilteredColor = getSpecularLightColor(R, roughness);\r\n        vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\r\n        vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\r\n\r\n        col = col * (1.0 -  (F * envBRDF.x + envBRDF.y) ) + specular;\r\n    } \r\n\r\n    // gamma correction\r\n    col = max( vec3(0), col - 0.004);\r\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\r\n    \r\n    return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n    vec2 mo = iMouse.xy/iResolution.xy - .5;\r\n    if(iMouse.w <= 0.) {\r\n        mo = vec2(.2*sin(-iTime*.1+.3)+.045,.1-.2*sin(-iTime*.1+.3));\r\n    }\r\n    float a = 5.05;\r\n    vec3 ro = vec3( .25 + 2.*cos(6.0*mo.x+a), 2. + 2. * mo.y, 2.0*sin(6.0*mo.x+a) );\r\n    vec3 ta = vec3( .25, .5, .0 );\r\n    mat3 ca = setCamera( ro, ta );\r\n\r\n    vec3 colT = vec3(0);\r\n    \r\n    for (int x=0; x<AA; x++) {\r\n        for(int y=0; y<AA; y++) {\r\n\t\t    vec2 p = (-iResolution.xy + 2.0*(fragCoord + vec2(x,y)/float(AA) - .5))/iResolution.y;\r\n   \t\t\tvec3 rd = ca * normalize( vec3(p.xy,1.6) );  \r\n            colT += render( ro, rd);           \r\n        }\r\n    }\r\n    \r\n    colT /= float(AA*AA);\r\n    \r\n    fragColor = vec4(colT, 1.0);\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\r\n\tMAX_T = 1000.;\r\n    fragColor = vec4(render(ro * 25. + vec3(0.5,4.,1.5), rd), 1.);\r\n}","inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\buffer01.png","type":"buffer","channel":3,"sampler":null,"published":0}],"outputs":[],"code":"// Old watch (IBL). Created by Reinder Nijhoff 2018\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/lscBW4\r\n//\r\n// I have moved all ray-march code to this tab, in order to keep the IBL-code in the \r\n// 'Image tab' more readable. The physically-based properties of the materials are also \r\n// defined here.\r\n//\r\n// All (signed) distance field (SDF) code is copy-paste from the excellent framework by \r\n// Inigo Quilez:\r\n//\r\n// https://www.shadertoy.com/view/Xds3zN\r\n//\r\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n//\r\n\r\n#define MAT_TABLE    1.\r\n#define MAT_PENCIL_0 2.\r\n#define MAT_PENCIL_1 3.\r\n#define MAT_PENCIL_2 4.\r\n#define MAT_DIAL     5.\r\n#define MAT_HAND     6.\r\n#define MAT_METAL_0  7.\r\n#define MAT_METAL_1  8.\r\n\r\n#define CLOCK_ROT_X -0.26\r\n#define CLOCK_ROT_Y 0.2\r\n#define CLOCK_OFFSET_Y 0.42\r\n#define PENCIL_POS vec3(-0.31,-0.2, -.725)\r\n\r\nfloat MAX_T = 10.;\r\n\r\n//\r\n// SDF functions (by Inigo Quilez).\r\n//\r\n\r\nfloat sdPlane( const vec3 p ) {\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdTorus( const vec3 p, const vec2 t ) {\r\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\r\n  return length(q)-t.y;\r\n}\r\n\r\nfloat sdTorusYZ( const vec3 p, const vec2 t ) {\r\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\r\n  return length(q)-t.y;\r\n}\r\n\r\nfloat sdTorusYX( const vec3 p, const vec2 t ) {\r\n  vec2 q = vec2(length(p.yx)-t.x,p.z);\r\n  return length(q)-t.y;\r\n}\r\n\r\nfloat sdCylinder( const vec3 p, const vec2 h ) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat sdCylinderZY( const vec3 p, const vec2 h ) {\r\n  vec2 d = abs(vec2(length(p.zy),p.x)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat sdCylinderXY( const vec3 p, const vec2 h ) {\r\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\n\r\nfloat sdHexPrism( const vec3 p, const vec2 h ) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.x-h.y,max((q.z*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.x-h.y;\r\n    float d2 = max((q.z*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\n\r\nfloat sdEllipsoid( const vec3 p, const vec3 r ) {\r\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\r\n}\r\n\r\nfloat sdCapsule( const vec3 p, const vec3 a, const vec3 b, const float r ) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\n\r\nfloat sdSphere( const vec3 p, const float r ) {\r\n    return length(p) - r;\r\n}\r\n\r\nfloat sdCone( const vec3 p, const vec2 c ) {\r\n    float q = length(p.yz);\r\n    return dot(c,vec2(q,p.x));\r\n}\r\n\r\nfloat sdSegment2D( const vec2 p, const vec2 a, const vec2 b, const float w ) {\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - w;\r\n}\r\n\r\nfloat opS( const float d1, const float d2 ) {\r\n    return max(-d1,d2);\r\n}\r\n\r\nfloat opU( const float d1, const float d2 ) {\r\n    return min(d1,d2);\r\n}\r\n\r\nvec3 rotateX( in vec3 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.yz = mat2(co,-si,si,co)*p.yz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateY( in vec3 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xz = mat2(co,-si,si,co)*p.xz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateZ( in vec3 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xy = mat2(co,-si,si,co)*p.xy;\r\n    return p;\r\n}\r\n\r\nvec2 rotate( in vec2 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p = mat2(co,-si,si,co) * p;\r\n    return p;\r\n}\r\n\r\n//\r\n// Hash without Sine by Dave Hoskins.\r\n//\r\n\r\nfloat hash11(float p) {\r\n\tvec3 p3  = fract(vec3(p) * .1031);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\n//\r\n// SDF of the scene.\r\n//\r\n\r\nfloat mapHand( const vec3 pos, const float w, const float l, const float r ) {\r\n    float d = sdSegment2D(pos.xz, vec2(0,-w*10.), vec2(0,l), w);\r\n    d = min(d, length(pos.xz) - (.03+r));\r\n    return max(d, abs(pos.y)-.005);\r\n}\r\n\r\nvec2 map( in vec3 pos, in vec3 p1, in vec3 ps, in vec3 pm, in vec3 ph, \r\n         const bool watchIntersect, const bool pencilIntersect ) {\r\n    //--- table\r\n    vec2 res = vec2(sdPlane(pos), MAT_TABLE);\r\n    \r\n    // chain\r\n    if (pos.z > 1.1) {\r\n        float h = smoothstep(3., -.4, pos.z)*.74 + .045;\r\n        float dChain0 = length(pos.xy+vec2(.3*sin(pos.z), -h))-.1;\r\n        if (dChain0 < 0.1) {\r\n            dChain0 = 10.;\r\n            float pth1z = floor(pos.z*5.);\r\n            if (pth1z > 5.) {\r\n\t            float pth1 = hash11(floor(pos.z*5.));\r\n    \t        vec3 pt1 = vec3(pos.x + .3*sin(pos.z)- pth1 *.02 + 0.02, pos.y-h - pth1 *.03, mod(pos.z, .2) - .1);\r\n        \t    pt1 = rotateZ(pt1, .6 * smoothstep(2.,3., pos.z));\r\n            \tdChain0 = sdTorus(pt1, vec2(.071, .02)); \r\n            }\r\n            \r\n            float pth2z = floor(pos.z*5. + .5);\r\n            float pth2 = hash11(pth2z); \r\n            vec3 pt2 = vec3(pos.x + .3*sin(pos.z)- pth2 *.02 + 0.02, pos.y-h - pth2 *.03, mod(pos.z + .1, .2) - .1);\r\n            pt2 = rotateZ(pt2, 1.1 * smoothstep(2.,3., pos.z));\r\n            dChain0 = opU(dChain0, sdTorusYZ(pt2, vec2(.071, .02)));          \r\n        }\r\n        if (dChain0 < res.x) res = vec2(dChain0, MAT_METAL_1);\r\n    }\r\n    //--- pencil\r\n    if (pencilIntersect) {\r\n        float dPencil0 = sdHexPrism(pos + PENCIL_POS, vec2(.2, 2.));\r\n        dPencil0 = opS(-sdCone(pos + (PENCIL_POS + vec3(-2.05,0,0)), vec2(.95,0.3122)),dPencil0);\r\n        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.4,-2.82,-1.03)), 3.), dPencil0);\r\n        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.5,-0.82,2.86)), 3.), dPencil0);\r\n        if (dPencil0 < res.x) res = vec2(dPencil0, MAT_PENCIL_0);\r\n\r\n        float dPencil1 = sdCapsule(pos, -PENCIL_POS - vec3(2.2,0.,0.), -PENCIL_POS-vec3(2.55, 0., 0.), .21);\r\n        if (dPencil1 < res.x) res = vec2(dPencil1, MAT_PENCIL_1);\r\n        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);\r\n        float r = .02*abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\r\n\r\n        float dPencil2 = sdCylinderZY(pos + PENCIL_POS + vec3(2.25,-0.0125,0), vec2(.22 - r,.25));\r\n        if (dPencil2 < res.x) res = vec2(dPencil2, MAT_PENCIL_2);\r\n    }\r\n    \r\n    //--- watch\r\n    if (watchIntersect) {\r\n        float dDial = sdCylinder(p1, vec2(1.05,.13));\r\n        if (dDial < res.x) res = vec2(dDial, MAT_DIAL);\r\n\r\n        float dC = sdTorusYX(vec3(max(abs(p1.x)-.5*p1.y-0.19,0.),p1.y+0.12,p1.z-1.18), vec2(0.11,0.02));\r\n        if (dC < res.x) res = vec2(dC, MAT_METAL_1);\r\n        \r\n        float dM = sdTorus(p1 + vec3(0,-.165,0), vec2(1.005,.026));   \r\n        float bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15,0.04));\r\n        if(bb < 0.5) {\r\n            float a = atan(p1.y, p1.x);\r\n            float c = abs(fract(a*3.1415)-.5);\r\n            float d = min(abs(p1.z-1.3), .02);\r\n            bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15 - 40.*d*d - .1*c*c,0.04));\r\n        } \r\n        dM = opU(dM, bb);\r\n         \r\n        dM = opU(dM, sdCylinderZY(p1+vec3(0,0,-1.18), vec2(0.06,0.2)));\r\n        float rr = min(abs(p1.z-1.26), .2);\r\n        dM = opU(dM, sdCylinderXY(p1+vec3(0,0,-1.2), vec2(0.025 + 0.35*rr,0.1)));\r\n       \r\n        p1.y = abs(p1.y);\r\n        dM = opU(dM, sdTorus(p1 + vec3(0,-.1,0), vec2(1.025,.075)));\r\n        dM = opU(dM, sdCylinder(p1, vec2(1.1,.1)));\r\n        dM = opS(sdTorus(p1 + vec3(0,-.1,0), vec2(1.11,.015)), dM);\r\n        dM = opU(dM, sdCylinder(p1, vec2(0.01,0.175)));\r\n        dM = opU(dM, sdCylinder(p1+vec3(0,0,.6), vec2(0.01,0.155)));\r\n        if (dM < res.x) res = vec2(dM, MAT_METAL_0);\r\n\r\n        // minutes hand\r\n        float dMin = mapHand(pm + vec3(0,-.16,0), .02, 0.7, 0.015);\r\n        if (dMin < res.x) res = vec2(dMin, MAT_HAND);\r\n        // hours hand\r\n        float dHour = mapHand(ph + vec3(0,-.15,0), .02, 0.4, 0.03);\r\n        if (dHour < res.x) res = vec2(dHour, MAT_HAND);\r\n        // seconds hand\r\n        float dSeconds = mapHand(ps + vec3(0,-.14,0), .01, 0.17, 0.006);\r\n        if (dSeconds < res.x) res = vec2(dSeconds, MAT_HAND);\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\nvec2 map( in vec3 pos ) {\r\n    vec3 p1 = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    \r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\r\n    \r\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\r\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\r\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\r\n    \r\n    return map( pos, p1, ps, pm, ph, true, true );\r\n}\r\n\r\nfloat mapGlass( in vec3 pos ) {\r\n    return sdEllipsoid( pos - vec3(0,.10,0), vec3(1.,.2,1.) );\r\n}\r\n\r\n//\r\n// Ray march code.\r\n//\r\n\r\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float r ) {\r\n\tvec3 oc = ro;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - r * r;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n    h = sqrt( h );\r\n\treturn vec2(-b - h, -b + h);\r\n}\r\n\r\nbool boxIntserct( in vec3 ro, in vec3 rd, in vec3 rad ) {\r\n    vec3 m = 1.0/rd;\r\n    vec3 n = m*ro;\r\n    vec3 k = abs(m)*rad;\r\n\t\r\n    vec3 t1 = -n - k;\r\n    vec3 t2 = -n + k;\r\n\r\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\r\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\r\n\t\r\n\tif( tN > tF || tF < 0.0) return false;\r\n\r\n\treturn true;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos ) {\r\n    const vec2 e = vec2(1.0,-1.0)*0.0075;\r\n    return normalize( e.xyy*map( pos + e.xyy ).x + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\r\n}\r\n\r\nvec2 castRay( in vec3 ro, in vec3 rd ) {\r\n    float tmin = 0.5;\r\n    float tmax = MAX_T;\r\n    \r\n    // bounding volume\r\n    const float top = 0.95;\r\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\r\n    float tp2 = (top-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>top ) tmin = max( tmin, tp2 );\r\n                                                 else           tmax = min( tmax, tp2 ); }\r\n    \r\n    float t = tmin;\r\n    float mat = -1.;\r\n    \r\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\r\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\r\n    \r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\r\n    \r\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\r\n    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );\r\n    \r\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\r\n    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );\r\n    \r\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\r\n    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );\r\n    \r\n    bool watchIntersect = boxIntserct(p1, rd1, vec3(1.1,.2,1.4));\r\n    bool pencilIntersect = boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));\r\n    \r\n    for( int i=0; i<48; i++ ) {\r\n\t    float precis = 0.00025*t;\r\n\t    vec2 res = map( ro+rd*t, p1+rd1*t, ps+rds*t, pm+rdm*t, ph+rdh*t, \r\n                       watchIntersect, pencilIntersect );\r\n        if( res.x<precis || t>tmax ) break; //return vec2(t, mat);\r\n        t += res.x;\r\n        mat = res.y;\r\n    }\r\n\r\n    if( t>tmax ) t=-1.0;\r\n    return vec2(t, mat);\r\n}\r\n\r\nvec3 calcNormalGlass( in vec3 pos ) {\r\n    const vec2 e = vec2(1.0,-1.0)*0.005;\r\n    return normalize( e.xyy*mapGlass( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*mapGlass( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*mapGlass( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*mapGlass( pos + e.xxx ) );\r\n}\r\n\r\nfloat castRayGlass( in vec3 ro, in vec3 rd ) {\r\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\r\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\r\n\r\n    float t = -1.;\r\n    vec2 bb = sphIntersect( p1- vec3(0,.10,0), rd1, 1.);\r\n    if (bb.y > 0.) {\r\n        t = max(bb.x, 0.);\r\n        float tmax = bb.y;\r\n        for( int i=0; i<24; i++ ) {\r\n            float precis = 0.00025*t;\r\n            float res = mapGlass( p1+rd1*t );\r\n            if( res<precis || t>tmax ) break; \r\n            t += res;\r\n        }\r\n\r\n        if( t>tmax ) t=-1.0;\r\n    }\r\n    return t;\r\n}\r\n\r\n\r\nfloat calcAO( in vec3 ro, in vec3 rd ) {\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    \r\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\r\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\r\n    \r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\r\n    \r\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\r\n    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );\r\n    \r\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\r\n    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );\r\n    \r\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\r\n    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );\r\n    \r\n    bool watchIntersect = true; //boxIntserct(p1, rd1, vec3(1.1,.2,1.4));\r\n    bool pencilIntersect = true; //boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));\r\n    \r\n    \r\n    for( int i=0; i<6; i++ ) {\r\n        float h = 0.001 + 0.25*float(i)/5.0;\r\n        float d = map( ro+rd*h, p1+rd1*h, ps+rds*h, pm+rdm*h, ph+rdh*h, \r\n                       watchIntersect, pencilIntersect ).x;\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n    }\r\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \r\n}\r\n\r\n//\r\n// Material properties.\r\n//\r\n\r\nvec4 texNoise( sampler2D sam, in vec3 p, in vec3 n ) {\r\n\tvec4 x = texture( sam, p.yz );\r\n\tvec4 y = texture( sam, p.zx );\r\n\tvec4 z = texture( sam, p.xy );\r\n\r\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\r\n}\r\n\r\nvoid getMaterialProperties(\r\n    in vec3 pos, in float mat,\r\n    inout vec3 normal, inout vec3 albedo, inout float ao, inout float roughness, inout float metallic,\r\n\tsampler2D tex1, sampler2D tex2, sampler2D tex3) {\r\n    \r\n    vec3 pinv = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    pinv = rotateY( pinv, CLOCK_ROT_Y );\r\n    \r\n    normal = calcNormal( pos );\r\n    ao = calcAO(pos, normal);\r\n    metallic = 0.;\r\n    \r\n    vec4 noise = texNoise(tex1, pinv * .5, normal);\r\n    float metalnoise = 1.- noise.r;\r\n    metalnoise*=metalnoise;\r\n\r\n    mat -= .5;\r\n    if (mat < MAT_TABLE) {\r\n        albedo = .7 * pow(texture(tex1, rotate(pos.xz * .4 + .25, -.3)).rgb, 2.2*vec3(0.45,0.5,0.5));\r\n        roughness = 0.95 - albedo.r * .6;\r\n    }\r\n    else if( mat < MAT_PENCIL_0 ) {\r\n        vec2 npos = pos.yz + PENCIL_POS.yz;\r\n        if (length(npos) < 0.055) {\r\n        \talbedo = vec3(0.02);\r\n        \troughness = .9;\r\n        } else if(sdHexPrism(pos + PENCIL_POS, vec2(.195, 3.)) < 0.) {\r\n        \talbedo = .8* texture(tex1, pos.xz).rgb;\r\n        \troughness = 0.99;\r\n        } else {\r\n        \talbedo = .5*pow(vec3(1.,.8,.15), vec3(2.2));\r\n        \troughness = .75 - noise.b * .4;\r\n        }\r\n        albedo *= noise.g * .75 + .7;\r\n    }\r\n    else if( mat < MAT_PENCIL_1 ) {\r\n       \talbedo = .4*pow(vec3(.85,.75,.55), vec3(2.2));\r\n       \troughness = 1.;\r\n    }\r\n    else if( mat < MAT_PENCIL_2 ) {\r\n        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);\r\n        float r = 1. - abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\r\n\r\n        r -= 4. * metalnoise;  \r\n        ao *= .5 + .5 * r;\r\n\t    albedo = mix(vec3(0.5, 0.3, 0.2),vec3(0.560, 0.570, 0.580), ao * ao); // Iron\r\n   \t\troughness = 1.-.25*r;\r\n   \t\tmetallic = 1.; \r\n    }\r\n    else if( mat < MAT_DIAL ) {\r\n        float dial = texture(tex2, vec2(-.5 * pinv.x + .5, +.5 * pinv.z + .5)).r;\r\n        albedo = vec3(dial);\r\n        roughness = dial + .95;\r\n    }\r\n    else if( mat < MAT_HAND ) {\r\n        albedo = vec3(0.02);\r\n        roughness = .65;\r\n    }\r\n    else if( mat < MAT_METAL_0 ) {\r\n\t    albedo = vec3(1.000, 0.766, 0.336); // Gold\r\n   \t\troughness = .6;\r\n   \t\tmetallic = 1.; \r\n    } \r\n    else if( mat < MAT_METAL_1 ) {\r\n\t    albedo = vec3(0.972, 0.960, 0.915); // Silver\r\n   \t\troughness = .7 + max(.15 * length(pos.xz)-.3, 0.); // prevent aliasing\r\n   \t\tmetallic = 1.; \r\n    }\r\n    \r\n    if (mat < MAT_PENCIL_2) {\r\n        ao = min(ao, smoothstep(.95, 1.5, length(pos.xz)));\r\n    }\r\n    \r\n    if (metallic > .5) {   \r\n        albedo *= 1.-metalnoise;\r\n        roughness += metalnoise*4.;\r\n    }\r\n    \r\n    ao = clamp(.1+.9*ao, 0., 1.);\r\n    roughness = clamp(roughness, 0., 1.);\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta ) {\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(0.0, 1.0,0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n\r\n// Old watch (IBL). Created by Reinder Nijhoff 2018\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/lscBW4\r\n//\r\n// This shader uses Image Based Lighting (IBL) to render an old watch. The\r\n// materials of the objects have physically-based properties.\r\n//\r\n// A material is defined by its albedo and roughness value and it can be a \r\n// metal or a non-metal.\r\n//\r\n// I have used the IBL technique as explained in the article 'Real Shading in\r\n// Unreal Engine 4' by Brian Karis of Epic Games.[1] According to this article,\r\n// the lighting of a material is the sum of two components:\r\n// \r\n// 1. Diffuse: a look-up (using the normal vector) in a pre-computed environment map.\r\n// 2. Specular: a look-up (based on the reflection vector and the roughness of the\r\n//       material) in a pre-computed environment map, combined with a look-up in a\r\n//       pre-calculated BRDF integration map (Buf B).  \r\n// \r\n// Note that I do NOT (pre)compute the environment maps needed in this shader. Instead,\r\n// I use (the lod levels of) a Shadertoy cubemap that I have remapped using a random \r\n// function to get something HDR-ish. This is not correct and not how it is described\r\n// in the article, but I think that for this scene the result is good enough.\r\n//\r\n// I made a shader that renders this same scene using a simple path tracer. You can\r\n// compare the result here:\r\n//\r\n// https://www.shadertoy.com/view/MlyyzW\r\n//\r\n// [1] http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\r\n//\r\n\r\n#define MAX_LOD 8.\r\n#define DIFFUSE_LOD 6.75\r\n#define AA 2\r\n// #define P_MALIN_AO \r\n\r\nvec3 getSpecularLightColor( vec3 N, float roughness ) {\r\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\r\n    return pow(textureLod(iChannel0, N.xy, roughness * MAX_LOD).rgb, vec3(4.5)) * 6.5;\r\n}\r\n\r\nvec3 getDiffuseLightColor( vec3 N ) {\r\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\r\n    return .25 +pow(textureLod(iChannel0, N.xy, DIFFUSE_LOD).rgb, vec3(3.)) * 1.;\r\n}\r\n\r\n//\r\n// Modified FrenelSchlick: https://seblagarde.wordpress.com/2011/08/17/hello-world/\r\n//\r\nvec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\r\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\n\r\n//\r\n// Image based lighting\r\n//\r\n\r\nvec3 lighting(in vec3 ro, in vec3 pos, in vec3 N, in vec3 albedo, in float ao, in float roughness, in float metallic ) {\r\n    vec3 V = normalize(ro - pos); \r\n    vec3 R = reflect(-V, N);\r\n    float NdotV = max(0.0, dot(N, V));\r\n\r\n    vec3 F0 = vec3(0.04); \r\n    F0 = mix(F0, albedo, metallic);\r\n\r\n    vec3 F = FresnelSchlickRoughness(NdotV, F0, roughness);\r\n\r\n    vec3 kS = F;\r\n\r\n    vec3 prefilteredColor = getSpecularLightColor(R, roughness);\r\n    vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\r\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\r\n\r\n    vec3 kD = vec3(1.0) - kS;\r\n\r\n    kD *= 1.0 - metallic;\r\n\r\n    vec3 irradiance = getDiffuseLightColor(N);\r\n\r\n    vec3 diffuse  = albedo * irradiance;\r\n\r\n#ifdef P_MALIN_AO\r\n    vec3 color = kD * diffuse * ao + specular * calcAO(pos, R);\r\n#else\r\n    vec3 color = (kD * diffuse + specular) * ao;\r\n#endif\r\n\r\n    return color;\r\n}\r\n\r\n//\r\n// main \r\n//\r\n\r\nvec3 render( const in vec3 ro, const in vec3 rd ) {\r\n    vec3 col = vec3(0); \r\n    vec2 res = castRay( ro, rd );\r\n\r\n    if (res.x > 0.) {\r\n        vec3 pos = ro + rd * res.x;\r\n        vec3 N, albedo;\r\n        float roughness, metallic, ao;\r\n\r\n        getMaterialProperties(pos, res.y, N, albedo, ao, roughness, metallic, iChannel1, iChannel2, iChannel3);\r\n\r\n        col = lighting(ro, pos, N, albedo, ao, roughness, metallic);\r\n        col *= max(0.0, min(1.1, 10./dot(pos,pos)) - .15);\r\n    }\r\n\r\n    // Glass. \r\n    float glass = castRayGlass( ro, rd );\r\n    if (glass > 0. && (glass < res.x || res.x < 0.)) {\r\n        vec3 N = calcNormalGlass(ro+rd*glass);\r\n        vec3 pos = ro + rd * glass;\r\n\r\n        vec3 V = normalize(ro - pos); \r\n        vec3 R = reflect(-V, N);\r\n        float NdotV = max(0.0, dot(N, V));\r\n\r\n        float roughness = texture(iChannel2, pos.xz*.5 + .5).g;\r\n\r\n        vec3 F = FresnelSchlickRoughness(NdotV, vec3(.08), roughness);\r\n        vec3 prefilteredColor = getSpecularLightColor(R, roughness);\r\n        vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\r\n        vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\r\n\r\n        col = col * (1.0 -  (F * envBRDF.x + envBRDF.y) ) + specular;\r\n    } \r\n\r\n    // gamma correction\r\n    col = max( vec3(0), col - 0.004);\r\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\r\n    \r\n    return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n    vec2 mo = iMouse.xy/iResolution.xy - .5;\r\n    if(iMouse.w <= 0.) {\r\n        mo = vec2(.2*sin(-iTime*.1+.3)+.045,.1-.2*sin(-iTime*.1+.3));\r\n    }\r\n    float a = 5.05;\r\n    vec3 ro = vec3( .25 + 2.*cos(6.0*mo.x+a), 2. + 2. * mo.y, 2.0*sin(6.0*mo.x+a) );\r\n    vec3 ta = vec3( .25, .5, .0 );\r\n    mat3 ca = setCamera( ro, ta );\r\n\r\n    vec3 colT = vec3(0);\r\n    \r\n    for (int x=0; x<AA; x++) {\r\n        for(int y=0; y<AA; y++) {\r\n\t\t    vec2 p = (-iResolution.xy + 2.0*(fragCoord + vec2(x,y)/float(AA) - .5))/iResolution.y;\r\n   \t\t\tvec3 rd = ca * normalize( vec3(p.xy,1.6) );  \r\n            colT += render( ro, rd);           \r\n        }\r\n    }\r\n    \r\n    colT /= float(AA*AA);\r\n    \r\n    fragColor = vec4(colT, 1.0);\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\r\n\tMAX_T = 1000.;\r\n    fragColor = vec4(render(ro * 25. + vec3(0.5,4.,1.5), rd), 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\buffer01.png","type":"buffer","channel":3,"sampler":null,"published":0}],"Info":{"Name":"a new shader","id":null,"date":null,"viewed":0,"name":"a new shader","description":"","likes":0,"published":null,"tags":[""]},"ver":null,"info":{"Name":"a new shader","id":null,"date":null,"viewed":0,"name":"a new shader","description":"","likes":0,"published":null,"tags":[""]},"renderpass":[{"Code":"// Old watch (IBL). Created by Reinder Nijhoff 2018\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/lscBW4\r\n//\r\n// I have moved all ray-march code to this tab, in order to keep the IBL-code in the \r\n// 'Image tab' more readable. The physically-based properties of the materials are also \r\n// defined here.\r\n//\r\n// All (signed) distance field (SDF) code is copy-paste from the excellent framework by \r\n// Inigo Quilez:\r\n//\r\n// https://www.shadertoy.com/view/Xds3zN\r\n//\r\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n//\r\n\r\n#define MAT_TABLE    1.\r\n#define MAT_PENCIL_0 2.\r\n#define MAT_PENCIL_1 3.\r\n#define MAT_PENCIL_2 4.\r\n#define MAT_DIAL     5.\r\n#define MAT_HAND     6.\r\n#define MAT_METAL_0  7.\r\n#define MAT_METAL_1  8.\r\n\r\n#define CLOCK_ROT_X -0.26\r\n#define CLOCK_ROT_Y 0.2\r\n#define CLOCK_OFFSET_Y 0.42\r\n#define PENCIL_POS vec3(-0.31,-0.2, -.725)\r\n\r\nfloat MAX_T = 10.;\r\n\r\n//\r\n// SDF functions (by Inigo Quilez).\r\n//\r\n\r\nfloat sdPlane( const vec3 p ) {\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdTorus( const vec3 p, const vec2 t ) {\r\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\r\n  return length(q)-t.y;\r\n}\r\n\r\nfloat sdTorusYZ( const vec3 p, const vec2 t ) {\r\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\r\n  return length(q)-t.y;\r\n}\r\n\r\nfloat sdTorusYX( const vec3 p, const vec2 t ) {\r\n  vec2 q = vec2(length(p.yx)-t.x,p.z);\r\n  return length(q)-t.y;\r\n}\r\n\r\nfloat sdCylinder( const vec3 p, const vec2 h ) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat sdCylinderZY( const vec3 p, const vec2 h ) {\r\n  vec2 d = abs(vec2(length(p.zy),p.x)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat sdCylinderXY( const vec3 p, const vec2 h ) {\r\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\n\r\nfloat sdHexPrism( const vec3 p, const vec2 h ) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.x-h.y,max((q.z*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.x-h.y;\r\n    float d2 = max((q.z*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\n\r\nfloat sdEllipsoid( const vec3 p, const vec3 r ) {\r\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\r\n}\r\n\r\nfloat sdCapsule( const vec3 p, const vec3 a, const vec3 b, const float r ) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\n\r\nfloat sdSphere( const vec3 p, const float r ) {\r\n    return length(p) - r;\r\n}\r\n\r\nfloat sdCone( const vec3 p, const vec2 c ) {\r\n    float q = length(p.yz);\r\n    return dot(c,vec2(q,p.x));\r\n}\r\n\r\nfloat sdSegment2D( const vec2 p, const vec2 a, const vec2 b, const float w ) {\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - w;\r\n}\r\n\r\nfloat opS( const float d1, const float d2 ) {\r\n    return max(-d1,d2);\r\n}\r\n\r\nfloat opU( const float d1, const float d2 ) {\r\n    return min(d1,d2);\r\n}\r\n\r\nvec3 rotateX( in vec3 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.yz = mat2(co,-si,si,co)*p.yz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateY( in vec3 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xz = mat2(co,-si,si,co)*p.xz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateZ( in vec3 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xy = mat2(co,-si,si,co)*p.xy;\r\n    return p;\r\n}\r\n\r\nvec2 rotate( in vec2 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p = mat2(co,-si,si,co) * p;\r\n    return p;\r\n}\r\n\r\n//\r\n// Hash without Sine by Dave Hoskins.\r\n//\r\n\r\nfloat hash11(float p) {\r\n\tvec3 p3  = fract(vec3(p) * .1031);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\n//\r\n// SDF of the scene.\r\n//\r\n\r\nfloat mapHand( const vec3 pos, const float w, const float l, const float r ) {\r\n    float d = sdSegment2D(pos.xz, vec2(0,-w*10.), vec2(0,l), w);\r\n    d = min(d, length(pos.xz) - (.03+r));\r\n    return max(d, abs(pos.y)-.005);\r\n}\r\n\r\nvec2 map( in vec3 pos, in vec3 p1, in vec3 ps, in vec3 pm, in vec3 ph, \r\n         const bool watchIntersect, const bool pencilIntersect ) {\r\n    //--- table\r\n    vec2 res = vec2(sdPlane(pos), MAT_TABLE);\r\n    \r\n    // chain\r\n    if (pos.z > 1.1) {\r\n        float h = smoothstep(3., -.4, pos.z)*.74 + .045;\r\n        float dChain0 = length(pos.xy+vec2(.3*sin(pos.z), -h))-.1;\r\n        if (dChain0 < 0.1) {\r\n            dChain0 = 10.;\r\n            float pth1z = floor(pos.z*5.);\r\n            if (pth1z > 5.) {\r\n\t            float pth1 = hash11(floor(pos.z*5.));\r\n    \t        vec3 pt1 = vec3(pos.x + .3*sin(pos.z)- pth1 *.02 + 0.02, pos.y-h - pth1 *.03, mod(pos.z, .2) - .1);\r\n        \t    pt1 = rotateZ(pt1, .6 * smoothstep(2.,3., pos.z));\r\n            \tdChain0 = sdTorus(pt1, vec2(.071, .02)); \r\n            }\r\n            \r\n            float pth2z = floor(pos.z*5. + .5);\r\n            float pth2 = hash11(pth2z); \r\n            vec3 pt2 = vec3(pos.x + .3*sin(pos.z)- pth2 *.02 + 0.02, pos.y-h - pth2 *.03, mod(pos.z + .1, .2) - .1);\r\n            pt2 = rotateZ(pt2, 1.1 * smoothstep(2.,3., pos.z));\r\n            dChain0 = opU(dChain0, sdTorusYZ(pt2, vec2(.071, .02)));          \r\n        }\r\n        if (dChain0 < res.x) res = vec2(dChain0, MAT_METAL_1);\r\n    }\r\n    //--- pencil\r\n    if (pencilIntersect) {\r\n        float dPencil0 = sdHexPrism(pos + PENCIL_POS, vec2(.2, 2.));\r\n        dPencil0 = opS(-sdCone(pos + (PENCIL_POS + vec3(-2.05,0,0)), vec2(.95,0.3122)),dPencil0);\r\n        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.4,-2.82,-1.03)), 3.), dPencil0);\r\n        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.5,-0.82,2.86)), 3.), dPencil0);\r\n        if (dPencil0 < res.x) res = vec2(dPencil0, MAT_PENCIL_0);\r\n\r\n        float dPencil1 = sdCapsule(pos, -PENCIL_POS - vec3(2.2,0.,0.), -PENCIL_POS-vec3(2.55, 0., 0.), .21);\r\n        if (dPencil1 < res.x) res = vec2(dPencil1, MAT_PENCIL_1);\r\n        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);\r\n        float r = .02*abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\r\n\r\n        float dPencil2 = sdCylinderZY(pos + PENCIL_POS + vec3(2.25,-0.0125,0), vec2(.22 - r,.25));\r\n        if (dPencil2 < res.x) res = vec2(dPencil2, MAT_PENCIL_2);\r\n    }\r\n    \r\n    //--- watch\r\n    if (watchIntersect) {\r\n        float dDial = sdCylinder(p1, vec2(1.05,.13));\r\n        if (dDial < res.x) res = vec2(dDial, MAT_DIAL);\r\n\r\n        float dC = sdTorusYX(vec3(max(abs(p1.x)-.5*p1.y-0.19,0.),p1.y+0.12,p1.z-1.18), vec2(0.11,0.02));\r\n        if (dC < res.x) res = vec2(dC, MAT_METAL_1);\r\n        \r\n        float dM = sdTorus(p1 + vec3(0,-.165,0), vec2(1.005,.026));   \r\n        float bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15,0.04));\r\n        if(bb < 0.5) {\r\n            float a = atan(p1.y, p1.x);\r\n            float c = abs(fract(a*3.1415)-.5);\r\n            float d = min(abs(p1.z-1.3), .02);\r\n            bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15 - 40.*d*d - .1*c*c,0.04));\r\n        } \r\n        dM = opU(dM, bb);\r\n         \r\n        dM = opU(dM, sdCylinderZY(p1+vec3(0,0,-1.18), vec2(0.06,0.2)));\r\n        float rr = min(abs(p1.z-1.26), .2);\r\n        dM = opU(dM, sdCylinderXY(p1+vec3(0,0,-1.2), vec2(0.025 + 0.35*rr,0.1)));\r\n       \r\n        p1.y = abs(p1.y);\r\n        dM = opU(dM, sdTorus(p1 + vec3(0,-.1,0), vec2(1.025,.075)));\r\n        dM = opU(dM, sdCylinder(p1, vec2(1.1,.1)));\r\n        dM = opS(sdTorus(p1 + vec3(0,-.1,0), vec2(1.11,.015)), dM);\r\n        dM = opU(dM, sdCylinder(p1, vec2(0.01,0.175)));\r\n        dM = opU(dM, sdCylinder(p1+vec3(0,0,.6), vec2(0.01,0.155)));\r\n        if (dM < res.x) res = vec2(dM, MAT_METAL_0);\r\n\r\n        // minutes hand\r\n        float dMin = mapHand(pm + vec3(0,-.16,0), .02, 0.7, 0.015);\r\n        if (dMin < res.x) res = vec2(dMin, MAT_HAND);\r\n        // hours hand\r\n        float dHour = mapHand(ph + vec3(0,-.15,0), .02, 0.4, 0.03);\r\n        if (dHour < res.x) res = vec2(dHour, MAT_HAND);\r\n        // seconds hand\r\n        float dSeconds = mapHand(ps + vec3(0,-.14,0), .01, 0.17, 0.006);\r\n        if (dSeconds < res.x) res = vec2(dSeconds, MAT_HAND);\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\nvec2 map( in vec3 pos ) {\r\n    vec3 p1 = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    \r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\r\n    \r\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\r\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\r\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\r\n    \r\n    return map( pos, p1, ps, pm, ph, true, true );\r\n}\r\n\r\nfloat mapGlass( in vec3 pos ) {\r\n    return sdEllipsoid( pos - vec3(0,.10,0), vec3(1.,.2,1.) );\r\n}\r\n\r\n//\r\n// Ray march code.\r\n//\r\n\r\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float r ) {\r\n\tvec3 oc = ro;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - r * r;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n    h = sqrt( h );\r\n\treturn vec2(-b - h, -b + h);\r\n}\r\n\r\nbool boxIntserct( in vec3 ro, in vec3 rd, in vec3 rad ) {\r\n    vec3 m = 1.0/rd;\r\n    vec3 n = m*ro;\r\n    vec3 k = abs(m)*rad;\r\n\t\r\n    vec3 t1 = -n - k;\r\n    vec3 t2 = -n + k;\r\n\r\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\r\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\r\n\t\r\n\tif( tN > tF || tF < 0.0) return false;\r\n\r\n\treturn true;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos ) {\r\n    const vec2 e = vec2(1.0,-1.0)*0.0075;\r\n    return normalize( e.xyy*map( pos + e.xyy ).x + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\r\n}\r\n\r\nvec2 castRay( in vec3 ro, in vec3 rd ) {\r\n    float tmin = 0.5;\r\n    float tmax = MAX_T;\r\n    \r\n    // bounding volume\r\n    const float top = 0.95;\r\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\r\n    float tp2 = (top-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>top ) tmin = max( tmin, tp2 );\r\n                                                 else           tmax = min( tmax, tp2 ); }\r\n    \r\n    float t = tmin;\r\n    float mat = -1.;\r\n    \r\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\r\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\r\n    \r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\r\n    \r\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\r\n    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );\r\n    \r\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\r\n    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );\r\n    \r\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\r\n    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );\r\n    \r\n    bool watchIntersect = boxIntserct(p1, rd1, vec3(1.1,.2,1.4));\r\n    bool pencilIntersect = boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));\r\n    \r\n    for( int i=0; i<48; i++ ) {\r\n\t    float precis = 0.00025*t;\r\n\t    vec2 res = map( ro+rd*t, p1+rd1*t, ps+rds*t, pm+rdm*t, ph+rdh*t, \r\n                       watchIntersect, pencilIntersect );\r\n        if( res.x<precis || t>tmax ) break; //return vec2(t, mat);\r\n        t += res.x;\r\n        mat = res.y;\r\n    }\r\n\r\n    if( t>tmax ) t=-1.0;\r\n    return vec2(t, mat);\r\n}\r\n\r\nvec3 calcNormalGlass( in vec3 pos ) {\r\n    const vec2 e = vec2(1.0,-1.0)*0.005;\r\n    return normalize( e.xyy*mapGlass( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*mapGlass( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*mapGlass( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*mapGlass( pos + e.xxx ) );\r\n}\r\n\r\nfloat castRayGlass( in vec3 ro, in vec3 rd ) {\r\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\r\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\r\n\r\n    float t = -1.;\r\n    vec2 bb = sphIntersect( p1- vec3(0,.10,0), rd1, 1.);\r\n    if (bb.y > 0.) {\r\n        t = max(bb.x, 0.);\r\n        float tmax = bb.y;\r\n        for( int i=0; i<24; i++ ) {\r\n            float precis = 0.00025*t;\r\n            float res = mapGlass( p1+rd1*t );\r\n            if( res<precis || t>tmax ) break; \r\n            t += res;\r\n        }\r\n\r\n        if( t>tmax ) t=-1.0;\r\n    }\r\n    return t;\r\n}\r\n\r\n\r\nfloat calcAO( in vec3 ro, in vec3 rd ) {\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    \r\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\r\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\r\n    \r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\r\n    \r\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\r\n    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );\r\n    \r\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\r\n    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );\r\n    \r\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\r\n    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );\r\n    \r\n    bool watchIntersect = true; //boxIntserct(p1, rd1, vec3(1.1,.2,1.4));\r\n    bool pencilIntersect = true; //boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));\r\n    \r\n    \r\n    for( int i=0; i<6; i++ ) {\r\n        float h = 0.001 + 0.25*float(i)/5.0;\r\n        float d = map( ro+rd*h, p1+rd1*h, ps+rds*h, pm+rdm*h, ph+rdh*h, \r\n                       watchIntersect, pencilIntersect ).x;\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n    }\r\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \r\n}\r\n\r\n//\r\n// Material properties.\r\n//\r\n\r\nvec4 texNoise( sampler2D sam, in vec3 p, in vec3 n ) {\r\n\tvec4 x = texture( sam, p.yz );\r\n\tvec4 y = texture( sam, p.zx );\r\n\tvec4 z = texture( sam, p.xy );\r\n\r\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\r\n}\r\n\r\nvoid getMaterialProperties(\r\n    in vec3 pos, in float mat,\r\n    inout vec3 normal, inout vec3 albedo, inout float ao, inout float roughness, inout float metallic,\r\n\tsampler2D tex1, sampler2D tex2, sampler2D tex3) {\r\n    \r\n    vec3 pinv = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    pinv = rotateY( pinv, CLOCK_ROT_Y );\r\n    \r\n    normal = calcNormal( pos );\r\n    ao = calcAO(pos, normal);\r\n    metallic = 0.;\r\n    \r\n    vec4 noise = texNoise(tex1, pinv * .5, normal);\r\n    float metalnoise = 1.- noise.r;\r\n    metalnoise*=metalnoise;\r\n\r\n    mat -= .5;\r\n    if (mat < MAT_TABLE) {\r\n        albedo = .7 * pow(texture(tex1, rotate(pos.xz * .4 + .25, -.3)).rgb, 2.2*vec3(0.45,0.5,0.5));\r\n        roughness = 0.95 - albedo.r * .6;\r\n    }\r\n    else if( mat < MAT_PENCIL_0 ) {\r\n        vec2 npos = pos.yz + PENCIL_POS.yz;\r\n        if (length(npos) < 0.055) {\r\n        \talbedo = vec3(0.02);\r\n        \troughness = .9;\r\n        } else if(sdHexPrism(pos + PENCIL_POS, vec2(.195, 3.)) < 0.) {\r\n        \talbedo = .8* texture(tex1, pos.xz).rgb;\r\n        \troughness = 0.99;\r\n        } else {\r\n        \talbedo = .5*pow(vec3(1.,.8,.15), vec3(2.2));\r\n        \troughness = .75 - noise.b * .4;\r\n        }\r\n        albedo *= noise.g * .75 + .7;\r\n    }\r\n    else if( mat < MAT_PENCIL_1 ) {\r\n       \talbedo = .4*pow(vec3(.85,.75,.55), vec3(2.2));\r\n       \troughness = 1.;\r\n    }\r\n    else if( mat < MAT_PENCIL_2 ) {\r\n        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);\r\n        float r = 1. - abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\r\n\r\n        r -= 4. * metalnoise;  \r\n        ao *= .5 + .5 * r;\r\n\t    albedo = mix(vec3(0.5, 0.3, 0.2),vec3(0.560, 0.570, 0.580), ao * ao); // Iron\r\n   \t\troughness = 1.-.25*r;\r\n   \t\tmetallic = 1.; \r\n    }\r\n    else if( mat < MAT_DIAL ) {\r\n        float dial = texture(tex2, vec2(-.5 * pinv.x + .5, +.5 * pinv.z + .5)).r;\r\n        albedo = vec3(dial);\r\n        roughness = dial + .95;\r\n    }\r\n    else if( mat < MAT_HAND ) {\r\n        albedo = vec3(0.02);\r\n        roughness = .65;\r\n    }\r\n    else if( mat < MAT_METAL_0 ) {\r\n\t    albedo = vec3(1.000, 0.766, 0.336); // Gold\r\n   \t\troughness = .6;\r\n   \t\tmetallic = 1.; \r\n    } \r\n    else if( mat < MAT_METAL_1 ) {\r\n\t    albedo = vec3(0.972, 0.960, 0.915); // Silver\r\n   \t\troughness = .7 + max(.15 * length(pos.xz)-.3, 0.); // prevent aliasing\r\n   \t\tmetallic = 1.; \r\n    }\r\n    \r\n    if (mat < MAT_PENCIL_2) {\r\n        ao = min(ao, smoothstep(.95, 1.5, length(pos.xz)));\r\n    }\r\n    \r\n    if (metallic > .5) {   \r\n        albedo *= 1.-metalnoise;\r\n        roughness += metalnoise*4.;\r\n    }\r\n    \r\n    ao = clamp(.1+.9*ao, 0., 1.);\r\n    roughness = clamp(roughness, 0., 1.);\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta ) {\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(0.0, 1.0,0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n\r\n// Old watch (IBL). Created by Reinder Nijhoff 2018\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/lscBW4\r\n//\r\n// This shader uses Image Based Lighting (IBL) to render an old watch. The\r\n// materials of the objects have physically-based properties.\r\n//\r\n// A material is defined by its albedo and roughness value and it can be a \r\n// metal or a non-metal.\r\n//\r\n// I have used the IBL technique as explained in the article 'Real Shading in\r\n// Unreal Engine 4' by Brian Karis of Epic Games.[1] According to this article,\r\n// the lighting of a material is the sum of two components:\r\n// \r\n// 1. Diffuse: a look-up (using the normal vector) in a pre-computed environment map.\r\n// 2. Specular: a look-up (based on the reflection vector and the roughness of the\r\n//       material) in a pre-computed environment map, combined with a look-up in a\r\n//       pre-calculated BRDF integration map (Buf B).  \r\n// \r\n// Note that I do NOT (pre)compute the environment maps needed in this shader. Instead,\r\n// I use (the lod levels of) a Shadertoy cubemap that I have remapped using a random \r\n// function to get something HDR-ish. This is not correct and not how it is described\r\n// in the article, but I think that for this scene the result is good enough.\r\n//\r\n// I made a shader that renders this same scene using a simple path tracer. You can\r\n// compare the result here:\r\n//\r\n// https://www.shadertoy.com/view/MlyyzW\r\n//\r\n// [1] http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\r\n//\r\n\r\n#define MAX_LOD 8.\r\n#define DIFFUSE_LOD 6.75\r\n#define AA 2\r\n// #define P_MALIN_AO \r\n\r\nvec3 getSpecularLightColor( vec3 N, float roughness ) {\r\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\r\n    return pow(textureLod(iChannel0, N.xy, roughness * MAX_LOD).rgb, vec3(4.5)) * 6.5;\r\n}\r\n\r\nvec3 getDiffuseLightColor( vec3 N ) {\r\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\r\n    return .25 +pow(textureLod(iChannel0, N.xy, DIFFUSE_LOD).rgb, vec3(3.)) * 1.;\r\n}\r\n\r\n//\r\n// Modified FrenelSchlick: https://seblagarde.wordpress.com/2011/08/17/hello-world/\r\n//\r\nvec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\r\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\n\r\n//\r\n// Image based lighting\r\n//\r\n\r\nvec3 lighting(in vec3 ro, in vec3 pos, in vec3 N, in vec3 albedo, in float ao, in float roughness, in float metallic ) {\r\n    vec3 V = normalize(ro - pos); \r\n    vec3 R = reflect(-V, N);\r\n    float NdotV = max(0.0, dot(N, V));\r\n\r\n    vec3 F0 = vec3(0.04); \r\n    F0 = mix(F0, albedo, metallic);\r\n\r\n    vec3 F = FresnelSchlickRoughness(NdotV, F0, roughness);\r\n\r\n    vec3 kS = F;\r\n\r\n    vec3 prefilteredColor = getSpecularLightColor(R, roughness);\r\n    vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\r\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\r\n\r\n    vec3 kD = vec3(1.0) - kS;\r\n\r\n    kD *= 1.0 - metallic;\r\n\r\n    vec3 irradiance = getDiffuseLightColor(N);\r\n\r\n    vec3 diffuse  = albedo * irradiance;\r\n\r\n#ifdef P_MALIN_AO\r\n    vec3 color = kD * diffuse * ao + specular * calcAO(pos, R);\r\n#else\r\n    vec3 color = (kD * diffuse + specular) * ao;\r\n#endif\r\n\r\n    return color;\r\n}\r\n\r\n//\r\n// main \r\n//\r\n\r\nvec3 render( const in vec3 ro, const in vec3 rd ) {\r\n    vec3 col = vec3(0); \r\n    vec2 res = castRay( ro, rd );\r\n\r\n    if (res.x > 0.) {\r\n        vec3 pos = ro + rd * res.x;\r\n        vec3 N, albedo;\r\n        float roughness, metallic, ao;\r\n\r\n        getMaterialProperties(pos, res.y, N, albedo, ao, roughness, metallic, iChannel1, iChannel2, iChannel3);\r\n\r\n        col = lighting(ro, pos, N, albedo, ao, roughness, metallic);\r\n        col *= max(0.0, min(1.1, 10./dot(pos,pos)) - .15);\r\n    }\r\n\r\n    // Glass. \r\n    float glass = castRayGlass( ro, rd );\r\n    if (glass > 0. && (glass < res.x || res.x < 0.)) {\r\n        vec3 N = calcNormalGlass(ro+rd*glass);\r\n        vec3 pos = ro + rd * glass;\r\n\r\n        vec3 V = normalize(ro - pos); \r\n        vec3 R = reflect(-V, N);\r\n        float NdotV = max(0.0, dot(N, V));\r\n\r\n        float roughness = texture(iChannel2, pos.xz*.5 + .5).g;\r\n\r\n        vec3 F = FresnelSchlickRoughness(NdotV, vec3(.08), roughness);\r\n        vec3 prefilteredColor = getSpecularLightColor(R, roughness);\r\n        vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\r\n        vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\r\n\r\n        col = col * (1.0 -  (F * envBRDF.x + envBRDF.y) ) + specular;\r\n    } \r\n\r\n    // gamma correction\r\n    col = max( vec3(0), col - 0.004);\r\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\r\n    \r\n    return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n    vec2 mo = iMouse.xy/iResolution.xy - .5;\r\n    if(iMouse.w <= 0.) {\r\n        mo = vec2(.2*sin(-iTime*.1+.3)+.045,.1-.2*sin(-iTime*.1+.3));\r\n    }\r\n    float a = 5.05;\r\n    vec3 ro = vec3( .25 + 2.*cos(6.0*mo.x+a), 2. + 2. * mo.y, 2.0*sin(6.0*mo.x+a) );\r\n    vec3 ta = vec3( .25, .5, .0 );\r\n    mat3 ca = setCamera( ro, ta );\r\n\r\n    vec3 colT = vec3(0);\r\n    \r\n    for (int x=0; x<AA; x++) {\r\n        for(int y=0; y<AA; y++) {\r\n\t\t    vec2 p = (-iResolution.xy + 2.0*(fragCoord + vec2(x,y)/float(AA) - .5))/iResolution.y;\r\n   \t\t\tvec3 rd = ca * normalize( vec3(p.xy,1.6) );  \r\n            colT += render( ro, rd);           \r\n        }\r\n    }\r\n    \r\n    colT /= float(AA*AA);\r\n    \r\n    fragColor = vec4(colT, 1.0);\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\r\n\tMAX_T = 1000.;\r\n    fragColor = vec4(render(ro * 25. + vec3(0.5,4.,1.5), rd), 1.);\r\n}","inputs":[{"id":null,"filepath":"\\media\\misc\\buffer00.png","type":"buffer","channel":0,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\texture\\08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":null,"published":0},{"id":null,"filepath":"\\media\\misc\\buffer01.png","type":"buffer","channel":3,"sampler":null,"published":0}],"outputs":[],"code":"// Old watch (IBL). Created by Reinder Nijhoff 2018\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/lscBW4\r\n//\r\n// I have moved all ray-march code to this tab, in order to keep the IBL-code in the \r\n// 'Image tab' more readable. The physically-based properties of the materials are also \r\n// defined here.\r\n//\r\n// All (signed) distance field (SDF) code is copy-paste from the excellent framework by \r\n// Inigo Quilez:\r\n//\r\n// https://www.shadertoy.com/view/Xds3zN\r\n//\r\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n//\r\n\r\n#define MAT_TABLE    1.\r\n#define MAT_PENCIL_0 2.\r\n#define MAT_PENCIL_1 3.\r\n#define MAT_PENCIL_2 4.\r\n#define MAT_DIAL     5.\r\n#define MAT_HAND     6.\r\n#define MAT_METAL_0  7.\r\n#define MAT_METAL_1  8.\r\n\r\n#define CLOCK_ROT_X -0.26\r\n#define CLOCK_ROT_Y 0.2\r\n#define CLOCK_OFFSET_Y 0.42\r\n#define PENCIL_POS vec3(-0.31,-0.2, -.725)\r\n\r\nfloat MAX_T = 10.;\r\n\r\n//\r\n// SDF functions (by Inigo Quilez).\r\n//\r\n\r\nfloat sdPlane( const vec3 p ) {\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdTorus( const vec3 p, const vec2 t ) {\r\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\r\n  return length(q)-t.y;\r\n}\r\n\r\nfloat sdTorusYZ( const vec3 p, const vec2 t ) {\r\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\r\n  return length(q)-t.y;\r\n}\r\n\r\nfloat sdTorusYX( const vec3 p, const vec2 t ) {\r\n  vec2 q = vec2(length(p.yx)-t.x,p.z);\r\n  return length(q)-t.y;\r\n}\r\n\r\nfloat sdCylinder( const vec3 p, const vec2 h ) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat sdCylinderZY( const vec3 p, const vec2 h ) {\r\n  vec2 d = abs(vec2(length(p.zy),p.x)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat sdCylinderXY( const vec3 p, const vec2 h ) {\r\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\n\r\nfloat sdHexPrism( const vec3 p, const vec2 h ) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.x-h.y,max((q.z*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.x-h.y;\r\n    float d2 = max((q.z*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\n\r\nfloat sdEllipsoid( const vec3 p, const vec3 r ) {\r\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\r\n}\r\n\r\nfloat sdCapsule( const vec3 p, const vec3 a, const vec3 b, const float r ) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\n\r\nfloat sdSphere( const vec3 p, const float r ) {\r\n    return length(p) - r;\r\n}\r\n\r\nfloat sdCone( const vec3 p, const vec2 c ) {\r\n    float q = length(p.yz);\r\n    return dot(c,vec2(q,p.x));\r\n}\r\n\r\nfloat sdSegment2D( const vec2 p, const vec2 a, const vec2 b, const float w ) {\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - w;\r\n}\r\n\r\nfloat opS( const float d1, const float d2 ) {\r\n    return max(-d1,d2);\r\n}\r\n\r\nfloat opU( const float d1, const float d2 ) {\r\n    return min(d1,d2);\r\n}\r\n\r\nvec3 rotateX( in vec3 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.yz = mat2(co,-si,si,co)*p.yz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateY( in vec3 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xz = mat2(co,-si,si,co)*p.xz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateZ( in vec3 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xy = mat2(co,-si,si,co)*p.xy;\r\n    return p;\r\n}\r\n\r\nvec2 rotate( in vec2 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p = mat2(co,-si,si,co) * p;\r\n    return p;\r\n}\r\n\r\n//\r\n// Hash without Sine by Dave Hoskins.\r\n//\r\n\r\nfloat hash11(float p) {\r\n\tvec3 p3  = fract(vec3(p) * .1031);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\n//\r\n// SDF of the scene.\r\n//\r\n\r\nfloat mapHand( const vec3 pos, const float w, const float l, const float r ) {\r\n    float d = sdSegment2D(pos.xz, vec2(0,-w*10.), vec2(0,l), w);\r\n    d = min(d, length(pos.xz) - (.03+r));\r\n    return max(d, abs(pos.y)-.005);\r\n}\r\n\r\nvec2 map( in vec3 pos, in vec3 p1, in vec3 ps, in vec3 pm, in vec3 ph, \r\n         const bool watchIntersect, const bool pencilIntersect ) {\r\n    //--- table\r\n    vec2 res = vec2(sdPlane(pos), MAT_TABLE);\r\n    \r\n    // chain\r\n    if (pos.z > 1.1) {\r\n        float h = smoothstep(3., -.4, pos.z)*.74 + .045;\r\n        float dChain0 = length(pos.xy+vec2(.3*sin(pos.z), -h))-.1;\r\n        if (dChain0 < 0.1) {\r\n            dChain0 = 10.;\r\n            float pth1z = floor(pos.z*5.);\r\n            if (pth1z > 5.) {\r\n\t            float pth1 = hash11(floor(pos.z*5.));\r\n    \t        vec3 pt1 = vec3(pos.x + .3*sin(pos.z)- pth1 *.02 + 0.02, pos.y-h - pth1 *.03, mod(pos.z, .2) - .1);\r\n        \t    pt1 = rotateZ(pt1, .6 * smoothstep(2.,3., pos.z));\r\n            \tdChain0 = sdTorus(pt1, vec2(.071, .02)); \r\n            }\r\n            \r\n            float pth2z = floor(pos.z*5. + .5);\r\n            float pth2 = hash11(pth2z); \r\n            vec3 pt2 = vec3(pos.x + .3*sin(pos.z)- pth2 *.02 + 0.02, pos.y-h - pth2 *.03, mod(pos.z + .1, .2) - .1);\r\n            pt2 = rotateZ(pt2, 1.1 * smoothstep(2.,3., pos.z));\r\n            dChain0 = opU(dChain0, sdTorusYZ(pt2, vec2(.071, .02)));          \r\n        }\r\n        if (dChain0 < res.x) res = vec2(dChain0, MAT_METAL_1);\r\n    }\r\n    //--- pencil\r\n    if (pencilIntersect) {\r\n        float dPencil0 = sdHexPrism(pos + PENCIL_POS, vec2(.2, 2.));\r\n        dPencil0 = opS(-sdCone(pos + (PENCIL_POS + vec3(-2.05,0,0)), vec2(.95,0.3122)),dPencil0);\r\n        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.4,-2.82,-1.03)), 3.), dPencil0);\r\n        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.5,-0.82,2.86)), 3.), dPencil0);\r\n        if (dPencil0 < res.x) res = vec2(dPencil0, MAT_PENCIL_0);\r\n\r\n        float dPencil1 = sdCapsule(pos, -PENCIL_POS - vec3(2.2,0.,0.), -PENCIL_POS-vec3(2.55, 0., 0.), .21);\r\n        if (dPencil1 < res.x) res = vec2(dPencil1, MAT_PENCIL_1);\r\n        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);\r\n        float r = .02*abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\r\n\r\n        float dPencil2 = sdCylinderZY(pos + PENCIL_POS + vec3(2.25,-0.0125,0), vec2(.22 - r,.25));\r\n        if (dPencil2 < res.x) res = vec2(dPencil2, MAT_PENCIL_2);\r\n    }\r\n    \r\n    //--- watch\r\n    if (watchIntersect) {\r\n        float dDial = sdCylinder(p1, vec2(1.05,.13));\r\n        if (dDial < res.x) res = vec2(dDial, MAT_DIAL);\r\n\r\n        float dC = sdTorusYX(vec3(max(abs(p1.x)-.5*p1.y-0.19,0.),p1.y+0.12,p1.z-1.18), vec2(0.11,0.02));\r\n        if (dC < res.x) res = vec2(dC, MAT_METAL_1);\r\n        \r\n        float dM = sdTorus(p1 + vec3(0,-.165,0), vec2(1.005,.026));   \r\n        float bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15,0.04));\r\n        if(bb < 0.5) {\r\n            float a = atan(p1.y, p1.x);\r\n            float c = abs(fract(a*3.1415)-.5);\r\n            float d = min(abs(p1.z-1.3), .02);\r\n            bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15 - 40.*d*d - .1*c*c,0.04));\r\n        } \r\n        dM = opU(dM, bb);\r\n         \r\n        dM = opU(dM, sdCylinderZY(p1+vec3(0,0,-1.18), vec2(0.06,0.2)));\r\n        float rr = min(abs(p1.z-1.26), .2);\r\n        dM = opU(dM, sdCylinderXY(p1+vec3(0,0,-1.2), vec2(0.025 + 0.35*rr,0.1)));\r\n       \r\n        p1.y = abs(p1.y);\r\n        dM = opU(dM, sdTorus(p1 + vec3(0,-.1,0), vec2(1.025,.075)));\r\n        dM = opU(dM, sdCylinder(p1, vec2(1.1,.1)));\r\n        dM = opS(sdTorus(p1 + vec3(0,-.1,0), vec2(1.11,.015)), dM);\r\n        dM = opU(dM, sdCylinder(p1, vec2(0.01,0.175)));\r\n        dM = opU(dM, sdCylinder(p1+vec3(0,0,.6), vec2(0.01,0.155)));\r\n        if (dM < res.x) res = vec2(dM, MAT_METAL_0);\r\n\r\n        // minutes hand\r\n        float dMin = mapHand(pm + vec3(0,-.16,0), .02, 0.7, 0.015);\r\n        if (dMin < res.x) res = vec2(dMin, MAT_HAND);\r\n        // hours hand\r\n        float dHour = mapHand(ph + vec3(0,-.15,0), .02, 0.4, 0.03);\r\n        if (dHour < res.x) res = vec2(dHour, MAT_HAND);\r\n        // seconds hand\r\n        float dSeconds = mapHand(ps + vec3(0,-.14,0), .01, 0.17, 0.006);\r\n        if (dSeconds < res.x) res = vec2(dSeconds, MAT_HAND);\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\nvec2 map( in vec3 pos ) {\r\n    vec3 p1 = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    \r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\r\n    \r\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\r\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\r\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\r\n    \r\n    return map( pos, p1, ps, pm, ph, true, true );\r\n}\r\n\r\nfloat mapGlass( in vec3 pos ) {\r\n    return sdEllipsoid( pos - vec3(0,.10,0), vec3(1.,.2,1.) );\r\n}\r\n\r\n//\r\n// Ray march code.\r\n//\r\n\r\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float r ) {\r\n\tvec3 oc = ro;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - r * r;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n    h = sqrt( h );\r\n\treturn vec2(-b - h, -b + h);\r\n}\r\n\r\nbool boxIntserct( in vec3 ro, in vec3 rd, in vec3 rad ) {\r\n    vec3 m = 1.0/rd;\r\n    vec3 n = m*ro;\r\n    vec3 k = abs(m)*rad;\r\n\t\r\n    vec3 t1 = -n - k;\r\n    vec3 t2 = -n + k;\r\n\r\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\r\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\r\n\t\r\n\tif( tN > tF || tF < 0.0) return false;\r\n\r\n\treturn true;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos ) {\r\n    const vec2 e = vec2(1.0,-1.0)*0.0075;\r\n    return normalize( e.xyy*map( pos + e.xyy ).x + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\r\n}\r\n\r\nvec2 castRay( in vec3 ro, in vec3 rd ) {\r\n    float tmin = 0.5;\r\n    float tmax = MAX_T;\r\n    \r\n    // bounding volume\r\n    const float top = 0.95;\r\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\r\n    float tp2 = (top-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>top ) tmin = max( tmin, tp2 );\r\n                                                 else           tmax = min( tmax, tp2 ); }\r\n    \r\n    float t = tmin;\r\n    float mat = -1.;\r\n    \r\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\r\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\r\n    \r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\r\n    \r\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\r\n    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );\r\n    \r\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\r\n    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );\r\n    \r\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\r\n    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );\r\n    \r\n    bool watchIntersect = boxIntserct(p1, rd1, vec3(1.1,.2,1.4));\r\n    bool pencilIntersect = boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));\r\n    \r\n    for( int i=0; i<48; i++ ) {\r\n\t    float precis = 0.00025*t;\r\n\t    vec2 res = map( ro+rd*t, p1+rd1*t, ps+rds*t, pm+rdm*t, ph+rdh*t, \r\n                       watchIntersect, pencilIntersect );\r\n        if( res.x<precis || t>tmax ) break; //return vec2(t, mat);\r\n        t += res.x;\r\n        mat = res.y;\r\n    }\r\n\r\n    if( t>tmax ) t=-1.0;\r\n    return vec2(t, mat);\r\n}\r\n\r\nvec3 calcNormalGlass( in vec3 pos ) {\r\n    const vec2 e = vec2(1.0,-1.0)*0.005;\r\n    return normalize( e.xyy*mapGlass( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*mapGlass( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*mapGlass( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*mapGlass( pos + e.xxx ) );\r\n}\r\n\r\nfloat castRayGlass( in vec3 ro, in vec3 rd ) {\r\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\r\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\r\n\r\n    float t = -1.;\r\n    vec2 bb = sphIntersect( p1- vec3(0,.10,0), rd1, 1.);\r\n    if (bb.y > 0.) {\r\n        t = max(bb.x, 0.);\r\n        float tmax = bb.y;\r\n        for( int i=0; i<24; i++ ) {\r\n            float precis = 0.00025*t;\r\n            float res = mapGlass( p1+rd1*t );\r\n            if( res<precis || t>tmax ) break; \r\n            t += res;\r\n        }\r\n\r\n        if( t>tmax ) t=-1.0;\r\n    }\r\n    return t;\r\n}\r\n\r\n\r\nfloat calcAO( in vec3 ro, in vec3 rd ) {\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    \r\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    p1 = rotateY( p1, CLOCK_ROT_Y );\r\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\r\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\r\n    \r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\r\n    \r\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\r\n    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );\r\n    \r\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\r\n    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );\r\n    \r\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\r\n    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );\r\n    \r\n    bool watchIntersect = true; //boxIntserct(p1, rd1, vec3(1.1,.2,1.4));\r\n    bool pencilIntersect = true; //boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));\r\n    \r\n    \r\n    for( int i=0; i<6; i++ ) {\r\n        float h = 0.001 + 0.25*float(i)/5.0;\r\n        float d = map( ro+rd*h, p1+rd1*h, ps+rds*h, pm+rdm*h, ph+rdh*h, \r\n                       watchIntersect, pencilIntersect ).x;\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n    }\r\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \r\n}\r\n\r\n//\r\n// Material properties.\r\n//\r\n\r\nvec4 texNoise( sampler2D sam, in vec3 p, in vec3 n ) {\r\n\tvec4 x = texture( sam, p.yz );\r\n\tvec4 y = texture( sam, p.zx );\r\n\tvec4 z = texture( sam, p.xy );\r\n\r\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\r\n}\r\n\r\nvoid getMaterialProperties(\r\n    in vec3 pos, in float mat,\r\n    inout vec3 normal, inout vec3 albedo, inout float ao, inout float roughness, inout float metallic,\r\n\tsampler2D tex1, sampler2D tex2, sampler2D tex3) {\r\n    \r\n    vec3 pinv = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\r\n    pinv = rotateY( pinv, CLOCK_ROT_Y );\r\n    \r\n    normal = calcNormal( pos );\r\n    ao = calcAO(pos, normal);\r\n    metallic = 0.;\r\n    \r\n    vec4 noise = texNoise(tex1, pinv * .5, normal);\r\n    float metalnoise = 1.- noise.r;\r\n    metalnoise*=metalnoise;\r\n\r\n    mat -= .5;\r\n    if (mat < MAT_TABLE) {\r\n        albedo = .7 * pow(texture(tex1, rotate(pos.xz * .4 + .25, -.3)).rgb, 2.2*vec3(0.45,0.5,0.5));\r\n        roughness = 0.95 - albedo.r * .6;\r\n    }\r\n    else if( mat < MAT_PENCIL_0 ) {\r\n        vec2 npos = pos.yz + PENCIL_POS.yz;\r\n        if (length(npos) < 0.055) {\r\n        \talbedo = vec3(0.02);\r\n        \troughness = .9;\r\n        } else if(sdHexPrism(pos + PENCIL_POS, vec2(.195, 3.)) < 0.) {\r\n        \talbedo = .8* texture(tex1, pos.xz).rgb;\r\n        \troughness = 0.99;\r\n        } else {\r\n        \talbedo = .5*pow(vec3(1.,.8,.15), vec3(2.2));\r\n        \troughness = .75 - noise.b * .4;\r\n        }\r\n        albedo *= noise.g * .75 + .7;\r\n    }\r\n    else if( mat < MAT_PENCIL_1 ) {\r\n       \talbedo = .4*pow(vec3(.85,.75,.55), vec3(2.2));\r\n       \troughness = 1.;\r\n    }\r\n    else if( mat < MAT_PENCIL_2 ) {\r\n        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);\r\n        float r = 1. - abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\r\n\r\n        r -= 4. * metalnoise;  \r\n        ao *= .5 + .5 * r;\r\n\t    albedo = mix(vec3(0.5, 0.3, 0.2),vec3(0.560, 0.570, 0.580), ao * ao); // Iron\r\n   \t\troughness = 1.-.25*r;\r\n   \t\tmetallic = 1.; \r\n    }\r\n    else if( mat < MAT_DIAL ) {\r\n        float dial = texture(tex2, vec2(-.5 * pinv.x + .5, +.5 * pinv.z + .5)).r;\r\n        albedo = vec3(dial);\r\n        roughness = dial + .95;\r\n    }\r\n    else if( mat < MAT_HAND ) {\r\n        albedo = vec3(0.02);\r\n        roughness = .65;\r\n    }\r\n    else if( mat < MAT_METAL_0 ) {\r\n\t    albedo = vec3(1.000, 0.766, 0.336); // Gold\r\n   \t\troughness = .6;\r\n   \t\tmetallic = 1.; \r\n    } \r\n    else if( mat < MAT_METAL_1 ) {\r\n\t    albedo = vec3(0.972, 0.960, 0.915); // Silver\r\n   \t\troughness = .7 + max(.15 * length(pos.xz)-.3, 0.); // prevent aliasing\r\n   \t\tmetallic = 1.; \r\n    }\r\n    \r\n    if (mat < MAT_PENCIL_2) {\r\n        ao = min(ao, smoothstep(.95, 1.5, length(pos.xz)));\r\n    }\r\n    \r\n    if (metallic > .5) {   \r\n        albedo *= 1.-metalnoise;\r\n        roughness += metalnoise*4.;\r\n    }\r\n    \r\n    ao = clamp(.1+.9*ao, 0., 1.);\r\n    roughness = clamp(roughness, 0., 1.);\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta ) {\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(0.0, 1.0,0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n\r\n// Old watch (IBL). Created by Reinder Nijhoff 2018\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/lscBW4\r\n//\r\n// This shader uses Image Based Lighting (IBL) to render an old watch. The\r\n// materials of the objects have physically-based properties.\r\n//\r\n// A material is defined by its albedo and roughness value and it can be a \r\n// metal or a non-metal.\r\n//\r\n// I have used the IBL technique as explained in the article 'Real Shading in\r\n// Unreal Engine 4' by Brian Karis of Epic Games.[1] According to this article,\r\n// the lighting of a material is the sum of two components:\r\n// \r\n// 1. Diffuse: a look-up (using the normal vector) in a pre-computed environment map.\r\n// 2. Specular: a look-up (based on the reflection vector and the roughness of the\r\n//       material) in a pre-computed environment map, combined with a look-up in a\r\n//       pre-calculated BRDF integration map (Buf B).  \r\n// \r\n// Note that I do NOT (pre)compute the environment maps needed in this shader. Instead,\r\n// I use (the lod levels of) a Shadertoy cubemap that I have remapped using a random \r\n// function to get something HDR-ish. This is not correct and not how it is described\r\n// in the article, but I think that for this scene the result is good enough.\r\n//\r\n// I made a shader that renders this same scene using a simple path tracer. You can\r\n// compare the result here:\r\n//\r\n// https://www.shadertoy.com/view/MlyyzW\r\n//\r\n// [1] http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\r\n//\r\n\r\n#define MAX_LOD 8.\r\n#define DIFFUSE_LOD 6.75\r\n#define AA 2\r\n// #define P_MALIN_AO \r\n\r\nvec3 getSpecularLightColor( vec3 N, float roughness ) {\r\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\r\n    return pow(textureLod(iChannel0, N.xy, roughness * MAX_LOD).rgb, vec3(4.5)) * 6.5;\r\n}\r\n\r\nvec3 getDiffuseLightColor( vec3 N ) {\r\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\r\n    return .25 +pow(textureLod(iChannel0, N.xy, DIFFUSE_LOD).rgb, vec3(3.)) * 1.;\r\n}\r\n\r\n//\r\n// Modified FrenelSchlick: https://seblagarde.wordpress.com/2011/08/17/hello-world/\r\n//\r\nvec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\r\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\n\r\n//\r\n// Image based lighting\r\n//\r\n\r\nvec3 lighting(in vec3 ro, in vec3 pos, in vec3 N, in vec3 albedo, in float ao, in float roughness, in float metallic ) {\r\n    vec3 V = normalize(ro - pos); \r\n    vec3 R = reflect(-V, N);\r\n    float NdotV = max(0.0, dot(N, V));\r\n\r\n    vec3 F0 = vec3(0.04); \r\n    F0 = mix(F0, albedo, metallic);\r\n\r\n    vec3 F = FresnelSchlickRoughness(NdotV, F0, roughness);\r\n\r\n    vec3 kS = F;\r\n\r\n    vec3 prefilteredColor = getSpecularLightColor(R, roughness);\r\n    vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\r\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\r\n\r\n    vec3 kD = vec3(1.0) - kS;\r\n\r\n    kD *= 1.0 - metallic;\r\n\r\n    vec3 irradiance = getDiffuseLightColor(N);\r\n\r\n    vec3 diffuse  = albedo * irradiance;\r\n\r\n#ifdef P_MALIN_AO\r\n    vec3 color = kD * diffuse * ao + specular * calcAO(pos, R);\r\n#else\r\n    vec3 color = (kD * diffuse + specular) * ao;\r\n#endif\r\n\r\n    return color;\r\n}\r\n\r\n//\r\n// main \r\n//\r\n\r\nvec3 render( const in vec3 ro, const in vec3 rd ) {\r\n    vec3 col = vec3(0); \r\n    vec2 res = castRay( ro, rd );\r\n\r\n    if (res.x > 0.) {\r\n        vec3 pos = ro + rd * res.x;\r\n        vec3 N, albedo;\r\n        float roughness, metallic, ao;\r\n\r\n        getMaterialProperties(pos, res.y, N, albedo, ao, roughness, metallic, iChannel1, iChannel2, iChannel3);\r\n\r\n        col = lighting(ro, pos, N, albedo, ao, roughness, metallic);\r\n        col *= max(0.0, min(1.1, 10./dot(pos,pos)) - .15);\r\n    }\r\n\r\n    // Glass. \r\n    float glass = castRayGlass( ro, rd );\r\n    if (glass > 0. && (glass < res.x || res.x < 0.)) {\r\n        vec3 N = calcNormalGlass(ro+rd*glass);\r\n        vec3 pos = ro + rd * glass;\r\n\r\n        vec3 V = normalize(ro - pos); \r\n        vec3 R = reflect(-V, N);\r\n        float NdotV = max(0.0, dot(N, V));\r\n\r\n        float roughness = texture(iChannel2, pos.xz*.5 + .5).g;\r\n\r\n        vec3 F = FresnelSchlickRoughness(NdotV, vec3(.08), roughness);\r\n        vec3 prefilteredColor = getSpecularLightColor(R, roughness);\r\n        vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\r\n        vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\r\n\r\n        col = col * (1.0 -  (F * envBRDF.x + envBRDF.y) ) + specular;\r\n    } \r\n\r\n    // gamma correction\r\n    col = max( vec3(0), col - 0.004);\r\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\r\n    \r\n    return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n    vec2 mo = iMouse.xy/iResolution.xy - .5;\r\n    if(iMouse.w <= 0.) {\r\n        mo = vec2(.2*sin(-iTime*.1+.3)+.045,.1-.2*sin(-iTime*.1+.3));\r\n    }\r\n    float a = 5.05;\r\n    vec3 ro = vec3( .25 + 2.*cos(6.0*mo.x+a), 2. + 2. * mo.y, 2.0*sin(6.0*mo.x+a) );\r\n    vec3 ta = vec3( .25, .5, .0 );\r\n    mat3 ca = setCamera( ro, ta );\r\n\r\n    vec3 colT = vec3(0);\r\n    \r\n    for (int x=0; x<AA; x++) {\r\n        for(int y=0; y<AA; y++) {\r\n\t\t    vec2 p = (-iResolution.xy + 2.0*(fragCoord + vec2(x,y)/float(AA) - .5))/iResolution.y;\r\n   \t\t\tvec3 rd = ca * normalize( vec3(p.xy,1.6) );  \r\n            colT += render( ro, rd);           \r\n        }\r\n    }\r\n    \r\n    colT /= float(AA*AA);\r\n    \r\n    fragColor = vec4(colT, 1.0);\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\r\n\tMAX_T = 1000.;\r\n    fragColor = vec4(render(ro * 25. + vec3(0.5,4.,1.5), rd), 1.);\r\n}","name":"Image","description":null,"type":"image"},{"Code":"vec2 rotate( in vec2 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p = mat2(co,-si,si,co) * p;\r\n    return p;\r\n}\r\n// Old watch (IBL). Created by Reinder Nijhoff 2018\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/lscBW4\r\n//\r\n// In this buffer the albedo of the dial (red channel) and the roughness\r\n// of the glass (green channel) is pre-calculated.\r\n//\r\n\r\nbool resolutionChanged() {\r\n    return floor(texelFetch(iChannel0, ivec2(0), 0).r) != floor(iResolution.x);\r\n}\r\n\r\nfloat printChar(vec2 uv, uint c) {\r\n    float d = textureLod(iChannel1, (uv + vec2( c & 0xFU, 0xFU - (c >> 4))) / 16.,0.).a;\r\n\treturn smoothstep(1.,0., smoothstep(.5,.51,d));\r\n}\r\n\r\nfloat dialSub( in vec2 uv, float wr ) {\r\n    float r = length( uv );\r\n    float a = atan( uv.y, uv.x )+3.1415926;\r\n\r\n    float f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n    float g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n    float w = fwidth(f);\r\n    f = 1.0 - smoothstep( 0.2*g+0.05-w, 0.2*g+0.05+w, f );\r\n    float s = abs(fwidth(r));\r\n    f *= smoothstep( 0.9 - wr -s, 0.9 - wr, r ) - smoothstep( 0.9, 0.9+s, r );\r\n    float hwr = wr * .5;\r\n    f -= 1.-smoothstep(hwr+s,hwr,abs(r-0.9+hwr)) - smoothstep(hwr-s,hwr,abs(r-0.9+hwr));\r\n\r\n    return .1 + .8 * clamp(1.-f,0.,1.);\r\n}\r\n\r\nfloat dial(vec2 uv) {\r\n    float d = dialSub(uv, 0.05);\r\n\r\n    vec2 uvs = uv;\r\n    \r\n    uvs.y += 0.6;\r\n    uvs *= 1./(0.85-0.6);\r\n\r\n    d = min(d, dialSub(uvs, 0.1));\r\n    \r\n    vec2 center = vec2(0.5);\r\n    vec2 radius = vec2(3.65, 0.);\r\n    \r\n    for (int i=0; i<9; i++) {\r\n        if(i!=5) {\r\n\t        float a = 6.28318530718 * float(i+4)/12.;\r\n    \t    vec2 uvt = clamp(uv * 5. + center + rotate(radius, a), vec2(0), vec2(1));\r\n        \td = mix(d, 0.3, printChar(uvt, uint(49+i)));\r\n        }\r\n    }\r\n    for (int i=0; i<3; i++) {\r\n\t    float a = 6.28318530718 * float(i+13)/12.;\r\n    \tvec2 uvt1 = clamp(uv * 5. + center + rotate(radius, a) + vec2(.25,0.), vec2(0), vec2(1));\r\n        d = mix(d, 0.3, printChar(uvt1, uint(49)));\r\n    \tvec2 uvt = clamp(uv * 5. + center + rotate(radius, a)+ vec2(-.15,0.), vec2(0), vec2(1));\r\n        d = mix(d, 0.3, printChar(uvt, uint(48+i)));\r\n    }\r\n    \r\n    d *= .9 + .25*texture(iChannel2, uv*.5+.5).r;\r\n    \r\n    return pow(clamp(d, 0., 1.), 2.2);\r\n}\r\n\r\nfloat roughnessGlass(vec2 uv) {\r\n    uv = uv * .5 + .5;\r\n    return smoothstep(0.2, 0.8, texture(iChannel2, uv * .3).r) * .4 + .2;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \r\n    if(resolutionChanged() && iResolution.x > 0.  && iResolution.x > 0.) {\r\n        if (fragCoord.x < 1.5 && fragCoord.y < 1.5) {\r\n            fragColor = floor(iResolution.xyxy);\r\n        } else {\r\n            vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.xy;\r\n\r\n            fragColor = vec4( dial(uv), roughnessGlass(uv), 0., 1.0 );      \r\n        }\r\n    } else {\r\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\r\n    }\r\n}","inputs":[],"outputs":[],"code":"vec2 rotate( in vec2 p, const float t ) {\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p = mat2(co,-si,si,co) * p;\r\n    return p;\r\n}\r\n// Old watch (IBL). Created by Reinder Nijhoff 2018\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/lscBW4\r\n//\r\n// In this buffer the albedo of the dial (red channel) and the roughness\r\n// of the glass (green channel) is pre-calculated.\r\n//\r\n\r\nbool resolutionChanged() {\r\n    return floor(texelFetch(iChannel0, ivec2(0), 0).r) != floor(iResolution.x);\r\n}\r\n\r\nfloat printChar(vec2 uv, uint c) {\r\n    float d = textureLod(iChannel1, (uv + vec2( c & 0xFU, 0xFU - (c >> 4))) / 16.,0.).a;\r\n\treturn smoothstep(1.,0., smoothstep(.5,.51,d));\r\n}\r\n\r\nfloat dialSub( in vec2 uv, float wr ) {\r\n    float r = length( uv );\r\n    float a = atan( uv.y, uv.x )+3.1415926;\r\n\r\n    float f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n    float g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n    float w = fwidth(f);\r\n    f = 1.0 - smoothstep( 0.2*g+0.05-w, 0.2*g+0.05+w, f );\r\n    float s = abs(fwidth(r));\r\n    f *= smoothstep( 0.9 - wr -s, 0.9 - wr, r ) - smoothstep( 0.9, 0.9+s, r );\r\n    float hwr = wr * .5;\r\n    f -= 1.-smoothstep(hwr+s,hwr,abs(r-0.9+hwr)) - smoothstep(hwr-s,hwr,abs(r-0.9+hwr));\r\n\r\n    return .1 + .8 * clamp(1.-f,0.,1.);\r\n}\r\n\r\nfloat dial(vec2 uv) {\r\n    float d = dialSub(uv, 0.05);\r\n\r\n    vec2 uvs = uv;\r\n    \r\n    uvs.y += 0.6;\r\n    uvs *= 1./(0.85-0.6);\r\n\r\n    d = min(d, dialSub(uvs, 0.1));\r\n    \r\n    vec2 center = vec2(0.5);\r\n    vec2 radius = vec2(3.65, 0.);\r\n    \r\n    for (int i=0; i<9; i++) {\r\n        if(i!=5) {\r\n\t        float a = 6.28318530718 * float(i+4)/12.;\r\n    \t    vec2 uvt = clamp(uv * 5. + center + rotate(radius, a), vec2(0), vec2(1));\r\n        \td = mix(d, 0.3, printChar(uvt, uint(49+i)));\r\n        }\r\n    }\r\n    for (int i=0; i<3; i++) {\r\n\t    float a = 6.28318530718 * float(i+13)/12.;\r\n    \tvec2 uvt1 = clamp(uv * 5. + center + rotate(radius, a) + vec2(.25,0.), vec2(0), vec2(1));\r\n        d = mix(d, 0.3, printChar(uvt1, uint(49)));\r\n    \tvec2 uvt = clamp(uv * 5. + center + rotate(radius, a)+ vec2(-.15,0.), vec2(0), vec2(1));\r\n        d = mix(d, 0.3, printChar(uvt, uint(48+i)));\r\n    }\r\n    \r\n    d *= .9 + .25*texture(iChannel2, uv*.5+.5).r;\r\n    \r\n    return pow(clamp(d, 0., 1.), 2.2);\r\n}\r\n\r\nfloat roughnessGlass(vec2 uv) {\r\n    uv = uv * .5 + .5;\r\n    return smoothstep(0.2, 0.8, texture(iChannel2, uv * .3).r) * .4 + .2;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \r\n    if(resolutionChanged() && iResolution.x > 0.  && iResolution.x > 0.) {\r\n        if (fragCoord.x < 1.5 && fragCoord.y < 1.5) {\r\n            fragColor = floor(iResolution.xyxy);\r\n        } else {\r\n            vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.xy;\r\n\r\n            fragColor = vec4( dial(uv), roughnessGlass(uv), 0., 1.0 );      \r\n        }\r\n    } else {\r\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\r\n    }\r\n}","name":"Buf A","description":null,"type":null},{"Code":"// Old watch (IBL). Created by Reinder Nijhoff 2018\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/lscBW4\r\n//\r\n// In this buffer I pre-calculate the BRDF integration map, as described in:\r\n// http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\r\n//\r\n\r\nconst float PI = 3.14159265359;\r\n\r\n// see: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\r\nfloat PartialGeometryGGX(float NdotV, float a) {\r\n    float k = a / 2.0;\r\n\r\n    float nominator   = NdotV;\r\n    float denominator = NdotV * (1.0 - k) + k;\r\n\r\n    return nominator / denominator;\r\n}\r\n\r\nfloat GeometryGGX_Smith(float NdotV, float NdotL, float roughness) {\r\n    float a = roughness*roughness;\r\n    float G1 = PartialGeometryGGX(NdotV, a);\r\n    float G2 = PartialGeometryGGX(NdotL, a);\r\n    return G1 * G2;\r\n}\r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n\r\nvec2 Hammersley(int i, int N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(uint(i)));\r\n} \r\n\r\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness) {\r\n    float a = roughness*roughness;\r\n    float phi      = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\r\n    vec3 HTangent;\r\n    HTangent.x = sinTheta*cos(phi);\r\n    HTangent.y = sinTheta*sin(phi);\r\n    HTangent.z = cosTheta;\r\n\r\n    return HTangent;\r\n}\r\n\r\nvec2 IntegrateBRDF(float roughness, float NdotV) {\r\n    vec3 V;\r\n    V.x = sqrt(1.0 - NdotV*NdotV);\r\n    V.y = 0.0;\r\n    V.z = NdotV;\r\n\r\n    float A = 0.0;\r\n    float B = 0.0;\r\n\r\n    const int SAMPLE_COUNT = 128;\r\n\r\n    vec3 N = vec3(0.0, 0.0, 1.0);\r\n    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 TangentX = normalize(cross(UpVector, N));\r\n    vec3 TangentY = cross(N, TangentX);\r\n\r\n    for(int i = 0; i < SAMPLE_COUNT; ++i)  {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        vec3 HTangent = ImportanceSampleGGX(Xi, roughness);\r\n        \r\n        vec3 H = normalize(HTangent.x * TangentX + HTangent.y * TangentY + HTangent.z * N);\r\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n        float NdotL = max(L.z, 0.0);\r\n        float NdotH = max(H.z, 0.0);\r\n        float VdotH = max(dot(V, H), 0.0);\r\n\r\n        if(NdotL > 0.0) {\r\n            float G = GeometryGGX_Smith(NdotV, NdotL, roughness);\r\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\r\n            float Fc = pow(1.0 - VdotH, 5.0);\r\n\r\n            A += (1.0 - Fc) * G_Vis;\r\n            B += Fc * G_Vis;\r\n        }\r\n    }\r\n    A /= float(SAMPLE_COUNT);\r\n    B /= float(SAMPLE_COUNT);\r\n    return vec2(A, B);\r\n}\r\n\r\nbool resolutionChanged() {\r\n    return floor(texelFetch(iChannel0, ivec2(0), 0).r) != floor(iResolution.x);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    if(resolutionChanged()) {\r\n        if (fragCoord.x < 1.5 && fragCoord.y < 1.5) {\r\n            fragColor = floor(iResolution.xyxy);\r\n        } else {\r\n\t   \t\tvec2 uv = fragCoord / iResolution.xy;\r\n    \t\tvec2 integratedBRDF = IntegrateBRDF(uv.y, uv.x);\r\n   \t \t\tfragColor = vec4(integratedBRDF, 0.0,1.0);\r\n        }\r\n    } else {\r\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\r\n    }\r\n}","inputs":[],"outputs":[],"code":"// Old watch (IBL). Created by Reinder Nijhoff 2018\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/lscBW4\r\n//\r\n// In this buffer I pre-calculate the BRDF integration map, as described in:\r\n// http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\r\n//\r\n\r\nconst float PI = 3.14159265359;\r\n\r\n// see: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\r\nfloat PartialGeometryGGX(float NdotV, float a) {\r\n    float k = a / 2.0;\r\n\r\n    float nominator   = NdotV;\r\n    float denominator = NdotV * (1.0 - k) + k;\r\n\r\n    return nominator / denominator;\r\n}\r\n\r\nfloat GeometryGGX_Smith(float NdotV, float NdotL, float roughness) {\r\n    float a = roughness*roughness;\r\n    float G1 = PartialGeometryGGX(NdotV, a);\r\n    float G2 = PartialGeometryGGX(NdotL, a);\r\n    return G1 * G2;\r\n}\r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n\r\nvec2 Hammersley(int i, int N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(uint(i)));\r\n} \r\n\r\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness) {\r\n    float a = roughness*roughness;\r\n    float phi      = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\r\n    vec3 HTangent;\r\n    HTangent.x = sinTheta*cos(phi);\r\n    HTangent.y = sinTheta*sin(phi);\r\n    HTangent.z = cosTheta;\r\n\r\n    return HTangent;\r\n}\r\n\r\nvec2 IntegrateBRDF(float roughness, float NdotV) {\r\n    vec3 V;\r\n    V.x = sqrt(1.0 - NdotV*NdotV);\r\n    V.y = 0.0;\r\n    V.z = NdotV;\r\n\r\n    float A = 0.0;\r\n    float B = 0.0;\r\n\r\n    const int SAMPLE_COUNT = 128;\r\n\r\n    vec3 N = vec3(0.0, 0.0, 1.0);\r\n    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 TangentX = normalize(cross(UpVector, N));\r\n    vec3 TangentY = cross(N, TangentX);\r\n\r\n    for(int i = 0; i < SAMPLE_COUNT; ++i)  {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        vec3 HTangent = ImportanceSampleGGX(Xi, roughness);\r\n        \r\n        vec3 H = normalize(HTangent.x * TangentX + HTangent.y * TangentY + HTangent.z * N);\r\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n        float NdotL = max(L.z, 0.0);\r\n        float NdotH = max(H.z, 0.0);\r\n        float VdotH = max(dot(V, H), 0.0);\r\n\r\n        if(NdotL > 0.0) {\r\n            float G = GeometryGGX_Smith(NdotV, NdotL, roughness);\r\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\r\n            float Fc = pow(1.0 - VdotH, 5.0);\r\n\r\n            A += (1.0 - Fc) * G_Vis;\r\n            B += Fc * G_Vis;\r\n        }\r\n    }\r\n    A /= float(SAMPLE_COUNT);\r\n    B /= float(SAMPLE_COUNT);\r\n    return vec2(A, B);\r\n}\r\n\r\nbool resolutionChanged() {\r\n    return floor(texelFetch(iChannel0, ivec2(0), 0).r) != floor(iResolution.x);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    if(resolutionChanged()) {\r\n        if (fragCoord.x < 1.5 && fragCoord.y < 1.5) {\r\n            fragColor = floor(iResolution.xyxy);\r\n        } else {\r\n\t   \t\tvec2 uv = fragCoord / iResolution.xy;\r\n    \t\tvec2 integratedBRDF = IntegrateBRDF(uv.y, uv.x);\r\n   \t \t\tfragColor = vec4(integratedBRDF, 0.0,1.0);\r\n        }\r\n    } else {\r\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\r\n    }\r\n}","name":"Buf B","description":null,"type":null}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\n// See also:\r\n//\r\n// Input - Keyboard    : https://www.shadertoy.com/view/lsXGzf\r\n// Input - Microphone  : https://www.shadertoy.com/view/llSGDh\r\n// Input - Mouse       : https://www.shadertoy.com/view/Mss3zH\r\n// Input - Sound       : https://www.shadertoy.com/view/Xds3Rr\r\n// Input - SoundCloud  : https://www.shadertoy.com/view/MsdGzn\r\n// Input - Time        : https://www.shadertoy.com/view/lsXGz8\r\n// Input - TimeDelta   : https://www.shadertoy.com/view/lsKGWV\r\n// Inout - 3D Texture  : https://www.shadertoy.com/view/4llcR4\r\n\r\n\r\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\r\n{\r\n   float f = sdLine( p, a, b );\r\n   float g = fwidth(f)*w.y;\r\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\r\n}\r\n\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get time\r\n    float mils = fract(iDate.w);\r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\r\n    \r\n    // enable this for subsecond resolution\r\n    //secs += mils;\r\n\r\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\r\n\r\n\tfloat r = length( uv );\r\n\tfloat a = atan( uv.y, uv.x )+3.1415926;\r\n    \r\n\t// background color\r\n\tvec3 nightColor = vec3( 0.2, 0.2, 0.2 ) + 0.1*uv.y;\r\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\r\n\tvec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - \r\n\t\t\t\t                          smoothstep(19.0,21.0, hors ) );\r\n\r\n    // inner watch body\t\r\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\r\n\r\n    // 5 minute marks\t\r\n\tfloat f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n\tfloat w = fwidth(f);\r\n\tf = 1.0 - smoothstep( 0.1*g+0.05-w, 0.1*g+0.05+w, f );\r\n\tf *= smoothstep( 0.85, 0.86, r+0.05*g ) - smoothstep( 0.94, 0.95, r );\r\n\tcol = mix( col, vec3(0.0), f );\r\n\r\n\t// seconds hand\r\n\tvec2 dir;\r\n\tdir = vec2( sin(6.2831*secs/60.0), cos(6.2831*secs/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.9, uv+0.05, vec2(0.005,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.0, uv+0.05, vec2(0.055,4.0), vec4(0.0,0.0,0.0,0.2) ); \r\n    col = line( col, vec2(0.0), dir*0.9, uv,      vec2(0.005,1.0), vec4(0.5,0.0,0.0,1.0) );\r\n\r\n\t// minutes hand\r\n\tdir = vec2( sin(6.2831*mins/60.0), cos(6.2831*mins/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // hours hand\r\n\tdir = vec2( sin(6.2831*hors/12.0), cos(6.2831*hors/12.0) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // center mini circle\t\r\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.050,0.055,r) );\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.005,0.01,abs(r-0.055)) );\r\n\r\n    // border of watch\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(r-0.95)) );\r\n\r\n    // dithering    \r\n    col += (1.0/255.0)*hash3(uv.x+13.0*uv.y);\r\n\r\n\tfragColor = vec4( col,1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\n// See also:\r\n//\r\n// Input - Keyboard    : https://www.shadertoy.com/view/lsXGzf\r\n// Input - Microphone  : https://www.shadertoy.com/view/llSGDh\r\n// Input - Mouse       : https://www.shadertoy.com/view/Mss3zH\r\n// Input - Sound       : https://www.shadertoy.com/view/Xds3Rr\r\n// Input - SoundCloud  : https://www.shadertoy.com/view/MsdGzn\r\n// Input - Time        : https://www.shadertoy.com/view/lsXGz8\r\n// Input - TimeDelta   : https://www.shadertoy.com/view/lsKGWV\r\n// Inout - 3D Texture  : https://www.shadertoy.com/view/4llcR4\r\n\r\n\r\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\r\n{\r\n   float f = sdLine( p, a, b );\r\n   float g = fwidth(f)*w.y;\r\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\r\n}\r\n\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get time\r\n    float mils = fract(iDate.w);\r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\r\n    \r\n    // enable this for subsecond resolution\r\n    //secs += mils;\r\n\r\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\r\n\r\n\tfloat r = length( uv );\r\n\tfloat a = atan( uv.y, uv.x )+3.1415926;\r\n    \r\n\t// background color\r\n\tvec3 nightColor = vec3( 0.2, 0.2, 0.2 ) + 0.1*uv.y;\r\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\r\n\tvec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - \r\n\t\t\t\t                          smoothstep(19.0,21.0, hors ) );\r\n\r\n    // inner watch body\t\r\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\r\n\r\n    // 5 minute marks\t\r\n\tfloat f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n\tfloat w = fwidth(f);\r\n\tf = 1.0 - smoothstep( 0.1*g+0.05-w, 0.1*g+0.05+w, f );\r\n\tf *= smoothstep( 0.85, 0.86, r+0.05*g ) - smoothstep( 0.94, 0.95, r );\r\n\tcol = mix( col, vec3(0.0), f );\r\n\r\n\t// seconds hand\r\n\tvec2 dir;\r\n\tdir = vec2( sin(6.2831*secs/60.0), cos(6.2831*secs/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.9, uv+0.05, vec2(0.005,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.0, uv+0.05, vec2(0.055,4.0), vec4(0.0,0.0,0.0,0.2) ); \r\n    col = line( col, vec2(0.0), dir*0.9, uv,      vec2(0.005,1.0), vec4(0.5,0.0,0.0,1.0) );\r\n\r\n\t// minutes hand\r\n\tdir = vec2( sin(6.2831*mins/60.0), cos(6.2831*mins/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // hours hand\r\n\tdir = vec2( sin(6.2831*hors/12.0), cos(6.2831*hors/12.0) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // center mini circle\t\r\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.050,0.055,r) );\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.005,0.01,abs(r-0.055)) );\r\n\r\n    // border of watch\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(r-0.95)) );\r\n\r\n    // dithering    \r\n    col += (1.0/255.0)*hash3(uv.x+13.0*uv.y);\r\n\r\n\tfragColor = vec4( col,1.0 );\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"2D SDF Input - Time","id":null,"date":null,"viewed":0,"name":"2D SDF Input - Time","description":"Simple realtime, real time, watch. The background changes with the time of day - dark grey at night, and blue during the day","likes":0,"published":null,"tags":["2d"," time"," clock"," watch"]},"ver":null,"info":{"Name":"2D SDF Input - Time","id":null,"date":null,"viewed":0,"name":"2D SDF Input - Time","description":"Simple realtime, real time, watch. The background changes with the time of day - dark grey at night, and blue during the day","likes":0,"published":null,"tags":["2d"," time"," clock"," watch"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\n// See also:\r\n//\r\n// Input - Keyboard    : https://www.shadertoy.com/view/lsXGzf\r\n// Input - Microphone  : https://www.shadertoy.com/view/llSGDh\r\n// Input - Mouse       : https://www.shadertoy.com/view/Mss3zH\r\n// Input - Sound       : https://www.shadertoy.com/view/Xds3Rr\r\n// Input - SoundCloud  : https://www.shadertoy.com/view/MsdGzn\r\n// Input - Time        : https://www.shadertoy.com/view/lsXGz8\r\n// Input - TimeDelta   : https://www.shadertoy.com/view/lsKGWV\r\n// Inout - 3D Texture  : https://www.shadertoy.com/view/4llcR4\r\n\r\n\r\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\r\n{\r\n   float f = sdLine( p, a, b );\r\n   float g = fwidth(f)*w.y;\r\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\r\n}\r\n\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get time\r\n    float mils = fract(iDate.w);\r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\r\n    \r\n    // enable this for subsecond resolution\r\n    //secs += mils;\r\n\r\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\r\n\r\n\tfloat r = length( uv );\r\n\tfloat a = atan( uv.y, uv.x )+3.1415926;\r\n    \r\n\t// background color\r\n\tvec3 nightColor = vec3( 0.2, 0.2, 0.2 ) + 0.1*uv.y;\r\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\r\n\tvec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - \r\n\t\t\t\t                          smoothstep(19.0,21.0, hors ) );\r\n\r\n    // inner watch body\t\r\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\r\n\r\n    // 5 minute marks\t\r\n\tfloat f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n\tfloat w = fwidth(f);\r\n\tf = 1.0 - smoothstep( 0.1*g+0.05-w, 0.1*g+0.05+w, f );\r\n\tf *= smoothstep( 0.85, 0.86, r+0.05*g ) - smoothstep( 0.94, 0.95, r );\r\n\tcol = mix( col, vec3(0.0), f );\r\n\r\n\t// seconds hand\r\n\tvec2 dir;\r\n\tdir = vec2( sin(6.2831*secs/60.0), cos(6.2831*secs/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.9, uv+0.05, vec2(0.005,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.0, uv+0.05, vec2(0.055,4.0), vec4(0.0,0.0,0.0,0.2) ); \r\n    col = line( col, vec2(0.0), dir*0.9, uv,      vec2(0.005,1.0), vec4(0.5,0.0,0.0,1.0) );\r\n\r\n\t// minutes hand\r\n\tdir = vec2( sin(6.2831*mins/60.0), cos(6.2831*mins/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // hours hand\r\n\tdir = vec2( sin(6.2831*hors/12.0), cos(6.2831*hors/12.0) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // center mini circle\t\r\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.050,0.055,r) );\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.005,0.01,abs(r-0.055)) );\r\n\r\n    // border of watch\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(r-0.95)) );\r\n\r\n    // dithering    \r\n    col += (1.0/255.0)*hash3(uv.x+13.0*uv.y);\r\n\r\n\tfragColor = vec4( col,1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\n// See also:\r\n//\r\n// Input - Keyboard    : https://www.shadertoy.com/view/lsXGzf\r\n// Input - Microphone  : https://www.shadertoy.com/view/llSGDh\r\n// Input - Mouse       : https://www.shadertoy.com/view/Mss3zH\r\n// Input - Sound       : https://www.shadertoy.com/view/Xds3Rr\r\n// Input - SoundCloud  : https://www.shadertoy.com/view/MsdGzn\r\n// Input - Time        : https://www.shadertoy.com/view/lsXGz8\r\n// Input - TimeDelta   : https://www.shadertoy.com/view/lsKGWV\r\n// Inout - 3D Texture  : https://www.shadertoy.com/view/4llcR4\r\n\r\n\r\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\r\n{\r\n   float f = sdLine( p, a, b );\r\n   float g = fwidth(f)*w.y;\r\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\r\n}\r\n\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get time\r\n    float mils = fract(iDate.w);\r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\r\n    \r\n    // enable this for subsecond resolution\r\n    //secs += mils;\r\n\r\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\r\n\r\n\tfloat r = length( uv );\r\n\tfloat a = atan( uv.y, uv.x )+3.1415926;\r\n    \r\n\t// background color\r\n\tvec3 nightColor = vec3( 0.2, 0.2, 0.2 ) + 0.1*uv.y;\r\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\r\n\tvec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - \r\n\t\t\t\t                          smoothstep(19.0,21.0, hors ) );\r\n\r\n    // inner watch body\t\r\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\r\n\r\n    // 5 minute marks\t\r\n\tfloat f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n\tfloat w = fwidth(f);\r\n\tf = 1.0 - smoothstep( 0.1*g+0.05-w, 0.1*g+0.05+w, f );\r\n\tf *= smoothstep( 0.85, 0.86, r+0.05*g ) - smoothstep( 0.94, 0.95, r );\r\n\tcol = mix( col, vec3(0.0), f );\r\n\r\n\t// seconds hand\r\n\tvec2 dir;\r\n\tdir = vec2( sin(6.2831*secs/60.0), cos(6.2831*secs/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.9, uv+0.05, vec2(0.005,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.0, uv+0.05, vec2(0.055,4.0), vec4(0.0,0.0,0.0,0.2) ); \r\n    col = line( col, vec2(0.0), dir*0.9, uv,      vec2(0.005,1.0), vec4(0.5,0.0,0.0,1.0) );\r\n\r\n\t// minutes hand\r\n\tdir = vec2( sin(6.2831*mins/60.0), cos(6.2831*mins/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // hours hand\r\n\tdir = vec2( sin(6.2831*hors/12.0), cos(6.2831*hors/12.0) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // center mini circle\t\r\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.050,0.055,r) );\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.005,0.01,abs(r-0.055)) );\r\n\r\n    // border of watch\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(r-0.95)) );\r\n\r\n    // dithering    \r\n    col += (1.0/255.0)*hash3(uv.x+13.0*uv.y);\r\n\r\n\tfragColor = vec4( col,1.0 );\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Seascape","id":null,"date":null,"viewed":0,"name":"Seascape","description":"fully-procedural sea surface computing. without textures.\r\n\r\nAndroid version: https://play.google.com/store/apps/details?id=com.nature.seascape","likes":0,"published":null,"tags":["procedural"," noise"," waves"," sea"," water"," subsurface"]},"ver":null,"info":{"Name":"Seascape","id":null,"date":null,"viewed":0,"name":"Seascape","description":"fully-procedural sea surface computing. without textures.\r\n\r\nAndroid version: https://play.google.com/store/apps/details?id=com.nature.seascape","likes":0,"published":null,"tags":["procedural"," noise"," waves"," sea"," water"," subsurface"]},"renderpass":[{"Code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Rays traverse a uniform grid and are tested against a triangle (actually this is just\r\n// a ray-versus-plane test). Rather than sampling the heightfield 3 times to get the triangle\r\n// vertices, previous vertices are kept and only one of the vertices is updated at each step.\r\n// So the heightfield is only sampled once per step.\r\n//\r\n// The algorithm is similar to triangle strip rasterisation, in that each new vertex\r\n// together with previous 2 vertices define a triangle.\r\n//\r\n\r\n//\r\n// The shaders of this series:\r\n//\r\n//   Triangulated Heightfield Trick 1 - https://www.shadertoy.com/view/XlcBRX (Rigid, right-triangle)\r\n//   Triangulated Heightfield Trick 2 - https://www.shadertoy.com/view/tlXSzB (Rigid, equilateral)\r\n//   Triangulated Heightfield Trick 3 - https://www.shadertoy.com/view/ttsSzX (Deforming, equilateral)\r\n//   Tetrahedral Voxel Traversal      - https://www.shadertoy.com/view/wtfXWB (Rigid, tetrahedron)\r\n//\r\n\r\n\r\n// Use this to toggle between taking 1 sample of the heightfield and taking\r\n// 3 samples (to fully construct the triangle on every step).\r\n#define SINGLE_SAMPLE 1\r\n\r\nfloat minh = 0.0, maxh = 6.0;\r\nvec3 nn = vec3(0);\r\n\r\nfloat hash(float n)\r\n{\r\n    return fract(sin(n) * 43758.5453);\r\n}\r\n\r\nfloat noise(vec3 p)\r\n{\r\n    return hash(p.x + p.y*57.0 + p.z*117.0);\r\n}\r\n\r\nfloat valnoise(vec3 p)\r\n{\r\n    vec3 c = floor(p);\r\n    vec3 f = smoothstep(0., 1., fract(p));\r\n    return mix(\r\n        mix (mix(noise(c + vec3(0, 0, 0)), noise(c + vec3(1, 0, 0)), f.x),\r\n             mix(noise(c + vec3(0, 1, 0)), noise(c + vec3(1, 1, 0)), f.x), f.y),\r\n        mix (mix(noise(c + vec3(0, 0, 1)), noise(c + vec3(1, 0, 1)), f.x),\r\n             mix(noise(c + vec3(0, 1, 1)), noise(c + vec3(1, 1, 1)), f.x), f.y),\r\n        f.z);\r\n}\r\n\r\nfloat fbm(vec3 p)\r\n{\r\n    float f = 0.;\r\n    for(int i = 0; i < 5; ++i)\r\n        f += (valnoise(p * exp2(float(i))) - .5) / exp2(float(i));\r\n    return f;\r\n}\r\n\r\nfloat height(vec2 p)\r\n{\r\n    float h = mix(minh, maxh * 1.3, pow(clamp(.2 + .8 * fbm(vec3(p / 6., 0.)), 0., 1.), 1.3));\r\n    h += valnoise(vec3(p, .3));\r\n    return h;\r\n}\r\n\r\n// The raytracing function\r\nvec3 tr2(vec3 o,vec3 r)\r\n{\r\n    // Start ray at upper Y bounds\r\n    if(o.y > maxh)\r\n        o += r * (maxh - o.y) / r.y;\r\n    \r\n    vec2 oc = vec2(floor(o.x), floor(o.z)), c;\r\n    vec2 dn = normalize(vec2(-1, 1));\r\n    vec3 ta, tb, tc;\r\n\r\n    // Initialise the triangle vertices\r\n    ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\r\n    tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\r\n    if(fract(o.z) < fract(o.x))\r\n        tb = vec3(oc.x + 1., height(oc + vec2(1, 0)), oc.y + 0.);\r\n    else\r\n        tb = vec3(oc.x, height(oc + vec2(0, 1)), oc.y + 1.);\r\n\r\n    float t0 = 1e-4, t1;\r\n\r\n    // Ray slopes\r\n    vec2 dd = vec2(1) / r.xz;\r\n    float dnt = 1.0 / dot(r.xz, dn);\r\n    \r\n    float s = max(sign(dnt), 0.);\r\n    c = ((oc + max(sign(r.xz), 0.)) - o.xz) * dd;\r\n\r\n    vec3 rs = sign(r);\r\n\r\n    for(int i = 0; i < 450; ++i)\r\n    {  \r\n        t1 = min(c.x, c.y);\r\n\r\n        // Test ray against diagonal plane\r\n        float dt = dot(oc - o.xz, dn) * dnt;\r\n        if(dt > t0 && dt < t1)\r\n            t1 = dt;\r\n \r\n#if !SINGLE_SAMPLE\r\n        // Sample the heightfield for all three vertices.\r\n        vec2 of = (dot(o.xz + r.xz * (t0 + t1) * .5 - oc, dn) > 0.) ? vec2(0, 1) : vec2(1, 0);\r\n        tb = vec3(oc.x + of.x, height(oc + of), oc.y + of.y);\r\n        ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\r\n        tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\r\n#endif        \r\n\r\n        // Test ray against triangle plane\r\n        vec3 hn = cross(ta - tb, tc - tb);\r\n        float hh = dot(ta - o, hn) / dot(r, hn);\r\n\r\n        if(hh > t0 && hh < t1)\r\n        {\r\n            // Intersection with triangle has been found\r\n            nn = hn;\r\n            return o + r * hh;\r\n        }\r\n\r\n#if SINGLE_SAMPLE\r\n        vec2 offset;\r\n        \r\n        // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\r\n        // and 0.0 for the far one\r\n        vec2 ss = step(c, c.yx);\r\n\r\n        // Get the coordinate offset of where to read the next vertex height from\r\n        if(dt >= t0 && dt < c.x && dt < c.y)\r\n        {\r\n            offset = vec2(1. - s, s);\r\n        }\r\n        else\r\n        {\r\n            offset = dot(r.xz, ss) > 0. ? vec2(2, 1) : vec2(-1, 0);\r\n\r\n            if(c.y < c.x)\r\n                offset = offset.yx;\r\n        }\r\n\r\n        // Get the next vertex\r\n        vec3 tnew = vec3(oc + offset, height(oc + offset)).xzy;\r\n\r\n        // Update the triangle vertices.\r\n        if(dt >= t0 && dt < c.x && dt < c.y)\r\n        {\r\n            tb = tnew;\r\n        }\r\n        else\r\n        {\r\n            // Swap vertex order based on sign of ray axis\r\n            if(dot(r.xz, ss) > 0.)\r\n            {\r\n                ta = tb;\r\n                tb = tc;\r\n                tc = tnew;\r\n            }\r\n            else\r\n            {\r\n                tc = tb;\r\n                tb = ta;\r\n                ta = tnew;\r\n            }\r\n\r\n            // Step the grid coordinates along to the next cell\r\n            oc.xy += rs.xz * ss;\r\n            c.xy += dd.xy * rs.xz * ss;\r\n        }\r\n#else\r\n        // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\r\n        // and 0.0 for the far one\r\n        vec2 ss = step(c, c.yx);\r\n        \r\n        if(dt < t0 || dt >= c.x || dt >= c.y)\r\n        {\r\n            // Step the grid coordinates along to the next cell\r\n            oc.xy += rs.xz * ss;\r\n            c.xy += dd.xy * rs.xz * ss;\r\n        }\r\n        \r\n#endif\r\n        t0 = t1;\r\n\r\n        // Test if the ray left the upper Y bounds\r\n        if(((maxh - o.y) / r.y < t0 && r.y > 0.) || t0 > 200.)\r\n            return vec3(10000);\r\n\r\n    }\r\n    return vec3(10000);\r\n}\r\n\r\n// Ray direction function\r\nvec3 rfunc(vec2 uv)\r\n{\r\n    vec3 r = normalize(vec3(uv.xy, -1.3));\r\n    float ang = .7;\r\n    r.yz *= mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\r\n    return r;\r\n}\r\n\r\nfloat chequer(vec2 p)\r\n{\r\n    return step(0.5, fract(p.x + step(0.5, fract(p.y)) * 0.5));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord / iResolution.xy;\r\n    \r\n    vec2 t = uv * 2. - 1. + 1e-3;\r\n    t.x *= iResolution.x / iResolution.y;\r\n\r\n    // Setup primary ray\r\n    vec3 o = vec3(1.4, 9.5, -iTime), r = rfunc(t);\r\n\r\n    // Trace primary ray\r\n    vec3 rp = tr2(o, r);\r\n\r\n    // Surface normal\r\n    vec3 n = normalize(nn);\r\n    if(n.y < 0.)\r\n        n =- n;\r\n\r\n    // Checkerboard pattern\r\n    vec3 col = vec3(mix(.8, 1., chequer(rp.xz / 2.)));\r\n\r\n    if(fract(rp.z) < fract(rp.x))\r\n\t\tcol *= .7;\r\n    \r\n    // Light direction\r\n    vec3 ld = normalize(vec3(1.5, 1, -2));\r\n\r\n    // Directional shadow (raytraced)\r\n    vec3 rp2 = tr2(rp + n*1e-4 + ld * 1e-4, ld);\r\n    if(distance(rp, rp2) < 1000.)\r\n        col *= .4 * vec3(.65, .65, 1);\r\n\r\n    // Basic colouration\r\n    col *= mix(vec3(1, .8, .5) / 2., vec3(.3, 1, .3) / 4., 1. - clamp(rp.y / 2., 0., 1.));\r\n    col = mix(col, vec3(1) * .7, pow(clamp((rp.y - 2.5) / 2., 0., 1.), 2.));\r\n\r\n    // Directional light falloff\r\n    col *= pow(.5 + .5 * dot(n, ld), 1.);\r\n    \r\n    // Fog\r\n    col = mix(vec3(.65, .65, 1), col, exp2(-distance(rp, o) / 1024.));\r\n\r\n    // Clamp and gamma-correct\r\n    fragColor.rgb = pow(clamp(col * 2., 0., 1.), vec3(1. / 2.2));\r\n}\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"// Rays traverse a uniform grid and are tested against a triangle (actually this is just\r\n// a ray-versus-plane test). Rather than sampling the heightfield 3 times to get the triangle\r\n// vertices, previous vertices are kept and only one of the vertices is updated at each step.\r\n// So the heightfield is only sampled once per step.\r\n//\r\n// The algorithm is similar to triangle strip rasterisation, in that each new vertex\r\n// together with previous 2 vertices define a triangle.\r\n//\r\n\r\n//\r\n// The shaders of this series:\r\n//\r\n//   Triangulated Heightfield Trick 1 - https://www.shadertoy.com/view/XlcBRX (Rigid, right-triangle)\r\n//   Triangulated Heightfield Trick 2 - https://www.shadertoy.com/view/tlXSzB (Rigid, equilateral)\r\n//   Triangulated Heightfield Trick 3 - https://www.shadertoy.com/view/ttsSzX (Deforming, equilateral)\r\n//   Tetrahedral Voxel Traversal      - https://www.shadertoy.com/view/wtfXWB (Rigid, tetrahedron)\r\n//\r\n\r\n\r\n// Use this to toggle between taking 1 sample of the heightfield and taking\r\n// 3 samples (to fully construct the triangle on every step).\r\n#define SINGLE_SAMPLE 1\r\n\r\nfloat minh = 0.0, maxh = 6.0;\r\nvec3 nn = vec3(0);\r\n\r\nfloat hash(float n)\r\n{\r\n    return fract(sin(n) * 43758.5453);\r\n}\r\n\r\nfloat noise(vec3 p)\r\n{\r\n    return hash(p.x + p.y*57.0 + p.z*117.0);\r\n}\r\n\r\nfloat valnoise(vec3 p)\r\n{\r\n    vec3 c = floor(p);\r\n    vec3 f = smoothstep(0., 1., fract(p));\r\n    return mix(\r\n        mix (mix(noise(c + vec3(0, 0, 0)), noise(c + vec3(1, 0, 0)), f.x),\r\n             mix(noise(c + vec3(0, 1, 0)), noise(c + vec3(1, 1, 0)), f.x), f.y),\r\n        mix (mix(noise(c + vec3(0, 0, 1)), noise(c + vec3(1, 0, 1)), f.x),\r\n             mix(noise(c + vec3(0, 1, 1)), noise(c + vec3(1, 1, 1)), f.x), f.y),\r\n        f.z);\r\n}\r\n\r\nfloat fbm(vec3 p)\r\n{\r\n    float f = 0.;\r\n    for(int i = 0; i < 5; ++i)\r\n        f += (valnoise(p * exp2(float(i))) - .5) / exp2(float(i));\r\n    return f;\r\n}\r\n\r\nfloat height(vec2 p)\r\n{\r\n    float h = mix(minh, maxh * 1.3, pow(clamp(.2 + .8 * fbm(vec3(p / 6., 0.)), 0., 1.), 1.3));\r\n    h += valnoise(vec3(p, .3));\r\n    return h;\r\n}\r\n\r\n// The raytracing function\r\nvec3 tr2(vec3 o,vec3 r)\r\n{\r\n    // Start ray at upper Y bounds\r\n    if(o.y > maxh)\r\n        o += r * (maxh - o.y) / r.y;\r\n    \r\n    vec2 oc = vec2(floor(o.x), floor(o.z)), c;\r\n    vec2 dn = normalize(vec2(-1, 1));\r\n    vec3 ta, tb, tc;\r\n\r\n    // Initialise the triangle vertices\r\n    ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\r\n    tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\r\n    if(fract(o.z) < fract(o.x))\r\n        tb = vec3(oc.x + 1., height(oc + vec2(1, 0)), oc.y + 0.);\r\n    else\r\n        tb = vec3(oc.x, height(oc + vec2(0, 1)), oc.y + 1.);\r\n\r\n    float t0 = 1e-4, t1;\r\n\r\n    // Ray slopes\r\n    vec2 dd = vec2(1) / r.xz;\r\n    float dnt = 1.0 / dot(r.xz, dn);\r\n    \r\n    float s = max(sign(dnt), 0.);\r\n    c = ((oc + max(sign(r.xz), 0.)) - o.xz) * dd;\r\n\r\n    vec3 rs = sign(r);\r\n\r\n    for(int i = 0; i < 450; ++i)\r\n    {  \r\n        t1 = min(c.x, c.y);\r\n\r\n        // Test ray against diagonal plane\r\n        float dt = dot(oc - o.xz, dn) * dnt;\r\n        if(dt > t0 && dt < t1)\r\n            t1 = dt;\r\n \r\n#if !SINGLE_SAMPLE\r\n        // Sample the heightfield for all three vertices.\r\n        vec2 of = (dot(o.xz + r.xz * (t0 + t1) * .5 - oc, dn) > 0.) ? vec2(0, 1) : vec2(1, 0);\r\n        tb = vec3(oc.x + of.x, height(oc + of), oc.y + of.y);\r\n        ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\r\n        tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\r\n#endif        \r\n\r\n        // Test ray against triangle plane\r\n        vec3 hn = cross(ta - tb, tc - tb);\r\n        float hh = dot(ta - o, hn) / dot(r, hn);\r\n\r\n        if(hh > t0 && hh < t1)\r\n        {\r\n            // Intersection with triangle has been found\r\n            nn = hn;\r\n            return o + r * hh;\r\n        }\r\n\r\n#if SINGLE_SAMPLE\r\n        vec2 offset;\r\n        \r\n        // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\r\n        // and 0.0 for the far one\r\n        vec2 ss = step(c, c.yx);\r\n\r\n        // Get the coordinate offset of where to read the next vertex height from\r\n        if(dt >= t0 && dt < c.x && dt < c.y)\r\n        {\r\n            offset = vec2(1. - s, s);\r\n        }\r\n        else\r\n        {\r\n            offset = dot(r.xz, ss) > 0. ? vec2(2, 1) : vec2(-1, 0);\r\n\r\n            if(c.y < c.x)\r\n                offset = offset.yx;\r\n        }\r\n\r\n        // Get the next vertex\r\n        vec3 tnew = vec3(oc + offset, height(oc + offset)).xzy;\r\n\r\n        // Update the triangle vertices.\r\n        if(dt >= t0 && dt < c.x && dt < c.y)\r\n        {\r\n            tb = tnew;\r\n        }\r\n        else\r\n        {\r\n            // Swap vertex order based on sign of ray axis\r\n            if(dot(r.xz, ss) > 0.)\r\n            {\r\n                ta = tb;\r\n                tb = tc;\r\n                tc = tnew;\r\n            }\r\n            else\r\n            {\r\n                tc = tb;\r\n                tb = ta;\r\n                ta = tnew;\r\n            }\r\n\r\n            // Step the grid coordinates along to the next cell\r\n            oc.xy += rs.xz * ss;\r\n            c.xy += dd.xy * rs.xz * ss;\r\n        }\r\n#else\r\n        // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\r\n        // and 0.0 for the far one\r\n        vec2 ss = step(c, c.yx);\r\n        \r\n        if(dt < t0 || dt >= c.x || dt >= c.y)\r\n        {\r\n            // Step the grid coordinates along to the next cell\r\n            oc.xy += rs.xz * ss;\r\n            c.xy += dd.xy * rs.xz * ss;\r\n        }\r\n        \r\n#endif\r\n        t0 = t1;\r\n\r\n        // Test if the ray left the upper Y bounds\r\n        if(((maxh - o.y) / r.y < t0 && r.y > 0.) || t0 > 200.)\r\n            return vec3(10000);\r\n\r\n    }\r\n    return vec3(10000);\r\n}\r\n\r\n// Ray direction function\r\nvec3 rfunc(vec2 uv)\r\n{\r\n    vec3 r = normalize(vec3(uv.xy, -1.3));\r\n    float ang = .7;\r\n    r.yz *= mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\r\n    return r;\r\n}\r\n\r\nfloat chequer(vec2 p)\r\n{\r\n    return step(0.5, fract(p.x + step(0.5, fract(p.y)) * 0.5));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord / iResolution.xy;\r\n    \r\n    vec2 t = uv * 2. - 1. + 1e-3;\r\n    t.x *= iResolution.x / iResolution.y;\r\n\r\n    // Setup primary ray\r\n    vec3 o = vec3(1.4, 9.5, -iTime), r = rfunc(t);\r\n\r\n    // Trace primary ray\r\n    vec3 rp = tr2(o, r);\r\n\r\n    // Surface normal\r\n    vec3 n = normalize(nn);\r\n    if(n.y < 0.)\r\n        n =- n;\r\n\r\n    // Checkerboard pattern\r\n    vec3 col = vec3(mix(.8, 1., chequer(rp.xz / 2.)));\r\n\r\n    if(fract(rp.z) < fract(rp.x))\r\n\t\tcol *= .7;\r\n    \r\n    // Light direction\r\n    vec3 ld = normalize(vec3(1.5, 1, -2));\r\n\r\n    // Directional shadow (raytraced)\r\n    vec3 rp2 = tr2(rp + n*1e-4 + ld * 1e-4, ld);\r\n    if(distance(rp, rp2) < 1000.)\r\n        col *= .4 * vec3(.65, .65, 1);\r\n\r\n    // Basic colouration\r\n    col *= mix(vec3(1, .8, .5) / 2., vec3(.3, 1, .3) / 4., 1. - clamp(rp.y / 2., 0., 1.));\r\n    col = mix(col, vec3(1) * .7, pow(clamp((rp.y - 2.5) / 2., 0., 1.), 2.));\r\n\r\n    // Directional light falloff\r\n    col *= pow(.5 + .5 * dot(n, ld), 1.);\r\n    \r\n    // Fog\r\n    col = mix(vec3(.65, .65, 1), col, exp2(-distance(rp, o) / 1024.));\r\n\r\n    // Clamp and gamma-correct\r\n    fragColor.rgb = pow(clamp(col * 2., 0., 1.), vec3(1. / 2.2));\r\n}\r\n\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Triangulated Heightfield Trick","id":null,"date":null,"viewed":0,"name":"Triangulated Heightfield Trick","description":"Here is a trick to raytrace a triangulated heightfield taking only 1 sample of the heightfield for each triangle tested against the ray and reducing the ray-vs-triangle test to a ray-vs-plane test. Primary rays and shadow rays are both raytraced.","likes":0,"published":null,"tags":["raytracing","heightfield","polygonal"]},"ver":null,"info":{"Name":"Triangulated Heightfield Trick","id":null,"date":null,"viewed":0,"name":"Triangulated Heightfield Trick","description":"Here is a trick to raytrace a triangulated heightfield taking only 1 sample of the heightfield for each triangle tested against the ray and reducing the ray-vs-triangle test to a ray-vs-plane test. Primary rays and shadow rays are both raytraced.","likes":0,"published":null,"tags":["raytracing","heightfield","polygonal"]},"renderpass":[{"Code":"// Rays traverse a uniform grid and are tested against a triangle (actually this is just\r\n// a ray-versus-plane test). Rather than sampling the heightfield 3 times to get the triangle\r\n// vertices, previous vertices are kept and only one of the vertices is updated at each step.\r\n// So the heightfield is only sampled once per step.\r\n//\r\n// The algorithm is similar to triangle strip rasterisation, in that each new vertex\r\n// together with previous 2 vertices define a triangle.\r\n//\r\n\r\n//\r\n// The shaders of this series:\r\n//\r\n//   Triangulated Heightfield Trick 1 - https://www.shadertoy.com/view/XlcBRX (Rigid, right-triangle)\r\n//   Triangulated Heightfield Trick 2 - https://www.shadertoy.com/view/tlXSzB (Rigid, equilateral)\r\n//   Triangulated Heightfield Trick 3 - https://www.shadertoy.com/view/ttsSzX (Deforming, equilateral)\r\n//   Tetrahedral Voxel Traversal      - https://www.shadertoy.com/view/wtfXWB (Rigid, tetrahedron)\r\n//\r\n\r\n\r\n// Use this to toggle between taking 1 sample of the heightfield and taking\r\n// 3 samples (to fully construct the triangle on every step).\r\n#define SINGLE_SAMPLE 1\r\n\r\nfloat minh = 0.0, maxh = 6.0;\r\nvec3 nn = vec3(0);\r\n\r\nfloat hash(float n)\r\n{\r\n    return fract(sin(n) * 43758.5453);\r\n}\r\n\r\nfloat noise(vec3 p)\r\n{\r\n    return hash(p.x + p.y*57.0 + p.z*117.0);\r\n}\r\n\r\nfloat valnoise(vec3 p)\r\n{\r\n    vec3 c = floor(p);\r\n    vec3 f = smoothstep(0., 1., fract(p));\r\n    return mix(\r\n        mix (mix(noise(c + vec3(0, 0, 0)), noise(c + vec3(1, 0, 0)), f.x),\r\n             mix(noise(c + vec3(0, 1, 0)), noise(c + vec3(1, 1, 0)), f.x), f.y),\r\n        mix (mix(noise(c + vec3(0, 0, 1)), noise(c + vec3(1, 0, 1)), f.x),\r\n             mix(noise(c + vec3(0, 1, 1)), noise(c + vec3(1, 1, 1)), f.x), f.y),\r\n        f.z);\r\n}\r\n\r\nfloat fbm(vec3 p)\r\n{\r\n    float f = 0.;\r\n    for(int i = 0; i < 5; ++i)\r\n        f += (valnoise(p * exp2(float(i))) - .5) / exp2(float(i));\r\n    return f;\r\n}\r\n\r\nfloat height(vec2 p)\r\n{\r\n    float h = mix(minh, maxh * 1.3, pow(clamp(.2 + .8 * fbm(vec3(p / 6., 0.)), 0., 1.), 1.3));\r\n    h += valnoise(vec3(p, .3));\r\n    return h;\r\n}\r\n\r\n// The raytracing function\r\nvec3 tr2(vec3 o,vec3 r)\r\n{\r\n    // Start ray at upper Y bounds\r\n    if(o.y > maxh)\r\n        o += r * (maxh - o.y) / r.y;\r\n    \r\n    vec2 oc = vec2(floor(o.x), floor(o.z)), c;\r\n    vec2 dn = normalize(vec2(-1, 1));\r\n    vec3 ta, tb, tc;\r\n\r\n    // Initialise the triangle vertices\r\n    ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\r\n    tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\r\n    if(fract(o.z) < fract(o.x))\r\n        tb = vec3(oc.x + 1., height(oc + vec2(1, 0)), oc.y + 0.);\r\n    else\r\n        tb = vec3(oc.x, height(oc + vec2(0, 1)), oc.y + 1.);\r\n\r\n    float t0 = 1e-4, t1;\r\n\r\n    // Ray slopes\r\n    vec2 dd = vec2(1) / r.xz;\r\n    float dnt = 1.0 / dot(r.xz, dn);\r\n    \r\n    float s = max(sign(dnt), 0.);\r\n    c = ((oc + max(sign(r.xz), 0.)) - o.xz) * dd;\r\n\r\n    vec3 rs = sign(r);\r\n\r\n    for(int i = 0; i < 450; ++i)\r\n    {  \r\n        t1 = min(c.x, c.y);\r\n\r\n        // Test ray against diagonal plane\r\n        float dt = dot(oc - o.xz, dn) * dnt;\r\n        if(dt > t0 && dt < t1)\r\n            t1 = dt;\r\n \r\n#if !SINGLE_SAMPLE\r\n        // Sample the heightfield for all three vertices.\r\n        vec2 of = (dot(o.xz + r.xz * (t0 + t1) * .5 - oc, dn) > 0.) ? vec2(0, 1) : vec2(1, 0);\r\n        tb = vec3(oc.x + of.x, height(oc + of), oc.y + of.y);\r\n        ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\r\n        tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\r\n#endif        \r\n\r\n        // Test ray against triangle plane\r\n        vec3 hn = cross(ta - tb, tc - tb);\r\n        float hh = dot(ta - o, hn) / dot(r, hn);\r\n\r\n        if(hh > t0 && hh < t1)\r\n        {\r\n            // Intersection with triangle has been found\r\n            nn = hn;\r\n            return o + r * hh;\r\n        }\r\n\r\n#if SINGLE_SAMPLE\r\n        vec2 offset;\r\n        \r\n        // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\r\n        // and 0.0 for the far one\r\n        vec2 ss = step(c, c.yx);\r\n\r\n        // Get the coordinate offset of where to read the next vertex height from\r\n        if(dt >= t0 && dt < c.x && dt < c.y)\r\n        {\r\n            offset = vec2(1. - s, s);\r\n        }\r\n        else\r\n        {\r\n            offset = dot(r.xz, ss) > 0. ? vec2(2, 1) : vec2(-1, 0);\r\n\r\n            if(c.y < c.x)\r\n                offset = offset.yx;\r\n        }\r\n\r\n        // Get the next vertex\r\n        vec3 tnew = vec3(oc + offset, height(oc + offset)).xzy;\r\n\r\n        // Update the triangle vertices.\r\n        if(dt >= t0 && dt < c.x && dt < c.y)\r\n        {\r\n            tb = tnew;\r\n        }\r\n        else\r\n        {\r\n            // Swap vertex order based on sign of ray axis\r\n            if(dot(r.xz, ss) > 0.)\r\n            {\r\n                ta = tb;\r\n                tb = tc;\r\n                tc = tnew;\r\n            }\r\n            else\r\n            {\r\n                tc = tb;\r\n                tb = ta;\r\n                ta = tnew;\r\n            }\r\n\r\n            // Step the grid coordinates along to the next cell\r\n            oc.xy += rs.xz * ss;\r\n            c.xy += dd.xy * rs.xz * ss;\r\n        }\r\n#else\r\n        // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\r\n        // and 0.0 for the far one\r\n        vec2 ss = step(c, c.yx);\r\n        \r\n        if(dt < t0 || dt >= c.x || dt >= c.y)\r\n        {\r\n            // Step the grid coordinates along to the next cell\r\n            oc.xy += rs.xz * ss;\r\n            c.xy += dd.xy * rs.xz * ss;\r\n        }\r\n        \r\n#endif\r\n        t0 = t1;\r\n\r\n        // Test if the ray left the upper Y bounds\r\n        if(((maxh - o.y) / r.y < t0 && r.y > 0.) || t0 > 200.)\r\n            return vec3(10000);\r\n\r\n    }\r\n    return vec3(10000);\r\n}\r\n\r\n// Ray direction function\r\nvec3 rfunc(vec2 uv)\r\n{\r\n    vec3 r = normalize(vec3(uv.xy, -1.3));\r\n    float ang = .7;\r\n    r.yz *= mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\r\n    return r;\r\n}\r\n\r\nfloat chequer(vec2 p)\r\n{\r\n    return step(0.5, fract(p.x + step(0.5, fract(p.y)) * 0.5));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord / iResolution.xy;\r\n    \r\n    vec2 t = uv * 2. - 1. + 1e-3;\r\n    t.x *= iResolution.x / iResolution.y;\r\n\r\n    // Setup primary ray\r\n    vec3 o = vec3(1.4, 9.5, -iTime), r = rfunc(t);\r\n\r\n    // Trace primary ray\r\n    vec3 rp = tr2(o, r);\r\n\r\n    // Surface normal\r\n    vec3 n = normalize(nn);\r\n    if(n.y < 0.)\r\n        n =- n;\r\n\r\n    // Checkerboard pattern\r\n    vec3 col = vec3(mix(.8, 1., chequer(rp.xz / 2.)));\r\n\r\n    if(fract(rp.z) < fract(rp.x))\r\n\t\tcol *= .7;\r\n    \r\n    // Light direction\r\n    vec3 ld = normalize(vec3(1.5, 1, -2));\r\n\r\n    // Directional shadow (raytraced)\r\n    vec3 rp2 = tr2(rp + n*1e-4 + ld * 1e-4, ld);\r\n    if(distance(rp, rp2) < 1000.)\r\n        col *= .4 * vec3(.65, .65, 1);\r\n\r\n    // Basic colouration\r\n    col *= mix(vec3(1, .8, .5) / 2., vec3(.3, 1, .3) / 4., 1. - clamp(rp.y / 2., 0., 1.));\r\n    col = mix(col, vec3(1) * .7, pow(clamp((rp.y - 2.5) / 2., 0., 1.), 2.));\r\n\r\n    // Directional light falloff\r\n    col *= pow(.5 + .5 * dot(n, ld), 1.);\r\n    \r\n    // Fog\r\n    col = mix(vec3(.65, .65, 1), col, exp2(-distance(rp, o) / 1024.));\r\n\r\n    // Clamp and gamma-correct\r\n    fragColor.rgb = pow(clamp(col * 2., 0., 1.), vec3(1. / 2.2));\r\n}\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"// Rays traverse a uniform grid and are tested against a triangle (actually this is just\r\n// a ray-versus-plane test). Rather than sampling the heightfield 3 times to get the triangle\r\n// vertices, previous vertices are kept and only one of the vertices is updated at each step.\r\n// So the heightfield is only sampled once per step.\r\n//\r\n// The algorithm is similar to triangle strip rasterisation, in that each new vertex\r\n// together with previous 2 vertices define a triangle.\r\n//\r\n\r\n//\r\n// The shaders of this series:\r\n//\r\n//   Triangulated Heightfield Trick 1 - https://www.shadertoy.com/view/XlcBRX (Rigid, right-triangle)\r\n//   Triangulated Heightfield Trick 2 - https://www.shadertoy.com/view/tlXSzB (Rigid, equilateral)\r\n//   Triangulated Heightfield Trick 3 - https://www.shadertoy.com/view/ttsSzX (Deforming, equilateral)\r\n//   Tetrahedral Voxel Traversal      - https://www.shadertoy.com/view/wtfXWB (Rigid, tetrahedron)\r\n//\r\n\r\n\r\n// Use this to toggle between taking 1 sample of the heightfield and taking\r\n// 3 samples (to fully construct the triangle on every step).\r\n#define SINGLE_SAMPLE 1\r\n\r\nfloat minh = 0.0, maxh = 6.0;\r\nvec3 nn = vec3(0);\r\n\r\nfloat hash(float n)\r\n{\r\n    return fract(sin(n) * 43758.5453);\r\n}\r\n\r\nfloat noise(vec3 p)\r\n{\r\n    return hash(p.x + p.y*57.0 + p.z*117.0);\r\n}\r\n\r\nfloat valnoise(vec3 p)\r\n{\r\n    vec3 c = floor(p);\r\n    vec3 f = smoothstep(0., 1., fract(p));\r\n    return mix(\r\n        mix (mix(noise(c + vec3(0, 0, 0)), noise(c + vec3(1, 0, 0)), f.x),\r\n             mix(noise(c + vec3(0, 1, 0)), noise(c + vec3(1, 1, 0)), f.x), f.y),\r\n        mix (mix(noise(c + vec3(0, 0, 1)), noise(c + vec3(1, 0, 1)), f.x),\r\n             mix(noise(c + vec3(0, 1, 1)), noise(c + vec3(1, 1, 1)), f.x), f.y),\r\n        f.z);\r\n}\r\n\r\nfloat fbm(vec3 p)\r\n{\r\n    float f = 0.;\r\n    for(int i = 0; i < 5; ++i)\r\n        f += (valnoise(p * exp2(float(i))) - .5) / exp2(float(i));\r\n    return f;\r\n}\r\n\r\nfloat height(vec2 p)\r\n{\r\n    float h = mix(minh, maxh * 1.3, pow(clamp(.2 + .8 * fbm(vec3(p / 6., 0.)), 0., 1.), 1.3));\r\n    h += valnoise(vec3(p, .3));\r\n    return h;\r\n}\r\n\r\n// The raytracing function\r\nvec3 tr2(vec3 o,vec3 r)\r\n{\r\n    // Start ray at upper Y bounds\r\n    if(o.y > maxh)\r\n        o += r * (maxh - o.y) / r.y;\r\n    \r\n    vec2 oc = vec2(floor(o.x), floor(o.z)), c;\r\n    vec2 dn = normalize(vec2(-1, 1));\r\n    vec3 ta, tb, tc;\r\n\r\n    // Initialise the triangle vertices\r\n    ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\r\n    tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\r\n    if(fract(o.z) < fract(o.x))\r\n        tb = vec3(oc.x + 1., height(oc + vec2(1, 0)), oc.y + 0.);\r\n    else\r\n        tb = vec3(oc.x, height(oc + vec2(0, 1)), oc.y + 1.);\r\n\r\n    float t0 = 1e-4, t1;\r\n\r\n    // Ray slopes\r\n    vec2 dd = vec2(1) / r.xz;\r\n    float dnt = 1.0 / dot(r.xz, dn);\r\n    \r\n    float s = max(sign(dnt), 0.);\r\n    c = ((oc + max(sign(r.xz), 0.)) - o.xz) * dd;\r\n\r\n    vec3 rs = sign(r);\r\n\r\n    for(int i = 0; i < 450; ++i)\r\n    {  \r\n        t1 = min(c.x, c.y);\r\n\r\n        // Test ray against diagonal plane\r\n        float dt = dot(oc - o.xz, dn) * dnt;\r\n        if(dt > t0 && dt < t1)\r\n            t1 = dt;\r\n \r\n#if !SINGLE_SAMPLE\r\n        // Sample the heightfield for all three vertices.\r\n        vec2 of = (dot(o.xz + r.xz * (t0 + t1) * .5 - oc, dn) > 0.) ? vec2(0, 1) : vec2(1, 0);\r\n        tb = vec3(oc.x + of.x, height(oc + of), oc.y + of.y);\r\n        ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\r\n        tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\r\n#endif        \r\n\r\n        // Test ray against triangle plane\r\n        vec3 hn = cross(ta - tb, tc - tb);\r\n        float hh = dot(ta - o, hn) / dot(r, hn);\r\n\r\n        if(hh > t0 && hh < t1)\r\n        {\r\n            // Intersection with triangle has been found\r\n            nn = hn;\r\n            return o + r * hh;\r\n        }\r\n\r\n#if SINGLE_SAMPLE\r\n        vec2 offset;\r\n        \r\n        // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\r\n        // and 0.0 for the far one\r\n        vec2 ss = step(c, c.yx);\r\n\r\n        // Get the coordinate offset of where to read the next vertex height from\r\n        if(dt >= t0 && dt < c.x && dt < c.y)\r\n        {\r\n            offset = vec2(1. - s, s);\r\n        }\r\n        else\r\n        {\r\n            offset = dot(r.xz, ss) > 0. ? vec2(2, 1) : vec2(-1, 0);\r\n\r\n            if(c.y < c.x)\r\n                offset = offset.yx;\r\n        }\r\n\r\n        // Get the next vertex\r\n        vec3 tnew = vec3(oc + offset, height(oc + offset)).xzy;\r\n\r\n        // Update the triangle vertices.\r\n        if(dt >= t0 && dt < c.x && dt < c.y)\r\n        {\r\n            tb = tnew;\r\n        }\r\n        else\r\n        {\r\n            // Swap vertex order based on sign of ray axis\r\n            if(dot(r.xz, ss) > 0.)\r\n            {\r\n                ta = tb;\r\n                tb = tc;\r\n                tc = tnew;\r\n            }\r\n            else\r\n            {\r\n                tc = tb;\r\n                tb = ta;\r\n                ta = tnew;\r\n            }\r\n\r\n            // Step the grid coordinates along to the next cell\r\n            oc.xy += rs.xz * ss;\r\n            c.xy += dd.xy * rs.xz * ss;\r\n        }\r\n#else\r\n        // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\r\n        // and 0.0 for the far one\r\n        vec2 ss = step(c, c.yx);\r\n        \r\n        if(dt < t0 || dt >= c.x || dt >= c.y)\r\n        {\r\n            // Step the grid coordinates along to the next cell\r\n            oc.xy += rs.xz * ss;\r\n            c.xy += dd.xy * rs.xz * ss;\r\n        }\r\n        \r\n#endif\r\n        t0 = t1;\r\n\r\n        // Test if the ray left the upper Y bounds\r\n        if(((maxh - o.y) / r.y < t0 && r.y > 0.) || t0 > 200.)\r\n            return vec3(10000);\r\n\r\n    }\r\n    return vec3(10000);\r\n}\r\n\r\n// Ray direction function\r\nvec3 rfunc(vec2 uv)\r\n{\r\n    vec3 r = normalize(vec3(uv.xy, -1.3));\r\n    float ang = .7;\r\n    r.yz *= mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\r\n    return r;\r\n}\r\n\r\nfloat chequer(vec2 p)\r\n{\r\n    return step(0.5, fract(p.x + step(0.5, fract(p.y)) * 0.5));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord / iResolution.xy;\r\n    \r\n    vec2 t = uv * 2. - 1. + 1e-3;\r\n    t.x *= iResolution.x / iResolution.y;\r\n\r\n    // Setup primary ray\r\n    vec3 o = vec3(1.4, 9.5, -iTime), r = rfunc(t);\r\n\r\n    // Trace primary ray\r\n    vec3 rp = tr2(o, r);\r\n\r\n    // Surface normal\r\n    vec3 n = normalize(nn);\r\n    if(n.y < 0.)\r\n        n =- n;\r\n\r\n    // Checkerboard pattern\r\n    vec3 col = vec3(mix(.8, 1., chequer(rp.xz / 2.)));\r\n\r\n    if(fract(rp.z) < fract(rp.x))\r\n\t\tcol *= .7;\r\n    \r\n    // Light direction\r\n    vec3 ld = normalize(vec3(1.5, 1, -2));\r\n\r\n    // Directional shadow (raytraced)\r\n    vec3 rp2 = tr2(rp + n*1e-4 + ld * 1e-4, ld);\r\n    if(distance(rp, rp2) < 1000.)\r\n        col *= .4 * vec3(.65, .65, 1);\r\n\r\n    // Basic colouration\r\n    col *= mix(vec3(1, .8, .5) / 2., vec3(.3, 1, .3) / 4., 1. - clamp(rp.y / 2., 0., 1.));\r\n    col = mix(col, vec3(1) * .7, pow(clamp((rp.y - 2.5) / 2., 0., 1.), 2.));\r\n\r\n    // Directional light falloff\r\n    col *= pow(.5 + .5 * dot(n, ld), 1.);\r\n    \r\n    // Fog\r\n    col = mix(vec3(.65, .65, 1), col, exp2(-distance(rp, o) / 1024.));\r\n\r\n    // Clamp and gamma-correct\r\n    fragColor.rgb = pow(clamp(col * 2., 0., 1.), vec3(1. / 2.2));\r\n}\r\n\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define TableSize 256\n\nconst float inner = 4.0;\nconst float outer = 9.0;\nconst float transition = 0.5;\nconst float low = 0.1;\nconst float high = 0.9;\n\n/*\nvec3 ringColorAntiliase(vec2 pos,float spotSize,float inner,float outer){\n    float R0,R1;\n    int I0,I1;\n    float weight;\n    R0 = sqrt(pos.x*pos.x+pos.y*pos.y)-0.5*spotSize;\n    R1 = R0+spotSize;\n    R0 = max(R0,0.0);\n    I0 = int(R0*float(TableSize-1)/outer);\n    I1 = int(R1*float(TableSize-1)/outer);\n    if(I0==I1)\n        I1++;\n    if(I0>=TableSize)\n        return vec3(0.0);\n    if(I1>=TableSize){\n        weight = float(TableSize-I0)/float(I1-I0);\n        I1 = TableSize - 1;\n    }else\n        weight = 1.0;\n    return weight*(integralTable[I1]-integralTable[I0])/float(I1-I0);\n}\n*/\n\nvec3 ringColor(vec2 pos, float inner,float outer){\n    \n    float R;\n    int I;\n    R = sqrt(pos.x*pos.x+pos.y*pos.y);\n  \n    float x = R/outer;\n    \n    return texelFetch( iChannel0, ivec2(int(x*iResolution.x-0.5),0),0).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord-0.5);\n    \n    vec2 pos = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    pos *= 9.0;\n    //vec2 mouse = 2.0*(iMouse.xy / iResolution.xy - vec2(0.5,0.5));\n    //float scale = 9.0;\n    //vec2 pos = (p+vec2(mouse.x*10.0,0.0))*scale;\n    //float width = 2.0/iResolution.y*scale;\n    //float spotSize = sqrt(width*width + width*width)/2.0;\n    \n    vec3 col;\n    col = ringColor(pos,inner,outer);\n       \n    fragColor = vec4(col,1.0);\n}","inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TableSize 256\n\nconst float inner = 4.0;\nconst float outer = 9.0;\nconst float transition = 0.5;\nconst float low = 0.1;\nconst float high = 0.9;\n\n/*\nvec3 ringColorAntiliase(vec2 pos,float spotSize,float inner,float outer){\n    float R0,R1;\n    int I0,I1;\n    float weight;\n    R0 = sqrt(pos.x*pos.x+pos.y*pos.y)-0.5*spotSize;\n    R1 = R0+spotSize;\n    R0 = max(R0,0.0);\n    I0 = int(R0*float(TableSize-1)/outer);\n    I1 = int(R1*float(TableSize-1)/outer);\n    if(I0==I1)\n        I1++;\n    if(I0>=TableSize)\n        return vec3(0.0);\n    if(I1>=TableSize){\n        weight = float(TableSize-I0)/float(I1-I0);\n        I1 = TableSize - 1;\n    }else\n        weight = 1.0;\n    return weight*(integralTable[I1]-integralTable[I0])/float(I1-I0);\n}\n*/\n\nvec3 ringColor(vec2 pos, float inner,float outer){\n    \n    float R;\n    int I;\n    R = sqrt(pos.x*pos.x+pos.y*pos.y);\n  \n    float x = R/outer;\n    \n    return texelFetch( iChannel0, ivec2(int(x*iResolution.x-0.5),0),0).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord-0.5);\n    \n    vec2 pos = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    pos *= 9.0;\n    //vec2 mouse = 2.0*(iMouse.xy / iResolution.xy - vec2(0.5,0.5));\n    //float scale = 9.0;\n    //vec2 pos = (p+vec2(mouse.x*10.0,0.0))*scale;\n    //float width = 2.0/iResolution.y*scale;\n    //float spotSize = sqrt(width*width + width*width)/2.0;\n    \n    vec3 col;\n    col = ringColor(pos,inner,outer);\n       \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"Info":{"Name":"Antialiase Planetary Ring","id":"tlt3Rs","date":"0","viewed":0,"name":"Antialiase Planetary Ring","description":"\u7D22\u5F15\u53CD\u952F\u9F7F\u884C\u661F\u73AF","likes":0,"published":"Private","tags":["math","indexantialiase"]},"ver":"0.1","info":{"Name":"Antialiase Planetary Ring","id":"tlt3Rs","date":"0","viewed":0,"name":"Antialiase Planetary Ring","description":"\u7D22\u5F15\u53CD\u952F\u9F7F\u884C\u661F\u73AF","likes":0,"published":"Private","tags":["math","indexantialiase"]},"renderpass":[{"Code":"#define TableSize 256\n\nconst float inner = 4.0;\nconst float outer = 9.0;\nconst float transition = 0.5;\nconst float low = 0.1;\nconst float high = 0.9;\n\n/*\nvec3 ringColorAntiliase(vec2 pos,float spotSize,float inner,float outer){\n    float R0,R1;\n    int I0,I1;\n    float weight;\n    R0 = sqrt(pos.x*pos.x+pos.y*pos.y)-0.5*spotSize;\n    R1 = R0+spotSize;\n    R0 = max(R0,0.0);\n    I0 = int(R0*float(TableSize-1)/outer);\n    I1 = int(R1*float(TableSize-1)/outer);\n    if(I0==I1)\n        I1++;\n    if(I0>=TableSize)\n        return vec3(0.0);\n    if(I1>=TableSize){\n        weight = float(TableSize-I0)/float(I1-I0);\n        I1 = TableSize - 1;\n    }else\n        weight = 1.0;\n    return weight*(integralTable[I1]-integralTable[I0])/float(I1-I0);\n}\n*/\n\nvec3 ringColor(vec2 pos, float inner,float outer){\n    \n    float R;\n    int I;\n    R = sqrt(pos.x*pos.x+pos.y*pos.y);\n  \n    float x = R/outer;\n    \n    return texelFetch( iChannel0, ivec2(int(x*iResolution.x-0.5),0),0).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord-0.5);\n    \n    vec2 pos = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    pos *= 9.0;\n    //vec2 mouse = 2.0*(iMouse.xy / iResolution.xy - vec2(0.5,0.5));\n    //float scale = 9.0;\n    //vec2 pos = (p+vec2(mouse.x*10.0,0.0))*scale;\n    //float width = 2.0/iResolution.y*scale;\n    //float spotSize = sqrt(width*width + width*width)/2.0;\n    \n    vec3 col;\n    col = ringColor(pos,inner,outer);\n       \n    fragColor = vec4(col,1.0);\n}","inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TableSize 256\n\nconst float inner = 4.0;\nconst float outer = 9.0;\nconst float transition = 0.5;\nconst float low = 0.1;\nconst float high = 0.9;\n\n/*\nvec3 ringColorAntiliase(vec2 pos,float spotSize,float inner,float outer){\n    float R0,R1;\n    int I0,I1;\n    float weight;\n    R0 = sqrt(pos.x*pos.x+pos.y*pos.y)-0.5*spotSize;\n    R1 = R0+spotSize;\n    R0 = max(R0,0.0);\n    I0 = int(R0*float(TableSize-1)/outer);\n    I1 = int(R1*float(TableSize-1)/outer);\n    if(I0==I1)\n        I1++;\n    if(I0>=TableSize)\n        return vec3(0.0);\n    if(I1>=TableSize){\n        weight = float(TableSize-I0)/float(I1-I0);\n        I1 = TableSize - 1;\n    }else\n        weight = 1.0;\n    return weight*(integralTable[I1]-integralTable[I0])/float(I1-I0);\n}\n*/\n\nvec3 ringColor(vec2 pos, float inner,float outer){\n    \n    float R;\n    int I;\n    R = sqrt(pos.x*pos.x+pos.y*pos.y);\n  \n    float x = R/outer;\n    \n    return texelFetch( iChannel0, ivec2(int(x*iResolution.x-0.5),0),0).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord-0.5);\n    \n    vec2 pos = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    pos *= 9.0;\n    //vec2 mouse = 2.0*(iMouse.xy / iResolution.xy - vec2(0.5,0.5));\n    //float scale = 9.0;\n    //vec2 pos = (p+vec2(mouse.x*10.0,0.0))*scale;\n    //float width = 2.0/iResolution.y*scale;\n    //float spotSize = sqrt(width*width + width*width)/2.0;\n    \n    vec3 col;\n    col = ringColor(pos,inner,outer);\n       \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"Code":"//\u8FD9\u4E2Abuff\u7528\u6765\u5728ichanell0\u5236\u4F5C\u4E00\u5F20\u566A\u58F0\u7EB9\u7406\u56FE\u5F62\u7684\u79EF\u5206\u56FE\n\nconst float inner = 4.0;\nconst float outer = 9.0;\nconst float transition = 0.5;\nconst float low = 0.1;\nconst float high = 0.9;\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = (p==re) ? va : fragColor;\n}\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = ( p.x>=re.x && p.y>=re.y && p.x<=re.z && p.y<=re.w ) ? va : fragColor;\n}\n\nfloat makeRandomGray(float x, float inner,float outer,float transition,float low,float high)\n{\n    float R;\n    float A;\n    float F;\n    \n    R = outer*x;//[0,outer]\n    if(R<=inner)\n        A = 0.0;\n    else if(R<inner+transition){\n        A = (R-inner)/transition;\n        A *= A*(3.0-2.0*A);\n    }else if(R>outer-transition){\n        A = (outer-R)/transition;\n        A *= A*(3.0-2.0*A);\n    }else\n        A = 1.0;\n    F = fractal_noise(vec2(R,0.0));\n      \n    F = smoothstep(low,high,F)*A;\n       \n    return F;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n     //ivec2 ipx = ivec2(fragCoord-0.5);\n     vec2 p = fragCoord/iResolution.xy;\n     bool initialized = loadValue(ivec2(0,0)).x != 0.0;\n     if(initialized){\n        return;\n    }\n    float gray = makeRandomGray(p.x, inner, outer,transition,low,high);\n    fragColor = vec4(vec3(gray),1.0);\n}","inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\u8FD9\u4E2Abuff\u7528\u6765\u5728ichanell0\u5236\u4F5C\u4E00\u5F20\u566A\u58F0\u7EB9\u7406\u56FE\u5F62\u7684\u79EF\u5206\u56FE\n\nconst float inner = 4.0;\nconst float outer = 9.0;\nconst float transition = 0.5;\nconst float low = 0.1;\nconst float high = 0.9;\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = (p==re) ? va : fragColor;\n}\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = ( p.x>=re.x && p.y>=re.y && p.x<=re.z && p.y<=re.w ) ? va : fragColor;\n}\n\nfloat makeRandomGray(float x, float inner,float outer,float transition,float low,float high)\n{\n    float R;\n    float A;\n    float F;\n    \n    R = outer*x;//[0,outer]\n    if(R<=inner)\n        A = 0.0;\n    else if(R<inner+transition){\n        A = (R-inner)/transition;\n        A *= A*(3.0-2.0*A);\n    }else if(R>outer-transition){\n        A = (outer-R)/transition;\n        A *= A*(3.0-2.0*A);\n    }else\n        A = 1.0;\n    F = fractal_noise(vec2(R,0.0));\n      \n    F = smoothstep(low,high,F)*A;\n       \n    return F;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n     //ivec2 ipx = ivec2(fragCoord-0.5);\n     vec2 p = fragCoord/iResolution.xy;\n     bool initialized = loadValue(ivec2(0,0)).x != 0.0;\n     if(initialized){\n        return;\n    }\n    float gray = makeRandomGray(p.x, inner, outer,transition,low,high);\n    fragColor = vec4(vec3(gray),1.0);\n}","name":"Buf A","description":"","type":"buffer"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(1,0.8,0.2), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(1,0.8,0.2), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Bump Mapping","id":"3l3GWS","date":"1577616030","viewed":34,"name":"Bump Mapping","description":"\u51F9\u51F8\u8D34\u56FE","likes":2,"published":"Public","tags":["noise","bump"]},"ver":"0.1","info":{"Name":"Bump Mapping","id":"3l3GWS","date":"1577616030","viewed":34,"name":"Bump Mapping","description":"\u51F9\u51F8\u8D34\u56FE","likes":2,"published":"Public","tags":["noise","bump"]},"renderpass":[{"Code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(1,0.8,0.2), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(1,0.8,0.2), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Catmull-Rom Spline Demo","id":"3tt3zS","date":"1576731439","viewed":48,"name":"Catmull-Rom Spline Demo","description":"Catmull-Rom\u6837\u6761\u7EBF\u63D2\u503C\u793A\u4F8B","likes":1,"published":"Public","tags":["spline","catmullrom","interpolating"]},"ver":"0.1","info":{"Name":"Catmull-Rom Spline Demo","id":"3tt3zS","date":"1576731439","viewed":48,"name":"Catmull-Rom Spline Demo","description":"Catmull-Rom\u6837\u6761\u7EBF\u63D2\u503C\u793A\u4F8B","likes":1,"published":"Public","tags":["spline","catmullrom","interpolating"]},"renderpass":[{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 1.0 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 1.0 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Example of 3D Noise","id":"Wtc3W7","date":"0","viewed":0,"name":"Example of 3D Noise","description":"3d\u566A\u58F0\u793A\u4F8B","likes":0,"published":"Private","tags":["3d","noise"]},"ver":"0.1","info":{"Name":"Example of 3D Noise","id":"Wtc3W7","date":"0","viewed":0,"name":"Example of 3D Noise","description":"3d\u566A\u58F0\u793A\u4F8B","likes":0,"published":"Private","tags":["3d","noise"]},"renderpass":[{"Code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 1.0 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 1.0 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Examples Of 2D Noise","id":"llKyDc","date":"1576221630","viewed":61,"name":"Examples Of 2D Noise","description":"2d\u566A\u58F0\u793A\u4F8B","likes":6,"published":"Public","tags":["2d","noise"]},"ver":"0.1","info":{"Name":"Examples Of 2D Noise","id":"llKyDc","date":"1576221630","viewed":61,"name":"Examples Of 2D Noise","description":"2d\u566A\u58F0\u793A\u4F8B","likes":6,"published":"Public","tags":["2d","noise"]},"renderpass":[{"Code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Eye-2D","id":"3dyXDt","date":"0","viewed":0,"name":"Eye-2D","description":"Eye-2D","likes":0,"published":"Private","tags":["2dmodel"]},"ver":"0.1","info":{"Name":"Eye-2D","id":"3dyXDt","date":"0","viewed":0,"name":"Eye-2D","description":"Eye-2D","likes":0,"published":"Private","tags":["2dmodel"]},"renderpass":[{"Code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","name":"Image","description":"","type":"image"},"Inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"Info":{"Name":"Greate Material Demo","id":"ttX3Rs","date":"0","viewed":0,"name":"Greate Material Demo","description":"Greate Material Demo","likes":0,"published":"Private","tags":["material"]},"ver":"0.1","info":{"Name":"Greate Material Demo","id":"ttX3Rs","date":"0","viewed":0,"name":"Greate Material Demo","description":"Greate Material Demo","likes":0,"published":"Private","tags":["material"]},"renderpass":[{"Code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    int isIn = 1;\n    for( int i=0; i<200; i++ )\n    {\n        if( m2 > 2.0 ) { isIn = 0; break; }\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    vec3 col = vec3(isIn==1?0:1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    int isIn = 1;\n    for( int i=0; i<200; i++ )\n    {\n        if( m2 > 2.0 ) { isIn = 0; break; }\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    vec3 col = vec3(isIn==1?0:1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Mandelbrot Set Render1","id":"3lsXWH","date":"1562757823","viewed":102,"name":"Mandelbrot Set Render1","description":"render of Mandelbrot set","likes":1,"published":"Public","tags":["fractal"]},"ver":"0.1","info":{"Name":"Mandelbrot Set Render1","id":"3lsXWH","date":"1562757823","viewed":102,"name":"Mandelbrot Set Render1","description":"render of Mandelbrot set","likes":1,"published":"Public","tags":["fractal"]},"renderpass":[{"Code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    int isIn = 1;\n    for( int i=0; i<200; i++ )\n    {\n        if( m2 > 2.0 ) { isIn = 0; break; }\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    vec3 col = vec3(isIn==1?0:1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    int isIn = 1;\n    for( int i=0; i<200; i++ )\n    {\n        if( m2 > 2.0 ) { isIn = 0; break; }\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    vec3 col = vec3(isIn==1?0:1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Mandelbrot Set Render2","id":"wtlSW8","date":"1562830347","viewed":89,"name":"Mandelbrot Set Render2","description":"mandelbrot set Render2\nreferences:\nhttps://www.shadertoy.com/view/lsX3W4\n","likes":1,"published":"Public","tags":["fractal"]},"ver":"0.1","info":{"Name":"Mandelbrot Set Render2","id":"wtlSW8","date":"1562830347","viewed":89,"name":"Mandelbrot Set Render2","description":"mandelbrot set Render2\nreferences:\nhttps://www.shadertoy.com/view/lsX3W4\n","likes":1,"published":"Public","tags":["fractal"]},"renderpass":[{"Code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    int iterMax = 0;\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n        iterMax++;\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    \n    density = pow(density,3.0);\n    \n    vec2 vCorner = vec2(pixelScale.x*iResolution.x/2.0, pixelScale.y*iResolution.y/2.0);\n    float dmax = sqrt(vCorner.x*vCorner.x+vCorner.y*vCorner.y);\n    float dN = d/dmax;\n    \n    vec4 col = vec4(128.0,0,128.0,1.0);\n    if(density > 0.01){\n        col = vec4(mix(1.0,0.0,density)); \n    }else{\n        col = vec4(mix(1.0,0.0,d/dmax));\n        //col = vec4(1.0);\n    }\n    fragColor = col;\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    int iterMax = 0;\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n        iterMax++;\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    \n    density = pow(density,3.0);\n    \n    vec2 vCorner = vec2(pixelScale.x*iResolution.x/2.0, pixelScale.y*iResolution.y/2.0);\n    float dmax = sqrt(vCorner.x*vCorner.x+vCorner.y*vCorner.y);\n    float dN = d/dmax;\n    \n    vec4 col = vec4(128.0,0,128.0,1.0);\n    if(density > 0.01){\n        col = vec4(mix(1.0,0.0,density)); \n    }else{\n        col = vec4(mix(1.0,0.0,d/dmax));\n        //col = vec4(1.0);\n    }\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Mandelbrot Set Render3","id":"3lfXW4","date":"0","viewed":0,"name":"Mandelbrot Set Render3","description":"Mandelbrot Set Render","likes":0,"published":"Private","tags":["fractal"]},"ver":"0.1","info":{"Name":"Mandelbrot Set Render3","id":"3lfXW4","date":"0","viewed":0,"name":"Mandelbrot Set Render3","description":"Mandelbrot Set Render","likes":0,"published":"Private","tags":["fractal"]},"renderpass":[{"Code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    int iterMax = 0;\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n        iterMax++;\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    \n    density = pow(density,3.0);\n    \n    vec2 vCorner = vec2(pixelScale.x*iResolution.x/2.0, pixelScale.y*iResolution.y/2.0);\n    float dmax = sqrt(vCorner.x*vCorner.x+vCorner.y*vCorner.y);\n    float dN = d/dmax;\n    \n    vec4 col = vec4(128.0,0,128.0,1.0);\n    if(density > 0.01){\n        col = vec4(mix(1.0,0.0,density)); \n    }else{\n        col = vec4(mix(1.0,0.0,d/dmax));\n        //col = vec4(1.0);\n    }\n    fragColor = col;\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    int iterMax = 0;\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n        iterMax++;\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    \n    density = pow(density,3.0);\n    \n    vec2 vCorner = vec2(pixelScale.x*iResolution.x/2.0, pixelScale.y*iResolution.y/2.0);\n    float dmax = sqrt(vCorner.x*vCorner.x+vCorner.y*vCorner.y);\n    float dN = d/dmax;\n    \n    vec4 col = vec4(128.0,0,128.0,1.0);\n    if(density > 0.01){\n        col = vec4(mix(1.0,0.0,density)); \n    }else{\n        col = vec4(mix(1.0,0.0,d/dmax));\n        //col = vec4(1.0);\n    }\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(0.0,1.0,m);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(0.0,1.0,m)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float m = marble(pos*2.0);\n        m = 0.5*m;\n        col = marbleColor(m);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(0.0,1.0,m);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(0.0,1.0,m)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float m = marble(pos*2.0);\n        m = 0.5*m;\n        col = marbleColor(m);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","name":"Image","description":"","type":"image"},"Inputs":[{"id":null,"filepath":"\\media\\texture\\8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":null,"published":0}],"Info":{"Name":"Marble Material","id":"Wtc3DM","date":"1576576570","viewed":47,"name":"Marble Material","description":"\u7A0B\u5E8F\u6027\u7684\u5927\u7406\u77F3\u6750\u8D28\uFF0C\u770B\u8D77\u6765\u66F4\u50CF\u62FC\u5408\u677F","likes":2,"published":"Public","tags":["marble","fractalnoise"]},"ver":"0.1","info":{"Name":"Marble Material","id":"Wtc3DM","date":"1576576570","viewed":47,"name":"Marble Material","description":"\u7A0B\u5E8F\u6027\u7684\u5927\u7406\u77F3\u6750\u8D28\uFF0C\u770B\u8D77\u6765\u66F4\u50CF\u62FC\u5408\u677F","likes":2,"published":"Public","tags":["marble","fractalnoise"]},"renderpass":[{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(0.0,1.0,m);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(0.0,1.0,m)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float m = marble(pos*2.0);\n        m = 0.5*m;\n        col = marbleColor(m);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","inputs":[{"id":null,"filepath":"\\media\\texture\\8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":null,"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(0.0,1.0,m);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(0.0,1.0,m)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float m = marble(pos*2.0);\n        m = 0.5*m;\n        col = marbleColor(m);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"float NearClipPlaneDist = 2.0;\nvec3 LightPos = vec3(5,5,5);\nvec3 LightColor = vec3(1,1,1);\nvec3 Ambient = vec3(0.1,0.1,0.1);\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nbool boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\tvec3 roo = ro - cen;\n    if( abs(roo.x)<rad.x && \n        abs(roo.y)<rad.y && \n        abs(roo.z)<rad.z )\n        return true;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\treturn ( tN < tF && tF > 0.0);\n}\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\nbool intersectMesh( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, out vec2 oUV, out int oTri )\n{\n    ro.z += 0.5;\n    if( !boxIntersect( ro, rd, vec3(0.0), vec3(0.18,0.3,0.52) ) )\n        return false;\n    bool res = false;\n    float tmin = tmax;\n    for( int i=0; i<numFaces; i++ )\n    {\n\t\t// get the triangle\n        vec3 v0 = getVertex(i,0);\n        vec3 v1 = getVertex(i,1);\n        vec3 v2 = getVertex(i,2);\n\n        vec3 h = triIntersect( ro, rd, v0, v1, v2 );\n        if( h.x>0.0 && h.x<tmin)\n        {\n            tmin = h.x;\n            oNor = normalize(cross(v1-v0,v2-v0));;\n            oDis = tmin;\n            oUV = h.yz;\n            oTri = i;\n            res = true;\n        }\n    }\n    \n    return res;\n}\n\nvec3 lambert(in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.5;\n    float kd = 1.0;\n    float ks = 0.5;\n    float shininess = 2.0;\n    vec3 objCol = vec3(1,0.8,0.2);\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objCol;\n    vec3 d = kd * LightColor * dot(normal, l) * objCol;\n    vec3 s = ks * LightColor * pow(dot(ref, view), shininess) * objCol;\n    return a + d + s;\n}   \n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    float tmin = 1e10; \n    vec3 nor = vec3(0.0);\n    float t;\n    vec3 tnor;\n    vec2 uv;\n    int ttri;\n    if( intersectMesh( ro, rd, tmin, t, tnor, uv, ttri ) )\n    {\n        vec3 p = ro + rd * t;\n        return lambert(ro, tnor, rd);             \n               \n    }\n    return Ambient;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    float time = iTime * 0.5;\n    vec3 cameraPos = vec3(2.0 * cos(time + 6.0*mousePos.x), 1.0 + mousePos.y, 2.0 * sin(time + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n    vec3 col = render(cameraPos, rayDir);\n    col = pow( col, vec3(0.4545) );\n    // Output to screen\n    fragColor = vec4(col.xyz, 1);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float NearClipPlaneDist = 2.0;\nvec3 LightPos = vec3(5,5,5);\nvec3 LightColor = vec3(1,1,1);\nvec3 Ambient = vec3(0.1,0.1,0.1);\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nbool boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\tvec3 roo = ro - cen;\n    if( abs(roo.x)<rad.x && \n        abs(roo.y)<rad.y && \n        abs(roo.z)<rad.z )\n        return true;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\treturn ( tN < tF && tF > 0.0);\n}\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\nbool intersectMesh( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, out vec2 oUV, out int oTri )\n{\n    ro.z += 0.5;\n    if( !boxIntersect( ro, rd, vec3(0.0), vec3(0.18,0.3,0.52) ) )\n        return false;\n    bool res = false;\n    float tmin = tmax;\n    for( int i=0; i<numFaces; i++ )\n    {\n\t\t// get the triangle\n        vec3 v0 = getVertex(i,0);\n        vec3 v1 = getVertex(i,1);\n        vec3 v2 = getVertex(i,2);\n\n        vec3 h = triIntersect( ro, rd, v0, v1, v2 );\n        if( h.x>0.0 && h.x<tmin)\n        {\n            tmin = h.x;\n            oNor = normalize(cross(v1-v0,v2-v0));;\n            oDis = tmin;\n            oUV = h.yz;\n            oTri = i;\n            res = true;\n        }\n    }\n    \n    return res;\n}\n\nvec3 lambert(in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.5;\n    float kd = 1.0;\n    float ks = 0.5;\n    float shininess = 2.0;\n    vec3 objCol = vec3(1,0.8,0.2);\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objCol;\n    vec3 d = kd * LightColor * dot(normal, l) * objCol;\n    vec3 s = ks * LightColor * pow(dot(ref, view), shininess) * objCol;\n    return a + d + s;\n}   \n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    float tmin = 1e10; \n    vec3 nor = vec3(0.0);\n    float t;\n    vec3 tnor;\n    vec2 uv;\n    int ttri;\n    if( intersectMesh( ro, rd, tmin, t, tnor, uv, ttri ) )\n    {\n        vec3 p = ro + rd * t;\n        return lambert(ro, tnor, rd);             \n               \n    }\n    return Ambient;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    float time = iTime * 0.5;\n    vec3 cameraPos = vec3(2.0 * cos(time + 6.0*mousePos.x), 1.0 + mousePos.y, 2.0 * sin(time + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n    vec3 col = render(cameraPos, rayDir);\n    col = pow( col, vec3(0.4545) );\n    // Output to screen\n    fragColor = vec4(col.xyz, 1);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Mesh Render","id":"3lXGRs","date":"0","viewed":0,"name":"Mesh Render","description":"Mesh Render","likes":0,"published":"Private","tags":["mesh"]},"ver":"0.1","info":{"Name":"Mesh Render","id":"3lXGRs","date":"0","viewed":0,"name":"Mesh Render","description":"Mesh Render","likes":0,"published":"Private","tags":["mesh"]},"renderpass":[{"Code":"float NearClipPlaneDist = 2.0;\nvec3 LightPos = vec3(5,5,5);\nvec3 LightColor = vec3(1,1,1);\nvec3 Ambient = vec3(0.1,0.1,0.1);\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nbool boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\tvec3 roo = ro - cen;\n    if( abs(roo.x)<rad.x && \n        abs(roo.y)<rad.y && \n        abs(roo.z)<rad.z )\n        return true;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\treturn ( tN < tF && tF > 0.0);\n}\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\nbool intersectMesh( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, out vec2 oUV, out int oTri )\n{\n    ro.z += 0.5;\n    if( !boxIntersect( ro, rd, vec3(0.0), vec3(0.18,0.3,0.52) ) )\n        return false;\n    bool res = false;\n    float tmin = tmax;\n    for( int i=0; i<numFaces; i++ )\n    {\n\t\t// get the triangle\n        vec3 v0 = getVertex(i,0);\n        vec3 v1 = getVertex(i,1);\n        vec3 v2 = getVertex(i,2);\n\n        vec3 h = triIntersect( ro, rd, v0, v1, v2 );\n        if( h.x>0.0 && h.x<tmin)\n        {\n            tmin = h.x;\n            oNor = normalize(cross(v1-v0,v2-v0));;\n            oDis = tmin;\n            oUV = h.yz;\n            oTri = i;\n            res = true;\n        }\n    }\n    \n    return res;\n}\n\nvec3 lambert(in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.5;\n    float kd = 1.0;\n    float ks = 0.5;\n    float shininess = 2.0;\n    vec3 objCol = vec3(1,0.8,0.2);\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objCol;\n    vec3 d = kd * LightColor * dot(normal, l) * objCol;\n    vec3 s = ks * LightColor * pow(dot(ref, view), shininess) * objCol;\n    return a + d + s;\n}   \n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    float tmin = 1e10; \n    vec3 nor = vec3(0.0);\n    float t;\n    vec3 tnor;\n    vec2 uv;\n    int ttri;\n    if( intersectMesh( ro, rd, tmin, t, tnor, uv, ttri ) )\n    {\n        vec3 p = ro + rd * t;\n        return lambert(ro, tnor, rd);             \n               \n    }\n    return Ambient;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    float time = iTime * 0.5;\n    vec3 cameraPos = vec3(2.0 * cos(time + 6.0*mousePos.x), 1.0 + mousePos.y, 2.0 * sin(time + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n    vec3 col = render(cameraPos, rayDir);\n    col = pow( col, vec3(0.4545) );\n    // Output to screen\n    fragColor = vec4(col.xyz, 1);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float NearClipPlaneDist = 2.0;\nvec3 LightPos = vec3(5,5,5);\nvec3 LightColor = vec3(1,1,1);\nvec3 Ambient = vec3(0.1,0.1,0.1);\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nbool boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\tvec3 roo = ro - cen;\n    if( abs(roo.x)<rad.x && \n        abs(roo.y)<rad.y && \n        abs(roo.z)<rad.z )\n        return true;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\treturn ( tN < tF && tF > 0.0);\n}\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\nbool intersectMesh( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, out vec2 oUV, out int oTri )\n{\n    ro.z += 0.5;\n    if( !boxIntersect( ro, rd, vec3(0.0), vec3(0.18,0.3,0.52) ) )\n        return false;\n    bool res = false;\n    float tmin = tmax;\n    for( int i=0; i<numFaces; i++ )\n    {\n\t\t// get the triangle\n        vec3 v0 = getVertex(i,0);\n        vec3 v1 = getVertex(i,1);\n        vec3 v2 = getVertex(i,2);\n\n        vec3 h = triIntersect( ro, rd, v0, v1, v2 );\n        if( h.x>0.0 && h.x<tmin)\n        {\n            tmin = h.x;\n            oNor = normalize(cross(v1-v0,v2-v0));;\n            oDis = tmin;\n            oUV = h.yz;\n            oTri = i;\n            res = true;\n        }\n    }\n    \n    return res;\n}\n\nvec3 lambert(in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.5;\n    float kd = 1.0;\n    float ks = 0.5;\n    float shininess = 2.0;\n    vec3 objCol = vec3(1,0.8,0.2);\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objCol;\n    vec3 d = kd * LightColor * dot(normal, l) * objCol;\n    vec3 s = ks * LightColor * pow(dot(ref, view), shininess) * objCol;\n    return a + d + s;\n}   \n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    float tmin = 1e10; \n    vec3 nor = vec3(0.0);\n    float t;\n    vec3 tnor;\n    vec2 uv;\n    int ttri;\n    if( intersectMesh( ro, rd, tmin, t, tnor, uv, ttri ) )\n    {\n        vec3 p = ro + rd * t;\n        return lambert(ro, tnor, rd);             \n               \n    }\n    return Ambient;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    float time = iTime * 0.5;\n    vec3 cameraPos = vec3(2.0 * cos(time + 6.0*mousePos.x), 1.0 + mousePos.y, 2.0 * sin(time + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n    vec3 col = render(cameraPos, rayDir);\n    col = pow( col, vec3(0.4545) );\n    // Output to screen\n    fragColor = vec4(col.xyz, 1);\n}","name":"Image","description":"","type":"image"},{"Code":"// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Fox model by pixelmannen: https://opengameart.org/content/fox-and-shiba\n//\n// NOT optimized for size, this model fits in a few hundred bytes really\n\nconst int numVertices = 290;\nconst int numFaces = 576;\n\nconst uint vertices[290] = uint[](\n 474194016U,  456372306U,  352611409U, 1003915346U,  997632126U, 1028056178U, 1012359285U, 1022864486U,\n1063764050U, 1051144299U, 1067953244U,  969343123U,  952500360U,  927354003U,  785584243U,  781389931U,\n 774033519U,  921167985U,  925333648U,  881367204U, 1044830290U, 1073188946U,  968207442U,  373581952U,\n 378821737U,  518232191U,  563316854U,  564356178U,  554918994U,  517177432U,  517177426U,  397597808U,\n 764610662U,  740491357U,  743613546U,   96613484U,   96606290U,    1245285U,   89298044U,  175384658U,\n  79914097U,    5465187U,  563317884U,  562283660U,  709059699U,  823379026U,  800305248U,  819190910U,\n 877969536U,  875891851U,  517180522U,  738414674U,  351569006U,    7574610U,     191570U,  474193989U,\n 880049234U, 1028056114U,  997632038U, 1012359215U, 1022864447U, 1051144250U, 1067953224U,  969342993U,\n 952500252U,  927353873U,  785584177U,  775078965U,  781389881U,  921167923U,  881367040U,  925333524U,\n 373581860U,  378821691U,  563316783U,  518232102U,  517177420U,  397597749U,  764610622U,  742566971U,\n 743637063U,   96613433U,    1245247U,   89297960U,    5465153U,   79914035U,  563317800U,  709059633U,\n 562283545U,  819189798U,  800305220U,  877969444U,  875891738U,  517180474U,  351568949U,  518251537U,\n 518250643U,  327376978U,  320046201U,  562288788U,  706982036U,  529968210U,  554084434U,  555106425U,\n 467011731U,  373674127U,  373624984U,  351600768U,  462755997U,  723707023U,  786839700U,  786881618U,\n 851924050U,  781551771U,  855036037U,  888589462U,  859273329U,  851940434U,  915932242U,  989311074U,\n 996652114U,  874857619U,  507730063U,  207761533U,  687205523U,  687247442U,  741788754U,  456565842U,\n 373704786U,  351650897U,  448997534U,  515069056U,  396551310U,  381872256U,  370278535U,  373422219U,\n 366061706U,  369207409U,  398579827U,  388097136U,  368183419U,  363992192U,  355579008U,  382856303U,\n 376566897U,  422716549U,  741538966U,  737264781U,  722664559U,  730978425U,  813981713U,  780341269U,\n 796070948U,  303384658U,  347428982U,  292862076U,  202548362U,  305407108U,  351600675U,  347428909U,\n 292861992U,  305407008U,  188987525U,  207754322U,  184813687U,  862336152U,  796071040U,  560236698U,\n 736498836U,  556137619U,  767726734U,  320046123U,  706981904U,  562288657U,  467011601U,  555106347U,\n 736458761U,  734256144U,  781551625U,  373674005U,  373624844U,  462755847U,  725807125U,  786839568U,\n 855035935U,  888589326U,  859273268U,  813981843U,  989311042U,  874857489U,  507729941U,  207761448U,\n 687205393U,  448997382U,  515068964U,  397599767U,  381872165U,  370278429U,  366061594U,  374470681U,\n 398579762U,  368183337U,  355578916U,  363992100U,  382856245U,  369207347U,  376566835U,  422716447U,\n 388097076U,  710014999U,  743635982U,  705827884U,  726861877U,  188987423U,  202548250U,  184813613U,\n 862336012U,  560236555U,  736498705U,  556137489U,  763526166U,  558185480U,  691365896U,  558185629U,\n 691366044U,  780341392U,  786609188U,  786613376U,  734256276U,  736458908U,  383898646U,  383898766U,\n 403811460U,  399539312U,  392218767U,  396364927U,  405822607U,  402699380U,  441454711U,  413141103U,\n 413141135U,  441454726U,  408990847U,  735105158U,  742427768U,  743560303U,  770818184U,  780255360U,\n 773890175U,  770819193U,  763480176U,  752921712U,  747753581U,  764527756U,  791682165U,  748685428U,\n 749735053U,  790633610U,  747671692U,  759212170U,  804262017U,  403811360U,  399539253U,  392218645U,\n 396364837U,  405822485U,  402699313U,  441454638U,  413141045U,  413141013U,  441454622U,  408990757U,\n 677453854U,  716306485U,  675338285U,  738309148U,  705737765U,  746693668U,  738311211U,  688972852U,\n 733071412U,  720498744U,  693162011U,  733070360U,  706748464U,  665867313U,  705699867U,  666916888U,\n 680580120U,  716177443U );\n\nconst uint faces[576] = uint[](\n  524800U,  1312771U,  2100742U,  2624521U,  1578500U,  2890252U,  4201998U,  4989969U,\n 2361876U,  5509652U,   792598U,   536599U,  7091225U,  7353881U,  7879168U,   277504U,\n 8138752U,  8929824U,  9717795U,  9717286U, 10768423U,  9718824U, 11556394U,   524312U,\n12344365U,  1054723U,  1312276U,  2100234U,  1575433U,  2626069U,  1574917U, 12869168U,\n 2889732U, 13121561U, 12084781U,   536116U,  6566954U,  7616562U,  8412175U, 10767925U,\n14174245U,  9719849U, 10775094U, 10775589U,   263223U, 14704687U, 11825199U, 15233539U,\n15732795U, 15498301U, 16545338U, 17071680U, 17860162U, 18648133U, 14973460U, 16001556U,\n16778774U, 19137608U, 19412508U, 19698716U, 19938305U, 14456833U, 19175991U, 21012046U,\n 9479249U, 21275731U, 22325287U, 21800021U, 23113302U, 14419017U, 23638573U, 16806915U,\n  815636U, 15470654U, 14972477U, 16022549U, 15234617U, 23378011U, 16809530U,  7387723U,\n13415469U, 18875486U, 19437142U, 19951197U, 23632964U, 10266677U,  9464914U, 22324308U,\n13936694U, 14198866U, 14703193U, 23883865U, 12327951U, 12082703U,  4211744U,  3940384U,\n23376964U, 17347140U, 12075041U, 13392929U, 23619152U, 20493392U, 17598542U, 20743758U,\n19709528U, 22582872U,  7115827U, 22832714U, 22589002U,  6575147U, 25178667U,  6829619U,\n11555866U, 13391898U,  7617564U,  7903260U, 19970588U,  7627776U, 16823900U, 17072220U,\n 5795931U, 16788571U,  3152433U, 12589105U,  5773360U, 14691376U, 25429044U, 25454690U,\n25974316U, 26265132U, 27053157U, 27315813U, 28103785U, 27842664U, 13643370U, 28624940U,\n29417070U, 29940849U, 30467187U,  4777485U, 30993012U, 30728306U,  1582091U,  5040243U,\n31203858U,  2158599U,  1895942U,  3469873U,  5039634U,  4989556U, 25716843U, 32030828U,\n32293474U, 31255569U, 33094268U, 27578495U, 33870464U, 34134122U, 34353760U, 34657303U,\n34876952U, 35720838U, 36508809U, 36201603U, 37296780U, 35987599U, 38078074U, 38073474U,\n35987083U, 38610029U, 39135266U, 39660633U, 39923289U, 38819891U, 39115412U, 40711321U,\n41236578U, 42024606U, 42287262U, 10041506U,  9520763U,  9238172U, 10568868U, 10569767U,\n13120131U, 33345637U, 28103322U, 40424065U, 27840617U, 29162606U, 13685867U, 29416562U,\n29942437U, 28596372U,  4725259U, 30729332U, 31517815U, 31204358U, 31518215U, 38324333U,\n 3694246U, 26300003U, 40436377U, 32036994U, 32294044U, 30992401U, 33093800U, 27590272U,\n34133124U, 27349607U, 34390138U, 34614917U, 34877471U, 36463754U, 38823457U, 44639379U,\n42545828U, 42779259U, 43069991U, 40710818U, 10044456U,  9500195U,  9254950U,   574046U,\n24691371U, 23157420U, 22851756U, 26828462U, 26528942U, 39412400U, 46738608U, 47266995U,\n47540398U, 18922676U, 45182039U, 29155511U, 48066738U, 48329913U, 31804017U, 49082993U,\n48533057U, 30731450U, 29420216U, 18642495U, 48794809U, 18184263U, 31461436U, 49313851U,\n49578588U, 48532551U, 18123962U, 24729246U, 25001141U, 25525931U, 31029317U, 32832704U,\n45704831U, 46989952U, 47547060U, 19760223U, 47285832U, 18974793U, 52268229U, 24481986U,\n53318857U, 54106828U, 50962110U, 49913537U, 53582544U, 55157430U, 55682639U, 22915123U,\n47818452U, 42052249U, 44936353U, 42547357U, 40715421U, 56141525U, 42748095U, 50111190U,\n55880407U, 56404519U, 19708610U, 45678181U, 47004831U, 47005313U, 45705395U, 33087159U,\n47234206U, 48029880U, 56714424U, 22899924U, 17075775U, 48294586U, 30994620U, 18708539U,\n49344572U, 45196470U, 23364760U, 56973485U, 33898137U, 47545537U, 44924630U, 48819269U,\n57245822U, 33384064U, 47284931U, 57498799U, 25003198U, 18974404U, 19236941U, 54631112U,\n20997844U, 55163089U, 40217303U, 25511615U, 40218151U, 55918753U, 56208033U, 55879253U,\n50088017U, 56140371U, 13178511U,    25743U, 58046144U, 58309312U, 58543716U, 58834532U,\n46507180U, 56998622U, 45200094U, 58572924U, 44416636U, 59067439U, 49136175U, 39696594U,\n59322434U, 17679426U, 59514894U, 43632142U, 44680870U, 59069606U, 57749144U, 59357336U,\n38814242U, 21080143U, 44679826U, 59843809U, 49137889U, 49079013U, 59864805U, 58771684U,\n60145892U, 58837672U, 32620712U, 46751962U, 48063706U, 55141014U, 39691414U, 38389860U,\n58294490U, 46251226U, 57212087U, 33116270U, 29678760U, 60089000U, 45202608U, 46487728U,\n 8198285U, 34881165U,    73360U,  8126608U, 34933895U, 34671239U, 51480263U, 51742919U,\n20285643U, 52730571U, 50711747U, 60621956U, 24407756U, 54573772U, 14457550U, 53505742U,\n54628445U, 40712811U, 40449643U, 42021535U, 44909214U, 41206891U, 45927549U, 26791549U,\n32820905U, 32570025U, 28425897U, 27318441U, 25216679U, 28360871U, 43892332U, 11322976U,\n58045109U, 32866523U, 45939419U, 47537371U, 58026715U, 45396063U, 24996569U, 45399769U,\n49622194U, 56720050U,  3466917U, 31726245U, 12345977U, 49045113U, 23407805U, 24163005U,\n17136344U, 48530136U, 29969011U, 56717497U, 60891879U, 61149834U, 61460711U, 61986027U,\n61676681U, 62199016U, 61460104U, 61411470U, 62771950U, 63037166U, 63035627U, 63296748U,\n63300842U, 62511858U, 63776405U, 64350357U, 65138422U, 65926393U, 65927418U, 66409619U,\n66975486U, 67502335U, 66971899U, 67241204U, 68284675U, 66713336U, 67503874U, 35195533U,\n36243089U, 36716176U, 36250344U, 38077671U, 61150445U, 63557866U, 61674217U, 62247154U,\n61414635U, 61723375U, 63036657U, 62775531U, 63297776U, 61201134U, 62514417U, 38591125U,\n67708659U, 64242940U, 64574717U, 65390327U, 63777524U, 67970818U, 67503360U, 67757812U,\n68288254U, 67501828U, 67234047U, 68290305U, 66711812U, 54397670U, 53873864U, 68554470U,\n69079816U, 53088461U, 52565253U, 60427974U, 52039370U, 68819211U, 70392587U, 69606152U,\n69082377U, 71179527U, 69867279U, 54927571U, 55452945U, 72755475U, 73543446U, 73805592U,\n74331345U, 73284380U, 75382045U, 71973655U, 75644690U, 72499994U, 73283860U, 74071328U,\n51481291U, 50958543U, 20288206U, 54366469U, 50700006U, 52563210U, 68558599U, 53874950U,\n68556047U, 53088008U, 68817164U, 70130446U, 70654216U, 69606669U, 69864715U, 71177998U,\n47817427U, 54935824U, 20849433U, 57812763U, 59387157U, 55451922U, 54932768U, 75644191U,\n71450898U, 74859292U, 74857761U, 71974685U, 74072862U, 72497441U, 68022518U, 66455286U,\n73282321U, 71970577U, 72493846U, 73279766U, 44690679U, 59593975U, 65140473U, 64876793U,\n65923317U, 66189045U, 59279128U, 72992024U, 17604377U, 73434905U, 59634426U,  4310778U,\n 4322556U,  8921340U, 57787669U, 72202517U, 74069779U, 72496403U, 66397955U, 64301602U,\n55452239U, 74293980U, 53845193U, 53058249U, 35986572U, 37819020U, 37294214U, 37035142U,\n53057221U, 52008133U, 51236039U, 52284614U, 60622983U, 60624520U,  5509130U,  2107966U );\n\nuint getIndex( int faceID, int vertexID )\n{\n    return (faces[faceID] >> (9*vertexID) ) & 511U;\n}\n\nvec3 getVertex( uint id )\n{\n    uint d = vertices[id];\n    vec3 v = vec3(ivec3(d,d>>10,d>>20)&1023) / 1023.0;\n    return v + vec3( -0.0803029,-0.26890646, -0.5770213127 );\n}\n\nvec3 getVertex(int faceID, int vertexID){\n    return getVertex(getIndex(faceID, vertexID));\n}\n","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Fox model by pixelmannen: https://opengameart.org/content/fox-and-shiba\n//\n// NOT optimized for size, this model fits in a few hundred bytes really\n\nconst int numVertices = 290;\nconst int numFaces = 576;\n\nconst uint vertices[290] = uint[](\n 474194016U,  456372306U,  352611409U, 1003915346U,  997632126U, 1028056178U, 1012359285U, 1022864486U,\n1063764050U, 1051144299U, 1067953244U,  969343123U,  952500360U,  927354003U,  785584243U,  781389931U,\n 774033519U,  921167985U,  925333648U,  881367204U, 1044830290U, 1073188946U,  968207442U,  373581952U,\n 378821737U,  518232191U,  563316854U,  564356178U,  554918994U,  517177432U,  517177426U,  397597808U,\n 764610662U,  740491357U,  743613546U,   96613484U,   96606290U,    1245285U,   89298044U,  175384658U,\n  79914097U,    5465187U,  563317884U,  562283660U,  709059699U,  823379026U,  800305248U,  819190910U,\n 877969536U,  875891851U,  517180522U,  738414674U,  351569006U,    7574610U,     191570U,  474193989U,\n 880049234U, 1028056114U,  997632038U, 1012359215U, 1022864447U, 1051144250U, 1067953224U,  969342993U,\n 952500252U,  927353873U,  785584177U,  775078965U,  781389881U,  921167923U,  881367040U,  925333524U,\n 373581860U,  378821691U,  563316783U,  518232102U,  517177420U,  397597749U,  764610622U,  742566971U,\n 743637063U,   96613433U,    1245247U,   89297960U,    5465153U,   79914035U,  563317800U,  709059633U,\n 562283545U,  819189798U,  800305220U,  877969444U,  875891738U,  517180474U,  351568949U,  518251537U,\n 518250643U,  327376978U,  320046201U,  562288788U,  706982036U,  529968210U,  554084434U,  555106425U,\n 467011731U,  373674127U,  373624984U,  351600768U,  462755997U,  723707023U,  786839700U,  786881618U,\n 851924050U,  781551771U,  855036037U,  888589462U,  859273329U,  851940434U,  915932242U,  989311074U,\n 996652114U,  874857619U,  507730063U,  207761533U,  687205523U,  687247442U,  741788754U,  456565842U,\n 373704786U,  351650897U,  448997534U,  515069056U,  396551310U,  381872256U,  370278535U,  373422219U,\n 366061706U,  369207409U,  398579827U,  388097136U,  368183419U,  363992192U,  355579008U,  382856303U,\n 376566897U,  422716549U,  741538966U,  737264781U,  722664559U,  730978425U,  813981713U,  780341269U,\n 796070948U,  303384658U,  347428982U,  292862076U,  202548362U,  305407108U,  351600675U,  347428909U,\n 292861992U,  305407008U,  188987525U,  207754322U,  184813687U,  862336152U,  796071040U,  560236698U,\n 736498836U,  556137619U,  767726734U,  320046123U,  706981904U,  562288657U,  467011601U,  555106347U,\n 736458761U,  734256144U,  781551625U,  373674005U,  373624844U,  462755847U,  725807125U,  786839568U,\n 855035935U,  888589326U,  859273268U,  813981843U,  989311042U,  874857489U,  507729941U,  207761448U,\n 687205393U,  448997382U,  515068964U,  397599767U,  381872165U,  370278429U,  366061594U,  374470681U,\n 398579762U,  368183337U,  355578916U,  363992100U,  382856245U,  369207347U,  376566835U,  422716447U,\n 388097076U,  710014999U,  743635982U,  705827884U,  726861877U,  188987423U,  202548250U,  184813613U,\n 862336012U,  560236555U,  736498705U,  556137489U,  763526166U,  558185480U,  691365896U,  558185629U,\n 691366044U,  780341392U,  786609188U,  786613376U,  734256276U,  736458908U,  383898646U,  383898766U,\n 403811460U,  399539312U,  392218767U,  396364927U,  405822607U,  402699380U,  441454711U,  413141103U,\n 413141135U,  441454726U,  408990847U,  735105158U,  742427768U,  743560303U,  770818184U,  780255360U,\n 773890175U,  770819193U,  763480176U,  752921712U,  747753581U,  764527756U,  791682165U,  748685428U,\n 749735053U,  790633610U,  747671692U,  759212170U,  804262017U,  403811360U,  399539253U,  392218645U,\n 396364837U,  405822485U,  402699313U,  441454638U,  413141045U,  413141013U,  441454622U,  408990757U,\n 677453854U,  716306485U,  675338285U,  738309148U,  705737765U,  746693668U,  738311211U,  688972852U,\n 733071412U,  720498744U,  693162011U,  733070360U,  706748464U,  665867313U,  705699867U,  666916888U,\n 680580120U,  716177443U );\n\nconst uint faces[576] = uint[](\n  524800U,  1312771U,  2100742U,  2624521U,  1578500U,  2890252U,  4201998U,  4989969U,\n 2361876U,  5509652U,   792598U,   536599U,  7091225U,  7353881U,  7879168U,   277504U,\n 8138752U,  8929824U,  9717795U,  9717286U, 10768423U,  9718824U, 11556394U,   524312U,\n12344365U,  1054723U,  1312276U,  2100234U,  1575433U,  2626069U,  1574917U, 12869168U,\n 2889732U, 13121561U, 12084781U,   536116U,  6566954U,  7616562U,  8412175U, 10767925U,\n14174245U,  9719849U, 10775094U, 10775589U,   263223U, 14704687U, 11825199U, 15233539U,\n15732795U, 15498301U, 16545338U, 17071680U, 17860162U, 18648133U, 14973460U, 16001556U,\n16778774U, 19137608U, 19412508U, 19698716U, 19938305U, 14456833U, 19175991U, 21012046U,\n 9479249U, 21275731U, 22325287U, 21800021U, 23113302U, 14419017U, 23638573U, 16806915U,\n  815636U, 15470654U, 14972477U, 16022549U, 15234617U, 23378011U, 16809530U,  7387723U,\n13415469U, 18875486U, 19437142U, 19951197U, 23632964U, 10266677U,  9464914U, 22324308U,\n13936694U, 14198866U, 14703193U, 23883865U, 12327951U, 12082703U,  4211744U,  3940384U,\n23376964U, 17347140U, 12075041U, 13392929U, 23619152U, 20493392U, 17598542U, 20743758U,\n19709528U, 22582872U,  7115827U, 22832714U, 22589002U,  6575147U, 25178667U,  6829619U,\n11555866U, 13391898U,  7617564U,  7903260U, 19970588U,  7627776U, 16823900U, 17072220U,\n 5795931U, 16788571U,  3152433U, 12589105U,  5773360U, 14691376U, 25429044U, 25454690U,\n25974316U, 26265132U, 27053157U, 27315813U, 28103785U, 27842664U, 13643370U, 28624940U,\n29417070U, 29940849U, 30467187U,  4777485U, 30993012U, 30728306U,  1582091U,  5040243U,\n31203858U,  2158599U,  1895942U,  3469873U,  5039634U,  4989556U, 25716843U, 32030828U,\n32293474U, 31255569U, 33094268U, 27578495U, 33870464U, 34134122U, 34353760U, 34657303U,\n34876952U, 35720838U, 36508809U, 36201603U, 37296780U, 35987599U, 38078074U, 38073474U,\n35987083U, 38610029U, 39135266U, 39660633U, 39923289U, 38819891U, 39115412U, 40711321U,\n41236578U, 42024606U, 42287262U, 10041506U,  9520763U,  9238172U, 10568868U, 10569767U,\n13120131U, 33345637U, 28103322U, 40424065U, 27840617U, 29162606U, 13685867U, 29416562U,\n29942437U, 28596372U,  4725259U, 30729332U, 31517815U, 31204358U, 31518215U, 38324333U,\n 3694246U, 26300003U, 40436377U, 32036994U, 32294044U, 30992401U, 33093800U, 27590272U,\n34133124U, 27349607U, 34390138U, 34614917U, 34877471U, 36463754U, 38823457U, 44639379U,\n42545828U, 42779259U, 43069991U, 40710818U, 10044456U,  9500195U,  9254950U,   574046U,\n24691371U, 23157420U, 22851756U, 26828462U, 26528942U, 39412400U, 46738608U, 47266995U,\n47540398U, 18922676U, 45182039U, 29155511U, 48066738U, 48329913U, 31804017U, 49082993U,\n48533057U, 30731450U, 29420216U, 18642495U, 48794809U, 18184263U, 31461436U, 49313851U,\n49578588U, 48532551U, 18123962U, 24729246U, 25001141U, 25525931U, 31029317U, 32832704U,\n45704831U, 46989952U, 47547060U, 19760223U, 47285832U, 18974793U, 52268229U, 24481986U,\n53318857U, 54106828U, 50962110U, 49913537U, 53582544U, 55157430U, 55682639U, 22915123U,\n47818452U, 42052249U, 44936353U, 42547357U, 40715421U, 56141525U, 42748095U, 50111190U,\n55880407U, 56404519U, 19708610U, 45678181U, 47004831U, 47005313U, 45705395U, 33087159U,\n47234206U, 48029880U, 56714424U, 22899924U, 17075775U, 48294586U, 30994620U, 18708539U,\n49344572U, 45196470U, 23364760U, 56973485U, 33898137U, 47545537U, 44924630U, 48819269U,\n57245822U, 33384064U, 47284931U, 57498799U, 25003198U, 18974404U, 19236941U, 54631112U,\n20997844U, 55163089U, 40217303U, 25511615U, 40218151U, 55918753U, 56208033U, 55879253U,\n50088017U, 56140371U, 13178511U,    25743U, 58046144U, 58309312U, 58543716U, 58834532U,\n46507180U, 56998622U, 45200094U, 58572924U, 44416636U, 59067439U, 49136175U, 39696594U,\n59322434U, 17679426U, 59514894U, 43632142U, 44680870U, 59069606U, 57749144U, 59357336U,\n38814242U, 21080143U, 44679826U, 59843809U, 49137889U, 49079013U, 59864805U, 58771684U,\n60145892U, 58837672U, 32620712U, 46751962U, 48063706U, 55141014U, 39691414U, 38389860U,\n58294490U, 46251226U, 57212087U, 33116270U, 29678760U, 60089000U, 45202608U, 46487728U,\n 8198285U, 34881165U,    73360U,  8126608U, 34933895U, 34671239U, 51480263U, 51742919U,\n20285643U, 52730571U, 50711747U, 60621956U, 24407756U, 54573772U, 14457550U, 53505742U,\n54628445U, 40712811U, 40449643U, 42021535U, 44909214U, 41206891U, 45927549U, 26791549U,\n32820905U, 32570025U, 28425897U, 27318441U, 25216679U, 28360871U, 43892332U, 11322976U,\n58045109U, 32866523U, 45939419U, 47537371U, 58026715U, 45396063U, 24996569U, 45399769U,\n49622194U, 56720050U,  3466917U, 31726245U, 12345977U, 49045113U, 23407805U, 24163005U,\n17136344U, 48530136U, 29969011U, 56717497U, 60891879U, 61149834U, 61460711U, 61986027U,\n61676681U, 62199016U, 61460104U, 61411470U, 62771950U, 63037166U, 63035627U, 63296748U,\n63300842U, 62511858U, 63776405U, 64350357U, 65138422U, 65926393U, 65927418U, 66409619U,\n66975486U, 67502335U, 66971899U, 67241204U, 68284675U, 66713336U, 67503874U, 35195533U,\n36243089U, 36716176U, 36250344U, 38077671U, 61150445U, 63557866U, 61674217U, 62247154U,\n61414635U, 61723375U, 63036657U, 62775531U, 63297776U, 61201134U, 62514417U, 38591125U,\n67708659U, 64242940U, 64574717U, 65390327U, 63777524U, 67970818U, 67503360U, 67757812U,\n68288254U, 67501828U, 67234047U, 68290305U, 66711812U, 54397670U, 53873864U, 68554470U,\n69079816U, 53088461U, 52565253U, 60427974U, 52039370U, 68819211U, 70392587U, 69606152U,\n69082377U, 71179527U, 69867279U, 54927571U, 55452945U, 72755475U, 73543446U, 73805592U,\n74331345U, 73284380U, 75382045U, 71973655U, 75644690U, 72499994U, 73283860U, 74071328U,\n51481291U, 50958543U, 20288206U, 54366469U, 50700006U, 52563210U, 68558599U, 53874950U,\n68556047U, 53088008U, 68817164U, 70130446U, 70654216U, 69606669U, 69864715U, 71177998U,\n47817427U, 54935824U, 20849433U, 57812763U, 59387157U, 55451922U, 54932768U, 75644191U,\n71450898U, 74859292U, 74857761U, 71974685U, 74072862U, 72497441U, 68022518U, 66455286U,\n73282321U, 71970577U, 72493846U, 73279766U, 44690679U, 59593975U, 65140473U, 64876793U,\n65923317U, 66189045U, 59279128U, 72992024U, 17604377U, 73434905U, 59634426U,  4310778U,\n 4322556U,  8921340U, 57787669U, 72202517U, 74069779U, 72496403U, 66397955U, 64301602U,\n55452239U, 74293980U, 53845193U, 53058249U, 35986572U, 37819020U, 37294214U, 37035142U,\n53057221U, 52008133U, 51236039U, 52284614U, 60622983U, 60624520U,  5509130U,  2107966U );\n\nuint getIndex( int faceID, int vertexID )\n{\n    return (faces[faceID] >> (9*vertexID) ) & 511U;\n}\n\nvec3 getVertex( uint id )\n{\n    uint d = vertices[id];\n    vec3 v = vec3(ivec3(d,d>>10,d>>20)&1023) / 1023.0;\n    return v + vec3( -0.0803029,-0.26890646, -0.5770213127 );\n}\n\nvec3 getVertex(int faceID, int vertexID){\n    return getVertex(getIndex(faceID, vertexID));\n}\n","name":"Common","description":"","type":"common"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(0.0,1.0,x);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(0.0,1.0,x)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(0.0,1.0,flameDensity));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(0.0,1.0,x);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(0.0,1.0,x)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(0.0,1.0,flameDensity));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Noise-Based Procedural Flame","id":"Wtc3RB","date":"0","viewed":0,"name":"Noise-Based Procedural Flame","description":"\u8FC7\u7A0B\u6027\u706B\u7130","likes":0,"published":"Private","tags":["procedural","noise","flame"]},"ver":"0.1","info":{"Name":"Noise-Based Procedural Flame","id":"Wtc3RB","date":"0","viewed":0,"name":"Noise-Based Procedural Flame","description":"\u8FC7\u7A0B\u6027\u706B\u7130","likes":0,"published":"Private","tags":["procedural","noise","flame"]},"renderpass":[{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(0.0,1.0,x);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(0.0,1.0,x)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(0.0,1.0,flameDensity));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(0.0,1.0,x);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(0.0,1.0,x)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(0.0,1.0,flameDensity));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"vec3 cloudPlane(vec2 p){\n    vec3 cloudColor = vec3(1.0,1.0,1.0);\n    vec3 skyColor = vec3(135.0/255.0,206.0/255.0,235.0/255.0);\n    float PI = 3.1415926;\n    float offset = 0.5;\n    float x = p.x;\n    float y = p.y;\n    float xphase = 0.9;\n    float yphase = 0.7;\n    float xfreq = 2.0*3.1415926*0.023;\n    float yfreq = 2.0*3.1415926*0.021;\n    float amplitude = 0.3;\n    float f = 0.0;\n    float fx = 0.0;\n    float fy = 0.0;\n    for(float i =0.0;i<5.0;i+=1.0)\n    {\n        fx = amplitude*(offset + cos(xfreq*(x+xphase)));\n        fy = amplitude*(offset+cos(yfreq*(y+yphase)));\n        f += fx*fy;\n        \n        xphase = PI/2.0*0.9*cos(yfreq*y);\n        yphase = PI/2.0*1.1*cos(xfreq*x);\n        xfreq *= 1.9+i*0.1;\n        yfreq *= 2.2-i*0.08;\n        amplitude *= 0.707;\n    }\n    f = clamp(0.0,1.0,f);\n    vec3 col = mix(skyColor,cloudColor,f);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    vec3 col = cloudPlane(p*30.0+vec2(0,19));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cloudPlane(vec2 p){\n    vec3 cloudColor = vec3(1.0,1.0,1.0);\n    vec3 skyColor = vec3(135.0/255.0,206.0/255.0,235.0/255.0);\n    float PI = 3.1415926;\n    float offset = 0.5;\n    float x = p.x;\n    float y = p.y;\n    float xphase = 0.9;\n    float yphase = 0.7;\n    float xfreq = 2.0*3.1415926*0.023;\n    float yfreq = 2.0*3.1415926*0.021;\n    float amplitude = 0.3;\n    float f = 0.0;\n    float fx = 0.0;\n    float fy = 0.0;\n    for(float i =0.0;i<5.0;i+=1.0)\n    {\n        fx = amplitude*(offset + cos(xfreq*(x+xphase)));\n        fy = amplitude*(offset+cos(yfreq*(y+yphase)));\n        f += fx*fy;\n        \n        xphase = PI/2.0*0.9*cos(yfreq*y);\n        yphase = PI/2.0*1.1*cos(xfreq*x);\n        xfreq *= 1.9+i*0.1;\n        yfreq *= 2.2-i*0.08;\n        amplitude *= 0.707;\n    }\n    f = clamp(0.0,1.0,f);\n    vec3 col = mix(skyColor,cloudColor,f);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    vec3 col = cloudPlane(p*30.0+vec2(0,19));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Procedural 2D Cloud Plane","id":"3lt3Dr","date":"0","viewed":0,"name":"Procedural 2D Cloud Plane","description":"2d\u4E91\u5E73\u9762","likes":0,"published":"Private","tags":["procedural2dcloudspectralsynthesis"]},"ver":"0.1","info":{"Name":"Procedural 2D Cloud Plane","id":"3lt3Dr","date":"0","viewed":0,"name":"Procedural 2D Cloud Plane","description":"2d\u4E91\u5E73\u9762","likes":0,"published":"Private","tags":["procedural2dcloudspectralsynthesis"]},"renderpass":[{"Code":"vec3 cloudPlane(vec2 p){\n    vec3 cloudColor = vec3(1.0,1.0,1.0);\n    vec3 skyColor = vec3(135.0/255.0,206.0/255.0,235.0/255.0);\n    float PI = 3.1415926;\n    float offset = 0.5;\n    float x = p.x;\n    float y = p.y;\n    float xphase = 0.9;\n    float yphase = 0.7;\n    float xfreq = 2.0*3.1415926*0.023;\n    float yfreq = 2.0*3.1415926*0.021;\n    float amplitude = 0.3;\n    float f = 0.0;\n    float fx = 0.0;\n    float fy = 0.0;\n    for(float i =0.0;i<5.0;i+=1.0)\n    {\n        fx = amplitude*(offset + cos(xfreq*(x+xphase)));\n        fy = amplitude*(offset+cos(yfreq*(y+yphase)));\n        f += fx*fy;\n        \n        xphase = PI/2.0*0.9*cos(yfreq*y);\n        yphase = PI/2.0*1.1*cos(xfreq*x);\n        xfreq *= 1.9+i*0.1;\n        yfreq *= 2.2-i*0.08;\n        amplitude *= 0.707;\n    }\n    f = clamp(0.0,1.0,f);\n    vec3 col = mix(skyColor,cloudColor,f);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    vec3 col = cloudPlane(p*30.0+vec2(0,19));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cloudPlane(vec2 p){\n    vec3 cloudColor = vec3(1.0,1.0,1.0);\n    vec3 skyColor = vec3(135.0/255.0,206.0/255.0,235.0/255.0);\n    float PI = 3.1415926;\n    float offset = 0.5;\n    float x = p.x;\n    float y = p.y;\n    float xphase = 0.9;\n    float yphase = 0.7;\n    float xfreq = 2.0*3.1415926*0.023;\n    float yfreq = 2.0*3.1415926*0.021;\n    float amplitude = 0.3;\n    float f = 0.0;\n    float fx = 0.0;\n    float fy = 0.0;\n    for(float i =0.0;i<5.0;i+=1.0)\n    {\n        fx = amplitude*(offset + cos(xfreq*(x+xphase)));\n        fy = amplitude*(offset+cos(yfreq*(y+yphase)));\n        f += fx*fy;\n        \n        xphase = PI/2.0*0.9*cos(yfreq*y);\n        yphase = PI/2.0*1.1*cos(xfreq*x);\n        xfreq *= 1.9+i*0.1;\n        yfreq *= 2.2-i*0.08;\n        amplitude *= 0.707;\n    }\n    f = clamp(0.0,1.0,f);\n    vec3 col = mix(skyColor,cloudColor,f);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    vec3 col = cloudPlane(p*30.0+vec2(0,19));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Procedural Brick Texture 2D","id":"wlcGRM","date":"1576151122","viewed":55,"name":"Procedural Brick Texture 2D","description":"2D\u53CD\u952F\u9F7F\u7816\u5757\u8D34\u56FE","likes":4,"published":"Public","tags":["2d","brick","antialiase"]},"ver":"0.1","info":{"Name":"Procedural Brick Texture 2D","id":"wlcGRM","date":"1576151122","viewed":55,"name":"Procedural Brick Texture 2D","description":"2D\u53CD\u952F\u9F7F\u7816\u5757\u8D34\u56FE","likes":4,"published":"Public","tags":["2d","brick","antialiase"]},"renderpass":[{"Code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Procedural Five-Point Star","id":"3ttGDr","date":"1576051881","viewed":39,"name":"Procedural Five-Point Star","description":"\u4E94\u89D2\u661F","likes":1,"published":"Public","tags":["procedural","2d","fivepointstar"]},"ver":"0.1","info":{"Name":"Procedural Five-Point Star","id":"3ttGDr","date":"1576051881","viewed":39,"name":"Procedural Five-Point Star","description":"\u4E94\u89D2\u661F","likes":1,"published":"Public","tags":["procedural","2d","fivepointstar"]},"renderpass":[{"Code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"Code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = smoothstep(0.0,0.01,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = smoothstep(0.0,0.01,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"vec3 FivePointStars(vec2 p, float rmin, float rmax, vec3 starColor, vec3 bgColor, int ncells)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    \n    float scellctr = floor(p.x*float(ncells));\n    float tcellctr = floor(p.y*float(ncells));\n    float in_out = 0;\n    for(int i = -1;i<=1;i++){\n        for(int j = -1;j<=1;j++){\n            \n        }\n    }\n    \n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = smoothstep(0.0,0.01,cross(d,d1).z);\n    vec3 col = mix(starColor, bgColor, in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 FivePointStars(vec2 p, float rmin, float rmax, vec3 starColor, vec3 bgColor, int ncells)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    \n    float scellctr = floor(p.x*float(ncells));\n    float tcellctr = floor(p.y*float(ncells));\n    float in_out = 0;\n    for(int i = -1;i<=1;i++){\n        for(int j = -1;j<=1;j++){\n            \n        }\n    }\n    \n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = smoothstep(0.0,0.01,cross(d,d1).z);\n    vec3 col = mix(starColor, bgColor, in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Random Placement Pattern","id":"wld3WM","date":"0","viewed":0,"name":"Random Placement Pattern","description":"\u968F\u673A\u653E\u7F6E\u4E94\u89D2\u661F","likes":0,"published":"Private","tags":["randomplacement"]},"ver":"0.1","info":{"Name":"Random Placement Pattern","id":"wld3WM","date":"0","viewed":0,"name":"Random Placement Pattern","description":"\u968F\u673A\u653E\u7F6E\u4E94\u89D2\u661F","likes":0,"published":"Private","tags":["randomplacement"]},"renderpass":[{"Code":"vec3 FivePointStars(vec2 p, float rmin, float rmax, vec3 starColor, vec3 bgColor, int ncells)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    \n    float scellctr = floor(p.x*float(ncells));\n    float tcellctr = floor(p.y*float(ncells));\n    float in_out = 0;\n    for(int i = -1;i<=1;i++){\n        for(int j = -1;j<=1;j++){\n            \n        }\n    }\n    \n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = smoothstep(0.0,0.01,cross(d,d1).z);\n    vec3 col = mix(starColor, bgColor, in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 FivePointStars(vec2 p, float rmin, float rmax, vec3 starColor, vec3 bgColor, int ncells)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    \n    float scellctr = floor(p.x*float(ncells));\n    float tcellctr = floor(p.y*float(ncells));\n    float in_out = 0;\n    for(int i = -1;i<=1;i++){\n        for(int j = -1;j<=1;j++){\n            \n        }\n    }\n    \n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = smoothstep(0.0,0.01,cross(d,d1).z);\n    vec3 col = mix(starColor, bgColor, in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"RayMarch \u539F\u7406","id":"3stXDH","date":"0","viewed":0,"name":"RayMarch \u539F\u7406","description":"RayMarch","likes":0,"published":"Private","tags":["raymarch"]},"ver":"0.1","info":{"Name":"RayMarch \u539F\u7406","id":"3stXDH","date":"0","viewed":0,"name":"RayMarch \u539F\u7406","description":"RayMarch","likes":0,"published":"Private","tags":["raymarch"]},"renderpass":[{"Code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"const int STEPS=23;\n\nconst float smooth_pixels=3.;\nconst float thickness_pixels=0.1;\n    \nfloat dot2(vec2 p, vec2 q){\n\tp-=q;\n    return dot(p,p);\n}\nfloat circle(vec2 p,vec2 c,float r){\n\treturn length(p-c)-r;\n}\nfloat box( vec2 p,vec2 s, vec2 b){\n    p-=s;\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat dist(vec2 p){\n\tfloat c0=circle(p,vec2(-1.,0.1),0.6);\n    float c1=circle(p,vec2(1,0.7),0.14);\n    float b=box(p,vec2(1.,-0.6),vec2(0.5,0.8));\n    return min(c1,min(c0,b));\n}\nfloat circ(vec2 p,vec2 c,float r,float w,float sf){\n\treturn smoothstep(w+sf,w,abs(length(p-c)-r+w+sf));\n}\nfloat cut(float x){\n\treturn clamp(x,0.,1.);\n}\nfloat line(vec2 p,vec2 p2,vec2 uv,float w,float sf){\n    vec2 n=uv-p;\n\tvec2 k=p2-p;\n\treturn smoothstep(w+sf,w,length(n-k*clamp(dot(n,k)/dot(k,k),0.,1.)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float sf=smooth_pixels/iResolution.y;\n    float w=thickness_pixels/iResolution.y;\n    \n    vec2 ro=vec2(-1.4,-0.9); //ray origin\n    vec2 rd=normalize(vec2(5,3));\n    \n    float t=mod(iTime*4.,float(2*STEPS));\n    \n\tvec3 col=vec3(0);\n    col+=0.0001/dot2(uv,ro)*vec3(-1,1,1);\n    col+=smoothstep(sf,0.,dist(uv));\n    \n    float d;\n    vec2 p=ro;\n    vec2 j;\n    for(int i=1;i<=STEPS;i++){\n\t\td=dist(p);\n    \tcol+=circ(uv,p,d*cut(t-float(i*2-2)),w,sf)*vec3(1,0,0);\n        j=rd*cut(t-float(i*2-1));\n        p+=j*d;\n    }\n    p-=rd*(w+sf);\n    col+=line(ro,p,uv,w,sf);\n    \n    \n    fragColor=vec4(col,1.);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int STEPS=23;\n\nconst float smooth_pixels=3.;\nconst float thickness_pixels=0.1;\n    \nfloat dot2(vec2 p, vec2 q){\n\tp-=q;\n    return dot(p,p);\n}\nfloat circle(vec2 p,vec2 c,float r){\n\treturn length(p-c)-r;\n}\nfloat box( vec2 p,vec2 s, vec2 b){\n    p-=s;\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat dist(vec2 p){\n\tfloat c0=circle(p,vec2(-1.,0.1),0.6);\n    float c1=circle(p,vec2(1,0.7),0.14);\n    float b=box(p,vec2(1.,-0.6),vec2(0.5,0.8));\n    return min(c1,min(c0,b));\n}\nfloat circ(vec2 p,vec2 c,float r,float w,float sf){\n\treturn smoothstep(w+sf,w,abs(length(p-c)-r+w+sf));\n}\nfloat cut(float x){\n\treturn clamp(x,0.,1.);\n}\nfloat line(vec2 p,vec2 p2,vec2 uv,float w,float sf){\n    vec2 n=uv-p;\n\tvec2 k=p2-p;\n\treturn smoothstep(w+sf,w,length(n-k*clamp(dot(n,k)/dot(k,k),0.,1.)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float sf=smooth_pixels/iResolution.y;\n    float w=thickness_pixels/iResolution.y;\n    \n    vec2 ro=vec2(-1.4,-0.9); //ray origin\n    vec2 rd=normalize(vec2(5,3));\n    \n    float t=mod(iTime*4.,float(2*STEPS));\n    \n\tvec3 col=vec3(0);\n    col+=0.0001/dot2(uv,ro)*vec3(-1,1,1);\n    col+=smoothstep(sf,0.,dist(uv));\n    \n    float d;\n    vec2 p=ro;\n    vec2 j;\n    for(int i=1;i<=STEPS;i++){\n\t\td=dist(p);\n    \tcol+=circ(uv,p,d*cut(t-float(i*2-2)),w,sf)*vec3(1,0,0);\n        j=rd*cut(t-float(i*2-1));\n        p+=j*d;\n    }\n    p-=rd*(w+sf);\n    col+=line(ro,p,uv,w,sf);\n    \n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"RayMarch-Concept","id":"3llGRf","date":"0","viewed":0,"name":"RayMarch-Concept","description":"RayMarch-Concept","likes":0,"published":"Private","tags":["raymarchconcept"]},"ver":"0.1","info":{"Name":"RayMarch-Concept","id":"3llGRf","date":"0","viewed":0,"name":"RayMarch-Concept","description":"RayMarch-Concept","likes":0,"published":"Private","tags":["raymarchconcept"]},"renderpass":[{"Code":"const int STEPS=23;\n\nconst float smooth_pixels=3.;\nconst float thickness_pixels=0.1;\n    \nfloat dot2(vec2 p, vec2 q){\n\tp-=q;\n    return dot(p,p);\n}\nfloat circle(vec2 p,vec2 c,float r){\n\treturn length(p-c)-r;\n}\nfloat box( vec2 p,vec2 s, vec2 b){\n    p-=s;\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat dist(vec2 p){\n\tfloat c0=circle(p,vec2(-1.,0.1),0.6);\n    float c1=circle(p,vec2(1,0.7),0.14);\n    float b=box(p,vec2(1.,-0.6),vec2(0.5,0.8));\n    return min(c1,min(c0,b));\n}\nfloat circ(vec2 p,vec2 c,float r,float w,float sf){\n\treturn smoothstep(w+sf,w,abs(length(p-c)-r+w+sf));\n}\nfloat cut(float x){\n\treturn clamp(x,0.,1.);\n}\nfloat line(vec2 p,vec2 p2,vec2 uv,float w,float sf){\n    vec2 n=uv-p;\n\tvec2 k=p2-p;\n\treturn smoothstep(w+sf,w,length(n-k*clamp(dot(n,k)/dot(k,k),0.,1.)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float sf=smooth_pixels/iResolution.y;\n    float w=thickness_pixels/iResolution.y;\n    \n    vec2 ro=vec2(-1.4,-0.9); //ray origin\n    vec2 rd=normalize(vec2(5,3));\n    \n    float t=mod(iTime*4.,float(2*STEPS));\n    \n\tvec3 col=vec3(0);\n    col+=0.0001/dot2(uv,ro)*vec3(-1,1,1);\n    col+=smoothstep(sf,0.,dist(uv));\n    \n    float d;\n    vec2 p=ro;\n    vec2 j;\n    for(int i=1;i<=STEPS;i++){\n\t\td=dist(p);\n    \tcol+=circ(uv,p,d*cut(t-float(i*2-2)),w,sf)*vec3(1,0,0);\n        j=rd*cut(t-float(i*2-1));\n        p+=j*d;\n    }\n    p-=rd*(w+sf);\n    col+=line(ro,p,uv,w,sf);\n    \n    \n    fragColor=vec4(col,1.);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int STEPS=23;\n\nconst float smooth_pixels=3.;\nconst float thickness_pixels=0.1;\n    \nfloat dot2(vec2 p, vec2 q){\n\tp-=q;\n    return dot(p,p);\n}\nfloat circle(vec2 p,vec2 c,float r){\n\treturn length(p-c)-r;\n}\nfloat box( vec2 p,vec2 s, vec2 b){\n    p-=s;\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat dist(vec2 p){\n\tfloat c0=circle(p,vec2(-1.,0.1),0.6);\n    float c1=circle(p,vec2(1,0.7),0.14);\n    float b=box(p,vec2(1.,-0.6),vec2(0.5,0.8));\n    return min(c1,min(c0,b));\n}\nfloat circ(vec2 p,vec2 c,float r,float w,float sf){\n\treturn smoothstep(w+sf,w,abs(length(p-c)-r+w+sf));\n}\nfloat cut(float x){\n\treturn clamp(x,0.,1.);\n}\nfloat line(vec2 p,vec2 p2,vec2 uv,float w,float sf){\n    vec2 n=uv-p;\n\tvec2 k=p2-p;\n\treturn smoothstep(w+sf,w,length(n-k*clamp(dot(n,k)/dot(k,k),0.,1.)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float sf=smooth_pixels/iResolution.y;\n    float w=thickness_pixels/iResolution.y;\n    \n    vec2 ro=vec2(-1.4,-0.9); //ray origin\n    vec2 rd=normalize(vec2(5,3));\n    \n    float t=mod(iTime*4.,float(2*STEPS));\n    \n\tvec3 col=vec3(0);\n    col+=0.0001/dot2(uv,ro)*vec3(-1,1,1);\n    col+=smoothstep(sf,0.,dist(uv));\n    \n    float d;\n    vec2 p=ro;\n    vec2 j;\n    for(int i=1;i<=STEPS;i++){\n\t\td=dist(p);\n    \tcol+=circ(uv,p,d*cut(t-float(i*2-2)),w,sf)*vec3(1,0,0);\n        j=rd*cut(t-float(i*2-1));\n        p+=j*d;\n    }\n    p-=rd*(w+sf);\n    col+=line(ro,p,uv,w,sf);\n    \n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n//#define ZERO (min(iFrame,0))\n#define ZERO (0)\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n//#define ZERO (min(iFrame,0))\n#define ZERO (0)\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"RayMarch-Primitives","id":"WllGRX","date":"0","viewed":0,"name":"RayMarch-Primitives","description":"RayMarch-Primitives","likes":0,"published":"Private","tags":["primitives"]},"ver":"0.1","info":{"Name":"RayMarch-Primitives","id":"WllGRX","date":"0","viewed":0,"name":"RayMarch-Primitives","description":"RayMarch-Primitives","likes":0,"published":"Private","tags":["primitives"]},"renderpass":[{"Code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n//#define ZERO (min(iFrame,0))\n#define ZERO (0)\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n//#define ZERO (min(iFrame,0))\n#define ZERO (0)\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Raymarch in Raymarch","id":"wllXWH","date":"0","viewed":0,"name":"Raymarch in Raymarch","description":"Raymarch tutorial","likes":0,"published":"Private","tags":["raymarch"]},"ver":"0.1","info":{"Name":"Raymarch in Raymarch","id":"wllXWH","date":"0","viewed":0,"name":"Raymarch in Raymarch","description":"Raymarch tutorial","likes":0,"published":"Private","tags":["raymarch"]},"renderpass":[{"Code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(texelFetch( iChannel0,ivec2(10,10),0).xyz,1.0);\n}","inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(texelFetch( iChannel0,ivec2(10,10),0).xyz,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"Info":{"Name":"ShaderToyFrameworkTest","id":"3tK3R1","date":"0","viewed":0,"name":"ShaderToyFrameworkTest","description":"test","likes":0,"published":"Private","tags":["test"]},"ver":"0.1","info":{"Name":"ShaderToyFrameworkTest","id":"3tK3R1","date":"0","viewed":0,"name":"ShaderToyFrameworkTest","description":"test","likes":0,"published":"Private","tags":["test"]},"renderpass":[{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(texelFetch( iChannel0,ivec2(10,10),0).xyz,1.0);\n}","inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(texelFetch( iChannel0,ivec2(10,10),0).xyz,1.0);\n}","name":"Image","description":"","type":"image"},{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0,0.0,0.0,1.0);\n}","inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0,0.0,0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,1.0,0.0,1.0);\n}","inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,1.0,0.0,1.0);\n}","name":"Buf B","description":"","type":"buffer"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Sphere UV","id":"wl33W2","date":"1577591248","viewed":40,"name":"Sphere UV","description":"\u7403\u4F53UV\u5750\u6807","likes":5,"published":"Public","tags":["math","uv","sphere"]},"ver":"0.1","info":{"Name":"Sphere UV","id":"wl33W2","date":"1577591248","viewed":40,"name":"Sphere UV","description":"\u7403\u4F53UV\u5750\u6807","likes":5,"published":"Public","tags":["math","uv","sphere"]},"renderpass":[{"Code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},"Inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"Info":{"Name":"Test_1channel_0buff","id":"3tK3zw","date":"0","viewed":0,"name":"Test_1channel_0buff","description":"test","likes":0,"published":"Private","tags":["test"]},"ver":"0.1","info":{"Name":"Test_1channel_0buff","id":"3tK3zw","date":"0","viewed":0,"name":"Test_1channel_0buff","description":"test","likes":0,"published":"Private","tags":["test"]},"renderpass":[{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},"Inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"Info":{"Name":"Test_1channel_1buff","id":"3lK3zw","date":"0","viewed":0,"name":"Test_1channel_1buff","description":"test","likes":0,"published":"Private","tags":["test"]},"ver":"0.1","info":{"Name":"Test_1channel_1buff","id":"3lK3zw","date":"0","viewed":0,"name":"Test_1channel_1buff","description":"test","likes":0,"published":"Private","tags":["test"]},"renderpass":[{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel1,fragCoord/iResolution.xy);\n}","inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel1,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},"Inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"Info":{"Name":"Test_2channel_0buff","id":"WtK3zw","date":"0","viewed":0,"name":"Test_2channel_0buff","description":"test","likes":0,"published":"Private","tags":["test"]},"ver":"0.1","info":{"Name":"Test_2channel_0buff","id":"WtK3zw","date":"0","viewed":0,"name":"Test_2channel_0buff","description":"test","likes":0,"published":"Private","tags":["test"]},"renderpass":[{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel1,fragCoord/iResolution.xy);\n}","inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel1,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},"Inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"Info":{"Name":"Test_2channel_2buff","id":"WlK3zw","date":"0","viewed":0,"name":"Test_2channel_2buff","description":"test","likes":0,"published":"Private","tags":["test"]},"ver":"0.1","info":{"Name":"Test_2channel_2buff","id":"WlK3zw","date":"0","viewed":0,"name":"Test_2channel_2buff","description":"test","likes":0,"published":"Private","tags":["test"]},"renderpass":[{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0,0.0,0.0,1.0);\n}","inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0,0.0,0.0,1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"Code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,1.0,0.0,1.0);\n}","inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,1.0,0.0,1.0);\n}","name":"Buf B","description":"","type":"buffer"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"float GlyphSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel0, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255. );\n}\t\n\nvoid Text( inout vec3 color, vec2 p )\n{    \n    float glyphRatio = 2.0;\n    vec2 glyphScale = 6. * vec2( 1., glyphRatio );\n    vec2 t = floor( p / glyphScale );\n\n    uint v = 0u;\n\tv = t.y == 12. ? ( t.x < 4. ? 1936287828u : ( t.x < 8. ? 544434464u : ( t.x < 12. ? 1696624225u : ( t.x < 16. ? 1886216568u : ( t.x < 20. ? 1746953580u : ( t.x < 24. ? 1948284783u : ( t.x < 28. ? 1717903471u : ( t.x < 32. ? 1768122726u : ( t.x < 36. ? 1819569765u : ( t.x < 40. ? 1701978233u : ( t.x < 44. ? 1919247470u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 11. ? ( t.x < 4. ? 1735549292u : ( t.x < 8. ? 1818370149u : ( t.x < 12. ? 1936417647u : ( t.x < 16. ? 543584032u : ( t.x < 20. ? 1954047348u : ( t.x < 24. ? 1700012078u : ( t.x < 28. ? 1763734648u : ( t.x < 32. ? 1852121203u : ( t.x < 36. ? 1701080931u : ( t.x < 40. ? 1935745124u : ( t.x < 44. ? 1931501856u : 29797u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 10. ? ( t.x < 4. ? 1965057647u : ( t.x < 8. ? 1937010281u : ( t.x < 12. ? 540092448u : ( t.x < 16. ? 1918986339u : ( t.x < 20. ? 1954112047u : ( t.x < 24. ? 539828325u : ( t.x < 28. ? 1751326772u : ( t.x < 32. ? 796095073u : ( t.x < 36. ? 1953393013u : ( t.x < 40. ? 1310731817u : ( t.x < 44. ? 544503909u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 9. ? ( t.x < 4. ? 1701995379u : ( t.x < 8. ? 1663069797u : ( t.x < 12. ? 1685221231u : ( t.x < 16. ? 1918967923u : ( t.x < 20. ? 1868767333u : ( t.x < 24. ? 1919252078u : ( t.x < 28. ? 543450484u : ( t.x < 32. ? 1948282740u : ( t.x < 36. ? 543517801u : ( t.x < 40. ? 1629512809u : ( t.x < 44. ? 2122862u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 8. ? ( t.x < 4. ? 1918986339u : ( t.x < 8. ? 544434464u : ( t.x < 12. ? 1868784996u : ( t.x < 16. ? 778331492u : 0u ) ) ) ) : v;\n\tv = t.y == 7. ? 0u : v;\n\tv = t.y == 6. ? ( t.x < 4. ? 1853321028u : ( t.x < 8. ? 1701079411u : ( t.x < 12. ? 544434464u : ( t.x < 16. ? 1952540788u : ( t.x < 20. ? 1702257952u : ( t.x < 24. ? 1730181490u : ( t.x < 28. ? 1752201580u : ( t.x < 32. ? 1937075488u : ( t.x < 36. ? 1700929652u : ( t.x < 40. ? 1701344288u : ( t.x < 44. ? 1835103008u : 101u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 5. ? ( t.x < 4. ? 1702521203u : ( t.x < 8. ? 1969365036u : ( t.x < 12. ? 1852776564u : ( t.x < 16. ? 1701344288u : ( t.x < 20. ? 1752461088u : ( t.x < 24. ? 1746956901u : ( t.x < 28. ? 543452769u : ( t.x < 32. ? 1730176375u : ( t.x < 36. ? 1713402981u : ( t.x < 40. ? 544502625u : 0u ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 4. ? ( t.x < 4. ? 1886220131u : ( t.x < 8. ? 1952541801u : ( t.x < 12. ? 544108393u : ( t.x < 16. ? 1701669236u : ( t.x < 20. ? 1851859059u : ( t.x < 24. ? 1919361124u : ( t.x < 28. ? 544498021u : ( t.x < 32. ? 1953396082u : ( t.x < 36. ? 6647145u : 0u ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 3. ? ( t.x < 4. ? 1718773104u : ( t.x < 8. ? 1634562671u : ( t.x < 12. ? 543515502u : ( t.x < 16. ? 1852404520u : ( t.x < 20. ? 543517799u : ( t.x < 24. ? 544761204u : ( t.x < 28. ? 1668572518u : ( t.x < 32. ? 1768959848u : ( t.x < 36. ? 694969720u : ( t.x < 40. ? 46u : 0u ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 2. ? 0u : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 1868787269u : ( t.x < 8. ? 544367972u : ( t.x < 12. ? 1629516649u : ( t.x < 16. ? 1818845558u : ( t.x < 20. ? 1701601889u : ( t.x < 24. ? 544108320u : ( t.x < 28. ? 1215588679u : ( t.x < 32. ? 3826293u : 0u ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 1886680168u : ( t.x < 8. ? 791624307u : ( t.x < 12. ? 1752459623u : ( t.x < 16. ? 1663984245u : ( t.x < 20. ? 1798270319u : ( t.x < 24. ? 1802658158u : ( t.x < 28. ? 1667856239u : ( t.x < 32. ? 1750282106u : ( t.x < 36. ? 1919247457u : ( t.x < 40. ? 1417244532u : ( t.x < 44. ? 7632997u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 48. ? v : 0u;\n\n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * glyphScale ) / glyphScale;\n    p.x = ( p.x - .5 ) / glyphRatio + .5;\n\n    float sdf = GlyphSDF( p, c );\n    if ( c != 0. )\n    {\n    \tcolor = mix( vec3( .2 ), color, smoothstep( -.04, +.04, sdf ) );\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2. * uv - 1.;\n\tp.x *= iResolution.x / iResolution.y;    \n    p = p * 100. - vec2( -150, -78 );\n    \n    vec3 color = vec3( mix( 1., .5, smoothstep( 0., 1., abs( .5 - uv.y ) ) ) );\n    Text( color, p );\n\tfragColor = vec4( color, 1. );\n}","inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float GlyphSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel0, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255. );\n}\t\n\nvoid Text( inout vec3 color, vec2 p )\n{    \n    float glyphRatio = 2.0;\n    vec2 glyphScale = 6. * vec2( 1., glyphRatio );\n    vec2 t = floor( p / glyphScale );\n\n    uint v = 0u;\n\tv = t.y == 12. ? ( t.x < 4. ? 1936287828u : ( t.x < 8. ? 544434464u : ( t.x < 12. ? 1696624225u : ( t.x < 16. ? 1886216568u : ( t.x < 20. ? 1746953580u : ( t.x < 24. ? 1948284783u : ( t.x < 28. ? 1717903471u : ( t.x < 32. ? 1768122726u : ( t.x < 36. ? 1819569765u : ( t.x < 40. ? 1701978233u : ( t.x < 44. ? 1919247470u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 11. ? ( t.x < 4. ? 1735549292u : ( t.x < 8. ? 1818370149u : ( t.x < 12. ? 1936417647u : ( t.x < 16. ? 543584032u : ( t.x < 20. ? 1954047348u : ( t.x < 24. ? 1700012078u : ( t.x < 28. ? 1763734648u : ( t.x < 32. ? 1852121203u : ( t.x < 36. ? 1701080931u : ( t.x < 40. ? 1935745124u : ( t.x < 44. ? 1931501856u : 29797u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 10. ? ( t.x < 4. ? 1965057647u : ( t.x < 8. ? 1937010281u : ( t.x < 12. ? 540092448u : ( t.x < 16. ? 1918986339u : ( t.x < 20. ? 1954112047u : ( t.x < 24. ? 539828325u : ( t.x < 28. ? 1751326772u : ( t.x < 32. ? 796095073u : ( t.x < 36. ? 1953393013u : ( t.x < 40. ? 1310731817u : ( t.x < 44. ? 544503909u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 9. ? ( t.x < 4. ? 1701995379u : ( t.x < 8. ? 1663069797u : ( t.x < 12. ? 1685221231u : ( t.x < 16. ? 1918967923u : ( t.x < 20. ? 1868767333u : ( t.x < 24. ? 1919252078u : ( t.x < 28. ? 543450484u : ( t.x < 32. ? 1948282740u : ( t.x < 36. ? 543517801u : ( t.x < 40. ? 1629512809u : ( t.x < 44. ? 2122862u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 8. ? ( t.x < 4. ? 1918986339u : ( t.x < 8. ? 544434464u : ( t.x < 12. ? 1868784996u : ( t.x < 16. ? 778331492u : 0u ) ) ) ) : v;\n\tv = t.y == 7. ? 0u : v;\n\tv = t.y == 6. ? ( t.x < 4. ? 1853321028u : ( t.x < 8. ? 1701079411u : ( t.x < 12. ? 544434464u : ( t.x < 16. ? 1952540788u : ( t.x < 20. ? 1702257952u : ( t.x < 24. ? 1730181490u : ( t.x < 28. ? 1752201580u : ( t.x < 32. ? 1937075488u : ( t.x < 36. ? 1700929652u : ( t.x < 40. ? 1701344288u : ( t.x < 44. ? 1835103008u : 101u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 5. ? ( t.x < 4. ? 1702521203u : ( t.x < 8. ? 1969365036u : ( t.x < 12. ? 1852776564u : ( t.x < 16. ? 1701344288u : ( t.x < 20. ? 1752461088u : ( t.x < 24. ? 1746956901u : ( t.x < 28. ? 543452769u : ( t.x < 32. ? 1730176375u : ( t.x < 36. ? 1713402981u : ( t.x < 40. ? 544502625u : 0u ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 4. ? ( t.x < 4. ? 1886220131u : ( t.x < 8. ? 1952541801u : ( t.x < 12. ? 544108393u : ( t.x < 16. ? 1701669236u : ( t.x < 20. ? 1851859059u : ( t.x < 24. ? 1919361124u : ( t.x < 28. ? 544498021u : ( t.x < 32. ? 1953396082u : ( t.x < 36. ? 6647145u : 0u ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 3. ? ( t.x < 4. ? 1718773104u : ( t.x < 8. ? 1634562671u : ( t.x < 12. ? 543515502u : ( t.x < 16. ? 1852404520u : ( t.x < 20. ? 543517799u : ( t.x < 24. ? 544761204u : ( t.x < 28. ? 1668572518u : ( t.x < 32. ? 1768959848u : ( t.x < 36. ? 694969720u : ( t.x < 40. ? 46u : 0u ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 2. ? 0u : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 1868787269u : ( t.x < 8. ? 544367972u : ( t.x < 12. ? 1629516649u : ( t.x < 16. ? 1818845558u : ( t.x < 20. ? 1701601889u : ( t.x < 24. ? 544108320u : ( t.x < 28. ? 1215588679u : ( t.x < 32. ? 3826293u : 0u ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 1886680168u : ( t.x < 8. ? 791624307u : ( t.x < 12. ? 1752459623u : ( t.x < 16. ? 1663984245u : ( t.x < 20. ? 1798270319u : ( t.x < 24. ? 1802658158u : ( t.x < 28. ? 1667856239u : ( t.x < 32. ? 1750282106u : ( t.x < 36. ? 1919247457u : ( t.x < 40. ? 1417244532u : ( t.x < 44. ? 7632997u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 48. ? v : 0u;\n\n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * glyphScale ) / glyphScale;\n    p.x = ( p.x - .5 ) / glyphRatio + .5;\n\n    float sdf = GlyphSDF( p, c );\n    if ( c != 0. )\n    {\n    \tcolor = mix( vec3( .2 ), color, smoothstep( -.04, +.04, sdf ) );\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2. * uv - 1.;\n\tp.x *= iResolution.x / iResolution.y;    \n    p = p * 100. - vec2( -150, -78 );\n    \n    vec3 color = vec3( mix( 1., .5, smoothstep( 0., 1., abs( .5 - uv.y ) ) ) );\n    Text( color, p );\n\tfragColor = vec4( color, 1. );\n}","name":"Image","description":"","type":"image"},"Inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"Info":{"Name":"Text Render","id":"3tsGRX","date":"0","viewed":0,"name":"Text Render","description":"Text Render","likes":0,"published":"Private","tags":["textrender"]},"ver":"0.1","info":{"Name":"Text Render","id":"3tsGRX","date":"0","viewed":0,"name":"Text Render","description":"Text Render","likes":0,"published":"Private","tags":["textrender"]},"renderpass":[{"Code":"float GlyphSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel0, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255. );\n}\t\n\nvoid Text( inout vec3 color, vec2 p )\n{    \n    float glyphRatio = 2.0;\n    vec2 glyphScale = 6. * vec2( 1., glyphRatio );\n    vec2 t = floor( p / glyphScale );\n\n    uint v = 0u;\n\tv = t.y == 12. ? ( t.x < 4. ? 1936287828u : ( t.x < 8. ? 544434464u : ( t.x < 12. ? 1696624225u : ( t.x < 16. ? 1886216568u : ( t.x < 20. ? 1746953580u : ( t.x < 24. ? 1948284783u : ( t.x < 28. ? 1717903471u : ( t.x < 32. ? 1768122726u : ( t.x < 36. ? 1819569765u : ( t.x < 40. ? 1701978233u : ( t.x < 44. ? 1919247470u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 11. ? ( t.x < 4. ? 1735549292u : ( t.x < 8. ? 1818370149u : ( t.x < 12. ? 1936417647u : ( t.x < 16. ? 543584032u : ( t.x < 20. ? 1954047348u : ( t.x < 24. ? 1700012078u : ( t.x < 28. ? 1763734648u : ( t.x < 32. ? 1852121203u : ( t.x < 36. ? 1701080931u : ( t.x < 40. ? 1935745124u : ( t.x < 44. ? 1931501856u : 29797u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 10. ? ( t.x < 4. ? 1965057647u : ( t.x < 8. ? 1937010281u : ( t.x < 12. ? 540092448u : ( t.x < 16. ? 1918986339u : ( t.x < 20. ? 1954112047u : ( t.x < 24. ? 539828325u : ( t.x < 28. ? 1751326772u : ( t.x < 32. ? 796095073u : ( t.x < 36. ? 1953393013u : ( t.x < 40. ? 1310731817u : ( t.x < 44. ? 544503909u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 9. ? ( t.x < 4. ? 1701995379u : ( t.x < 8. ? 1663069797u : ( t.x < 12. ? 1685221231u : ( t.x < 16. ? 1918967923u : ( t.x < 20. ? 1868767333u : ( t.x < 24. ? 1919252078u : ( t.x < 28. ? 543450484u : ( t.x < 32. ? 1948282740u : ( t.x < 36. ? 543517801u : ( t.x < 40. ? 1629512809u : ( t.x < 44. ? 2122862u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 8. ? ( t.x < 4. ? 1918986339u : ( t.x < 8. ? 544434464u : ( t.x < 12. ? 1868784996u : ( t.x < 16. ? 778331492u : 0u ) ) ) ) : v;\n\tv = t.y == 7. ? 0u : v;\n\tv = t.y == 6. ? ( t.x < 4. ? 1853321028u : ( t.x < 8. ? 1701079411u : ( t.x < 12. ? 544434464u : ( t.x < 16. ? 1952540788u : ( t.x < 20. ? 1702257952u : ( t.x < 24. ? 1730181490u : ( t.x < 28. ? 1752201580u : ( t.x < 32. ? 1937075488u : ( t.x < 36. ? 1700929652u : ( t.x < 40. ? 1701344288u : ( t.x < 44. ? 1835103008u : 101u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 5. ? ( t.x < 4. ? 1702521203u : ( t.x < 8. ? 1969365036u : ( t.x < 12. ? 1852776564u : ( t.x < 16. ? 1701344288u : ( t.x < 20. ? 1752461088u : ( t.x < 24. ? 1746956901u : ( t.x < 28. ? 543452769u : ( t.x < 32. ? 1730176375u : ( t.x < 36. ? 1713402981u : ( t.x < 40. ? 544502625u : 0u ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 4. ? ( t.x < 4. ? 1886220131u : ( t.x < 8. ? 1952541801u : ( t.x < 12. ? 544108393u : ( t.x < 16. ? 1701669236u : ( t.x < 20. ? 1851859059u : ( t.x < 24. ? 1919361124u : ( t.x < 28. ? 544498021u : ( t.x < 32. ? 1953396082u : ( t.x < 36. ? 6647145u : 0u ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 3. ? ( t.x < 4. ? 1718773104u : ( t.x < 8. ? 1634562671u : ( t.x < 12. ? 543515502u : ( t.x < 16. ? 1852404520u : ( t.x < 20. ? 543517799u : ( t.x < 24. ? 544761204u : ( t.x < 28. ? 1668572518u : ( t.x < 32. ? 1768959848u : ( t.x < 36. ? 694969720u : ( t.x < 40. ? 46u : 0u ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 2. ? 0u : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 1868787269u : ( t.x < 8. ? 544367972u : ( t.x < 12. ? 1629516649u : ( t.x < 16. ? 1818845558u : ( t.x < 20. ? 1701601889u : ( t.x < 24. ? 544108320u : ( t.x < 28. ? 1215588679u : ( t.x < 32. ? 3826293u : 0u ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 1886680168u : ( t.x < 8. ? 791624307u : ( t.x < 12. ? 1752459623u : ( t.x < 16. ? 1663984245u : ( t.x < 20. ? 1798270319u : ( t.x < 24. ? 1802658158u : ( t.x < 28. ? 1667856239u : ( t.x < 32. ? 1750282106u : ( t.x < 36. ? 1919247457u : ( t.x < 40. ? 1417244532u : ( t.x < 44. ? 7632997u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 48. ? v : 0u;\n\n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * glyphScale ) / glyphScale;\n    p.x = ( p.x - .5 ) / glyphRatio + .5;\n\n    float sdf = GlyphSDF( p, c );\n    if ( c != 0. )\n    {\n    \tcolor = mix( vec3( .2 ), color, smoothstep( -.04, +.04, sdf ) );\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2. * uv - 1.;\n\tp.x *= iResolution.x / iResolution.y;    \n    p = p * 100. - vec2( -150, -78 );\n    \n    vec3 color = vec3( mix( 1., .5, smoothstep( 0., 1., abs( .5 - uv.y ) ) ) );\n    Text( color, p );\n\tfragColor = vec4( color, 1. );\n}","inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float GlyphSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel0, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255. );\n}\t\n\nvoid Text( inout vec3 color, vec2 p )\n{    \n    float glyphRatio = 2.0;\n    vec2 glyphScale = 6. * vec2( 1., glyphRatio );\n    vec2 t = floor( p / glyphScale );\n\n    uint v = 0u;\n\tv = t.y == 12. ? ( t.x < 4. ? 1936287828u : ( t.x < 8. ? 544434464u : ( t.x < 12. ? 1696624225u : ( t.x < 16. ? 1886216568u : ( t.x < 20. ? 1746953580u : ( t.x < 24. ? 1948284783u : ( t.x < 28. ? 1717903471u : ( t.x < 32. ? 1768122726u : ( t.x < 36. ? 1819569765u : ( t.x < 40. ? 1701978233u : ( t.x < 44. ? 1919247470u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 11. ? ( t.x < 4. ? 1735549292u : ( t.x < 8. ? 1818370149u : ( t.x < 12. ? 1936417647u : ( t.x < 16. ? 543584032u : ( t.x < 20. ? 1954047348u : ( t.x < 24. ? 1700012078u : ( t.x < 28. ? 1763734648u : ( t.x < 32. ? 1852121203u : ( t.x < 36. ? 1701080931u : ( t.x < 40. ? 1935745124u : ( t.x < 44. ? 1931501856u : 29797u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 10. ? ( t.x < 4. ? 1965057647u : ( t.x < 8. ? 1937010281u : ( t.x < 12. ? 540092448u : ( t.x < 16. ? 1918986339u : ( t.x < 20. ? 1954112047u : ( t.x < 24. ? 539828325u : ( t.x < 28. ? 1751326772u : ( t.x < 32. ? 796095073u : ( t.x < 36. ? 1953393013u : ( t.x < 40. ? 1310731817u : ( t.x < 44. ? 544503909u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 9. ? ( t.x < 4. ? 1701995379u : ( t.x < 8. ? 1663069797u : ( t.x < 12. ? 1685221231u : ( t.x < 16. ? 1918967923u : ( t.x < 20. ? 1868767333u : ( t.x < 24. ? 1919252078u : ( t.x < 28. ? 543450484u : ( t.x < 32. ? 1948282740u : ( t.x < 36. ? 543517801u : ( t.x < 40. ? 1629512809u : ( t.x < 44. ? 2122862u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 8. ? ( t.x < 4. ? 1918986339u : ( t.x < 8. ? 544434464u : ( t.x < 12. ? 1868784996u : ( t.x < 16. ? 778331492u : 0u ) ) ) ) : v;\n\tv = t.y == 7. ? 0u : v;\n\tv = t.y == 6. ? ( t.x < 4. ? 1853321028u : ( t.x < 8. ? 1701079411u : ( t.x < 12. ? 544434464u : ( t.x < 16. ? 1952540788u : ( t.x < 20. ? 1702257952u : ( t.x < 24. ? 1730181490u : ( t.x < 28. ? 1752201580u : ( t.x < 32. ? 1937075488u : ( t.x < 36. ? 1700929652u : ( t.x < 40. ? 1701344288u : ( t.x < 44. ? 1835103008u : 101u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 5. ? ( t.x < 4. ? 1702521203u : ( t.x < 8. ? 1969365036u : ( t.x < 12. ? 1852776564u : ( t.x < 16. ? 1701344288u : ( t.x < 20. ? 1752461088u : ( t.x < 24. ? 1746956901u : ( t.x < 28. ? 543452769u : ( t.x < 32. ? 1730176375u : ( t.x < 36. ? 1713402981u : ( t.x < 40. ? 544502625u : 0u ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 4. ? ( t.x < 4. ? 1886220131u : ( t.x < 8. ? 1952541801u : ( t.x < 12. ? 544108393u : ( t.x < 16. ? 1701669236u : ( t.x < 20. ? 1851859059u : ( t.x < 24. ? 1919361124u : ( t.x < 28. ? 544498021u : ( t.x < 32. ? 1953396082u : ( t.x < 36. ? 6647145u : 0u ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 3. ? ( t.x < 4. ? 1718773104u : ( t.x < 8. ? 1634562671u : ( t.x < 12. ? 543515502u : ( t.x < 16. ? 1852404520u : ( t.x < 20. ? 543517799u : ( t.x < 24. ? 544761204u : ( t.x < 28. ? 1668572518u : ( t.x < 32. ? 1768959848u : ( t.x < 36. ? 694969720u : ( t.x < 40. ? 46u : 0u ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 2. ? 0u : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 1868787269u : ( t.x < 8. ? 544367972u : ( t.x < 12. ? 1629516649u : ( t.x < 16. ? 1818845558u : ( t.x < 20. ? 1701601889u : ( t.x < 24. ? 544108320u : ( t.x < 28. ? 1215588679u : ( t.x < 32. ? 3826293u : 0u ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 1886680168u : ( t.x < 8. ? 791624307u : ( t.x < 12. ? 1752459623u : ( t.x < 16. ? 1663984245u : ( t.x < 20. ? 1798270319u : ( t.x < 24. ? 1802658158u : ( t.x < 28. ? 1667856239u : ( t.x < 32. ? 1750282106u : ( t.x < 36. ? 1919247457u : ( t.x < 40. ? 1417244532u : ( t.x < 44. ? 7632997u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 48. ? v : 0u;\n\n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * glyphScale ) / glyphScale;\n    p.x = ( p.x - .5 ) / glyphRatio + .5;\n\n    float sdf = GlyphSDF( p, c );\n    if ( c != 0. )\n    {\n    \tcolor = mix( vec3( .2 ), color, smoothstep( -.04, +.04, sdf ) );\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2. * uv - 1.;\n\tp.x *= iResolution.x / iResolution.y;    \n    p = p * 100. - vec2( -150, -78 );\n    \n    vec3 color = vec3( mix( 1., .5, smoothstep( 0., 1., abs( .5 - uv.y ) ) ) );\n    Text( color, p );\n\tfragColor = vec4( color, 1. );\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"Info":{"Name":"Worley Cellular Noise 2D","id":"tt3GRj","date":"1577105511","viewed":35,"name":"Worley Cellular Noise 2D","description":"Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["2d","noise","worley","cellular"]},"ver":"0.1","info":{"Name":"Worley Cellular Noise 2D","id":"tt3GRj","date":"1577105511","viewed":35,"name":"Worley Cellular Noise 2D","description":"Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["2d","noise","worley","cellular"]},"renderpass":[{"Code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[{"id":"XdX3Rn","filepath":"\\media\\texture\\52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[{"id":"XdX3Rn","filepath":"\\media\\texture\\52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"Info":{"Name":"Worley Cellular Noise 3D","id":"3ldGRl","date":"1577259203","viewed":50,"name":"Worley Cellular Noise 3D","description":"3d Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["3d","noise","worley","cellular"]},"ver":"0.1","info":{"Name":"Worley Cellular Noise 3D","id":"3ldGRl","date":"1577259203","viewed":50,"name":"Worley Cellular Noise 3D","description":"3d Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["3d","noise","worley","cellular"]},"renderpass":[{"Code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[{"id":"XdX3Rn","filepath":"\\media\\texture\\52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"fbm test1","id":"wsyXDV","date":"0","viewed":0,"name":"fbm test1","description":"math fbm noise","likes":0,"published":"Private","tags":["mathfbmnoise"]},"ver":"0.1","info":{"Name":"fbm test1","id":"wsyXDV","date":"0","viewed":0,"name":"fbm test1","description":"math fbm noise","likes":0,"published":"Private","tags":["mathfbmnoise"]},"renderpass":[{"Code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"\n\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453123);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture( sa, p.yz ).xyz;\n\tvec3 y = texture( sa, p.zx ).xyz;\n\tvec3 z = texture( sa, p.xy ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//----------------------------------------------------------------\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// trick by klems\n#define ZERO (min(iFrame,0))\n\n//----------------------------------------------------------------\n\nvec2 map( vec3 p )\n{\n\tp.y -= 1.8;\n    \n\t//p.x = abs(p.x);\n\n    //body\n\tvec3 q = p;\n    \n\t//q.y -= 0.3*pow(1.0-length(p.xz),1.0)*smoothstep(0.0, 0.2, p.y);\n\t//q.y *= 1.05;\n\t//q.z *= 1.0 + 0.1*smoothstep( 0.0, 0.5, q.z )*smoothstep( -0.5, 0.5, p.y );\n    //float dd = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.75,1.0) );\n\t/*\n    float am = clamp( 4.0*abs(p.y-0.45), 0.0, 1.0 );\n\tfloat fo = -0.03*(1.0-smoothstep( 0.0, 0.04*am, abs(dd-0.42) ))*am;\n    float dd2 = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.25,1.0) );\n\tfloat am2 = clamp( 1.5*(p.y-0.45), 0.0, 1.0 );\n\tfloat fo2 = -0.085*(1.0-smoothstep( 0.0, 0.08*am2, abs(dd2-0.42) ))*am2;\n    q.y += -0.05+0.05*length(q.x);\n\t*/\n\t//float d1 = length( q ) - 0.9;//+ fo + fo2;\n    q.y *= 1.3;\n    float d1 = sdRoundCone( q, 0.8, 0.6, 0.3);\n    vec2 res = vec2( d1, 1.0 );\n    \n    vec2 h;float d2;\n    /*\n\t// arms\n\tvec2 h = sdSegment( vec3(.83,0.15,0.0), vec3(1.02,-0.6,-.1), p );\n\tfloat d2 = h.x - 0.07;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(1.02,-0.6,-.1), vec3(0.95,-1.2,0.1), p );\n\td2 = h.x - 0.07 + h.y*0.02;\n\tres.x = smin( res.x, d2, 0.06 );\n\t*/\n    /*\n\t// hands\n\tif( p.y<-1.0 )\n\t{\n    float fa = sin(3.0*iTime);\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.97,-1.5,0.0), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.01 );\n\th = sdSegment( vec3(0.97,-1.5,0.0), vec3(0.95,-1.7,0.0)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(1.05,-1.5,0.1), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(1.05,-1.5,0.1), vec3(1.0,-1.75,0.1)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.98,-1.5,0.2), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(0.98,-1.5,0.2), vec3(0.95,-1.7,0.15)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.85,-1.4,0.2), p );\n\td2 = h.x - 0.04 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.05 );\n\th = sdSegment( vec3(0.85,-1.4,0.2), vec3(0.85,-1.63,0.15)+0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\t}\n\t*/\n    //x\u8F74\u5BF9\u79F0\u7ED8\u5236\n    vec3 tp = p;\n    tp.x = abs(p.x);\n\t// legs\n\th = sdSegment( vec3(0.2,-0.5,0.0), vec3(0.2,-1.0,0.0), tp );\n\td2 = h.x - 0.05 - h.y*0.02;\n    if( d2<res.x ) res = vec2( d2, 2.0);\n    // feet\n\th = sdSegment( vec3(0.2,-1.0,0.0), vec3(0.4,-1.0,0.0), tp);\n\td2 = h.x - 0.05 - 0.03*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n\t//arm\n\th = sdSegment( vec3(0.7,0.2,0.0), vec3(0.8,0.3,0.0), tp);\n\td2 = h.x - 0.10 + 0.03*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n    h = sdSegment( vec3(0.8,0.3,0.0), vec3(1.4,0.5,0.0), tp);\n\td2 = h.x - 0.10 + 0.04*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n    \n\t// horns\n    h = sdSegment( vec3(0.20,0.7,0.0), vec3(0.18,1.0,0.0), tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    h = sdSegment( vec3(0.18,1.0,0.0), vec3(0.14,1.4,0.0), tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    h = sdSegment( vec3(0.18,1.0,0.0), vec3(0.35,1.2,0.0),tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    \n    /*\n\tvec3 hp = tp - vec3(0.25,0.7,0.0);\n    hp.xy = mat2(0.6,0.8,-0.8,0.6)*hp.xy;\n    hp.x += 0.8*hp.y*hp.y;\n    float d4 = sdEllipsoid( hp, vec3(0.13,0.5,0.16) );\n\t//d4 *= 0.9;\n\tif( d4<res.x ) res = vec2( d4, 3.0 );\n    */\n    \n    \n\t// eyes\n\tfloat d3 = length( (tp - vec3(0.2,0.25,0.7))*vec3(1.0,1.0,1.0) ) - 0.1;\n\tif( d3<res.x ) res = vec2( d3, 2.0);\n\n    \n    \n\t// mouth\n    \n\tfloat mo = length( (q-vec3(0.0,-0.2,1.0))*vec3(0.6,1.6,0.25)/1.2 ) -0.3/1.2;\n\tfloat of = 0.1*pow(smoothstep( 0.0, 0.2, abs(p.x-0.3) ),0.5);\n\tmo = max( mo, -q.y-0.35-of );\n\n\tfloat li = smoothstep( 0.0, 0.05, mo+0.02 ) - smoothstep( 0.05, 0.10, mo+0.02 );\n\tres.x -= 0.03*li*clamp( (-q.y-0.4)*10.0, 0.0, 1.0 );\n\t\n\tif( -mo > res.x )\n\t\tres = vec2( -mo, 4.0 );\n    \n    res.x += 0.01*(smoothstep( 0.0, 0.05, mo+0.062 ) - smoothstep( 0.05, 0.10, mo+0.062 ));\n    \n\treturn vec2(res.x*0.8,res.y);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec3 eps = vec3(0.002,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.002*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float m = -1.0;\n\tfloat mint = 10.0;\n\n    // plane\t\n\tfloat tf = (0.0-ro.y)/rd.y;\n\tif( tf>0.0 ) { mint = tf; m = 0.0; }\n\t\n\t// mike\n\tfloat maxd = min(5.0,mint);\n\tfloat precis = 0.001;\n    float t = 0.0;\n\tfloat d = 0.0;\n    for( int i=ZERO; i<128; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        float h = res.x;\n\t\td = res.y;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t<maxd && t<mint )\n\t{\n\t\tmint = t;\n\t\tm = d;\n\t}\n\n    return vec3( mint, m, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n\t\tt += clamp( h, 0.01, 0.25 );\n\t\tif( res<0.005 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nvec3 lig = normalize(vec3(1.0,0.7,0.9));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\t//if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    \n\t#ifdef STEREO\n\tfloat eyeID = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n    #endif\n\n\n\t\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = sin(-0.25 + 0.31416*iTime) - 6.2831*(m.x-0.5);\n\n\tvec3 ro = vec3(4.5*sin(an),1.5,4.5*cos(an));\n    vec3 ta = vec3(0.0,1.5,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = vec3(1.0);\n\n\t// raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        // materials\n\t\tvec4 mate = vec4(0.0);\n\t\tvec2 mate2 = vec2(1.0,1.0);\n\t\tif( tmat.z<0.5 )\n\t\t{\n\t\t\tnor = vec3(0.0,1.0,0.0);\n\t\t    ref = reflect( rd, nor );\n\t\t\tmate.xyz = vec3(1.0);\n            mate2.y = 1.0 - 0.9*(2.0/(2.0+dot(pos.xz,pos.xz)));\n\t\t}\n\t\telse if( tmat.z<1.5 )//mat id == 1\n\t\t{\n            mate2.x = 4.0;\n\t\t\tmate = vec4(0.5,0.0,0.5,0.8);//\u7D2B\u8272\u57FA\u8C03\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.8*mate.xyz, vec3(0.3,0.0,0.4), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.3,0.0,0.4), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t\t\n\t\t\tmate.xyz *= 0.7;\n\n\t\t}\n\t\telse if( tmat.z<2.5 )//mat id == 2 \n\t\t{\n\t\t\tmate2.x = 4.0;\n\t\t\tmate = vec4(0.1,0.1,0.1,0.0);\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.8*mate.xyz, vec3(0.01,0.01,0.01), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.01,0.01,0.01), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t\t\n\t\t\tmate.xyz *= 0.7;\n\t\t}\n\t\telse if( tmat.z<3.5 )\n\t\t{\n\t\t\tmate = 0.8*vec4(0.85,0.7,0.6,0.0);\n            mate2.x = 0.0;\n\n\t\t\tfloat f = smoothstep( 0.0, 0.1, 0.5*abs(pos.x)+pos.y-3.02 );\n\t\t\tmate.xyz *= 1.0 - 0.8*vec3( f );\n\t\t\t\n\t\t\tmate.xyz *= 0.2 + 0.8*smoothstep( 0.0, 1.0, texturize( iChannel0, 0.1*2.1*pos*vec3(4.0,0.1,4.0), nor ).x );\n\t\t}\n\t\telse if( tmat.z<4.5 )//id == 4\u5185\u90E8\u6750\u8D28\n\t\t{\n\t\t\tfloat z = smoothstep( 0.0, 2.0, pos.z+0.5 );\n\t\t\tmate = 0.5*vec4(1.0,1.0,1.0,1.0);\n\t\t\tmate.x += 0.1*(1.0-z);\n\t\t\tmate2.y = z;\n\t\t}\n\n\n\t\t// lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mate2.y;\n        float amb = 0.5;\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 0.001, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        vec3  hal = normalize(lig-rd);\n        float spe = max(pow( clamp( dot(nor,hal), 0.0, 1.0), mate2.x*4.0 ),0.0 );\n\t\t\n\t\t// lights\n\t\tvec3 lin = vec3(0.0);\n        lin += 2.0*dif*vec3(1.00,1.00,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*amb*vec3(0.30,0.30,0.30)*occ;\n\t\tlin += 2.0*bou*vec3(0.40,0.40,0.40)*mate2.y;\n\t\tlin += 4.0*bac*vec3(0.40,0.30,0.25)*occ;\n        lin += 1.0*fre*vec3(1.00,1.00,1.00)*2.0*mate.w*(0.5+0.5*dif*sha)*occ;\n\n\t\tcol = mate.xyz*lin;\n\t\tcol += 4.0*spe*vec3(2.0)*mate.w*dif*sha*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n\t}\n\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\t// vigneting\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n   \n    fragColor = vec4( col, 1.0 );\n}\n","inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453123);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture( sa, p.yz ).xyz;\n\tvec3 y = texture( sa, p.zx ).xyz;\n\tvec3 z = texture( sa, p.xy ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//----------------------------------------------------------------\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// trick by klems\n#define ZERO (min(iFrame,0))\n\n//----------------------------------------------------------------\n\nvec2 map( vec3 p )\n{\n\tp.y -= 1.8;\n    \n\t//p.x = abs(p.x);\n\n    //body\n\tvec3 q = p;\n    \n\t//q.y -= 0.3*pow(1.0-length(p.xz),1.0)*smoothstep(0.0, 0.2, p.y);\n\t//q.y *= 1.05;\n\t//q.z *= 1.0 + 0.1*smoothstep( 0.0, 0.5, q.z )*smoothstep( -0.5, 0.5, p.y );\n    //float dd = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.75,1.0) );\n\t/*\n    float am = clamp( 4.0*abs(p.y-0.45), 0.0, 1.0 );\n\tfloat fo = -0.03*(1.0-smoothstep( 0.0, 0.04*am, abs(dd-0.42) ))*am;\n    float dd2 = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.25,1.0) );\n\tfloat am2 = clamp( 1.5*(p.y-0.45), 0.0, 1.0 );\n\tfloat fo2 = -0.085*(1.0-smoothstep( 0.0, 0.08*am2, abs(dd2-0.42) ))*am2;\n    q.y += -0.05+0.05*length(q.x);\n\t*/\n\t//float d1 = length( q ) - 0.9;//+ fo + fo2;\n    q.y *= 1.3;\n    float d1 = sdRoundCone( q, 0.8, 0.6, 0.3);\n    vec2 res = vec2( d1, 1.0 );\n    \n    vec2 h;float d2;\n    /*\n\t// arms\n\tvec2 h = sdSegment( vec3(.83,0.15,0.0), vec3(1.02,-0.6,-.1), p );\n\tfloat d2 = h.x - 0.07;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(1.02,-0.6,-.1), vec3(0.95,-1.2,0.1), p );\n\td2 = h.x - 0.07 + h.y*0.02;\n\tres.x = smin( res.x, d2, 0.06 );\n\t*/\n    /*\n\t// hands\n\tif( p.y<-1.0 )\n\t{\n    float fa = sin(3.0*iTime);\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.97,-1.5,0.0), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.01 );\n\th = sdSegment( vec3(0.97,-1.5,0.0), vec3(0.95,-1.7,0.0)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(1.05,-1.5,0.1), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(1.05,-1.5,0.1), vec3(1.0,-1.75,0.1)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.98,-1.5,0.2), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(0.98,-1.5,0.2), vec3(0.95,-1.7,0.15)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.85,-1.4,0.2), p );\n\td2 = h.x - 0.04 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.05 );\n\th = sdSegment( vec3(0.85,-1.4,0.2), vec3(0.85,-1.63,0.15)+0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\t}\n\t*/\n    //x\u8F74\u5BF9\u79F0\u7ED8\u5236\n    vec3 tp = p;\n    tp.x = abs(p.x);\n\t// legs\n\th = sdSegment( vec3(0.2,-0.5,0.0), vec3(0.2,-1.0,0.0), tp );\n\td2 = h.x - 0.05 - h.y*0.02;\n    if( d2<res.x ) res = vec2( d2, 2.0);\n    // feet\n\th = sdSegment( vec3(0.2,-1.0,0.0), vec3(0.4,-1.0,0.0), tp);\n\td2 = h.x - 0.05 - 0.03*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n\t//arm\n\th = sdSegment( vec3(0.7,0.2,0.0), vec3(0.8,0.3,0.0), tp);\n\td2 = h.x - 0.10 + 0.03*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n    h = sdSegment( vec3(0.8,0.3,0.0), vec3(1.4,0.5,0.0), tp);\n\td2 = h.x - 0.10 + 0.04*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n    \n\t// horns\n    h = sdSegment( vec3(0.20,0.7,0.0), vec3(0.18,1.0,0.0), tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    h = sdSegment( vec3(0.18,1.0,0.0), vec3(0.14,1.4,0.0), tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    h = sdSegment( vec3(0.18,1.0,0.0), vec3(0.35,1.2,0.0),tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    \n    /*\n\tvec3 hp = tp - vec3(0.25,0.7,0.0);\n    hp.xy = mat2(0.6,0.8,-0.8,0.6)*hp.xy;\n    hp.x += 0.8*hp.y*hp.y;\n    float d4 = sdEllipsoid( hp, vec3(0.13,0.5,0.16) );\n\t//d4 *= 0.9;\n\tif( d4<res.x ) res = vec2( d4, 3.0 );\n    */\n    \n    \n\t// eyes\n\tfloat d3 = length( (tp - vec3(0.2,0.25,0.7))*vec3(1.0,1.0,1.0) ) - 0.1;\n\tif( d3<res.x ) res = vec2( d3, 2.0);\n\n    \n    \n\t// mouth\n    \n\tfloat mo = length( (q-vec3(0.0,-0.2,1.0))*vec3(0.6,1.6,0.25)/1.2 ) -0.3/1.2;\n\tfloat of = 0.1*pow(smoothstep( 0.0, 0.2, abs(p.x-0.3) ),0.5);\n\tmo = max( mo, -q.y-0.35-of );\n\n\tfloat li = smoothstep( 0.0, 0.05, mo+0.02 ) - smoothstep( 0.05, 0.10, mo+0.02 );\n\tres.x -= 0.03*li*clamp( (-q.y-0.4)*10.0, 0.0, 1.0 );\n\t\n\tif( -mo > res.x )\n\t\tres = vec2( -mo, 4.0 );\n    \n    res.x += 0.01*(smoothstep( 0.0, 0.05, mo+0.062 ) - smoothstep( 0.05, 0.10, mo+0.062 ));\n    \n\treturn vec2(res.x*0.8,res.y);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec3 eps = vec3(0.002,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.002*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float m = -1.0;\n\tfloat mint = 10.0;\n\n    // plane\t\n\tfloat tf = (0.0-ro.y)/rd.y;\n\tif( tf>0.0 ) { mint = tf; m = 0.0; }\n\t\n\t// mike\n\tfloat maxd = min(5.0,mint);\n\tfloat precis = 0.001;\n    float t = 0.0;\n\tfloat d = 0.0;\n    for( int i=ZERO; i<128; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        float h = res.x;\n\t\td = res.y;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t<maxd && t<mint )\n\t{\n\t\tmint = t;\n\t\tm = d;\n\t}\n\n    return vec3( mint, m, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n\t\tt += clamp( h, 0.01, 0.25 );\n\t\tif( res<0.005 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nvec3 lig = normalize(vec3(1.0,0.7,0.9));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\t//if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    \n\t#ifdef STEREO\n\tfloat eyeID = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n    #endif\n\n\n\t\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = sin(-0.25 + 0.31416*iTime) - 6.2831*(m.x-0.5);\n\n\tvec3 ro = vec3(4.5*sin(an),1.5,4.5*cos(an));\n    vec3 ta = vec3(0.0,1.5,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = vec3(1.0);\n\n\t// raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        // materials\n\t\tvec4 mate = vec4(0.0);\n\t\tvec2 mate2 = vec2(1.0,1.0);\n\t\tif( tmat.z<0.5 )\n\t\t{\n\t\t\tnor = vec3(0.0,1.0,0.0);\n\t\t    ref = reflect( rd, nor );\n\t\t\tmate.xyz = vec3(1.0);\n            mate2.y = 1.0 - 0.9*(2.0/(2.0+dot(pos.xz,pos.xz)));\n\t\t}\n\t\telse if( tmat.z<1.5 )//mat id == 1\n\t\t{\n            mate2.x = 4.0;\n\t\t\tmate = vec4(0.5,0.0,0.5,0.8);//\u7D2B\u8272\u57FA\u8C03\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.8*mate.xyz, vec3(0.3,0.0,0.4), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.3,0.0,0.4), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t\t\n\t\t\tmate.xyz *= 0.7;\n\n\t\t}\n\t\telse if( tmat.z<2.5 )//mat id == 2 \n\t\t{\n\t\t\tmate2.x = 4.0;\n\t\t\tmate = vec4(0.1,0.1,0.1,0.0);\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.8*mate.xyz, vec3(0.01,0.01,0.01), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.01,0.01,0.01), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t\t\n\t\t\tmate.xyz *= 0.7;\n\t\t}\n\t\telse if( tmat.z<3.5 )\n\t\t{\n\t\t\tmate = 0.8*vec4(0.85,0.7,0.6,0.0);\n            mate2.x = 0.0;\n\n\t\t\tfloat f = smoothstep( 0.0, 0.1, 0.5*abs(pos.x)+pos.y-3.02 );\n\t\t\tmate.xyz *= 1.0 - 0.8*vec3( f );\n\t\t\t\n\t\t\tmate.xyz *= 0.2 + 0.8*smoothstep( 0.0, 1.0, texturize( iChannel0, 0.1*2.1*pos*vec3(4.0,0.1,4.0), nor ).x );\n\t\t}\n\t\telse if( tmat.z<4.5 )//id == 4\u5185\u90E8\u6750\u8D28\n\t\t{\n\t\t\tfloat z = smoothstep( 0.0, 2.0, pos.z+0.5 );\n\t\t\tmate = 0.5*vec4(1.0,1.0,1.0,1.0);\n\t\t\tmate.x += 0.1*(1.0-z);\n\t\t\tmate2.y = z;\n\t\t}\n\n\n\t\t// lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mate2.y;\n        float amb = 0.5;\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 0.001, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        vec3  hal = normalize(lig-rd);\n        float spe = max(pow( clamp( dot(nor,hal), 0.0, 1.0), mate2.x*4.0 ),0.0 );\n\t\t\n\t\t// lights\n\t\tvec3 lin = vec3(0.0);\n        lin += 2.0*dif*vec3(1.00,1.00,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*amb*vec3(0.30,0.30,0.30)*occ;\n\t\tlin += 2.0*bou*vec3(0.40,0.40,0.40)*mate2.y;\n\t\tlin += 4.0*bac*vec3(0.40,0.30,0.25)*occ;\n        lin += 1.0*fre*vec3(1.00,1.00,1.00)*2.0*mate.w*(0.5+0.5*dif*sha)*occ;\n\n\t\tcol = mate.xyz*lin;\n\t\tcol += 4.0*spe*vec3(2.0)*mate.w*dif*sha*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n\t}\n\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\t// vigneting\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n   \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},"Inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"Info":{"Name":"zilong","id":"WstSW8","date":"1571901597","viewed":27,"name":"zilong","description":"zilong","likes":0,"published":"Private","tags":["zilong"]},"ver":"0.1","info":{"Name":"zilong","id":"WstSW8","date":"1571901597","viewed":27,"name":"zilong","description":"zilong","likes":0,"published":"Private","tags":["zilong"]},"renderpass":[{"Code":"\n\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453123);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture( sa, p.yz ).xyz;\n\tvec3 y = texture( sa, p.zx ).xyz;\n\tvec3 z = texture( sa, p.xy ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//----------------------------------------------------------------\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// trick by klems\n#define ZERO (min(iFrame,0))\n\n//----------------------------------------------------------------\n\nvec2 map( vec3 p )\n{\n\tp.y -= 1.8;\n    \n\t//p.x = abs(p.x);\n\n    //body\n\tvec3 q = p;\n    \n\t//q.y -= 0.3*pow(1.0-length(p.xz),1.0)*smoothstep(0.0, 0.2, p.y);\n\t//q.y *= 1.05;\n\t//q.z *= 1.0 + 0.1*smoothstep( 0.0, 0.5, q.z )*smoothstep( -0.5, 0.5, p.y );\n    //float dd = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.75,1.0) );\n\t/*\n    float am = clamp( 4.0*abs(p.y-0.45), 0.0, 1.0 );\n\tfloat fo = -0.03*(1.0-smoothstep( 0.0, 0.04*am, abs(dd-0.42) ))*am;\n    float dd2 = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.25,1.0) );\n\tfloat am2 = clamp( 1.5*(p.y-0.45), 0.0, 1.0 );\n\tfloat fo2 = -0.085*(1.0-smoothstep( 0.0, 0.08*am2, abs(dd2-0.42) ))*am2;\n    q.y += -0.05+0.05*length(q.x);\n\t*/\n\t//float d1 = length( q ) - 0.9;//+ fo + fo2;\n    q.y *= 1.3;\n    float d1 = sdRoundCone( q, 0.8, 0.6, 0.3);\n    vec2 res = vec2( d1, 1.0 );\n    \n    vec2 h;float d2;\n    /*\n\t// arms\n\tvec2 h = sdSegment( vec3(.83,0.15,0.0), vec3(1.02,-0.6,-.1), p );\n\tfloat d2 = h.x - 0.07;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(1.02,-0.6,-.1), vec3(0.95,-1.2,0.1), p );\n\td2 = h.x - 0.07 + h.y*0.02;\n\tres.x = smin( res.x, d2, 0.06 );\n\t*/\n    /*\n\t// hands\n\tif( p.y<-1.0 )\n\t{\n    float fa = sin(3.0*iTime);\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.97,-1.5,0.0), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.01 );\n\th = sdSegment( vec3(0.97,-1.5,0.0), vec3(0.95,-1.7,0.0)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(1.05,-1.5,0.1), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(1.05,-1.5,0.1), vec3(1.0,-1.75,0.1)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.98,-1.5,0.2), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(0.98,-1.5,0.2), vec3(0.95,-1.7,0.15)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.85,-1.4,0.2), p );\n\td2 = h.x - 0.04 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.05 );\n\th = sdSegment( vec3(0.85,-1.4,0.2), vec3(0.85,-1.63,0.15)+0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\t}\n\t*/\n    //x\u8F74\u5BF9\u79F0\u7ED8\u5236\n    vec3 tp = p;\n    tp.x = abs(p.x);\n\t// legs\n\th = sdSegment( vec3(0.2,-0.5,0.0), vec3(0.2,-1.0,0.0), tp );\n\td2 = h.x - 0.05 - h.y*0.02;\n    if( d2<res.x ) res = vec2( d2, 2.0);\n    // feet\n\th = sdSegment( vec3(0.2,-1.0,0.0), vec3(0.4,-1.0,0.0), tp);\n\td2 = h.x - 0.05 - 0.03*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n\t//arm\n\th = sdSegment( vec3(0.7,0.2,0.0), vec3(0.8,0.3,0.0), tp);\n\td2 = h.x - 0.10 + 0.03*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n    h = sdSegment( vec3(0.8,0.3,0.0), vec3(1.4,0.5,0.0), tp);\n\td2 = h.x - 0.10 + 0.04*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n    \n\t// horns\n    h = sdSegment( vec3(0.20,0.7,0.0), vec3(0.18,1.0,0.0), tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    h = sdSegment( vec3(0.18,1.0,0.0), vec3(0.14,1.4,0.0), tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    h = sdSegment( vec3(0.18,1.0,0.0), vec3(0.35,1.2,0.0),tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    \n    /*\n\tvec3 hp = tp - vec3(0.25,0.7,0.0);\n    hp.xy = mat2(0.6,0.8,-0.8,0.6)*hp.xy;\n    hp.x += 0.8*hp.y*hp.y;\n    float d4 = sdEllipsoid( hp, vec3(0.13,0.5,0.16) );\n\t//d4 *= 0.9;\n\tif( d4<res.x ) res = vec2( d4, 3.0 );\n    */\n    \n    \n\t// eyes\n\tfloat d3 = length( (tp - vec3(0.2,0.25,0.7))*vec3(1.0,1.0,1.0) ) - 0.1;\n\tif( d3<res.x ) res = vec2( d3, 2.0);\n\n    \n    \n\t// mouth\n    \n\tfloat mo = length( (q-vec3(0.0,-0.2,1.0))*vec3(0.6,1.6,0.25)/1.2 ) -0.3/1.2;\n\tfloat of = 0.1*pow(smoothstep( 0.0, 0.2, abs(p.x-0.3) ),0.5);\n\tmo = max( mo, -q.y-0.35-of );\n\n\tfloat li = smoothstep( 0.0, 0.05, mo+0.02 ) - smoothstep( 0.05, 0.10, mo+0.02 );\n\tres.x -= 0.03*li*clamp( (-q.y-0.4)*10.0, 0.0, 1.0 );\n\t\n\tif( -mo > res.x )\n\t\tres = vec2( -mo, 4.0 );\n    \n    res.x += 0.01*(smoothstep( 0.0, 0.05, mo+0.062 ) - smoothstep( 0.05, 0.10, mo+0.062 ));\n    \n\treturn vec2(res.x*0.8,res.y);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec3 eps = vec3(0.002,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.002*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float m = -1.0;\n\tfloat mint = 10.0;\n\n    // plane\t\n\tfloat tf = (0.0-ro.y)/rd.y;\n\tif( tf>0.0 ) { mint = tf; m = 0.0; }\n\t\n\t// mike\n\tfloat maxd = min(5.0,mint);\n\tfloat precis = 0.001;\n    float t = 0.0;\n\tfloat d = 0.0;\n    for( int i=ZERO; i<128; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        float h = res.x;\n\t\td = res.y;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t<maxd && t<mint )\n\t{\n\t\tmint = t;\n\t\tm = d;\n\t}\n\n    return vec3( mint, m, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n\t\tt += clamp( h, 0.01, 0.25 );\n\t\tif( res<0.005 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nvec3 lig = normalize(vec3(1.0,0.7,0.9));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\t//if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    \n\t#ifdef STEREO\n\tfloat eyeID = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n    #endif\n\n\n\t\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = sin(-0.25 + 0.31416*iTime) - 6.2831*(m.x-0.5);\n\n\tvec3 ro = vec3(4.5*sin(an),1.5,4.5*cos(an));\n    vec3 ta = vec3(0.0,1.5,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = vec3(1.0);\n\n\t// raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        // materials\n\t\tvec4 mate = vec4(0.0);\n\t\tvec2 mate2 = vec2(1.0,1.0);\n\t\tif( tmat.z<0.5 )\n\t\t{\n\t\t\tnor = vec3(0.0,1.0,0.0);\n\t\t    ref = reflect( rd, nor );\n\t\t\tmate.xyz = vec3(1.0);\n            mate2.y = 1.0 - 0.9*(2.0/(2.0+dot(pos.xz,pos.xz)));\n\t\t}\n\t\telse if( tmat.z<1.5 )//mat id == 1\n\t\t{\n            mate2.x = 4.0;\n\t\t\tmate = vec4(0.5,0.0,0.5,0.8);//\u7D2B\u8272\u57FA\u8C03\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.8*mate.xyz, vec3(0.3,0.0,0.4), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.3,0.0,0.4), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t\t\n\t\t\tmate.xyz *= 0.7;\n\n\t\t}\n\t\telse if( tmat.z<2.5 )//mat id == 2 \n\t\t{\n\t\t\tmate2.x = 4.0;\n\t\t\tmate = vec4(0.1,0.1,0.1,0.0);\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.8*mate.xyz, vec3(0.01,0.01,0.01), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.01,0.01,0.01), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t\t\n\t\t\tmate.xyz *= 0.7;\n\t\t}\n\t\telse if( tmat.z<3.5 )\n\t\t{\n\t\t\tmate = 0.8*vec4(0.85,0.7,0.6,0.0);\n            mate2.x = 0.0;\n\n\t\t\tfloat f = smoothstep( 0.0, 0.1, 0.5*abs(pos.x)+pos.y-3.02 );\n\t\t\tmate.xyz *= 1.0 - 0.8*vec3( f );\n\t\t\t\n\t\t\tmate.xyz *= 0.2 + 0.8*smoothstep( 0.0, 1.0, texturize( iChannel0, 0.1*2.1*pos*vec3(4.0,0.1,4.0), nor ).x );\n\t\t}\n\t\telse if( tmat.z<4.5 )//id == 4\u5185\u90E8\u6750\u8D28\n\t\t{\n\t\t\tfloat z = smoothstep( 0.0, 2.0, pos.z+0.5 );\n\t\t\tmate = 0.5*vec4(1.0,1.0,1.0,1.0);\n\t\t\tmate.x += 0.1*(1.0-z);\n\t\t\tmate2.y = z;\n\t\t}\n\n\n\t\t// lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mate2.y;\n        float amb = 0.5;\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 0.001, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        vec3  hal = normalize(lig-rd);\n        float spe = max(pow( clamp( dot(nor,hal), 0.0, 1.0), mate2.x*4.0 ),0.0 );\n\t\t\n\t\t// lights\n\t\tvec3 lin = vec3(0.0);\n        lin += 2.0*dif*vec3(1.00,1.00,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*amb*vec3(0.30,0.30,0.30)*occ;\n\t\tlin += 2.0*bou*vec3(0.40,0.40,0.40)*mate2.y;\n\t\tlin += 4.0*bac*vec3(0.40,0.30,0.25)*occ;\n        lin += 1.0*fre*vec3(1.00,1.00,1.00)*2.0*mate.w*(0.5+0.5*dif*sha)*occ;\n\n\t\tcol = mate.xyz*lin;\n\t\tcol += 4.0*spe*vec3(2.0)*mate.w*dif*sha*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n\t}\n\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\t// vigneting\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n   \n    fragColor = vec4( col, 1.0 );\n}\n","inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453123);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture( sa, p.yz ).xyz;\n\tvec3 y = texture( sa, p.zx ).xyz;\n\tvec3 z = texture( sa, p.xy ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//----------------------------------------------------------------\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// trick by klems\n#define ZERO (min(iFrame,0))\n\n//----------------------------------------------------------------\n\nvec2 map( vec3 p )\n{\n\tp.y -= 1.8;\n    \n\t//p.x = abs(p.x);\n\n    //body\n\tvec3 q = p;\n    \n\t//q.y -= 0.3*pow(1.0-length(p.xz),1.0)*smoothstep(0.0, 0.2, p.y);\n\t//q.y *= 1.05;\n\t//q.z *= 1.0 + 0.1*smoothstep( 0.0, 0.5, q.z )*smoothstep( -0.5, 0.5, p.y );\n    //float dd = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.75,1.0) );\n\t/*\n    float am = clamp( 4.0*abs(p.y-0.45), 0.0, 1.0 );\n\tfloat fo = -0.03*(1.0-smoothstep( 0.0, 0.04*am, abs(dd-0.42) ))*am;\n    float dd2 = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.25,1.0) );\n\tfloat am2 = clamp( 1.5*(p.y-0.45), 0.0, 1.0 );\n\tfloat fo2 = -0.085*(1.0-smoothstep( 0.0, 0.08*am2, abs(dd2-0.42) ))*am2;\n    q.y += -0.05+0.05*length(q.x);\n\t*/\n\t//float d1 = length( q ) - 0.9;//+ fo + fo2;\n    q.y *= 1.3;\n    float d1 = sdRoundCone( q, 0.8, 0.6, 0.3);\n    vec2 res = vec2( d1, 1.0 );\n    \n    vec2 h;float d2;\n    /*\n\t// arms\n\tvec2 h = sdSegment( vec3(.83,0.15,0.0), vec3(1.02,-0.6,-.1), p );\n\tfloat d2 = h.x - 0.07;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(1.02,-0.6,-.1), vec3(0.95,-1.2,0.1), p );\n\td2 = h.x - 0.07 + h.y*0.02;\n\tres.x = smin( res.x, d2, 0.06 );\n\t*/\n    /*\n\t// hands\n\tif( p.y<-1.0 )\n\t{\n    float fa = sin(3.0*iTime);\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.97,-1.5,0.0), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.01 );\n\th = sdSegment( vec3(0.97,-1.5,0.0), vec3(0.95,-1.7,0.0)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(1.05,-1.5,0.1), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(1.05,-1.5,0.1), vec3(1.0,-1.75,0.1)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.98,-1.5,0.2), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(0.98,-1.5,0.2), vec3(0.95,-1.7,0.15)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.85,-1.4,0.2), p );\n\td2 = h.x - 0.04 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.05 );\n\th = sdSegment( vec3(0.85,-1.4,0.2), vec3(0.85,-1.63,0.15)+0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\t}\n\t*/\n    //x\u8F74\u5BF9\u79F0\u7ED8\u5236\n    vec3 tp = p;\n    tp.x = abs(p.x);\n\t// legs\n\th = sdSegment( vec3(0.2,-0.5,0.0), vec3(0.2,-1.0,0.0), tp );\n\td2 = h.x - 0.05 - h.y*0.02;\n    if( d2<res.x ) res = vec2( d2, 2.0);\n    // feet\n\th = sdSegment( vec3(0.2,-1.0,0.0), vec3(0.4,-1.0,0.0), tp);\n\td2 = h.x - 0.05 - 0.03*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n\t//arm\n\th = sdSegment( vec3(0.7,0.2,0.0), vec3(0.8,0.3,0.0), tp);\n\td2 = h.x - 0.10 + 0.03*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n    h = sdSegment( vec3(0.8,0.3,0.0), vec3(1.4,0.5,0.0), tp);\n\td2 = h.x - 0.10 + 0.04*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n    \n\t// horns\n    h = sdSegment( vec3(0.20,0.7,0.0), vec3(0.18,1.0,0.0), tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    h = sdSegment( vec3(0.18,1.0,0.0), vec3(0.14,1.4,0.0), tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    h = sdSegment( vec3(0.18,1.0,0.0), vec3(0.35,1.2,0.0),tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    \n    /*\n\tvec3 hp = tp - vec3(0.25,0.7,0.0);\n    hp.xy = mat2(0.6,0.8,-0.8,0.6)*hp.xy;\n    hp.x += 0.8*hp.y*hp.y;\n    float d4 = sdEllipsoid( hp, vec3(0.13,0.5,0.16) );\n\t//d4 *= 0.9;\n\tif( d4<res.x ) res = vec2( d4, 3.0 );\n    */\n    \n    \n\t// eyes\n\tfloat d3 = length( (tp - vec3(0.2,0.25,0.7))*vec3(1.0,1.0,1.0) ) - 0.1;\n\tif( d3<res.x ) res = vec2( d3, 2.0);\n\n    \n    \n\t// mouth\n    \n\tfloat mo = length( (q-vec3(0.0,-0.2,1.0))*vec3(0.6,1.6,0.25)/1.2 ) -0.3/1.2;\n\tfloat of = 0.1*pow(smoothstep( 0.0, 0.2, abs(p.x-0.3) ),0.5);\n\tmo = max( mo, -q.y-0.35-of );\n\n\tfloat li = smoothstep( 0.0, 0.05, mo+0.02 ) - smoothstep( 0.05, 0.10, mo+0.02 );\n\tres.x -= 0.03*li*clamp( (-q.y-0.4)*10.0, 0.0, 1.0 );\n\t\n\tif( -mo > res.x )\n\t\tres = vec2( -mo, 4.0 );\n    \n    res.x += 0.01*(smoothstep( 0.0, 0.05, mo+0.062 ) - smoothstep( 0.05, 0.10, mo+0.062 ));\n    \n\treturn vec2(res.x*0.8,res.y);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec3 eps = vec3(0.002,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.002*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float m = -1.0;\n\tfloat mint = 10.0;\n\n    // plane\t\n\tfloat tf = (0.0-ro.y)/rd.y;\n\tif( tf>0.0 ) { mint = tf; m = 0.0; }\n\t\n\t// mike\n\tfloat maxd = min(5.0,mint);\n\tfloat precis = 0.001;\n    float t = 0.0;\n\tfloat d = 0.0;\n    for( int i=ZERO; i<128; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        float h = res.x;\n\t\td = res.y;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t<maxd && t<mint )\n\t{\n\t\tmint = t;\n\t\tm = d;\n\t}\n\n    return vec3( mint, m, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n\t\tt += clamp( h, 0.01, 0.25 );\n\t\tif( res<0.005 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nvec3 lig = normalize(vec3(1.0,0.7,0.9));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\t//if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    \n\t#ifdef STEREO\n\tfloat eyeID = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n    #endif\n\n\n\t\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = sin(-0.25 + 0.31416*iTime) - 6.2831*(m.x-0.5);\n\n\tvec3 ro = vec3(4.5*sin(an),1.5,4.5*cos(an));\n    vec3 ta = vec3(0.0,1.5,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = vec3(1.0);\n\n\t// raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        // materials\n\t\tvec4 mate = vec4(0.0);\n\t\tvec2 mate2 = vec2(1.0,1.0);\n\t\tif( tmat.z<0.5 )\n\t\t{\n\t\t\tnor = vec3(0.0,1.0,0.0);\n\t\t    ref = reflect( rd, nor );\n\t\t\tmate.xyz = vec3(1.0);\n            mate2.y = 1.0 - 0.9*(2.0/(2.0+dot(pos.xz,pos.xz)));\n\t\t}\n\t\telse if( tmat.z<1.5 )//mat id == 1\n\t\t{\n            mate2.x = 4.0;\n\t\t\tmate = vec4(0.5,0.0,0.5,0.8);//\u7D2B\u8272\u57FA\u8C03\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.8*mate.xyz, vec3(0.3,0.0,0.4), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.3,0.0,0.4), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t\t\n\t\t\tmate.xyz *= 0.7;\n\n\t\t}\n\t\telse if( tmat.z<2.5 )//mat id == 2 \n\t\t{\n\t\t\tmate2.x = 4.0;\n\t\t\tmate = vec4(0.1,0.1,0.1,0.0);\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.8*mate.xyz, vec3(0.01,0.01,0.01), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.01,0.01,0.01), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t\t\n\t\t\tmate.xyz *= 0.7;\n\t\t}\n\t\telse if( tmat.z<3.5 )\n\t\t{\n\t\t\tmate = 0.8*vec4(0.85,0.7,0.6,0.0);\n            mate2.x = 0.0;\n\n\t\t\tfloat f = smoothstep( 0.0, 0.1, 0.5*abs(pos.x)+pos.y-3.02 );\n\t\t\tmate.xyz *= 1.0 - 0.8*vec3( f );\n\t\t\t\n\t\t\tmate.xyz *= 0.2 + 0.8*smoothstep( 0.0, 1.0, texturize( iChannel0, 0.1*2.1*pos*vec3(4.0,0.1,4.0), nor ).x );\n\t\t}\n\t\telse if( tmat.z<4.5 )//id == 4\u5185\u90E8\u6750\u8D28\n\t\t{\n\t\t\tfloat z = smoothstep( 0.0, 2.0, pos.z+0.5 );\n\t\t\tmate = 0.5*vec4(1.0,1.0,1.0,1.0);\n\t\t\tmate.x += 0.1*(1.0-z);\n\t\t\tmate2.y = z;\n\t\t}\n\n\n\t\t// lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mate2.y;\n        float amb = 0.5;\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 0.001, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        vec3  hal = normalize(lig-rd);\n        float spe = max(pow( clamp( dot(nor,hal), 0.0, 1.0), mate2.x*4.0 ),0.0 );\n\t\t\n\t\t// lights\n\t\tvec3 lin = vec3(0.0);\n        lin += 2.0*dif*vec3(1.00,1.00,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*amb*vec3(0.30,0.30,0.30)*occ;\n\t\tlin += 2.0*bou*vec3(0.40,0.40,0.40)*mate2.y;\n\t\tlin += 4.0*bac*vec3(0.40,0.30,0.25)*occ;\n        lin += 1.0*fre*vec3(1.00,1.00,1.00)*2.0*mate.w*(0.5+0.5*dif*sha)*occ;\n\n\t\tcol = mate.xyz*lin;\n\t\tcol += 4.0*spe*vec3(2.0)*mate.w*dif*sha*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n\t}\n\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\t// vigneting\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n   \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}]}